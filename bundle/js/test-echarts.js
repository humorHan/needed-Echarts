webpackJsonp([3,4],[
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(4);


/***/ },
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by humorHan on 2016/8/24.
	 */
	;;
	var echarts = __webpack_require__(5);
	__webpack_require__(103);
	// 引入提示框和标题组件
	__webpack_require__(131);
	__webpack_require__(135);
	var myChart = echarts.init(document.getElementById('test'));
	myChart.setOption({
	    title: {
	        text: 'ECharts 入门示例'
	    },
	    tooltip: {},
	    legend: {
	        data:['销量']
	    },
	    xAxis: {
	        data: ["衬衫","羊毛衫","雪纺衫","裤子","高跟鞋","袜子"]
	    },
	    yAxis: {},
	    series: [{
	        name: '销量',
	        type: 'bar',
	        data: [5, 20, 36, 10, 10, 20]
	    }]
	});
	/*var echarts = require('../dep/echarts.min.js');
	var myChart = echarts.init(document.getElementById('test'));
	myChart.setOption({
	    title: {
	        text: 'ECharts 入门示例'
	    },
	    tooltip: {},
	    legend: {
	        data:['销量']
	    },
	    xAxis: {
	        data: ["衬衫","羊毛衫","雪纺衫","裤子","高跟鞋","袜子"]
	    },
	    yAxis: {},
	    series: [{
	        name: '销量',
	        type: 'bar',
	        data: [5, 20, 36, 10, 10, 20]
	    }]
	});*/


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global) {// Enable DEV mode when using source code without build. which has no __DEV__ variable
	// In build process 'typeof __DEV__' will be replace with 'boolean'
	// So this code will be removed or disabled anyway after built.
	if (typeof __DEV__ === 'undefined') {
	    // In browser
	    if (typeof window !== 'undefined') {
	        window.__DEV__ = true;
	    }
	    // In node
	    else if (typeof global !== 'undefined') {
	        global.__DEV__ = true;
	    }
	}
	
	/*!
	 * ECharts, a javascript interactive chart library.
	 *
	 * Copyright (c) 2015, Baidu Inc.
	 * All rights reserved.
	 *
	 * LICENSE
	 * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt
	 */
	
	/**
	 * @module echarts
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var env = __webpack_require__(6);
	
	    var GlobalModel = __webpack_require__(7);
	    var ExtensionAPI = __webpack_require__(29);
	    var CoordinateSystemManager = __webpack_require__(30);
	    var OptionManager = __webpack_require__(31);
	
	    var ComponentModel = __webpack_require__(23);
	    var SeriesModel = __webpack_require__(32);
	
	    var ComponentView = __webpack_require__(33);
	    var ChartView = __webpack_require__(46);
	    var graphic = __webpack_require__(47);
	
	    var zrender = __webpack_require__(85);
	    var zrUtil = __webpack_require__(8);
	    var colorTool = __webpack_require__(43);
	    var Eventful = __webpack_require__(37);
	    var timsort = __webpack_require__(89);
	
	    var each = zrUtil.each;
	
	    var PRIORITY_PROCESSOR_FILTER = 1000;
	    var PRIORITY_PROCESSOR_STATISTIC = 5000;
	
	
	    var PRIORITY_VISUAL_LAYOUT = 1000;
	    var PRIORITY_VISUAL_GLOBAL = 2000;
	    var PRIORITY_VISUAL_CHART = 3000;
	    var PRIORITY_VISUAL_COMPONENT = 4000;
	    var PRIORITY_VISUAL_BRUSH = 5000;
	
	    // Main process have three entries: `setOption`, `dispatchAction` and `resize`,
	    // where they must not be invoked nestedly, except the only case: invoke
	    // dispatchAction with updateMethod "none" in main process.
	    // This flag is used to carry out this rule.
	    // All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).
	    var IN_MAIN_PROCESS = '__flag_in_main_process';
	    var HAS_GRADIENT_OR_PATTERN_BG = '_hasGradientOrPatternBg';
	
	
	    var OPTION_UPDATED = '_optionUpdated';
	
	    function createRegisterEventWithLowercaseName(method) {
	        return function (eventName, handler, context) {
	            // Event name is all lowercase
	            eventName = eventName && eventName.toLowerCase();
	            Eventful.prototype[method].call(this, eventName, handler, context);
	        };
	    }
	    /**
	     * @module echarts~MessageCenter
	     */
	    function MessageCenter() {
	        Eventful.call(this);
	    }
	    MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');
	    MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');
	    MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');
	    zrUtil.mixin(MessageCenter, Eventful);
	    /**
	     * @module echarts~ECharts
	     */
	    function ECharts (dom, theme, opts) {
	        opts = opts || {};
	
	        // Get theme by name
	        if (typeof theme === 'string') {
	            theme = themeStorage[theme];
	        }
	
	        /**
	         * @type {string}
	         */
	        this.id;
	        /**
	         * Group id
	         * @type {string}
	         */
	        this.group;
	        /**
	         * @type {HTMLDomElement}
	         * @private
	         */
	        this._dom = dom;
	        /**
	         * @type {module:zrender/ZRender}
	         * @private
	         */
	        this._zr = zrender.init(dom, {
	            renderer: opts.renderer || 'canvas',
	            devicePixelRatio: opts.devicePixelRatio
	        });
	
	        /**
	         * @type {Object}
	         * @private
	         */
	        this._theme = zrUtil.clone(theme);
	
	        /**
	         * @type {Array.<module:echarts/view/Chart>}
	         * @private
	         */
	        this._chartsViews = [];
	
	        /**
	         * @type {Object.<string, module:echarts/view/Chart>}
	         * @private
	         */
	        this._chartsMap = {};
	
	        /**
	         * @type {Array.<module:echarts/view/Component>}
	         * @private
	         */
	        this._componentsViews = [];
	
	        /**
	         * @type {Object.<string, module:echarts/view/Component>}
	         * @private
	         */
	        this._componentsMap = {};
	
	        /**
	         * @type {module:echarts/ExtensionAPI}
	         * @private
	         */
	        this._api = new ExtensionAPI(this);
	
	        /**
	         * @type {module:echarts/CoordinateSystem}
	         * @private
	         */
	        this._coordSysMgr = new CoordinateSystemManager();
	
	        Eventful.call(this);
	
	        /**
	         * @type {module:echarts~MessageCenter}
	         * @private
	         */
	        this._messageCenter = new MessageCenter();
	
	        // Init mouse events
	        this._initEvents();
	
	        // In case some people write `window.onresize = chart.resize`
	        this.resize = zrUtil.bind(this.resize, this);
	
	        // Can't dispatch action during rendering procedure
	        this._pendingActions = [];
	        // Sort on demand
	        function prioritySortFunc(a, b) {
	            return a.prio - b.prio;
	        }
	        timsort(visualFuncs, prioritySortFunc);
	        timsort(dataProcessorFuncs, prioritySortFunc);
	
	        this._zr.animation.on('frame', this._onframe, this);
	    }
	
	    var echartsProto = ECharts.prototype;
	
	    echartsProto._onframe = function () {
	        // Lazy update
	        if (this[OPTION_UPDATED]) {
	
	            this[IN_MAIN_PROCESS] = true;
	
	            updateMethods.prepareAndUpdate.call(this);
	
	            this[IN_MAIN_PROCESS] = false;
	
	            this[OPTION_UPDATED] = false;
	        }
	    };
	    /**
	     * @return {HTMLDomElement}
	     */
	    echartsProto.getDom = function () {
	        return this._dom;
	    };
	
	    /**
	     * @return {module:zrender~ZRender}
	     */
	    echartsProto.getZr = function () {
	        return this._zr;
	    };
	
	    /**
	     * @param {Object} option
	     * @param {boolean} notMerge
	     * @param {boolean} [lazyUpdate=false] Useful when setOption frequently.
	     */
	    echartsProto.setOption = function (option, notMerge, lazyUpdate) {
	        if (__DEV__) {
	            zrUtil.assert(!this[IN_MAIN_PROCESS], '`setOption` should not be called during main process.');
	        }
	
	        this[IN_MAIN_PROCESS] = true;
	
	        if (!this._model || notMerge) {
	            var optionManager = new OptionManager(this._api);
	            var theme = this._theme;
	            var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);
	            ecModel.init(null, null, theme, optionManager);
	        }
	
	        this._model.setOption(option, optionPreprocessorFuncs);
	
	        if (lazyUpdate) {
	            this[OPTION_UPDATED] = true;
	        }
	        else {
	            updateMethods.prepareAndUpdate.call(this);
	            this._zr.refreshImmediately();
	            this[OPTION_UPDATED] = false;
	        }
	
	        this[IN_MAIN_PROCESS] = false;
	
	        this._flushPendingActions();
	    };
	
	    /**
	     * @DEPRECATED
	     */
	    echartsProto.setTheme = function () {
	        console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');
	    };
	
	    /**
	     * @return {module:echarts/model/Global}
	     */
	    echartsProto.getModel = function () {
	        return this._model;
	    };
	
	    /**
	     * @return {Object}
	     */
	    echartsProto.getOption = function () {
	        return this._model && this._model.getOption();
	    };
	
	    /**
	     * @return {number}
	     */
	    echartsProto.getWidth = function () {
	        return this._zr.getWidth();
	    };
	
	    /**
	     * @return {number}
	     */
	    echartsProto.getHeight = function () {
	        return this._zr.getHeight();
	    };
	
	    /**
	     * Get canvas which has all thing rendered
	     * @param {Object} opts
	     * @param {string} [opts.backgroundColor]
	     */
	    echartsProto.getRenderedCanvas = function (opts) {
	        if (!env.canvasSupported) {
	            return;
	        }
	        opts = opts || {};
	        opts.pixelRatio = opts.pixelRatio || 1;
	        opts.backgroundColor = opts.backgroundColor
	            || this._model.get('backgroundColor');
	        var zr = this._zr;
	        var list = zr.storage.getDisplayList();
	        // Stop animations
	        zrUtil.each(list, function (el) {
	            el.stopAnimation(true);
	        });
	        return zr.painter.getRenderedCanvas(opts);
	    };
	    /**
	     * @return {string}
	     * @param {Object} opts
	     * @param {string} [opts.type='png']
	     * @param {string} [opts.pixelRatio=1]
	     * @param {string} [opts.backgroundColor]
	     */
	    echartsProto.getDataURL = function (opts) {
	        opts = opts || {};
	        var excludeComponents = opts.excludeComponents;
	        var ecModel = this._model;
	        var excludesComponentViews = [];
	        var self = this;
	
	        each(excludeComponents, function (componentType) {
	            ecModel.eachComponent({
	                mainType: componentType
	            }, function (component) {
	                var view = self._componentsMap[component.__viewId];
	                if (!view.group.ignore) {
	                    excludesComponentViews.push(view);
	                    view.group.ignore = true;
	                }
	            });
	        });
	
	        var url = this.getRenderedCanvas(opts).toDataURL(
	            'image/' + (opts && opts.type || 'png')
	        );
	
	        each(excludesComponentViews, function (view) {
	            view.group.ignore = false;
	        });
	        return url;
	    };
	
	
	    /**
	     * @return {string}
	     * @param {Object} opts
	     * @param {string} [opts.type='png']
	     * @param {string} [opts.pixelRatio=1]
	     * @param {string} [opts.backgroundColor]
	     */
	    echartsProto.getConnectedDataURL = function (opts) {
	        if (!env.canvasSupported) {
	            return;
	        }
	        var groupId = this.group;
	        var mathMin = Math.min;
	        var mathMax = Math.max;
	        var MAX_NUMBER = Infinity;
	        if (connectedGroups[groupId]) {
	            var left = MAX_NUMBER;
	            var top = MAX_NUMBER;
	            var right = -MAX_NUMBER;
	            var bottom = -MAX_NUMBER;
	            var canvasList = [];
	            var dpr = (opts && opts.pixelRatio) || 1;
	            for (var id in instances) {
	                var chart = instances[id];
	                if (chart.group === groupId) {
	                    var canvas = chart.getRenderedCanvas(
	                        zrUtil.clone(opts)
	                    );
	                    var boundingRect = chart.getDom().getBoundingClientRect();
	                    left = mathMin(boundingRect.left, left);
	                    top = mathMin(boundingRect.top, top);
	                    right = mathMax(boundingRect.right, right);
	                    bottom = mathMax(boundingRect.bottom, bottom);
	                    canvasList.push({
	                        dom: canvas,
	                        left: boundingRect.left,
	                        top: boundingRect.top
	                    });
	                }
	            }
	
	            left *= dpr;
	            top *= dpr;
	            right *= dpr;
	            bottom *= dpr;
	            var width = right - left;
	            var height = bottom - top;
	            var targetCanvas = zrUtil.createCanvas();
	            targetCanvas.width = width;
	            targetCanvas.height = height;
	            var zr = zrender.init(targetCanvas);
	
	            each(canvasList, function (item) {
	                var img = new graphic.Image({
	                    style: {
	                        x: item.left * dpr - left,
	                        y: item.top * dpr - top,
	                        image: item.dom
	                    }
	                });
	                zr.add(img);
	            });
	            zr.refreshImmediately();
	
	            return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));
	        }
	        else {
	            return this.getDataURL(opts);
	        }
	    };
	
	    var updateMethods = {
	
	
	        /**
	         * @param {Object} payload
	         * @private
	         */
	        update: function (payload) {
	            // console.time && console.time('update');
	
	            var ecModel = this._model;
	            var api = this._api;
	            var coordSysMgr = this._coordSysMgr;
	            var zr = this._zr;
	            // update before setOption
	            if (!ecModel) {
	                return;
	            }
	
	            // Fixme First time update ?
	            ecModel.restoreData();
	
	            // TODO
	            // Save total ecModel here for undo/redo (after restoring data and before processing data).
	            // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.
	
	            // Create new coordinate system each update
	            // In LineView may save the old coordinate system and use it to get the orignal point
	            coordSysMgr.create(this._model, this._api);
	
	            processData.call(this, ecModel, api);
	
	            stackSeriesData.call(this, ecModel);
	
	            coordSysMgr.update(ecModel, api);
	
	            doVisualEncoding.call(this, ecModel, payload);
	
	            doRender.call(this, ecModel, payload);
	
	            // Set background
	            var backgroundColor = ecModel.get('backgroundColor') || 'transparent';
	
	            var painter = zr.painter;
	            // TODO all use clearColor ?
	            if (painter.isSingleCanvas && painter.isSingleCanvas()) {
	                zr.configLayer(0, {
	                    clearColor: backgroundColor
	                });
	            }
	            else {
	                // In IE8
	                if (!env.canvasSupported) {
	                    var colorArr = colorTool.parse(backgroundColor);
	                    backgroundColor = colorTool.stringify(colorArr, 'rgb');
	                    if (colorArr[3] === 0) {
	                        backgroundColor = 'transparent';
	                    }
	                }
	                if (backgroundColor.colorStops || backgroundColor.image) {
	                    // Gradient background
	                    // FIXME Fixed layer？
	                    zr.configLayer(0, {
	                        clearColor: backgroundColor
	                    });
	                    this[HAS_GRADIENT_OR_PATTERN_BG] = true;
	
	                    this._dom.style.background = 'transparent';
	                }
	                else {
	                    if (this[HAS_GRADIENT_OR_PATTERN_BG]) {
	                        zr.configLayer(0, {
	                            clearColor: null
	                        });
	                    }
	                    this[HAS_GRADIENT_OR_PATTERN_BG] = false;
	
	                    this._dom.style.background = backgroundColor;
	                }
	            }
	
	            // console.time && console.timeEnd('update');
	        },
	
	        // PENDING
	        /**
	         * @param {Object} payload
	         * @private
	         */
	        updateView: function (payload) {
	            var ecModel = this._model;
	
	            // update before setOption
	            if (!ecModel) {
	                return;
	            }
	
	            ecModel.eachSeries(function (seriesModel) {
	                seriesModel.getData().clearAllVisual();
	            });
	
	            doVisualEncoding.call(this, ecModel, payload);
	
	            invokeUpdateMethod.call(this, 'updateView', ecModel, payload);
	        },
	
	        /**
	         * @param {Object} payload
	         * @private
	         */
	        updateVisual: function (payload) {
	            var ecModel = this._model;
	
	            // update before setOption
	            if (!ecModel) {
	                return;
	            }
	
	            ecModel.eachSeries(function (seriesModel) {
	                seriesModel.getData().clearAllVisual();
	            });
	
	            doVisualEncoding.call(this, ecModel, payload);
	
	            invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);
	        },
	
	        /**
	         * @param {Object} payload
	         * @private
	         */
	        updateLayout: function (payload) {
	            var ecModel = this._model;
	
	            // update before setOption
	            if (!ecModel) {
	                return;
	            }
	
	            doLayout.call(this, ecModel, payload);
	
	            invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);
	        },
	
	        /**
	         * @param {Object} payload
	         * @private
	         */
	        highlight: function (payload) {
	            toggleHighlight.call(this, 'highlight', payload);
	        },
	
	        /**
	         * @param {Object} payload
	         * @private
	         */
	        downplay: function (payload) {
	            toggleHighlight.call(this, 'downplay', payload);
	        },
	
	        /**
	         * @param {Object} payload
	         * @private
	         */
	        prepareAndUpdate: function (payload) {
	            var ecModel = this._model;
	
	            prepareView.call(this, 'component', ecModel);
	
	            prepareView.call(this, 'chart', ecModel);
	
	            updateMethods.update.call(this, payload);
	        }
	    };
	
	    /**
	     * @param {Object} payload
	     * @private
	     */
	    function toggleHighlight(method, payload) {
	        var ecModel = this._model;
	
	        // dispatchAction before setOption
	        if (!ecModel) {
	            return;
	        }
	
	        ecModel.eachComponent(
	            {mainType: 'series', query: payload},
	            function (seriesModel, index) {
	                var chartView = this._chartsMap[seriesModel.__viewId];
	                if (chartView && chartView.__alive) {
	                    chartView[method](
	                        seriesModel, ecModel, this._api, payload
	                    );
	                }
	            },
	            this
	        );
	    }
	
	    /**
	     * Resize the chart
	     */
	    echartsProto.resize = function () {
	        if (__DEV__) {
	            zrUtil.assert(!this[IN_MAIN_PROCESS], '`resize` should not be called during main process.');
	        }
	
	        this[IN_MAIN_PROCESS] = true;
	
	        this._zr.resize();
	
	        var optionChanged = this._model && this._model.resetOption('media');
	        updateMethods[optionChanged ? 'prepareAndUpdate' : 'update'].call(this);
	
	        // Resize loading effect
	        this._loadingFX && this._loadingFX.resize();
	
	        this[IN_MAIN_PROCESS] = false;
	
	        this._flushPendingActions();
	    };
	
	    /**
	     * Show loading effect
	     * @param  {string} [name='default']
	     * @param  {Object} [cfg]
	     */
	    echartsProto.showLoading = function (name, cfg) {
	        if (zrUtil.isObject(name)) {
	            cfg = name;
	            name = '';
	        }
	        name = name || 'default';
	
	        this.hideLoading();
	        if (!loadingEffects[name]) {
	            if (__DEV__) {
	                console.warn('Loading effects ' + name + ' not exists.');
	            }
	            return;
	        }
	        var el = loadingEffects[name](this._api, cfg);
	        var zr = this._zr;
	        this._loadingFX = el;
	
	        zr.add(el);
	    };
	
	    /**
	     * Hide loading effect
	     */
	    echartsProto.hideLoading = function () {
	        this._loadingFX && this._zr.remove(this._loadingFX);
	        this._loadingFX = null;
	    };
	
	    /**
	     * @param {Object} eventObj
	     * @return {Object}
	     */
	    echartsProto.makeActionFromEvent = function (eventObj) {
	        var payload = zrUtil.extend({}, eventObj);
	        payload.type = eventActionMap[eventObj.type];
	        return payload;
	    };
	
	    /**
	     * @pubilc
	     * @param {Object} payload
	     * @param {string} [payload.type] Action type
	     * @param {boolean} [silent=false] Whether trigger event.
	     */
	    echartsProto.dispatchAction = function (payload, silent) {
	        var actionWrap = actions[payload.type];
	        if (!actionWrap) {
	            return;
	        }
	
	        var actionInfo = actionWrap.actionInfo;
	        var updateMethod = actionInfo.update || 'update';
	
	        // if (__DEV__) {
	        //     zrUtil.assert(
	        //         !this[IN_MAIN_PROCESS],
	        //         '`dispatchAction` should not be called during main process.'
	        //         + 'unless updateMathod is "none".'
	        //     );
	        // }
	
	        // May dispatchAction in rendering procedure
	        if (this[IN_MAIN_PROCESS]) {
	            this._pendingActions.push(payload);
	            return;
	        }
	
	        this[IN_MAIN_PROCESS] = true;
	
	        var payloads = [payload];
	        var batched = false;
	        // Batch action
	        if (payload.batch) {
	            batched = true;
	            payloads = zrUtil.map(payload.batch, function (item) {
	                item = zrUtil.defaults(zrUtil.extend({}, item), payload);
	                item.batch = null;
	                return item;
	            });
	        }
	
	        var eventObjBatch = [];
	        var eventObj;
	        var isHighlightOrDownplay = payload.type === 'highlight' || payload.type === 'downplay';
	        for (var i = 0; i < payloads.length; i++) {
	            var batchItem = payloads[i];
	            // Action can specify the event by return it.
	            eventObj = actionWrap.action(batchItem, this._model);
	            // Emit event outside
	            eventObj = eventObj || zrUtil.extend({}, batchItem);
	            // Convert type to eventType
	            eventObj.type = actionInfo.event || eventObj.type;
	            eventObjBatch.push(eventObj);
	
	            // Highlight and downplay are special.
	            isHighlightOrDownplay && updateMethods[updateMethod].call(this, batchItem);
	        }
	
	        if (updateMethod !== 'none' && !isHighlightOrDownplay) {
	            // Still dirty
	            if (this[OPTION_UPDATED]) {
	                // FIXME Pass payload ?
	                updateMethods.prepareAndUpdate.call(this, payload);
	                this[OPTION_UPDATED] = false;
	            }
	            else {
	                updateMethods[updateMethod].call(this, payload);
	            }
	        }
	
	        // Follow the rule of action batch
	        if (batched) {
	            eventObj = {
	                type: actionInfo.event || payload.type,
	                batch: eventObjBatch
	            };
	        }
	        else {
	            eventObj = eventObjBatch[0];
	        }
	
	        this[IN_MAIN_PROCESS] = false;
	
	        !silent && this._messageCenter.trigger(eventObj.type, eventObj);
	
	        this._flushPendingActions();
	
	    };
	
	    echartsProto._flushPendingActions = function () {
	        var pendingActions = this._pendingActions;
	        while (pendingActions.length) {
	            var payload = pendingActions.shift();
	            this.dispatchAction(payload);
	        }
	    };
	
	    /**
	     * Register event
	     * @method
	     */
	    echartsProto.on = createRegisterEventWithLowercaseName('on');
	    echartsProto.off = createRegisterEventWithLowercaseName('off');
	    echartsProto.one = createRegisterEventWithLowercaseName('one');
	
	    /**
	     * @param {string} methodName
	     * @private
	     */
	    function invokeUpdateMethod(methodName, ecModel, payload) {
	        var api = this._api;
	
	        // Update all components
	        each(this._componentsViews, function (component) {
	            var componentModel = component.__model;
	            component[methodName](componentModel, ecModel, api, payload);
	
	            updateZ(componentModel, component);
	        }, this);
	
	        // Upate all charts
	        ecModel.eachSeries(function (seriesModel, idx) {
	            var chart = this._chartsMap[seriesModel.__viewId];
	            chart[methodName](seriesModel, ecModel, api, payload);
	
	            updateZ(seriesModel, chart);
	
	            updateProgressiveAndBlend(seriesModel, chart);
	        }, this);
	
	        // If use hover layer
	        updateHoverLayerStatus(this._zr, ecModel);
	    }
	
	    /**
	     * Prepare view instances of charts and components
	     * @param  {module:echarts/model/Global} ecModel
	     * @private
	     */
	    function prepareView(type, ecModel) {
	        var isComponent = type === 'component';
	        var viewList = isComponent ? this._componentsViews : this._chartsViews;
	        var viewMap = isComponent ? this._componentsMap : this._chartsMap;
	        var zr = this._zr;
	
	        for (var i = 0; i < viewList.length; i++) {
	            viewList[i].__alive = false;
	        }
	
	        ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {
	            if (isComponent) {
	                if (componentType === 'series') {
	                    return;
	                }
	            }
	            else {
	                model = componentType;
	            }
	
	            // Consider: id same and type changed.
	            var viewId = model.id + '_' + model.type;
	            var view = viewMap[viewId];
	            if (!view) {
	                var classType = ComponentModel.parseClassType(model.type);
	                var Clazz = isComponent
	                    ? ComponentView.getClass(classType.main, classType.sub)
	                    : ChartView.getClass(classType.sub);
	                if (Clazz) {
	                    view = new Clazz();
	                    view.init(ecModel, this._api);
	                    viewMap[viewId] = view;
	                    viewList.push(view);
	                    zr.add(view.group);
	                }
	                else {
	                    // Error
	                    return;
	                }
	            }
	
	            model.__viewId = viewId;
	            view.__alive = true;
	            view.__id = viewId;
	            view.__model = model;
	        }, this);
	
	        for (var i = 0; i < viewList.length;) {
	            var view = viewList[i];
	            if (!view.__alive) {
	                zr.remove(view.group);
	                view.dispose(ecModel, this._api);
	                viewList.splice(i, 1);
	                delete viewMap[view.__id];
	            }
	            else {
	                i++;
	            }
	        }
	    }
	
	    /**
	     * Processor data in each series
	     *
	     * @param {module:echarts/model/Global} ecModel
	     * @private
	     */
	    function processData(ecModel, api) {
	        each(dataProcessorFuncs, function (process) {
	            process.func(ecModel, api);
	        });
	    }
	
	    /**
	     * @private
	     */
	    function stackSeriesData(ecModel) {
	        var stackedDataMap = {};
	        ecModel.eachSeries(function (series) {
	            var stack = series.get('stack');
	            var data = series.getData();
	            if (stack && data.type === 'list') {
	                var previousStack = stackedDataMap[stack];
	                if (previousStack) {
	                    data.stackedOn = previousStack;
	                }
	                stackedDataMap[stack] = data;
	            }
	        });
	    }
	
	    /**
	     * Layout before each chart render there series, special visual encoding stage
	     *
	     * @param {module:echarts/model/Global} ecModel
	     * @private
	     */
	    function doLayout(ecModel, payload) {
	        var api = this._api;
	        each(visualFuncs, function (visual) {
	            if (visual.isLayout) {
	                visual.func(ecModel, api, payload);
	            }
	        });
	    }
	
	    /**
	     * Encode visual infomation from data after data processing
	     *
	     * @param {module:echarts/model/Global} ecModel
	     * @private
	     */
	    function doVisualEncoding(ecModel, payload) {
	        var api = this._api;
	        ecModel.clearColorPalette();
	        ecModel.eachSeries(function (seriesModel) {
	            seriesModel.clearColorPalette();
	        });
	        each(visualFuncs, function (visual) {
	            visual.func(ecModel, api, payload);
	        });
	    }
	
	    /**
	     * Render each chart and component
	     * @private
	     */
	    function doRender(ecModel, payload) {
	        var api = this._api;
	        // Render all components
	        each(this._componentsViews, function (componentView) {
	            var componentModel = componentView.__model;
	            componentView.render(componentModel, ecModel, api, payload);
	
	            updateZ(componentModel, componentView);
	        }, this);
	
	        each(this._chartsViews, function (chart) {
	            chart.__alive = false;
	        }, this);
	
	        // Render all charts
	        ecModel.eachSeries(function (seriesModel, idx) {
	            var chartView = this._chartsMap[seriesModel.__viewId];
	            chartView.__alive = true;
	            chartView.render(seriesModel, ecModel, api, payload);
	
	            chartView.group.silent = !!seriesModel.get('silent');
	
	            updateZ(seriesModel, chartView);
	
	            updateProgressiveAndBlend(seriesModel, chartView);
	
	        }, this);
	
	        // If use hover layer
	        updateHoverLayerStatus(this._zr, ecModel);
	
	        // Remove groups of unrendered charts
	        each(this._chartsViews, function (chart) {
	            if (!chart.__alive) {
	                chart.remove(ecModel, api);
	            }
	        }, this);
	    }
	
	    var MOUSE_EVENT_NAMES = [
	        'click', 'dblclick', 'mouseover', 'mouseout', 'mousemove', 'mousedown', 'mouseup', 'globalout'
	    ];
	    /**
	     * @private
	     */
	    echartsProto._initEvents = function () {
	        each(MOUSE_EVENT_NAMES, function (eveName) {
	            this._zr.on(eveName, function (e) {
	                var ecModel = this.getModel();
	                var el = e.target;
	                if (el && el.dataIndex != null) {
	                    var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);
	                    var params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};
	                    params.event = e;
	                    params.type = eveName;
	                    this.trigger(eveName, params);
	                }
	                // If element has custom eventData of components
	                else if (el && el.eventData) {
	                    this.trigger(eveName, el.eventData);
	                }
	            }, this);
	        }, this);
	
	        each(eventActionMap, function (actionType, eventType) {
	            this._messageCenter.on(eventType, function (event) {
	                this.trigger(eventType, event);
	            }, this);
	        }, this);
	    };
	
	    /**
	     * @return {boolean}
	     */
	    echartsProto.isDisposed = function () {
	        return this._disposed;
	    };
	
	    /**
	     * Clear
	     */
	    echartsProto.clear = function () {
	        this.setOption({ series: [] }, true);
	    };
	    /**
	     * Dispose instance
	     */
	    echartsProto.dispose = function () {
	        if (this._disposed) {
	            if (__DEV__) {
	                console.warn('Instance ' + this.id + ' has been disposed');
	            }
	            return;
	        }
	        this._disposed = true;
	
	        var api = this._api;
	        var ecModel = this._model;
	
	        each(this._componentsViews, function (component) {
	            component.dispose(ecModel, api);
	        });
	        each(this._chartsViews, function (chart) {
	            chart.dispose(ecModel, api);
	        });
	
	        // Dispose after all views disposed
	        this._zr.dispose();
	
	        delete instances[this.id];
	    };
	
	    zrUtil.mixin(ECharts, Eventful);
	
	    function updateHoverLayerStatus(zr, ecModel) {
	        var storage = zr.storage;
	        var elCount = 0;
	        storage.traverse(function (el) {
	            if (!el.isGroup) {
	                elCount++;
	            }
	        });
	        if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {
	            storage.traverse(function (el) {
	                if (!el.isGroup) {
	                    el.useHoverLayer = true;
	                }
	            });
	        }
	    }
	    /**
	     * Update chart progressive and blend.
	     * @param {module:echarts/model/Series|module:echarts/model/Component} model
	     * @param {module:echarts/view/Component|module:echarts/view/Chart} view
	     */
	    function updateProgressiveAndBlend(seriesModel, chartView) {
	        // Progressive configuration
	        var elCount = 0;
	        chartView.group.traverse(function (el) {
	            if (el.type !== 'group' && !el.ignore) {
	                elCount++;
	            }
	        });
	        var frameDrawNum = +seriesModel.get('progressive');
	        var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node;
	        if (needProgressive) {
	            chartView.group.traverse(function (el) {
	                // FIXME marker and other components
	                if (!el.isGroup) {
	                    el.progressive = needProgressive ?
	                        Math.floor(elCount++ / frameDrawNum) : -1;
	                    if (needProgressive) {
	                        el.stopAnimation(true);
	                    }
	                }
	            });
	        }
	
	        // Blend configration
	        var blendMode = seriesModel.get('blendMode') || null;
	        if (__DEV__) {
	            if (!env.canvasSupported && blendMode && blendMode !== 'source-over') {
	                console.warn('Only canvas support blendMode');
	            }
	        }
	        chartView.group.traverse(function (el) {
	            // FIXME marker and other components
	            if (!el.isGroup) {
	                el.setStyle('blend', blendMode);
	            }
	        });
	    }
	    /**
	     * @param {module:echarts/model/Series|module:echarts/model/Component} model
	     * @param {module:echarts/view/Component|module:echarts/view/Chart} view
	     */
	    function updateZ(model, view) {
	        var z = model.get('z');
	        var zlevel = model.get('zlevel');
	        // Set z and zlevel
	        view.group.traverse(function (el) {
	            if (el.type !== 'group') {
	                z != null && (el.z = z);
	                zlevel != null && (el.zlevel = zlevel);
	            }
	        });
	    }
	    /**
	     * @type {Array.<Function>}
	     * @inner
	     */
	    var actions = [];
	
	    /**
	     * Map eventType to actionType
	     * @type {Object}
	     */
	    var eventActionMap = {};
	
	    /**
	     * Data processor functions of each stage
	     * @type {Array.<Object.<string, Function>>}
	     * @inner
	     */
	    var dataProcessorFuncs = [];
	
	    /**
	     * @type {Array.<Function>}
	     * @inner
	     */
	    var optionPreprocessorFuncs = [];
	
	    /**
	     * Visual encoding functions of each stage
	     * @type {Array.<Object.<string, Function>>}
	     * @inner
	     */
	    var visualFuncs = [];
	    /**
	     * Theme storage
	     * @type {Object.<key, Object>}
	     */
	    var themeStorage = {};
	    /**
	     * Loading effects
	     */
	    var loadingEffects = {};
	
	
	    var instances = {};
	    var connectedGroups = {};
	
	    var idBase = new Date() - 0;
	    var groupIdBase = new Date() - 0;
	    var DOM_ATTRIBUTE_KEY = '_echarts_instance_';
	    /**
	     * @alias module:echarts
	     */
	    var echarts = {
	        /**
	         * @type {number}
	         */
	        version: '3.2.3',
	        dependencies: {
	            zrender: '3.1.3'
	        }
	    };
	
	    function enableConnect(chart) {
	
	        var STATUS_PENDING = 0;
	        var STATUS_UPDATING = 1;
	        var STATUS_UPDATED = 2;
	        var STATUS_KEY = '__connectUpdateStatus';
	        function updateConnectedChartsStatus(charts, status) {
	            for (var i = 0; i < charts.length; i++) {
	                var otherChart = charts[i];
	                otherChart[STATUS_KEY] = status;
	            }
	        }
	        zrUtil.each(eventActionMap, function (actionType, eventType) {
	            chart._messageCenter.on(eventType, function (event) {
	                if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {
	                    var action = chart.makeActionFromEvent(event);
	                    var otherCharts = [];
	                    for (var id in instances) {
	                        var otherChart = instances[id];
	                        if (otherChart !== chart && otherChart.group === chart.group) {
	                            otherCharts.push(otherChart);
	                        }
	                    }
	                    updateConnectedChartsStatus(otherCharts, STATUS_PENDING);
	                    each(otherCharts, function (otherChart) {
	                        if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {
	                            otherChart.dispatchAction(action);
	                        }
	                    });
	                    updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);
	                }
	            });
	        });
	
	    }
	    /**
	     * @param {HTMLDomElement} dom
	     * @param {Object} [theme]
	     * @param {Object} opts
	     */
	    echarts.init = function (dom, theme, opts) {
	        if (__DEV__) {
	            // Check version
	            if ((zrender.version.replace('.', '') - 0) < (echarts.dependencies.zrender.replace('.', '') - 0)) {
	                throw new Error(
	                    'ZRender ' + zrender.version
	                    + ' is too old for ECharts ' + echarts.version
	                    + '. Current version need ZRender '
	                    + echarts.dependencies.zrender + '+'
	                );
	            }
	            if (!dom) {
	                throw new Error('Initialize failed: invalid dom.');
	            }
	            if (zrUtil.isDom(dom) && dom.nodeName.toUpperCase() !== 'CANVAS' && (!dom.clientWidth || !dom.clientHeight)) {
	                console.warn('Can\'t get dom width or height');
	            }
	        }
	
	        var chart = new ECharts(dom, theme, opts);
	        chart.id = 'ec_' + idBase++;
	        instances[chart.id] = chart;
	
	        dom.setAttribute &&
	            dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);
	
	        enableConnect(chart);
	
	        return chart;
	    };
	
	    /**
	     * @return {string|Array.<module:echarts~ECharts>} groupId
	     */
	    echarts.connect = function (groupId) {
	        // Is array of charts
	        if (zrUtil.isArray(groupId)) {
	            var charts = groupId;
	            groupId = null;
	            // If any chart has group
	            zrUtil.each(charts, function (chart) {
	                if (chart.group != null) {
	                    groupId = chart.group;
	                }
	            });
	            groupId = groupId || ('g_' + groupIdBase++);
	            zrUtil.each(charts, function (chart) {
	                chart.group = groupId;
	            });
	        }
	        connectedGroups[groupId] = true;
	        return groupId;
	    };
	
	    /**
	     * @return {string} groupId
	     */
	    echarts.disConnect = function (groupId) {
	        connectedGroups[groupId] = false;
	    };
	
	    /**
	     * Dispose a chart instance
	     * @param  {module:echarts~ECharts|HTMLDomElement|string} chart
	     */
	    echarts.dispose = function (chart) {
	        if (zrUtil.isDom(chart)) {
	            chart = echarts.getInstanceByDom(chart);
	        }
	        else if (typeof chart === 'string') {
	            chart = instances[chart];
	        }
	        if ((chart instanceof ECharts) && !chart.isDisposed()) {
	            chart.dispose();
	        }
	    };
	
	    /**
	     * @param  {HTMLDomElement} dom
	     * @return {echarts~ECharts}
	     */
	    echarts.getInstanceByDom = function (dom) {
	        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);
	        return instances[key];
	    };
	    /**
	     * @param {string} key
	     * @return {echarts~ECharts}
	     */
	    echarts.getInstanceById = function (key) {
	        return instances[key];
	    };
	
	    /**
	     * Register theme
	     */
	    echarts.registerTheme = function (name, theme) {
	        themeStorage[name] = theme;
	    };
	
	    /**
	     * Register option preprocessor
	     * @param {Function} preprocessorFunc
	     */
	    echarts.registerPreprocessor = function (preprocessorFunc) {
	        optionPreprocessorFuncs.push(preprocessorFunc);
	    };
	
	    /**
	     * @param {number} [priority=1000]
	     * @param {Function} processorFunc
	     */
	    echarts.registerProcessor = function (priority, processorFunc) {
	        if (typeof priority === 'function') {
	            processorFunc = priority;
	            priority = PRIORITY_PROCESSOR_FILTER;
	        }
	        if (__DEV__) {
	            if (isNaN(priority)) {
	                throw new Error('Unkown processor priority');
	            }
	        }
	        dataProcessorFuncs.push({
	            prio: priority,
	            func: processorFunc
	        });
	    };
	
	    /**
	     * Usage:
	     * registerAction('someAction', 'someEvent', function () { ... });
	     * registerAction('someAction', function () { ... });
	     * registerAction(
	     *     {type: 'someAction', event: 'someEvent', update: 'updateView'},
	     *     function () { ... }
	     * );
	     *
	     * @param {(string|Object)} actionInfo
	     * @param {string} actionInfo.type
	     * @param {string} [actionInfo.event]
	     * @param {string} [actionInfo.update]
	     * @param {string} [eventName]
	     * @param {Function} action
	     */
	    echarts.registerAction = function (actionInfo, eventName, action) {
	        if (typeof eventName === 'function') {
	            action = eventName;
	            eventName = '';
	        }
	        var actionType = zrUtil.isObject(actionInfo)
	            ? actionInfo.type
	            : ([actionInfo, actionInfo = {
	                event: eventName
	            }][0]);
	
	        // Event name is all lowercase
	        actionInfo.event = (actionInfo.event || actionType).toLowerCase();
	        eventName = actionInfo.event;
	
	        if (!actions[actionType]) {
	            actions[actionType] = {action: action, actionInfo: actionInfo};
	        }
	        eventActionMap[eventName] = actionType;
	    };
	
	    /**
	     * @param {string} type
	     * @param {*} CoordinateSystem
	     */
	    echarts.registerCoordinateSystem = function (type, CoordinateSystem) {
	        CoordinateSystemManager.register(type, CoordinateSystem);
	    };
	
	    /**
	     * Layout is a special stage of visual encoding
	     * Most visual encoding like color are common for different chart
	     * But each chart has it's own layout algorithm
	     *
	     * @param {number} [priority=1000]
	     * @param {Function} layoutFunc
	     */
	    echarts.registerLayout = function (priority, layoutFunc) {
	        if (typeof priority === 'function') {
	            layoutFunc = priority;
	            priority = PRIORITY_VISUAL_LAYOUT;
	        }
	        if (__DEV__) {
	            if (isNaN(priority)) {
	                throw new Error('Unkown layout priority');
	            }
	        }
	        visualFuncs.push({
	            prio: priority,
	            func: layoutFunc,
	            isLayout: true
	        });
	    };
	
	    /**
	     * @param {number} [priority=3000]
	     * @param {Function} visualFunc
	     */
	    echarts.registerVisual = function (priority, visualFunc) {
	        if (typeof priority === 'function') {
	            visualFunc = priority;
	            priority = PRIORITY_VISUAL_CHART;
	        }
	        if (__DEV__) {
	            if (isNaN(priority)) {
	                throw new Error('Unkown visual priority');
	            }
	        }
	        visualFuncs.push({
	            prio: priority,
	            func: visualFunc
	        });
	    };
	
	    /**
	     * @param {string} name
	     */
	    echarts.registerLoading = function (name, loadingFx) {
	        loadingEffects[name] = loadingFx;
	    };
	
	
	    var parseClassType = ComponentModel.parseClassType;
	    /**
	     * @param {Object} opts
	     * @param {string} [superClass]
	     */
	    echarts.extendComponentModel = function (opts, superClass) {
	        var Clazz = ComponentModel;
	        if (superClass) {
	            var classType = parseClassType(superClass);
	            Clazz = ComponentModel.getClass(classType.main, classType.sub, true);
	        }
	        return Clazz.extend(opts);
	    };
	
	    /**
	     * @param {Object} opts
	     * @param {string} [superClass]
	     */
	    echarts.extendComponentView = function (opts, superClass) {
	        var Clazz = ComponentView;
	        if (superClass) {
	            var classType = parseClassType(superClass);
	            Clazz = ComponentView.getClass(classType.main, classType.sub, true);
	        }
	        return Clazz.extend(opts);
	    };
	
	    /**
	     * @param {Object} opts
	     * @param {string} [superClass]
	     */
	    echarts.extendSeriesModel = function (opts, superClass) {
	        var Clazz = SeriesModel;
	        if (superClass) {
	            superClass = 'series.' + superClass.replace('series.', '');
	            var classType = parseClassType(superClass);
	            Clazz = SeriesModel.getClass(classType.main, classType.sub, true);
	        }
	        return Clazz.extend(opts);
	    };
	
	    /**
	     * @param {Object} opts
	     * @param {string} [superClass]
	     */
	    echarts.extendChartView = function (opts, superClass) {
	        var Clazz = ChartView;
	        if (superClass) {
	            superClass.replace('series.', '');
	            var classType = parseClassType(superClass);
	            Clazz = ChartView.getClass(classType.main, true);
	        }
	        return Clazz.extend(opts);
	    };
	
	    /**
	     * ZRender need a canvas context to do measureText.
	     * But in node environment canvas may be created by node-canvas.
	     * So we need to specify how to create a canvas instead of using document.createElement('canvas')
	     *
	     * Be careful of using it in the browser.
	     *
	     * @param {Function} creator
	     * @example
	     *     var Canvas = require('canvas');
	     *     var echarts = require('echarts');
	     *     echarts.setCanvasCreator(function () {
	     *         // Small size is enough.
	     *         return new Canvas(32, 32);
	     *     });
	     */
	    echarts.setCanvasCreator = function (creator) {
	        zrUtil.createCanvas = creator;
	    };
	
	    echarts.registerVisual(PRIORITY_VISUAL_GLOBAL, __webpack_require__(97));
	    echarts.registerPreprocessor(__webpack_require__(98));
	    echarts.registerLoading('default', __webpack_require__(100));
	
	    // Default action
	    echarts.registerAction({
	        type: 'highlight',
	        event: 'highlight',
	        update: 'highlight'
	    }, zrUtil.noop);
	    echarts.registerAction({
	        type: 'downplay',
	        event: 'downplay',
	        update: 'downplay'
	    }, zrUtil.noop);
	
	
	    // --------
	    // Exports
	    // --------
	    //
	    echarts.List = __webpack_require__(101);
	    echarts.Model = __webpack_require__(16);
	
	    echarts.graphic = __webpack_require__(47);
	    echarts.number = __webpack_require__(11);
	    echarts.format = __webpack_require__(10);
	    echarts.matrix = __webpack_require__(15);
	    echarts.vector = __webpack_require__(14);
	    echarts.color = __webpack_require__(43);
	
	    echarts.util = {};
	    each([
	            'map', 'each', 'filter', 'indexOf', 'inherits',
	            'reduce', 'filter', 'bind', 'curry', 'isArray',
	            'isString', 'isObject', 'isFunction', 'extend', 'defaults'
	        ],
	        function (name) {
	            echarts.util[name] = zrUtil[name];
	        }
	    );
	
	    // PRIORITY
	    echarts.PRIORITY = {
	        PROCESSOR: {
	            FILTER: PRIORITY_PROCESSOR_FILTER,
	            STATISTIC: PRIORITY_PROCESSOR_STATISTIC
	        },
	        VISUAL: {
	            LAYOUT: PRIORITY_VISUAL_LAYOUT,
	            GLOBAL: PRIORITY_VISUAL_GLOBAL,
	            CHART: PRIORITY_VISUAL_CHART,
	            COMPONENT: PRIORITY_VISUAL_COMPONENT,
	            BRUSH: PRIORITY_VISUAL_BRUSH
	        }
	    };
	
	    return echarts;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * echarts设备环境识别
	 *
	 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
	 * @author firede[firede@firede.us]
	 * @desc thanks zepto.
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var env = {};
	    if (typeof navigator === 'undefined') {
	        // In node
	        env = {
	            browser: {},
	            os: {},
	            node: true,
	            // Assume canvas is supported
	            canvasSupported: true
	        };
	    }
	    else {
	        env = detect(navigator.userAgent);
	    }
	
	    return env;
	
	    // Zepto.js
	    // (c) 2010-2013 Thomas Fuchs
	    // Zepto.js may be freely distributed under the MIT license.
	
	    function detect(ua) {
	        var os = {};
	        var browser = {};
	        // var webkit = ua.match(/Web[kK]it[\/]{0,1}([\d.]+)/);
	        // var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
	        // var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
	        // var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
	        // var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
	        // var webos = ua.match(/(webOS|hpwOS)[\s\/]([\d.]+)/);
	        // var touchpad = webos && ua.match(/TouchPad/);
	        // var kindle = ua.match(/Kindle\/([\d.]+)/);
	        // var silk = ua.match(/Silk\/([\d._]+)/);
	        // var blackberry = ua.match(/(BlackBerry).*Version\/([\d.]+)/);
	        // var bb10 = ua.match(/(BB10).*Version\/([\d.]+)/);
	        // var rimtabletos = ua.match(/(RIM\sTablet\sOS)\s([\d.]+)/);
	        // var playbook = ua.match(/PlayBook/);
	        // var chrome = ua.match(/Chrome\/([\d.]+)/) || ua.match(/CriOS\/([\d.]+)/);
	        var firefox = ua.match(/Firefox\/([\d.]+)/);
	        // var safari = webkit && ua.match(/Mobile\//) && !chrome;
	        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;
	        var ie = ua.match(/MSIE\s([\d.]+)/)
	            // IE 11 Trident/7.0; rv:11.0
	            || ua.match(/Trident\/.+?rv:(([\d.]+))/);
	        var edge = ua.match(/Edge\/([\d.]+)/); // IE 12 and 12+
	
	        // Todo: clean this up with a better OS/browser seperation:
	        // - discern (more) between multiple browsers on android
	        // - decide if kindle fire in silk mode is android or not
	        // - Firefox on Android doesn't specify the Android version
	        // - possibly devide in os, device and browser hashes
	
	        // if (browser.webkit = !!webkit) browser.version = webkit[1];
	
	        // if (android) os.android = true, os.version = android[2];
	        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');
	        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');
	        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
	        // if (webos) os.webos = true, os.version = webos[2];
	        // if (touchpad) os.touchpad = true;
	        // if (blackberry) os.blackberry = true, os.version = blackberry[2];
	        // if (bb10) os.bb10 = true, os.version = bb10[2];
	        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];
	        // if (playbook) browser.playbook = true;
	        // if (kindle) os.kindle = true, os.version = kindle[1];
	        // if (silk) browser.silk = true, browser.version = silk[1];
	        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;
	        // if (chrome) browser.chrome = true, browser.version = chrome[1];
	        if (firefox) browser.firefox = true, browser.version = firefox[1];
	        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;
	        // if (webview) browser.webview = true;
	        if (ie) {
	            browser.ie = true; browser.version = ie[1];
	        }
	        if (ie) {
	            browser.ie = true;
	            browser.version = ie[1];
	        }
	        if (edge) {
	            browser.edge = true;
	            browser.version = edge[1];
	        }
	
	        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||
	        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));
	        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||
	        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\/([\d.]+)/)) ||
	        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));
	
	        return {
	            browser: browser,
	            os: os,
	            node: false,
	            // 原生canvas支持，改极端点了
	            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)
	            canvasSupported : document.createElement('canvas').getContext ? true : false,
	            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>
	            // works on most browsers
	            // IE10/11 does not support touch event, and MS Edge supports them but not by
	            // default, so we dont check navigator.maxTouchPoints for them here.
	            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,
	            // <http://caniuse.com/#search=pointer%20event>.
	            pointerEventsSupported: 'onpointerdown' in window
	                // Firefox supports pointer but not by default,
	                // only MS browsers are reliable on pointer events currently.
	                && (browser.edge || (browser.ie && browser.version >= 10))
	        };
	    }
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * ECharts global model
	 *
	 * @module {echarts/model/Global}
	 *
	 */
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var zrUtil = __webpack_require__(8);
	    var modelUtil = __webpack_require__(9);
	    var Model = __webpack_require__(16);
	    var each = zrUtil.each;
	    var filter = zrUtil.filter;
	    var map = zrUtil.map;
	    var isArray = zrUtil.isArray;
	    var indexOf = zrUtil.indexOf;
	    var isObject = zrUtil.isObject;
	
	    var ComponentModel = __webpack_require__(23);
	
	    var globalDefault = __webpack_require__(27);
	
	    var OPTION_INNER_KEY = '\0_ec_inner';
	
	    /**
	     * @alias module:echarts/model/Global
	     *
	     * @param {Object} option
	     * @param {module:echarts/model/Model} parentModel
	     * @param {Object} theme
	     */
	    var GlobalModel = Model.extend({
	
	        constructor: GlobalModel,
	
	        init: function (option, parentModel, theme, optionManager) {
	            theme = theme || {};
	
	            this.option = null; // Mark as not initialized.
	
	            /**
	             * @type {module:echarts/model/Model}
	             * @private
	             */
	            this._theme = new Model(theme);
	
	            /**
	             * @type {module:echarts/model/OptionManager}
	             */
	            this._optionManager = optionManager;
	        },
	
	        setOption: function (option, optionPreprocessorFuncs) {
	            zrUtil.assert(
	                !(OPTION_INNER_KEY in option),
	                'please use chart.getOption()'
	            );
	
	            this._optionManager.setOption(option, optionPreprocessorFuncs);
	
	            this.resetOption();
	        },
	
	        /**
	         * @param {string} type null/undefined: reset all.
	         *                      'recreate': force recreate all.
	         *                      'timeline': only reset timeline option
	         *                      'media': only reset media query option
	         * @return {boolean} Whether option changed.
	         */
	        resetOption: function (type) {
	            var optionChanged = false;
	            var optionManager = this._optionManager;
	
	            if (!type || type === 'recreate') {
	                var baseOption = optionManager.mountOption(type === 'recreate');
	
	                if (!this.option || type === 'recreate') {
	                    initBase.call(this, baseOption);
	                }
	                else {
	                    this.restoreData();
	                    this.mergeOption(baseOption);
	                }
	                optionChanged = true;
	            }
	
	            if (type === 'timeline' || type === 'media') {
	                this.restoreData();
	            }
	
	            if (!type || type === 'recreate' || type === 'timeline') {
	                var timelineOption = optionManager.getTimelineOption(this);
	                timelineOption && (this.mergeOption(timelineOption), optionChanged = true);
	            }
	
	            if (!type || type === 'recreate' || type === 'media') {
	                var mediaOptions = optionManager.getMediaOption(this, this._api);
	                if (mediaOptions.length) {
	                    each(mediaOptions, function (mediaOption) {
	                        this.mergeOption(mediaOption, optionChanged = true);
	                    }, this);
	                }
	            }
	
	            return optionChanged;
	        },
	
	        /**
	         * @protected
	         */
	        mergeOption: function (newOption) {
	            var option = this.option;
	            var componentsMap = this._componentsMap;
	            var newCptTypes = [];
	
	            // 如果不存在对应的 component model 则直接 merge
	            each(newOption, function (componentOption, mainType) {
	                if (componentOption == null) {
	                    return;
	                }
	
	                if (!ComponentModel.hasClass(mainType)) {
	                    option[mainType] = option[mainType] == null
	                        ? zrUtil.clone(componentOption)
	                        : zrUtil.merge(option[mainType], componentOption, true);
	                }
	                else {
	                    newCptTypes.push(mainType);
	                }
	            });
	
	            // FIXME OPTION 同步是否要改回原来的
	            ComponentModel.topologicalTravel(
	                newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this
	            );
	
	            this._seriesIndices = this._seriesIndices || [];
	
	            function visitComponent(mainType, dependencies) {
	                var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);
	
	                var mapResult = modelUtil.mappingToExists(
	                    componentsMap[mainType], newCptOptionList
	                );
	
	                makeKeyInfo(mainType, mapResult);
	
	                var dependentModels = getComponentsByTypes(
	                    componentsMap, dependencies
	                );
	
	                option[mainType] = [];
	                componentsMap[mainType] = [];
	
	                each(mapResult, function (resultItem, index) {
	                    var componentModel = resultItem.exist;
	                    var newCptOption = resultItem.option;
	
	                    zrUtil.assert(
	                        isObject(newCptOption) || componentModel,
	                        'Empty component definition'
	                    );
	
	                    // Consider where is no new option and should be merged using {},
	                    // see removeEdgeAndAdd in topologicalTravel and
	                    // ComponentModel.getAllClassMainTypes.
	                    if (!newCptOption) {
	                        componentModel.mergeOption({}, this);
	                        componentModel.optionUpdated({}, false);
	                    }
	                    else {
	                        var ComponentModelClass = ComponentModel.getClass(
	                            mainType, resultItem.keyInfo.subType, true
	                        );
	
	                        if (componentModel && componentModel instanceof ComponentModelClass) {
	                            componentModel.mergeOption(newCptOption, this);
	                            componentModel.optionUpdated(newCptOption, false);
	                        }
	                        else {
	                            // PENDING Global as parent ?
	                            var extraOpt = zrUtil.extend(
	                                {
	                                    dependentModels: dependentModels,
	                                    componentIndex: index
	                                },
	                                resultItem.keyInfo
	                            );
	                            componentModel = new ComponentModelClass(
	                                newCptOption, this, this, extraOpt
	                            );
	                            componentModel.init(newCptOption, this, this, extraOpt);
	                            // Call optionUpdated after init.
	                            // newCptOption has been used as componentModel.option
	                            // and may be merged with theme and default, so pass null
	                            // to avoid confusion.
	                            componentModel.optionUpdated(null, true);
	                        }
	                    }
	
	                    componentsMap[mainType][index] = componentModel;
	                    option[mainType][index] = componentModel.option;
	                }, this);
	
	                // Backup series for filtering.
	                if (mainType === 'series') {
	                    this._seriesIndices = createSeriesIndices(componentsMap.series);
	                }
	            }
	        },
	
	        /**
	         * Get option for output (cloned option and inner info removed)
	         * @public
	         * @return {Object}
	         */
	        getOption: function () {
	            var option = zrUtil.clone(this.option);
	
	            each(option, function (opts, mainType) {
	                if (ComponentModel.hasClass(mainType)) {
	                    var opts = modelUtil.normalizeToArray(opts);
	                    for (var i = opts.length - 1; i >= 0; i--) {
	                        // Remove options with inner id.
	                        if (modelUtil.isIdInner(opts[i])) {
	                            opts.splice(i, 1);
	                        }
	                    }
	                    option[mainType] = opts;
	                }
	            });
	
	            delete option[OPTION_INNER_KEY];
	
	            return option;
	        },
	
	        /**
	         * @return {module:echarts/model/Model}
	         */
	        getTheme: function () {
	            return this._theme;
	        },
	
	        /**
	         * @param {string} mainType
	         * @param {number} [idx=0]
	         * @return {module:echarts/model/Component}
	         */
	        getComponent: function (mainType, idx) {
	            var list = this._componentsMap[mainType];
	            if (list) {
	                return list[idx || 0];
	            }
	        },
	
	        /**
	         * @param {Object} condition
	         * @param {string} condition.mainType
	         * @param {string} [condition.subType] If ignore, only query by mainType
	         * @param {number} [condition.index] Either input index or id or name.
	         * @param {string} [condition.id] Either input index or id or name.
	         * @param {string} [condition.name] Either input index or id or name.
	         * @return {Array.<module:echarts/model/Component>}
	         */
	        queryComponents: function (condition) {
	            var mainType = condition.mainType;
	            if (!mainType) {
	                return [];
	            }
	
	            var index = condition.index;
	            var id = condition.id;
	            var name = condition.name;
	
	            var cpts = this._componentsMap[mainType];
	
	            if (!cpts || !cpts.length) {
	                return [];
	            }
	
	            var result;
	
	            if (index != null) {
	                if (!isArray(index)) {
	                    index = [index];
	                }
	                result = filter(map(index, function (idx) {
	                    return cpts[idx];
	                }), function (val) {
	                    return !!val;
	                });
	            }
	            else if (id != null) {
	                var isIdArray = isArray(id);
	                result = filter(cpts, function (cpt) {
	                    return (isIdArray && indexOf(id, cpt.id) >= 0)
	                        || (!isIdArray && cpt.id === id);
	                });
	            }
	            else if (name != null) {
	                var isNameArray = isArray(name);
	                result = filter(cpts, function (cpt) {
	                    return (isNameArray && indexOf(name, cpt.name) >= 0)
	                        || (!isNameArray && cpt.name === name);
	                });
	            }
	            else {
	                // Return all components with mainType
	                result = cpts;
	            }
	
	            return filterBySubType(result, condition);
	        },
	
	        /**
	         * The interface is different from queryComponents,
	         * which is convenient for inner usage.
	         *
	         * @usage
	         * var result = findComponents(
	         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}
	         * );
	         * var result = findComponents(
	         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}
	         * );
	         * var result = findComponents(
	         *     {mainType: 'series'},
	         *     function (model, index) {...}
	         * );
	         * // result like [component0, componnet1, ...]
	         *
	         * @param {Object} condition
	         * @param {string} condition.mainType Mandatory.
	         * @param {string} [condition.subType] Optional.
	         * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},
	         *        where xxx is mainType.
	         *        If query attribute is null/undefined or has no index/id/name,
	         *        do not filtering by query conditions, which is convenient for
	         *        no-payload situations or when target of action is global.
	         * @param {Function} [condition.filter] parameter: component, return boolean.
	         * @return {Array.<module:echarts/model/Component>}
	         */
	        findComponents: function (condition) {
	            var query = condition.query;
	            var mainType = condition.mainType;
	
	            var queryCond = getQueryCond(query);
	            var result = queryCond
	                ? this.queryComponents(queryCond)
	                : this._componentsMap[mainType];
	
	            return doFilter(filterBySubType(result, condition));
	
	            function getQueryCond(q) {
	                var indexAttr = mainType + 'Index';
	                var idAttr = mainType + 'Id';
	                var nameAttr = mainType + 'Name';
	                return q && (
	                        q.hasOwnProperty(indexAttr)
	                        || q.hasOwnProperty(idAttr)
	                        || q.hasOwnProperty(nameAttr)
	                    )
	                    ? {
	                        mainType: mainType,
	                        // subType will be filtered finally.
	                        index: q[indexAttr],
	                        id: q[idAttr],
	                        name: q[nameAttr]
	                    }
	                    : null;
	            }
	
	            function doFilter(res) {
	                return condition.filter
	                     ? filter(res, condition.filter)
	                     : res;
	            }
	        },
	
	        /**
	         * @usage
	         * eachComponent('legend', function (legendModel, index) {
	         *     ...
	         * });
	         * eachComponent(function (componentType, model, index) {
	         *     // componentType does not include subType
	         *     // (componentType is 'xxx' but not 'xxx.aa')
	         * });
	         * eachComponent(
	         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},
	         *     function (model, index) {...}
	         * );
	         * eachComponent(
	         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},
	         *     function (model, index) {...}
	         * );
	         *
	         * @param {string|Object=} mainType When mainType is object, the definition
	         *                                  is the same as the method 'findComponents'.
	         * @param {Function} cb
	         * @param {*} context
	         */
	        eachComponent: function (mainType, cb, context) {
	            var componentsMap = this._componentsMap;
	
	            if (typeof mainType === 'function') {
	                context = cb;
	                cb = mainType;
	                each(componentsMap, function (components, componentType) {
	                    each(components, function (component, index) {
	                        cb.call(context, componentType, component, index);
	                    });
	                });
	            }
	            else if (zrUtil.isString(mainType)) {
	                each(componentsMap[mainType], cb, context);
	            }
	            else if (isObject(mainType)) {
	                var queryResult = this.findComponents(mainType);
	                each(queryResult, cb, context);
	            }
	        },
	
	        /**
	         * @param {string} name
	         * @return {Array.<module:echarts/model/Series>}
	         */
	        getSeriesByName: function (name) {
	            var series = this._componentsMap.series;
	            return filter(series, function (oneSeries) {
	                return oneSeries.name === name;
	            });
	        },
	
	        /**
	         * @param {number} seriesIndex
	         * @return {module:echarts/model/Series}
	         */
	        getSeriesByIndex: function (seriesIndex) {
	            return this._componentsMap.series[seriesIndex];
	        },
	
	        /**
	         * @param {string} subType
	         * @return {Array.<module:echarts/model/Series>}
	         */
	        getSeriesByType: function (subType) {
	            var series = this._componentsMap.series;
	            return filter(series, function (oneSeries) {
	                return oneSeries.subType === subType;
	            });
	        },
	
	        /**
	         * @return {Array.<module:echarts/model/Series>}
	         */
	        getSeries: function () {
	            return this._componentsMap.series.slice();
	        },
	
	        /**
	         * After filtering, series may be different
	         * frome raw series.
	         *
	         * @param {Function} cb
	         * @param {*} context
	         */
	        eachSeries: function (cb, context) {
	            assertSeriesInitialized(this);
	            each(this._seriesIndices, function (rawSeriesIndex) {
	                var series = this._componentsMap.series[rawSeriesIndex];
	                cb.call(context, series, rawSeriesIndex);
	            }, this);
	        },
	
	        /**
	         * Iterate raw series before filtered.
	         *
	         * @param {Function} cb
	         * @param {*} context
	         */
	        eachRawSeries: function (cb, context) {
	            each(this._componentsMap.series, cb, context);
	        },
	
	        /**
	         * After filtering, series may be different.
	         * frome raw series.
	         *
	         * @parma {string} subType
	         * @param {Function} cb
	         * @param {*} context
	         */
	        eachSeriesByType: function (subType, cb, context) {
	            assertSeriesInitialized(this);
	            each(this._seriesIndices, function (rawSeriesIndex) {
	                var series = this._componentsMap.series[rawSeriesIndex];
	                if (series.subType === subType) {
	                    cb.call(context, series, rawSeriesIndex);
	                }
	            }, this);
	        },
	
	        /**
	         * Iterate raw series before filtered of given type.
	         *
	         * @parma {string} subType
	         * @param {Function} cb
	         * @param {*} context
	         */
	        eachRawSeriesByType: function (subType, cb, context) {
	            return each(this.getSeriesByType(subType), cb, context);
	        },
	
	        /**
	         * @param {module:echarts/model/Series} seriesModel
	         */
	        isSeriesFiltered: function (seriesModel) {
	            assertSeriesInitialized(this);
	            return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;
	        },
	
	        /**
	         * @param {Function} cb
	         * @param {*} context
	         */
	        filterSeries: function (cb, context) {
	            assertSeriesInitialized(this);
	            var filteredSeries = filter(
	                this._componentsMap.series, cb, context
	            );
	            this._seriesIndices = createSeriesIndices(filteredSeries);
	        },
	
	        restoreData: function () {
	            var componentsMap = this._componentsMap;
	
	            this._seriesIndices = createSeriesIndices(componentsMap.series);
	
	            var componentTypes = [];
	            each(componentsMap, function (components, componentType) {
	                componentTypes.push(componentType);
	            });
	
	            ComponentModel.topologicalTravel(
	                componentTypes,
	                ComponentModel.getAllClassMainTypes(),
	                function (componentType, dependencies) {
	                    each(componentsMap[componentType], function (component) {
	                        component.restoreData();
	                    });
	                }
	            );
	        }
	
	    });
	
	    /**
	     * @inner
	     */
	    function mergeTheme(option, theme) {
	        for (var name in theme) {
	            // 如果有 component model 则把具体的 merge 逻辑交给该 model 处理
	            if (!ComponentModel.hasClass(name)) {
	                if (typeof theme[name] === 'object') {
	                    option[name] = !option[name]
	                        ? zrUtil.clone(theme[name])
	                        : zrUtil.merge(option[name], theme[name], false);
	                }
	                else {
	                    if (option[name] == null) {
	                        option[name] = theme[name];
	                    }
	                }
	            }
	        }
	    }
	
	    function initBase(baseOption) {
	        baseOption = baseOption;
	
	        // Using OPTION_INNER_KEY to mark that this option can not be used outside,
	        // i.e. `chart.setOption(chart.getModel().option);` is forbiden.
	        this.option = {};
	        this.option[OPTION_INNER_KEY] = 1;
	
	        /**
	         * @type {Object.<string, Array.<module:echarts/model/Model>>}
	         * @private
	         */
	        this._componentsMap = {};
	
	        /**
	         * Mapping between filtered series list and raw series list.
	         * key: filtered series indices, value: raw series indices.
	         * @type {Array.<nubmer>}
	         * @private
	         */
	        this._seriesIndices = null;
	
	        mergeTheme(baseOption, this._theme.option);
	
	        // TODO Needs clone when merging to the unexisted property
	        zrUtil.merge(baseOption, globalDefault, false);
	
	        this.mergeOption(baseOption);
	    }
	
	    /**
	     * @inner
	     * @param {Array.<string>|string} types model types
	     * @return {Object} key: {string} type, value: {Array.<Object>} models
	     */
	    function getComponentsByTypes(componentsMap, types) {
	        if (!zrUtil.isArray(types)) {
	            types = types ? [types] : [];
	        }
	
	        var ret = {};
	        each(types, function (type) {
	            ret[type] = (componentsMap[type] || []).slice();
	        });
	
	        return ret;
	    }
	
	    /**
	     * @inner
	     */
	    function makeKeyInfo(mainType, mapResult) {
	        // We use this id to hash component models and view instances
	        // in echarts. id can be specified by user, or auto generated.
	
	        // The id generation rule ensures new view instance are able
	        // to mapped to old instance when setOption are called in
	        // no-merge mode. So we generate model id by name and plus
	        // type in view id.
	
	        // name can be duplicated among components, which is convenient
	        // to specify multi components (like series) by one name.
	
	        // Ensure that each id is distinct.
	        var idMap = {};
	
	        each(mapResult, function (item, index) {
	            var existCpt = item.exist;
	            existCpt && (idMap[existCpt.id] = item);
	        });
	
	        each(mapResult, function (item, index) {
	            var opt = item.option;
	
	            zrUtil.assert(
	                !opt || opt.id == null || !idMap[opt.id] || idMap[opt.id] === item,
	                'id duplicates: ' + (opt && opt.id)
	            );
	
	            opt && opt.id != null && (idMap[opt.id] = item);
	
	            // Complete subType
	            if (isObject(opt)) {
	                var subType = determineSubType(mainType, opt, item.exist);
	                item.keyInfo = {mainType: mainType, subType: subType};
	            }
	        });
	
	        // Make name and id.
	        each(mapResult, function (item, index) {
	            var existCpt = item.exist;
	            var opt = item.option;
	            var keyInfo = item.keyInfo;
	
	            if (!isObject(opt)) {
	                return;
	            }
	
	            // name can be overwitten. Consider case: axis.name = '20km'.
	            // But id generated by name will not be changed, which affect
	            // only in that case: setOption with 'not merge mode' and view
	            // instance will be recreated, which can be accepted.
	            keyInfo.name = opt.name != null
	                ? opt.name + ''
	                : existCpt
	                ? existCpt.name
	                : '\0-';
	
	            if (existCpt) {
	                keyInfo.id = existCpt.id;
	            }
	            else if (opt.id != null) {
	                keyInfo.id = opt.id + '';
	            }
	            else {
	                // Consider this situatoin:
	                //  optionA: [{name: 'a'}, {name: 'a'}, {..}]
	                //  optionB [{..}, {name: 'a'}, {name: 'a'}]
	                // Series with the same name between optionA and optionB
	                // should be mapped.
	                var idNum = 0;
	                do {
	                    keyInfo.id = '\0' + keyInfo.name + '\0' + idNum++;
	                }
	                while (idMap[keyInfo.id]);
	            }
	
	            idMap[keyInfo.id] = item;
	        });
	    }
	
	    /**
	     * @inner
	     */
	    function determineSubType(mainType, newCptOption, existComponent) {
	        var subType = newCptOption.type
	            ? newCptOption.type
	            : existComponent
	            ? existComponent.subType
	            // Use determineSubType only when there is no existComponent.
	            : ComponentModel.determineSubType(mainType, newCptOption);
	
	        // tooltip, markline, markpoint may always has no subType
	        return subType;
	    }
	
	    /**
	     * @inner
	     */
	    function createSeriesIndices(seriesModels) {
	        return map(seriesModels, function (series) {
	            return series.componentIndex;
	        }) || [];
	    }
	
	    /**
	     * @inner
	     */
	    function filterBySubType(components, condition) {
	        // Using hasOwnProperty for restrict. Consider
	        // subType is undefined in user payload.
	        return condition.hasOwnProperty('subType')
	            ? filter(components, function (cpt) {
	                return cpt.subType === condition.subType;
	            })
	            : components;
	    }
	
	    /**
	     * @inner
	     */
	    function assertSeriesInitialized(ecModel) {
	        // Components that use _seriesIndices should depends on series component,
	        // which make sure that their initialization is after series.
	        if (__DEV__) {
	            if (!ecModel._seriesIndices) {
	                throw new Error('Series has not been initialized yet.');
	            }
	        }
	    }
	
	    zrUtil.mixin(GlobalModel, __webpack_require__(28));
	
	    return GlobalModel;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * @module zrender/core/util
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
	
	    // 用于处理merge时无法遍历Date等对象的问题
	    var BUILTIN_OBJECT = {
	        '[object Function]': 1,
	        '[object RegExp]': 1,
	        '[object Date]': 1,
	        '[object Error]': 1,
	        '[object CanvasGradient]': 1,
	        '[object CanvasPattern]': 1,
	        // In node-canvas Image can be Canvas.Image
	        '[object Image]': 1
	    };
	
	    var objToString = Object.prototype.toString;
	
	    var arrayProto = Array.prototype;
	    var nativeForEach = arrayProto.forEach;
	    var nativeFilter = arrayProto.filter;
	    var nativeSlice = arrayProto.slice;
	    var nativeMap = arrayProto.map;
	    var nativeReduce = arrayProto.reduce;
	
	    /**
	     * @param {*} source
	     * @return {*} 拷贝后的新对象
	     */
	    function clone(source) {
	        if (typeof source == 'object' && source !== null) {
	            var result = source;
	            if (source instanceof Array) {
	                result = [];
	                for (var i = 0, len = source.length; i < len; i++) {
	                    result[i] = clone(source[i]);
	                }
	            }
	            else if (
	                !isBuildInObject(source)
	                // 是否为 dom 对象
	                && !isDom(source)
	            ) {
	                result = {};
	                for (var key in source) {
	                    if (source.hasOwnProperty(key)) {
	                        result[key] = clone(source[key]);
	                    }
	                }
	            }
	
	            return result;
	        }
	
	        return source;
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} target
	     * @param {*} source
	     * @param {boolean} [overwrite=false]
	     */
	    function merge(target, source, overwrite) {
	        // We should escapse that source is string
	        // and enter for ... in ...
	        if (!isObject(source) || !isObject(target)) {
	            return overwrite ? clone(source) : target;
	        }
	
	        for (var key in source) {
	            if (source.hasOwnProperty(key)) {
	                var targetProp = target[key];
	                var sourceProp = source[key];
	
	                if (isObject(sourceProp)
	                    && isObject(targetProp)
	                    && !isArray(sourceProp)
	                    && !isArray(targetProp)
	                    && !isDom(sourceProp)
	                    && !isDom(targetProp)
	                    && !isBuildInObject(sourceProp)
	                    && !isBuildInObject(targetProp)
	                ) {
	                    // 如果需要递归覆盖，就递归调用merge
	                    merge(targetProp, sourceProp, overwrite);
	                }
	                else if (overwrite || !(key in target)) {
	                    // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况
	                    // NOTE，在 target[key] 不存在的时候也是直接覆盖
	                    target[key] = clone(source[key], true);
	                }
	            }
	        }
	
	        return target;
	    }
	
	    /**
	     * @param {Array} targetAndSources The first item is target, and the rests are source.
	     * @param {boolean} [overwrite=false]
	     * @return {*} target
	     */
	    function mergeAll(targetAndSources, overwrite) {
	        var result = targetAndSources[0];
	        for (var i = 1, len = targetAndSources.length; i < len; i++) {
	            result = merge(result, targetAndSources[i], overwrite);
	        }
	        return result;
	    }
	
	    /**
	     * @param {*} target
	     * @param {*} source
	     * @memberOf module:zrender/core/util
	     */
	    function extend(target, source) {
	        for (var key in source) {
	            if (source.hasOwnProperty(key)) {
	                target[key] = source[key];
	            }
	        }
	        return target;
	    }
	
	    /**
	     * @param {*} target
	     * @param {*} source
	     * @param {boolen} [overlay=false]
	     * @memberOf module:zrender/core/util
	     */
	    function defaults(target, source, overlay) {
	        for (var key in source) {
	            if (source.hasOwnProperty(key)
	                && (overlay ? source[key] != null : target[key] == null)
	            ) {
	                target[key] = source[key];
	            }
	        }
	        return target;
	    }
	
	    function createCanvas() {
	        return document.createElement('canvas');
	    }
	    // FIXME
	    var _ctx;
	    function getContext() {
	        if (!_ctx) {
	            // Use util.createCanvas instead of createCanvas
	            // because createCanvas may be overwritten in different environment
	            _ctx = util.createCanvas().getContext('2d');
	        }
	        return _ctx;
	    }
	
	    /**
	     * 查询数组中元素的index
	     * @memberOf module:zrender/core/util
	     */
	    function indexOf(array, value) {
	        if (array) {
	            if (array.indexOf) {
	                return array.indexOf(value);
	            }
	            for (var i = 0, len = array.length; i < len; i++) {
	                if (array[i] === value) {
	                    return i;
	                }
	            }
	        }
	        return -1;
	    }
	
	    /**
	     * 构造类继承关系
	     *
	     * @memberOf module:zrender/core/util
	     * @param {Function} clazz 源类
	     * @param {Function} baseClazz 基类
	     */
	    function inherits(clazz, baseClazz) {
	        var clazzPrototype = clazz.prototype;
	        function F() {}
	        F.prototype = baseClazz.prototype;
	        clazz.prototype = new F();
	
	        for (var prop in clazzPrototype) {
	            clazz.prototype[prop] = clazzPrototype[prop];
	        }
	        clazz.prototype.constructor = clazz;
	        clazz.superClass = baseClazz;
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {Object|Function} target
	     * @param {Object|Function} sorce
	     * @param {boolean} overlay
	     */
	    function mixin(target, source, overlay) {
	        target = 'prototype' in target ? target.prototype : target;
	        source = 'prototype' in source ? source.prototype : source;
	
	        defaults(target, source, overlay);
	    }
	
	    /**
	     * @param {Array|TypedArray} data
	     */
	    function isArrayLike(data) {
	        if (! data) {
	            return;
	        }
	        if (typeof data == 'string') {
	            return false;
	        }
	        return typeof data.length == 'number';
	    }
	
	    /**
	     * 数组或对象遍历
	     * @memberOf module:zrender/core/util
	     * @param {Object|Array} obj
	     * @param {Function} cb
	     * @param {*} [context]
	     */
	    function each(obj, cb, context) {
	        if (!(obj && cb)) {
	            return;
	        }
	        if (obj.forEach && obj.forEach === nativeForEach) {
	            obj.forEach(cb, context);
	        }
	        else if (obj.length === +obj.length) {
	            for (var i = 0, len = obj.length; i < len; i++) {
	                cb.call(context, obj[i], i, obj);
	            }
	        }
	        else {
	            for (var key in obj) {
	                if (obj.hasOwnProperty(key)) {
	                    cb.call(context, obj[key], key, obj);
	                }
	            }
	        }
	    }
	
	    /**
	     * 数组映射
	     * @memberOf module:zrender/core/util
	     * @param {Array} obj
	     * @param {Function} cb
	     * @param {*} [context]
	     * @return {Array}
	     */
	    function map(obj, cb, context) {
	        if (!(obj && cb)) {
	            return;
	        }
	        if (obj.map && obj.map === nativeMap) {
	            return obj.map(cb, context);
	        }
	        else {
	            var result = [];
	            for (var i = 0, len = obj.length; i < len; i++) {
	                result.push(cb.call(context, obj[i], i, obj));
	            }
	            return result;
	        }
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {Array} obj
	     * @param {Function} cb
	     * @param {Object} [memo]
	     * @param {*} [context]
	     * @return {Array}
	     */
	    function reduce(obj, cb, memo, context) {
	        if (!(obj && cb)) {
	            return;
	        }
	        if (obj.reduce && obj.reduce === nativeReduce) {
	            return obj.reduce(cb, memo, context);
	        }
	        else {
	            for (var i = 0, len = obj.length; i < len; i++) {
	                memo = cb.call(context, memo, obj[i], i, obj);
	            }
	            return memo;
	        }
	    }
	
	    /**
	     * 数组过滤
	     * @memberOf module:zrender/core/util
	     * @param {Array} obj
	     * @param {Function} cb
	     * @param {*} [context]
	     * @return {Array}
	     */
	    function filter(obj, cb, context) {
	        if (!(obj && cb)) {
	            return;
	        }
	        if (obj.filter && obj.filter === nativeFilter) {
	            return obj.filter(cb, context);
	        }
	        else {
	            var result = [];
	            for (var i = 0, len = obj.length; i < len; i++) {
	                if (cb.call(context, obj[i], i, obj)) {
	                    result.push(obj[i]);
	                }
	            }
	            return result;
	        }
	    }
	
	    /**
	     * 数组项查找
	     * @memberOf module:zrender/core/util
	     * @param {Array} obj
	     * @param {Function} cb
	     * @param {*} [context]
	     * @return {Array}
	     */
	    function find(obj, cb, context) {
	        if (!(obj && cb)) {
	            return;
	        }
	        for (var i = 0, len = obj.length; i < len; i++) {
	            if (cb.call(context, obj[i], i, obj)) {
	                return obj[i];
	            }
	        }
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {Function} func
	     * @param {*} context
	     * @return {Function}
	     */
	    function bind(func, context) {
	        var args = nativeSlice.call(arguments, 2);
	        return function () {
	            return func.apply(context, args.concat(nativeSlice.call(arguments)));
	        };
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {Function} func
	     * @return {Function}
	     */
	    function curry(func) {
	        var args = nativeSlice.call(arguments, 1);
	        return function () {
	            return func.apply(this, args.concat(nativeSlice.call(arguments)));
	        };
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isArray(value) {
	        return objToString.call(value) === '[object Array]';
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isFunction(value) {
	        return typeof value === 'function';
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isString(value) {
	        return objToString.call(value) === '[object String]';
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isObject(value) {
	        // Avoid a V8 JIT bug in Chrome 19-20.
	        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	        var type = typeof value;
	        return type === 'function' || (!!value && type == 'object');
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isBuildInObject(value) {
	        return !!BUILTIN_OBJECT[objToString.call(value)];
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isDom(value) {
	        return value && value.nodeType === 1
	               && typeof(value.nodeName) == 'string';
	    }
	
	    /**
	     * If value1 is not null, then return value1, otherwise judget rest of values.
	     * @memberOf module:zrender/core/util
	     * @return {*} Final value
	     */
	    function retrieve(values) {
	        for (var i = 0, len = arguments.length; i < len; i++) {
	            if (arguments[i] != null) {
	                return arguments[i];
	            }
	        }
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {Array} arr
	     * @param {number} startIndex
	     * @param {number} endIndex
	     * @return {Array}
	     */
	    function slice() {
	        return Function.call.apply(nativeSlice, arguments);
	    }
	
	    /**
	     * @memberOf module:zrender/core/util
	     * @param {boolean} condition
	     * @param {string} message
	     */
	    function assert(condition, message) {
	        if (!condition) {
	            throw new Error(message);
	        }
	    }
	
	    var util = {
	        inherits: inherits,
	        mixin: mixin,
	        clone: clone,
	        merge: merge,
	        mergeAll: mergeAll,
	        extend: extend,
	        defaults: defaults,
	        getContext: getContext,
	        createCanvas: createCanvas,
	        indexOf: indexOf,
	        slice: slice,
	        find: find,
	        isArrayLike: isArrayLike,
	        each: each,
	        map: map,
	        reduce: reduce,
	        filter: filter,
	        bind: bind,
	        curry: curry,
	        isArray: isArray,
	        isString: isString,
	        isObject: isObject,
	        isFunction: isFunction,
	        isBuildInObject: isBuildInObject,
	        isDom: isDom,
	        retrieve: retrieve,
	        assert: assert,
	        noop: function () {}
	    };
	    return util;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
	
	    var formatUtil = __webpack_require__(10);
	    var nubmerUtil = __webpack_require__(11);
	    var Model = __webpack_require__(16);
	    var zrUtil = __webpack_require__(8);
	
	    var modelUtil = {};
	
	    /**
	     * If value is not array, then translate it to array.
	     * @param  {*} value
	     * @return {Array} [value] or value
	     */
	    modelUtil.normalizeToArray = function (value) {
	        return value instanceof Array
	            ? value
	            : value == null
	            ? []
	            : [value];
	    };
	
	    /**
	     * Sync default option between normal and emphasis like `position` and `show`
	     * In case some one will write code like
	     *     label: {
	     *         normal: {
	     *             show: false,
	     *             position: 'outside',
	     *             textStyle: {
	     *                 fontSize: 18
	     *             }
	     *         },
	     *         emphasis: {
	     *             show: true
	     *         }
	     *     }
	     * @param {Object} opt
	     * @param {Array.<string>} subOpts
	     */
	     modelUtil.defaultEmphasis = function (opt, subOpts) {
	        if (opt) {
	            var emphasisOpt = opt.emphasis = opt.emphasis || {};
	            var normalOpt = opt.normal = opt.normal || {};
	
	            // Default emphasis option from normal
	            zrUtil.each(subOpts, function (subOptName) {
	                var val = zrUtil.retrieve(emphasisOpt[subOptName], normalOpt[subOptName]);
	                if (val != null) {
	                    emphasisOpt[subOptName] = val;
	                }
	            });
	        }
	    };
	
	    modelUtil.LABEL_OPTIONS = ['position', 'show', 'textStyle', 'distance', 'formatter'];
	
	    /**
	     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]
	     * This helper method retieves value from data.
	     * @param {string|number|Date|Array|Object} dataItem
	     * @return {number|string|Date|Array.<number|string|Date>}
	     */
	    modelUtil.getDataItemValue = function (dataItem) {
	        // Performance sensitive.
	        return dataItem && (dataItem.value == null ? dataItem : dataItem.value);
	    };
	
	    /**
	     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]
	     * This helper method determine if dataItem has extra option besides value
	     * @param {string|number|Date|Array|Object} dataItem
	     */
	    modelUtil.isDataItemOption = function (dataItem) {
	        return zrUtil.isObject(dataItem)
	            && !(dataItem instanceof Array);
	            // // markLine data can be array
	            // && !(dataItem[0] && zrUtil.isObject(dataItem[0]) && !(dataItem[0] instanceof Array));
	    };
	
	    /**
	     * This helper method convert value in data.
	     * @param {string|number|Date} value
	     * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.
	     */
	    modelUtil.converDataValue = function (value, dimInfo) {
	        // Performance sensitive.
	        var dimType = dimInfo && dimInfo.type;
	        if (dimType === 'ordinal') {
	            return value;
	        }
	
	        if (dimType === 'time' && !isFinite(value) && value != null && value !== '-') {
	            value = +nubmerUtil.parseDate(value);
	        }
	
	        // dimType defaults 'number'.
	        // If dimType is not ordinal and value is null or undefined or NaN or '-',
	        // parse to NaN.
	        return (value == null || value === '')
	            ? NaN : +value; // If string (like '-'), using '+' parse to NaN
	    };
	
	    /**
	     * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.
	     * @param {module:echarts/data/List} data
	     * @param {Object} opt
	     * @param {string} [opt.seriesIndex]
	     * @param {Object} [opt.name]
	     * @param {Object} [opt.mainType]
	     * @param {Object} [opt.subType]
	     */
	    modelUtil.createDataFormatModel = function (data, opt) {
	        var model = new Model();
	        zrUtil.mixin(model, modelUtil.dataFormatMixin);
	        model.seriesIndex = opt.seriesIndex;
	        model.name = opt.name || '';
	        model.mainType = opt.mainType;
	        model.subType = opt.subType;
	
	        model.getData = function () {
	            return data;
	        };
	        return model;
	    };
	
	    // PENDING A little ugly
	    modelUtil.dataFormatMixin = {
	        /**
	         * Get params for formatter
	         * @param {number} dataIndex
	         * @param {string} [dataType]
	         * @return {Object}
	         */
	        getDataParams: function (dataIndex, dataType) {
	            var data = this.getData(dataType);
	
	            var seriesIndex = this.seriesIndex;
	            var seriesName = this.name;
	
	            var rawValue = this.getRawValue(dataIndex, dataType);
	            var rawDataIndex = data.getRawIndex(dataIndex);
	            var name = data.getName(dataIndex, true);
	            var itemOpt = data.getRawDataItem(dataIndex);
	
	            return {
	                componentType: this.mainType,
	                componentSubType: this.subType,
	                seriesType: this.mainType === 'series' ? this.subType : null,
	                seriesIndex: seriesIndex,
	                seriesName: seriesName,
	                name: name,
	                dataIndex: rawDataIndex,
	                data: itemOpt,
	                dataType: dataType,
	                value: rawValue,
	                color: data.getItemVisual(dataIndex, 'color'),
	
	                // Param name list for mapping `a`, `b`, `c`, `d`, `e`
	                $vars: ['seriesName', 'name', 'value']
	            };
	        },
	
	        /**
	         * Format label
	         * @param {number} dataIndex
	         * @param {string} [status='normal'] 'normal' or 'emphasis'
	         * @param {string} [dataType]
	         * @param {number} [dimIndex]
	         * @return {string}
	         */
	        getFormattedLabel: function (dataIndex, status, dataType, dimIndex) {
	            status = status || 'normal';
	            var data = this.getData(dataType);
	            var itemModel = data.getItemModel(dataIndex);
	
	            var params = this.getDataParams(dataIndex, dataType);
	            if (dimIndex != null && (params.value instanceof Array)) {
	                params.value = params.value[dimIndex];
	            }
	
	            var formatter = itemModel.get(['label', status, 'formatter']);
	
	            if (typeof formatter === 'function') {
	                params.status = status;
	                return formatter(params);
	            }
	            else if (typeof formatter === 'string') {
	                return formatUtil.formatTpl(formatter, params);
	            }
	        },
	
	        /**
	         * Get raw value in option
	         * @param {number} idx
	         * @param {string} [dataType]
	         * @return {Object}
	         */
	        getRawValue: function (idx, dataType) {
	            var data = this.getData(dataType);
	            var dataItem = data.getRawDataItem(idx);
	            if (dataItem != null) {
	                return (zrUtil.isObject(dataItem) && !(dataItem instanceof Array))
	                    ? dataItem.value : dataItem;
	            }
	        },
	
	        /**
	         * Should be implemented.
	         * @param {number} dataIndex
	         * @param {boolean} [multipleSeries=false]
	         * @param {number} [dataType]
	         * @return {string} tooltip string
	         */
	        formatTooltip: zrUtil.noop
	    };
	
	    /**
	     * Mapping to exists for merge.
	     *
	     * @public
	     * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists
	     * @param {Object|Array.<Object>} newCptOptions
	     * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],
	     *                          which order is the same as exists.
	     */
	    modelUtil.mappingToExists = function (exists, newCptOptions) {
	        // Mapping by the order by original option (but not order of
	        // new option) in merge mode. Because we should ensure
	        // some specified index (like xAxisIndex) is consistent with
	        // original option, which is easy to understand, espatially in
	        // media query. And in most case, merge option is used to
	        // update partial option but not be expected to change order.
	        newCptOptions = (newCptOptions || []).slice();
	
	        var result = zrUtil.map(exists || [], function (obj, index) {
	            return {exist: obj};
	        });
	
	        // Mapping by id or name if specified.
	        zrUtil.each(newCptOptions, function (cptOption, index) {
	            if (!zrUtil.isObject(cptOption)) {
	                return;
	            }
	
	            // id has highest priority.
	            for (var i = 0; i < result.length; i++) {
	                if (!result[i].option // Consider name: two map to one.
	                    && cptOption.id != null
	                    && result[i].exist.id === cptOption.id + ''
	                ) {
	                    result[i].option = cptOption;
	                    newCptOptions[index] = null;
	                    return;
	                }
	            }
	
	            for (var i = 0; i < result.length; i++) {
	                var exist = result[i].exist;
	                if (!result[i].option // Consider name: two map to one.
	                    // Can not match when both ids exist but different.
	                    && (exist.id == null || cptOption.id == null)
	                    && cptOption.name != null
	                    && !modelUtil.isIdInner(cptOption)
	                    && !modelUtil.isIdInner(exist)
	                    && exist.name === cptOption.name + ''
	                ) {
	                    result[i].option = cptOption;
	                    newCptOptions[index] = null;
	                    return;
	                }
	            }
	        });
	
	        // Otherwise mapping by index.
	        zrUtil.each(newCptOptions, function (cptOption, index) {
	            if (!zrUtil.isObject(cptOption)) {
	                return;
	            }
	
	            var i = 0;
	            for (; i < result.length; i++) {
	                var exist = result[i].exist;
	                if (!result[i].option
	                    && !modelUtil.isIdInner(exist)
	                    // Caution:
	                    // Do not overwrite id. But name can be overwritten,
	                    // because axis use name as 'show label text'.
	                    // 'exist' always has id and name and we dont
	                    // need to check it.
	                    && cptOption.id == null
	                ) {
	                    result[i].option = cptOption;
	                    break;
	                }
	            }
	
	            if (i >= result.length) {
	                result.push({option: cptOption});
	            }
	        });
	
	        return result;
	    };
	
	    /**
	     * @public
	     * @param {Object} cptOption
	     * @return {boolean}
	     */
	    modelUtil.isIdInner = function (cptOption) {
	        return zrUtil.isObject(cptOption)
	            && cptOption.id
	            && (cptOption.id + '').indexOf('\0_ec_\0') === 0;
	    };
	
	    /**
	     * A helper for removing duplicate items between batchA and batchB,
	     * and in themselves, and categorize by series.
	     *
	     * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]
	     * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]
	     * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]
	     */
	    modelUtil.compressBatches = function (batchA, batchB) {
	        var mapA = {};
	        var mapB = {};
	
	        makeMap(batchA || [], mapA);
	        makeMap(batchB || [], mapB, mapA);
	
	        return [mapToArray(mapA), mapToArray(mapB)];
	
	        function makeMap(sourceBatch, map, otherMap) {
	            for (var i = 0, len = sourceBatch.length; i < len; i++) {
	                var seriesId = sourceBatch[i].seriesId;
	                var dataIndices = modelUtil.normalizeToArray(sourceBatch[i].dataIndex);
	                var otherDataIndices = otherMap && otherMap[seriesId];
	
	                for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {
	                    var dataIndex = dataIndices[j];
	
	                    if (otherDataIndices && otherDataIndices[dataIndex]) {
	                        otherDataIndices[dataIndex] = null;
	                    }
	                    else {
	                        (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;
	                    }
	                }
	            }
	        }
	
	        function mapToArray(map, isData) {
	            var result = [];
	            for (var i in map) {
	                if (map.hasOwnProperty(i) && map[i] != null) {
	                    if (isData) {
	                        result.push(+i);
	                    }
	                    else {
	                        var dataIndices = mapToArray(map[i], true);
	                        dataIndices.length && result.push({seriesId: i, dataIndex: dataIndices});
	                    }
	                }
	            }
	            return result;
	        }
	    };
	
	    return modelUtil;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var zrUtil = __webpack_require__(8);
	    var numberUtil = __webpack_require__(11);
	    var textContain = __webpack_require__(12);
	
	    var formatUtil = {};
	    /**
	     * 每三位默认加,格式化
	     * @type {string|number} x
	     */
	    formatUtil.addCommas = function (x) {
	        if (isNaN(x)) {
	            return '-';
	        }
	        x = (x + '').split('.');
	        return x[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g,'$1,')
	               + (x.length > 1 ? ('.' + x[1]) : '');
	    };
	
	    /**
	     * @param {string} str
	     * @return {string} str
	     */
	    formatUtil.toCamelCase = function (str) {
	        return str.toLowerCase().replace(/-(.)/g, function(match, group1) {
	            return group1.toUpperCase();
	        });
	    };
	
	    /**
	     * Normalize css liked array configuration
	     * e.g.
	     *  3 => [3, 3, 3, 3]
	     *  [4, 2] => [4, 2, 4, 2]
	     *  [4, 3, 2] => [4, 3, 2, 3]
	     * @param {number|Array.<number>} val
	     */
	    formatUtil.normalizeCssArray = function (val) {
	        var len = val.length;
	        if (typeof (val) === 'number') {
	            return [val, val, val, val];
	        }
	        else if (len === 2) {
	            // vertical | horizontal
	            return [val[0], val[1], val[0], val[1]];
	        }
	        else if (len === 3) {
	            // top | horizontal | bottom
	            return [val[0], val[1], val[2], val[1]];
	        }
	        return val;
	    };
	
	    formatUtil.encodeHTML = function (source) {
	        return String(source)
	            .replace(/&/g, '&amp;')
	            .replace(/</g, '&lt;')
	            .replace(/>/g, '&gt;')
	            .replace(/"/g, '&quot;')
	            .replace(/'/g, '&#39;');
	    };
	
	    var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];
	
	    var wrapVar = function (varName, seriesIdx) {
	        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';
	    };
	
	    /**
	     * Template formatter
	     * @param  {string} tpl
	     * @param  {Array.<Object>|Object} paramsList
	     * @return {string}
	     */
	    formatUtil.formatTpl = function (tpl, paramsList) {
	        if (!zrUtil.isArray(paramsList)) {
	            paramsList = [paramsList];
	        }
	        var seriesLen = paramsList.length;
	        if (!seriesLen) {
	            return '';
	        }
	
	        var $vars = paramsList[0].$vars || [];
	        for (var i = 0; i < $vars.length; i++) {
	            var alias = TPL_VAR_ALIAS[i];
	            tpl = tpl.replace(wrapVar(alias),  wrapVar(alias, 0));
	        }
	        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {
	            for (var k = 0; k < $vars.length; k++) {
	                tpl = tpl.replace(
	                    wrapVar(TPL_VAR_ALIAS[k], seriesIdx),
	                    paramsList[seriesIdx][$vars[k]]
	                );
	            }
	        }
	
	        return tpl;
	    };
	
	
	    /**
	     * @param {string} str
	     * @return {string}
	     * @inner
	     */
	    var s2d = function (str) {
	        return str < 10 ? ('0' + str) : str;
	    };
	
	    /**
	     * ISO Date format
	     * @param {string} tpl
	     * @param {number} value
	     * @inner
	     */
	    formatUtil.formatTime = function (tpl, value) {
	        if (tpl === 'week'
	            || tpl === 'month'
	            || tpl === 'quarter'
	            || tpl === 'half-year'
	            || tpl === 'year'
	        ) {
	            tpl = 'MM-dd\nyyyy';
	        }
	
	        var date = numberUtil.parseDate(value);
	        var y = date.getFullYear();
	        var M = date.getMonth() + 1;
	        var d = date.getDate();
	        var h = date.getHours();
	        var m = date.getMinutes();
	        var s = date.getSeconds();
	
	        tpl = tpl.replace('MM', s2d(M))
	            .toLowerCase()
	            .replace('yyyy', y)
	            .replace('yy', y % 100)
	            .replace('dd', s2d(d))
	            .replace('d', d)
	            .replace('hh', s2d(h))
	            .replace('h', h)
	            .replace('mm', s2d(m))
	            .replace('m', m)
	            .replace('ss', s2d(s))
	            .replace('s', s);
	
	        return tpl;
	    };
	
	    /**
	     * Capital first
	     * @param {string} str
	     * @return {string}
	     */
	    formatUtil.capitalFirst = function (str) {
	        return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;
	    };
	
	    formatUtil.truncateText = textContain.truncateText;
	
	    return formatUtil;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * 数值处理模块
	 * @module echarts/util/number
	 */
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var number = {};
	
	    var RADIAN_EPSILON = 1e-4;
	
	    function _trim(str) {
	        return str.replace(/^\s+/, '').replace(/\s+$/, '');
	    }
	
	    /**
	     * Linear mapping a value from domain to range
	     * @memberOf module:echarts/util/number
	     * @param  {(number|Array.<number>)} val
	     * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]
	     * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]
	     * @param  {boolean} clamp
	     * @return {(number|Array.<number>}
	     */
	    number.linearMap = function (val, domain, range, clamp) {
	        var subDomain = domain[1] - domain[0];
	        var subRange = range[1] - range[0];
	
	        if (subDomain === 0) {
	            return subRange === 0
	                ? range[0]
	                : (range[0] + range[1]) / 2;
	        }
	
	        // Avoid accuracy problem in edge, such as
	        // 146.39 - 62.83 === 83.55999999999999.
	        // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError
	        // It is a little verbose for efficiency considering this method
	        // is a hotspot.
	        if (clamp) {
	            if (subDomain > 0) {
	                if (val <= domain[0]) {
	                    return range[0];
	                }
	                else if (val >= domain[1]) {
	                    return range[1];
	                }
	            }
	            else {
	                if (val >= domain[0]) {
	                    return range[0];
	                }
	                else if (val <= domain[1]) {
	                    return range[1];
	                }
	            }
	        }
	        else {
	            if (val === domain[0]) {
	                return range[0];
	            }
	            if (val === domain[1]) {
	                return range[1];
	            }
	        }
	
	        return (val - domain[0]) / subDomain * subRange + range[0];
	    };
	
	    /**
	     * Convert a percent string to absolute number.
	     * Returns NaN if percent is not a valid string or number
	     * @memberOf module:echarts/util/number
	     * @param {string|number} percent
	     * @param {number} all
	     * @return {number}
	     */
	    number.parsePercent = function(percent, all) {
	        switch (percent) {
	            case 'center':
	            case 'middle':
	                percent = '50%';
	                break;
	            case 'left':
	            case 'top':
	                percent = '0%';
	                break;
	            case 'right':
	            case 'bottom':
	                percent = '100%';
	                break;
	        }
	        if (typeof percent === 'string') {
	            if (_trim(percent).match(/%$/)) {
	                return parseFloat(percent) / 100 * all;
	            }
	
	            return parseFloat(percent);
	        }
	
	        return percent == null ? NaN : +percent;
	    };
	
	    /**
	     * Fix rounding error of float numbers
	     * @param {number} x
	     * @return {number}
	     */
	    number.round = function (x, precision) {
	        if (precision == null) {
	            precision = 10;
	        }
	        // PENDING
	        return +(+x).toFixed(precision);
	    };
	
	    number.asc = function (arr) {
	        arr.sort(function (a, b) {
	            return a - b;
	        });
	        return arr;
	    };
	
	    /**
	     * Get precision
	     * @param {number} val
	     */
	    number.getPrecision = function (val) {
	        val = +val;
	        if (isNaN(val)) {
	            return 0;
	        }
	        // It is much faster than methods converting number to string as follows
	        //      var tmp = val.toString();
	        //      return tmp.length - 1 - tmp.indexOf('.');
	        // especially when precision is low
	        var e = 1;
	        var count = 0;
	        while (Math.round(val * e) / e !== val) {
	            e *= 10;
	            count++;
	        }
	        return count;
	    };
	
	    number.getPrecisionSafe = function (val) {
	        var str = val.toString();
	        var dotIndex = str.indexOf('.');
	        if (dotIndex < 0) {
	            return 0;
	        }
	        return str.length - 1 - dotIndex;
	    };
	
	    /**
	     * @param {Array.<number>} dataExtent
	     * @param {Array.<number>} pixelExtent
	     * @return {number}  precision
	     */
	    number.getPixelPrecision = function (dataExtent, pixelExtent) {
	        var log = Math.log;
	        var LN10 = Math.LN10;
	        var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);
	        var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);
	        return Math.max(
	            -dataQuantity + sizeQuantity,
	            0
	        );
	    };
	
	    // Number.MAX_SAFE_INTEGER, ie do not support.
	    number.MAX_SAFE_INTEGER = 9007199254740991;
	
	    /**
	     * To 0 - 2 * PI, considering negative radian.
	     * @param {number} radian
	     * @return {number}
	     */
	    number.remRadian = function (radian) {
	        var pi2 = Math.PI * 2;
	        return (radian % pi2 + pi2) % pi2;
	    };
	
	    /**
	     * @param {type} radian
	     * @return {boolean}
	     */
	    number.isRadianAroundZero = function (val) {
	        return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;
	    };
	
	    /**
	     * @param {string|Date|number} value
	     * @return {Date} date
	     */
	    number.parseDate = function (value) {
	        if (value instanceof Date) {
	            return value;
	        }
	        else if (typeof value === 'string') {
	            // Treat as ISO format. See issue #3623
	            var ret = new Date(value);
	            if (isNaN(+ret)) {
	                // FIXME new Date('1970-01-01') is UTC, new Date('1970/01/01') is local
	                ret = new Date(new Date(value.replace(/-/g, '/')) - new Date('1970/01/01'));
	            }
	            return ret;
	        }
	
	        return new Date(Math.round(value));
	    };
	
	    /**
	     * Quantity of a number. e.g. 0.1, 1, 10, 100
	     * @param  {number} val
	     * @return {number}
	     */
	    number.quantity = function (val) {
	        return Math.pow(10, Math.floor(Math.log(val) / Math.LN10));
	    };
	
	    // "Nice Numbers for Graph Labels" of Graphic Gems
	    /**
	     * find a “nice” number approximately equal to x. Round the number if round = true, take ceiling if round = false
	     * The primary observation is that the “nicest” numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.
	     * @param  {number} val
	     * @param  {boolean} round
	     * @return {number}
	     */
	    number.nice = function (val, round) {
	        var exp10 = number.quantity(val);
	        var f = val / exp10; // between 1 and 10
	        var nf;
	        if (round) {
	            if (f < 1.5) { nf = 1; }
	            else if (f < 2.5) { nf = 2; }
	            else if (f < 4) { nf = 3; }
	            else if (f < 7) { nf = 5; }
	            else { nf = 10; }
	        }
	        else {
	            if (f < 1) { nf = 1; }
	            else if (f < 2) { nf = 2; }
	            else if (f < 3) { nf = 3; }
	            else if (f < 5) { nf = 5; }
	            else { nf = 10; }
	        }
	        return nf * exp10;
	    };
	
	    return number;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var textWidthCache = {};
	    var textWidthCacheCounter = 0;
	    var TEXT_CACHE_MAX = 5000;
	
	    var util = __webpack_require__(8);
	    var BoundingRect = __webpack_require__(13);
	    var retrieve = util.retrieve;
	
	    function getTextWidth(text, textFont) {
	        var key = text + ':' + textFont;
	        if (textWidthCache[key]) {
	            return textWidthCache[key];
	        }
	
	        var textLines = (text + '').split('\n');
	        var width = 0;
	
	        for (var i = 0, l = textLines.length; i < l; i++) {
	            // measureText 可以被覆盖以兼容不支持 Canvas 的环境
	            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);
	        }
	
	        if (textWidthCacheCounter > TEXT_CACHE_MAX) {
	            textWidthCacheCounter = 0;
	            textWidthCache = {};
	        }
	        textWidthCacheCounter++;
	        textWidthCache[key] = width;
	
	        return width;
	    }
	
	    function getTextRect(text, textFont, textAlign, textBaseline) {
	        var textLineLen = ((text || '') + '').split('\n').length;
	
	        var width = getTextWidth(text, textFont);
	        // FIXME 高度计算比较粗暴
	        var lineHeight = getTextWidth('国', textFont);
	        var height = textLineLen * lineHeight;
	
	        var rect = new BoundingRect(0, 0, width, height);
	        // Text has a special line height property
	        rect.lineHeight = lineHeight;
	
	        switch (textBaseline) {
	            case 'bottom':
	            case 'alphabetic':
	                rect.y -= lineHeight;
	                break;
	            case 'middle':
	                rect.y -= lineHeight / 2;
	                break;
	            // case 'hanging':
	            // case 'top':
	        }
	
	        // FIXME Right to left language
	        switch (textAlign) {
	            case 'end':
	            case 'right':
	                rect.x -= rect.width;
	                break;
	            case 'center':
	                rect.x -= rect.width / 2;
	                break;
	            // case 'start':
	            // case 'left':
	        }
	
	        return rect;
	    }
	
	    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {
	
	        var x = rect.x;
	        var y = rect.y;
	
	        var height = rect.height;
	        var width = rect.width;
	
	        var textHeight = textRect.height;
	
	        var halfHeight = height / 2 - textHeight / 2;
	
	        var textAlign = 'left';
	
	        switch (textPosition) {
	            case 'left':
	                x -= distance;
	                y += halfHeight;
	                textAlign = 'right';
	                break;
	            case 'right':
	                x += distance + width;
	                y += halfHeight;
	                textAlign = 'left';
	                break;
	            case 'top':
	                x += width / 2;
	                y -= distance + textHeight;
	                textAlign = 'center';
	                break;
	            case 'bottom':
	                x += width / 2;
	                y += height + distance;
	                textAlign = 'center';
	                break;
	            case 'inside':
	                x += width / 2;
	                y += halfHeight;
	                textAlign = 'center';
	                break;
	            case 'insideLeft':
	                x += distance;
	                y += halfHeight;
	                textAlign = 'left';
	                break;
	            case 'insideRight':
	                x += width - distance;
	                y += halfHeight;
	                textAlign = 'right';
	                break;
	            case 'insideTop':
	                x += width / 2;
	                y += distance;
	                textAlign = 'center';
	                break;
	            case 'insideBottom':
	                x += width / 2;
	                y += height - textHeight - distance;
	                textAlign = 'center';
	                break;
	            case 'insideTopLeft':
	                x += distance;
	                y += distance;
	                textAlign = 'left';
	                break;
	            case 'insideTopRight':
	                x += width - distance;
	                y += distance;
	                textAlign = 'right';
	                break;
	            case 'insideBottomLeft':
	                x += distance;
	                y += height - textHeight - distance;
	                break;
	            case 'insideBottomRight':
	                x += width - distance;
	                y += height - textHeight - distance;
	                textAlign = 'right';
	                break;
	        }
	
	        return {
	            x: x,
	            y: y,
	            textAlign: textAlign,
	            textBaseline: 'top'
	        };
	    }
	
	    /**
	     * Show ellipsis if overflow.
	     *
	     * @param  {string} text
	     * @param  {string} containerWidth
	     * @param  {string} textFont
	     * @param  {number} [ellipsis='...']
	     * @param  {Object} [options]
	     * @param  {number} [options.maxIterations=3]
	     * @param  {number} [options.minChar=0] If truncate result are less
	     *                  then minChar, ellipsis will not show, which is
	     *                  better for user hint in some cases.
	     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.
	     * @return {string}
	     */
	    function truncateText(text, containerWidth, textFont, ellipsis, options) {
	        if (!containerWidth) {
	            return '';
	        }
	
	        options = options || {};
	
	        ellipsis = retrieve(ellipsis, '...');
	        var maxIterations = retrieve(options.maxIterations, 2);
	        var minChar = retrieve(options.minChar, 0);
	        // FIXME
	        // Other languages?
	        var cnCharWidth = getTextWidth('国', textFont);
	        // FIXME
	        // Consider proportional font?
	        var ascCharWidth = getTextWidth('a', textFont);
	        var placeholder = retrieve(options.placeholder, '');
	
	        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.
	        // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.
	        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.
	        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {
	            contentWidth -= ascCharWidth;
	        }
	
	        var ellipsisWidth = getTextWidth(ellipsis);
	        if (ellipsisWidth > contentWidth) {
	            ellipsis = '';
	            ellipsisWidth = 0;
	        }
	
	        contentWidth = containerWidth - ellipsisWidth;
	
	        var textLines = (text + '').split('\n');
	
	        for (var i = 0, len = textLines.length; i < len; i++) {
	            var textLine = textLines[i];
	            var lineWidth = getTextWidth(textLine, textFont);
	
	            if (lineWidth <= containerWidth) {
	                continue;
	            }
	
	            for (var j = 0;; j++) {
	                if (lineWidth <= contentWidth || j >= maxIterations) {
	                    textLine += ellipsis;
	                    break;
	                }
	
	                var subLength = j === 0
	                    ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth)
	                    : lineWidth > 0
	                    ? Math.floor(textLine.length * contentWidth / lineWidth)
	                    : 0;
	
	                textLine = textLine.substr(0, subLength);
	                lineWidth = getTextWidth(textLine, textFont);
	            }
	
	            if (textLine === '') {
	                textLine = placeholder;
	            }
	
	            textLines[i] = textLine;
	        }
	
	        return textLines.join('\n');
	    }
	
	    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {
	        var width = 0;
	        var i = 0;
	        for (var len = text.length; i < len && width < contentWidth; i++) {
	            var charCode = text.charCodeAt(i);
	            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;
	        }
	        return i;
	    }
	
	    var textContain = {
	
	        getWidth: getTextWidth,
	
	        getBoundingRect: getTextRect,
	
	        adjustTextPositionOnRect: adjustTextPositionOnRect,
	
	        truncateText: truncateText,
	
	        measureText: function (text, textFont) {
	            var ctx = util.getContext();
	            ctx.font = textFont || '12px sans-serif';
	            return ctx.measureText(text);
	        }
	    };
	
	    return textContain;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * @module echarts/core/BoundingRect
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
	    'use strict';
	
	    var vec2 = __webpack_require__(14);
	    var matrix = __webpack_require__(15);
	
	    var v2ApplyTransform = vec2.applyTransform;
	    var mathMin = Math.min;
	    var mathAbs = Math.abs;
	    var mathMax = Math.max;
	    /**
	     * @alias module:echarts/core/BoundingRect
	     */
	    function BoundingRect(x, y, width, height) {
	        /**
	         * @type {number}
	         */
	        this.x = x;
	        /**
	         * @type {number}
	         */
	        this.y = y;
	        /**
	         * @type {number}
	         */
	        this.width = width;
	        /**
	         * @type {number}
	         */
	        this.height = height;
	    }
	
	    BoundingRect.prototype = {
	
	        constructor: BoundingRect,
	
	        /**
	         * @param {module:echarts/core/BoundingRect} other
	         */
	        union: function (other) {
	            var x = mathMin(other.x, this.x);
	            var y = mathMin(other.y, this.y);
	
	            this.width = mathMax(
	                    other.x + other.width,
	                    this.x + this.width
	                ) - x;
	            this.height = mathMax(
	                    other.y + other.height,
	                    this.y + this.height
	                ) - y;
	            this.x = x;
	            this.y = y;
	        },
	
	        /**
	         * @param {Array.<number>} m
	         * @methods
	         */
	        applyTransform: (function () {
	            var min = [];
	            var max = [];
	            return function (m) {
	                // In case usage like this
	                // el.getBoundingRect().applyTransform(el.transform)
	                // And element has no transform
	                if (!m) {
	                    return;
	                }
	                min[0] = this.x;
	                min[1] = this.y;
	                max[0] = this.x + this.width;
	                max[1] = this.y + this.height;
	
	                v2ApplyTransform(min, min, m);
	                v2ApplyTransform(max, max, m);
	
	                this.x = mathMin(min[0], max[0]);
	                this.y = mathMin(min[1], max[1]);
	                this.width = mathAbs(max[0] - min[0]);
	                this.height = mathAbs(max[1] - min[1]);
	            };
	        })(),
	
	        /**
	         * Calculate matrix of transforming from self to target rect
	         * @param  {module:zrender/core/BoundingRect} b
	         * @return {Array.<number>}
	         */
	        calculateTransform: function (b) {
	            var a = this;
	            var sx = b.width / a.width;
	            var sy = b.height / a.height;
	
	            var m = matrix.create();
	
	            // 矩阵右乘
	            matrix.translate(m, m, [-a.x, -a.y]);
	            matrix.scale(m, m, [sx, sy]);
	            matrix.translate(m, m, [b.x, b.y]);
	
	            return m;
	        },
	
	        /**
	         * @param {(module:echarts/core/BoundingRect|Object)} b
	         * @return {boolean}
	         */
	        intersect: function (b) {
	            var a = this;
	            var ax0 = a.x;
	            var ax1 = a.x + a.width;
	            var ay0 = a.y;
	            var ay1 = a.y + a.height;
	
	            var bx0 = b.x;
	            var bx1 = b.x + b.width;
	            var by0 = b.y;
	            var by1 = b.y + b.height;
	
	            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
	        },
	
	        contain: function (x, y) {
	            var rect = this;
	            return x >= rect.x
	                && x <= (rect.x + rect.width)
	                && y >= rect.y
	                && y <= (rect.y + rect.height);
	        },
	
	        /**
	         * @return {module:echarts/core/BoundingRect}
	         */
	        clone: function () {
	            return new BoundingRect(this.x, this.y, this.width, this.height);
	        },
	
	        /**
	         * Copy from another rect
	         */
	        copy: function (other) {
	            this.x = other.x;
	            this.y = other.y;
	            this.width = other.width;
	            this.height = other.height;
	        }
	    };
	
	    return BoundingRect;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var ArrayCtor = typeof Float32Array === 'undefined'
	        ? Array
	        : Float32Array;
	
	    /**
	     * @typedef {Float32Array|Array.<number>} Vector2
	     */
	    /**
	     * 二维向量类
	     * @exports zrender/tool/vector
	     */
	    var vector = {
	        /**
	         * 创建一个向量
	         * @param {number} [x=0]
	         * @param {number} [y=0]
	         * @return {Vector2}
	         */
	        create: function (x, y) {
	            var out = new ArrayCtor(2);
	            if (x == null) {
	                x = 0;
	            }
	            if (y == null) {
	                y = 0;
	            }
	            out[0] = x;
	            out[1] = y;
	            return out;
	        },
	
	        /**
	         * 复制向量数据
	         * @param {Vector2} out
	         * @param {Vector2} v
	         * @return {Vector2}
	         */
	        copy: function (out, v) {
	            out[0] = v[0];
	            out[1] = v[1];
	            return out;
	        },
	
	        /**
	         * 克隆一个向量
	         * @param {Vector2} v
	         * @return {Vector2}
	         */
	        clone: function (v) {
	            var out = new ArrayCtor(2);
	            out[0] = v[0];
	            out[1] = v[1];
	            return out;
	        },
	
	        /**
	         * 设置向量的两个项
	         * @param {Vector2} out
	         * @param {number} a
	         * @param {number} b
	         * @return {Vector2} 结果
	         */
	        set: function (out, a, b) {
	            out[0] = a;
	            out[1] = b;
	            return out;
	        },
	
	        /**
	         * 向量相加
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         */
	        add: function (out, v1, v2) {
	            out[0] = v1[0] + v2[0];
	            out[1] = v1[1] + v2[1];
	            return out;
	        },
	
	        /**
	         * 向量缩放后相加
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @param {number} a
	         */
	        scaleAndAdd: function (out, v1, v2, a) {
	            out[0] = v1[0] + v2[0] * a;
	            out[1] = v1[1] + v2[1] * a;
	            return out;
	        },
	
	        /**
	         * 向量相减
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         */
	        sub: function (out, v1, v2) {
	            out[0] = v1[0] - v2[0];
	            out[1] = v1[1] - v2[1];
	            return out;
	        },
	
	        /**
	         * 向量长度
	         * @param {Vector2} v
	         * @return {number}
	         */
	        len: function (v) {
	            return Math.sqrt(this.lenSquare(v));
	        },
	
	        /**
	         * 向量长度平方
	         * @param {Vector2} v
	         * @return {number}
	         */
	        lenSquare: function (v) {
	            return v[0] * v[0] + v[1] * v[1];
	        },
	
	        /**
	         * 向量乘法
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         */
	        mul: function (out, v1, v2) {
	            out[0] = v1[0] * v2[0];
	            out[1] = v1[1] * v2[1];
	            return out;
	        },
	
	        /**
	         * 向量除法
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         */
	        div: function (out, v1, v2) {
	            out[0] = v1[0] / v2[0];
	            out[1] = v1[1] / v2[1];
	            return out;
	        },
	
	        /**
	         * 向量点乘
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @return {number}
	         */
	        dot: function (v1, v2) {
	            return v1[0] * v2[0] + v1[1] * v2[1];
	        },
	
	        /**
	         * 向量缩放
	         * @param {Vector2} out
	         * @param {Vector2} v
	         * @param {number} s
	         */
	        scale: function (out, v, s) {
	            out[0] = v[0] * s;
	            out[1] = v[1] * s;
	            return out;
	        },
	
	        /**
	         * 向量归一化
	         * @param {Vector2} out
	         * @param {Vector2} v
	         */
	        normalize: function (out, v) {
	            var d = vector.len(v);
	            if (d === 0) {
	                out[0] = 0;
	                out[1] = 0;
	            }
	            else {
	                out[0] = v[0] / d;
	                out[1] = v[1] / d;
	            }
	            return out;
	        },
	
	        /**
	         * 计算向量间距离
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @return {number}
	         */
	        distance: function (v1, v2) {
	            return Math.sqrt(
	                (v1[0] - v2[0]) * (v1[0] - v2[0])
	                + (v1[1] - v2[1]) * (v1[1] - v2[1])
	            );
	        },
	
	        /**
	         * 向量距离平方
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @return {number}
	         */
	        distanceSquare: function (v1, v2) {
	            return (v1[0] - v2[0]) * (v1[0] - v2[0])
	                + (v1[1] - v2[1]) * (v1[1] - v2[1]);
	        },
	
	        /**
	         * 求负向量
	         * @param {Vector2} out
	         * @param {Vector2} v
	         */
	        negate: function (out, v) {
	            out[0] = -v[0];
	            out[1] = -v[1];
	            return out;
	        },
	
	        /**
	         * 插值两个点
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @param {number} t
	         */
	        lerp: function (out, v1, v2, t) {
	            out[0] = v1[0] + t * (v2[0] - v1[0]);
	            out[1] = v1[1] + t * (v2[1] - v1[1]);
	            return out;
	        },
	
	        /**
	         * 矩阵左乘向量
	         * @param {Vector2} out
	         * @param {Vector2} v
	         * @param {Vector2} m
	         */
	        applyTransform: function (out, v, m) {
	            var x = v[0];
	            var y = v[1];
	            out[0] = m[0] * x + m[2] * y + m[4];
	            out[1] = m[1] * x + m[3] * y + m[5];
	            return out;
	        },
	        /**
	         * 求两个向量最小值
	         * @param  {Vector2} out
	         * @param  {Vector2} v1
	         * @param  {Vector2} v2
	         */
	        min: function (out, v1, v2) {
	            out[0] = Math.min(v1[0], v2[0]);
	            out[1] = Math.min(v1[1], v2[1]);
	            return out;
	        },
	        /**
	         * 求两个向量最大值
	         * @param  {Vector2} out
	         * @param  {Vector2} v1
	         * @param  {Vector2} v2
	         */
	        max: function (out, v1, v2) {
	            out[0] = Math.max(v1[0], v2[0]);
	            out[1] = Math.max(v1[1], v2[1]);
	            return out;
	        }
	    };
	
	    vector.length = vector.len;
	    vector.lengthSquare = vector.lenSquare;
	    vector.dist = vector.distance;
	    vector.distSquare = vector.distanceSquare;
	
	    return vector;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var ArrayCtor = typeof Float32Array === 'undefined'
	        ? Array
	        : Float32Array;
	    /**
	     * 3x2矩阵操作类
	     * @exports zrender/tool/matrix
	     */
	    var matrix = {
	        /**
	         * 创建一个单位矩阵
	         * @return {Float32Array|Array.<number>}
	         */
	        create : function() {
	            var out = new ArrayCtor(6);
	            matrix.identity(out);
	
	            return out;
	        },
	        /**
	         * 设置矩阵为单位矩阵
	         * @param {Float32Array|Array.<number>} out
	         */
	        identity : function(out) {
	            out[0] = 1;
	            out[1] = 0;
	            out[2] = 0;
	            out[3] = 1;
	            out[4] = 0;
	            out[5] = 0;
	            return out;
	        },
	        /**
	         * 复制矩阵
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} m
	         */
	        copy: function(out, m) {
	            out[0] = m[0];
	            out[1] = m[1];
	            out[2] = m[2];
	            out[3] = m[3];
	            out[4] = m[4];
	            out[5] = m[5];
	            return out;
	        },
	        /**
	         * 矩阵相乘
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} m1
	         * @param {Float32Array|Array.<number>} m2
	         */
	        mul : function (out, m1, m2) {
	            // Consider matrix.mul(m, m2, m);
	            // where out is the same as m2.
	            // So use temp variable to escape error.
	            var out0 = m1[0] * m2[0] + m1[2] * m2[1];
	            var out1 = m1[1] * m2[0] + m1[3] * m2[1];
	            var out2 = m1[0] * m2[2] + m1[2] * m2[3];
	            var out3 = m1[1] * m2[2] + m1[3] * m2[3];
	            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
	            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
	            out[0] = out0;
	            out[1] = out1;
	            out[2] = out2;
	            out[3] = out3;
	            out[4] = out4;
	            out[5] = out5;
	            return out;
	        },
	        /**
	         * 平移变换
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} a
	         * @param {Float32Array|Array.<number>} v
	         */
	        translate : function(out, a, v) {
	            out[0] = a[0];
	            out[1] = a[1];
	            out[2] = a[2];
	            out[3] = a[3];
	            out[4] = a[4] + v[0];
	            out[5] = a[5] + v[1];
	            return out;
	        },
	        /**
	         * 旋转变换
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} a
	         * @param {number} rad
	         */
	        rotate : function(out, a, rad) {
	            var aa = a[0];
	            var ac = a[2];
	            var atx = a[4];
	            var ab = a[1];
	            var ad = a[3];
	            var aty = a[5];
	            var st = Math.sin(rad);
	            var ct = Math.cos(rad);
	
	            out[0] = aa * ct + ab * st;
	            out[1] = -aa * st + ab * ct;
	            out[2] = ac * ct + ad * st;
	            out[3] = -ac * st + ct * ad;
	            out[4] = ct * atx + st * aty;
	            out[5] = ct * aty - st * atx;
	            return out;
	        },
	        /**
	         * 缩放变换
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} a
	         * @param {Float32Array|Array.<number>} v
	         */
	        scale : function(out, a, v) {
	            var vx = v[0];
	            var vy = v[1];
	            out[0] = a[0] * vx;
	            out[1] = a[1] * vy;
	            out[2] = a[2] * vx;
	            out[3] = a[3] * vy;
	            out[4] = a[4] * vx;
	            out[5] = a[5] * vy;
	            return out;
	        },
	        /**
	         * 求逆矩阵
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} a
	         */
	        invert : function(out, a) {
	
	            var aa = a[0];
	            var ac = a[2];
	            var atx = a[4];
	            var ab = a[1];
	            var ad = a[3];
	            var aty = a[5];
	
	            var det = aa * ad - ab * ac;
	            if (!det) {
	                return null;
	            }
	            det = 1.0 / det;
	
	            out[0] = ad * det;
	            out[1] = -ab * det;
	            out[2] = -ac * det;
	            out[3] = aa * det;
	            out[4] = (ac * aty - ad * atx) * det;
	            out[5] = (ab * atx - aa * aty) * det;
	            return out;
	        }
	    };
	
	    return matrix;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * @module echarts/model/Model
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var zrUtil = __webpack_require__(8);
	    var clazzUtil = __webpack_require__(17);
	
	    /**
	     * @alias module:echarts/model/Model
	     * @constructor
	     * @param {Object} option
	     * @param {module:echarts/model/Model} [parentModel]
	     * @param {module:echarts/model/Global} [ecModel]
	     */
	    function Model(option, parentModel, ecModel) {
	        /**
	         * @type {module:echarts/model/Model}
	         * @readOnly
	         */
	        this.parentModel = parentModel;
	
	        /**
	         * @type {module:echarts/model/Global}
	         * @readOnly
	         */
	        this.ecModel = ecModel;
	
	        /**
	         * @type {Object}
	         * @protected
	         */
	        this.option = option;
	
	        // Simple optimization
	        // if (this.init) {
	        //     if (arguments.length <= 4) {
	        //         this.init(option, parentModel, ecModel, extraOpt);
	        //     }
	        //     else {
	        //         this.init.apply(this, arguments);
	        //     }
	        // }
	    }
	
	    Model.prototype = {
	
	        constructor: Model,
	
	        /**
	         * Model 的初始化函数
	         * @param {Object} option
	         */
	        init: null,
	
	        /**
	         * 从新的 Option merge
	         */
	        mergeOption: function (option) {
	            zrUtil.merge(this.option, option, true);
	        },
	
	        /**
	         * @param {string} path
	         * @param {boolean} [ignoreParent=false]
	         * @return {*}
	         */
	        get: function (path, ignoreParent) {
	            if (!path) {
	                return this.option;
	            }
	
	            if (typeof path === 'string') {
	                path = path.split('.');
	            }
	
	            var obj = this.option;
	            var parentModel = this.parentModel;
	            for (var i = 0; i < path.length; i++) {
	                // Ignore empty
	                if (!path[i]) {
	                    continue;
	                }
	                // obj could be number/string/... (like 0)
	                obj = (obj && typeof obj === 'object') ? obj[path[i]] : null;
	                if (obj == null) {
	                    break;
	                }
	            }
	            if (obj == null && parentModel && !ignoreParent) {
	                obj = parentModel.get(path);
	            }
	            return obj;
	        },
	
	        /**
	         * @param {string} key
	         * @param {boolean} [ignoreParent=false]
	         * @return {*}
	         */
	        getShallow: function (key, ignoreParent) {
	            var option = this.option;
	
	            var val = option == null ? option : option[key];
	            var parentModel = this.parentModel;
	            if (val == null && parentModel && !ignoreParent) {
	                val = parentModel.getShallow(key);
	            }
	            return val;
	        },
	
	        /**
	         * @param {string} path
	         * @param {module:echarts/model/Model} [parentModel]
	         * @return {module:echarts/model/Model}
	         */
	        getModel: function (path, parentModel) {
	            var obj = this.get(path, true);
	            var thisParentModel = this.parentModel;
	            var model = new Model(
	                obj, parentModel || (thisParentModel && thisParentModel.getModel(path)),
	                this.ecModel
	            );
	            return model;
	        },
	
	        /**
	         * If model has option
	         */
	        isEmpty: function () {
	            return this.option == null;
	        },
	
	        restoreData: function () {},
	
	        // Pending
	        clone: function () {
	            var Ctor = this.constructor;
	            return new Ctor(zrUtil.clone(this.option));
	        },
	
	        setReadOnly: function (properties) {
	            clazzUtil.setReadOnly(this, properties);
	        }
	    };
	
	    // Enable Model.extend.
	    clazzUtil.enableClassExtend(Model);
	
	    var mixin = zrUtil.mixin;
	    mixin(Model, __webpack_require__(18));
	    mixin(Model, __webpack_require__(20));
	    mixin(Model, __webpack_require__(21));
	    mixin(Model, __webpack_require__(22));
	
	    return Model;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var zrUtil = __webpack_require__(8);
	
	    var clazz = {};
	
	    var TYPE_DELIMITER = '.';
	    var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';
	    /**
	     * @public
	     */
	    var parseClassType = clazz.parseClassType = function (componentType) {
	        var ret = {main: '', sub: ''};
	        if (componentType) {
	            componentType = componentType.split(TYPE_DELIMITER);
	            ret.main = componentType[0] || '';
	            ret.sub = componentType[1] || '';
	        }
	        return ret;
	    };
	    /**
	     * @public
	     */
	    clazz.enableClassExtend = function (RootClass) {
	
	        RootClass.$constructor = RootClass;
	        RootClass.extend = function (proto) {
	            var superClass = this;
	            var ExtendedClass = function () {
	                if (!proto.$constructor) {
	                    superClass.apply(this, arguments);
	                }
	                else {
	                    proto.$constructor.apply(this, arguments);
	                }
	            };
	
	            zrUtil.extend(ExtendedClass.prototype, proto);
	
	            ExtendedClass.extend = this.extend;
	            ExtendedClass.superCall = superCall;
	            ExtendedClass.superApply = superApply;
	            zrUtil.inherits(ExtendedClass, this);
	            ExtendedClass.superClass = superClass;
	
	            return ExtendedClass;
	        };
	    };
	
	    // superCall should have class info, which can not be fetch from 'this'.
	    // Consider this case:
	    // class A has method f,
	    // class B inherits class A, overrides method f, f call superApply('f'),
	    // class C inherits class B, do not overrides method f,
	    // then when method of class C is called, dead loop occured.
	    function superCall(context, methodName) {
	        var args = zrUtil.slice(arguments, 2);
	        return this.superClass.prototype[methodName].apply(context, args);
	    }
	
	    function superApply(context, methodName, args) {
	        return this.superClass.prototype[methodName].apply(context, args);
	    }
	
	    /**
	     * @param {Object} entity
	     * @param {Object} options
	     * @param {boolean} [options.registerWhenExtend]
	     * @public
	     */
	    clazz.enableClassManagement = function (entity, options) {
	        options = options || {};
	
	        /**
	         * Component model classes
	         * key: componentType,
	         * value:
	         *     componentClass, when componentType is 'xxx'
	         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'
	         * @type {Object}
	         */
	        var storage = {};
	
	        entity.registerClass = function (Clazz, componentType) {
	            if (componentType) {
	                componentType = parseClassType(componentType);
	
	                if (!componentType.sub) {
	                    if (__DEV__) {
	                        if (storage[componentType.main]) {
	                            console.warn(componentType.main + ' exists.');
	                        }
	                    }
	                    storage[componentType.main] = Clazz;
	                }
	                else if (componentType.sub !== IS_CONTAINER) {
	                    var container = makeContainer(componentType);
	                    container[componentType.sub] = Clazz;
	                }
	            }
	            return Clazz;
	        };
	
	        entity.getClass = function (componentTypeMain, subType, throwWhenNotFound) {
	            var Clazz = storage[componentTypeMain];
	
	            if (Clazz && Clazz[IS_CONTAINER]) {
	                Clazz = subType ? Clazz[subType] : null;
	            }
	
	            if (throwWhenNotFound && !Clazz) {
	                throw new Error(
	                    'Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.'
	                );
	            }
	
	            return Clazz;
	        };
	
	        entity.getClassesByMainType = function (componentType) {
	            componentType = parseClassType(componentType);
	
	            var result = [];
	            var obj = storage[componentType.main];
	
	            if (obj && obj[IS_CONTAINER]) {
	                zrUtil.each(obj, function (o, type) {
	                    type !== IS_CONTAINER && result.push(o);
	                });
	            }
	            else {
	                result.push(obj);
	            }
	
	            return result;
	        };
	
	        entity.hasClass = function (componentType) {
	            // Just consider componentType.main.
	            componentType = parseClassType(componentType);
	            return !!storage[componentType.main];
	        };
	
	        /**
	         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']
	         */
	        entity.getAllClassMainTypes = function () {
	            var types = [];
	            zrUtil.each(storage, function (obj, type) {
	                types.push(type);
	            });
	            return types;
	        };
	
	        /**
	         * If a main type is container and has sub types
	         * @param  {string}  mainType
	         * @return {boolean}
	         */
	        entity.hasSubTypes = function (componentType) {
	            componentType = parseClassType(componentType);
	            var obj = storage[componentType.main];
	            return obj && obj[IS_CONTAINER];
	        };
	
	        entity.parseClassType = parseClassType;
	
	        function makeContainer(componentType) {
	            var container = storage[componentType.main];
	            if (!container || !container[IS_CONTAINER]) {
	                container = storage[componentType.main] = {};
	                container[IS_CONTAINER] = true;
	            }
	            return container;
	        }
	
	        if (options.registerWhenExtend) {
	            var originalExtend = entity.extend;
	            if (originalExtend) {
	                entity.extend = function (proto) {
	                    var ExtendedClass = originalExtend.call(this, proto);
	                    return entity.registerClass(ExtendedClass, proto.type);
	                };
	            }
	        }
	
	        return entity;
	    };
	
	    /**
	     * @param {string|Array.<string>} properties
	     */
	    clazz.setReadOnly = function (obj, properties) {
	        // FIXME It seems broken in IE8 simulation of IE11
	        // if (!zrUtil.isArray(properties)) {
	        //     properties = properties != null ? [properties] : [];
	        // }
	        // zrUtil.each(properties, function (prop) {
	        //     var value = obj[prop];
	
	        //     Object.defineProperty
	        //         && Object.defineProperty(obj, prop, {
	        //             value: value, writable: false
	        //         });
	        //     zrUtil.isArray(obj[prop])
	        //         && Object.freeze
	        //         && Object.freeze(obj[prop]);
	        // });
	    };
	
	    return clazz;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	    var getLineStyle = __webpack_require__(19)(
	        [
	            ['lineWidth', 'width'],
	            ['stroke', 'color'],
	            ['opacity'],
	            ['shadowBlur'],
	            ['shadowOffsetX'],
	            ['shadowOffsetY'],
	            ['shadowColor']
	        ]
	    );
	    return {
	        getLineStyle: function (excludes) {
	            var style = getLineStyle.call(this, excludes);
	            var lineDash = this.getLineDash();
	            lineDash && (style.lineDash = lineDash);
	            return style;
	        },
	
	        getLineDash: function () {
	            var lineType = this.get('type');
	            return (lineType === 'solid' || lineType == null) ? null
	                : (lineType === 'dashed' ? [5, 5] : [2, 2]);
	        }
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;// TODO Parse shadow style
	// TODO Only shallow path support
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	    var zrUtil = __webpack_require__(8);
	
	    return function (properties) {
	        // Normalize
	        for (var i = 0; i < properties.length; i++) {
	            if (!properties[i][1]) {
	               properties[i][1] = properties[i][0];
	            }
	        }
	        return function (excludes) {
	            var style = {};
	            for (var i = 0; i < properties.length; i++) {
	                var propName = properties[i][1];
	                if (excludes && zrUtil.indexOf(excludes, propName) >= 0) {
	                    continue;
	                }
	                var val = this.getShallow(propName);
	                if (val != null) {
	                    style[properties[i][0]] = val;
	                }
	            }
	            return style;
	        };
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	    return {
	        getAreaStyle: __webpack_require__(19)(
	            [
	                ['fill', 'color'],
	                ['shadowBlur'],
	                ['shadowOffsetX'],
	                ['shadowOffsetY'],
	                ['opacity'],
	                ['shadowColor']
	            ]
	        )
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var textContain = __webpack_require__(12);
	
	    function getShallow(model, path) {
	        return model && model.getShallow(path);
	    }
	
	    return {
	        /**
	         * Get color property or get color from option.textStyle.color
	         * @return {string}
	         */
	        getTextColor: function () {
	            var ecModel = this.ecModel;
	            return this.getShallow('color')
	                || (ecModel && ecModel.get('textStyle.color'));
	        },
	
	        /**
	         * Create font string from fontStyle, fontWeight, fontSize, fontFamily
	         * @return {string}
	         */
	        getFont: function () {
	            var ecModel = this.ecModel;
	            var gTextStyleModel = ecModel && ecModel.getModel('textStyle');
	            return [
	                // FIXME in node-canvas fontWeight is before fontStyle
	                this.getShallow('fontStyle') || getShallow(gTextStyleModel, 'fontStyle'),
	                this.getShallow('fontWeight') || getShallow(gTextStyleModel, 'fontWeight'),
	                (this.getShallow('fontSize') || getShallow(gTextStyleModel, 'fontSize') || 12) + 'px',
	                this.getShallow('fontFamily') || getShallow(gTextStyleModel, 'fontFamily') || 'sans-serif'
	            ].join(' ');
	        },
	
	        getTextRect: function (text) {
	            var textStyle = this.get('textStyle') || {};
	            return textContain.getBoundingRect(
	                text,
	                this.getFont(),
	                textStyle.align,
	                textStyle.baseline
	            );
	        },
	
	        truncateText: function (text, containerWidth, ellipsis, options) {
	            return textContain.truncateText(
	                text, containerWidth, this.getFont(), ellipsis, options
	            );
	        }
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	    var getItemStyle = __webpack_require__(19)(
	        [
	            ['fill', 'color'],
	            ['stroke', 'borderColor'],
	            ['lineWidth', 'borderWidth'],
	            ['opacity'],
	            ['shadowBlur'],
	            ['shadowOffsetX'],
	            ['shadowOffsetY'],
	            ['shadowColor']
	        ]
	    );
	    return {
	        getItemStyle: function (excludes) {
	            var style = getItemStyle.call(this, excludes);
	            var lineDash = this.getBorderLineDash();
	            lineDash && (style.lineDash = lineDash);
	            return style;
	        },
	
	        getBorderLineDash: function () {
	            var lineType = this.get('borderType');
	            return (lineType === 'solid' || lineType == null) ? null
	                : (lineType === 'dashed' ? [5, 5] : [1, 1]);
	        }
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Component model
	 *
	 * @module echarts/model/Component
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
	
	    var Model = __webpack_require__(16);
	    var zrUtil = __webpack_require__(8);
	    var arrayPush = Array.prototype.push;
	    var componentUtil = __webpack_require__(24);
	    var clazzUtil = __webpack_require__(17);
	    var layout = __webpack_require__(25);
	
	    /**
	     * @alias module:echarts/model/Component
	     * @constructor
	     * @param {Object} option
	     * @param {module:echarts/model/Model} parentModel
	     * @param {module:echarts/model/Model} ecModel
	     */
	    var ComponentModel = Model.extend({
	
	        type: 'component',
	
	        /**
	         * @readOnly
	         * @type {string}
	         */
	        id: '',
	
	        /**
	         * @readOnly
	         */
	        name: '',
	
	        /**
	         * @readOnly
	         * @type {string}
	         */
	        mainType: '',
	
	        /**
	         * @readOnly
	         * @type {string}
	         */
	        subType: '',
	
	        /**
	         * @readOnly
	         * @type {number}
	         */
	        componentIndex: 0,
	
	        /**
	         * @type {Object}
	         * @protected
	         */
	        defaultOption: null,
	
	        /**
	         * @type {module:echarts/model/Global}
	         * @readOnly
	         */
	        ecModel: null,
	
	        /**
	         * key: componentType
	         * value:  Component model list, can not be null.
	         * @type {Object.<string, Array.<module:echarts/model/Model>>}
	         * @readOnly
	         */
	        dependentModels: [],
	
	        /**
	         * @type {string}
	         * @readOnly
	         */
	        uid: null,
	
	        /**
	         * Support merge layout params.
	         * Only support 'box' now (left/right/top/bottom/width/height).
	         * @type {string|Object} Object can be {ignoreSize: true}
	         * @readOnly
	         */
	        layoutMode: null,
	
	        $constructor: function (option, parentModel, ecModel, extraOpt) {
	            Model.call(this, option, parentModel, ecModel, extraOpt);
	
	            // Set dependentModels, componentIndex, name, id, mainType, subType.
	            zrUtil.extend(this, extraOpt);
	
	            this.uid = componentUtil.getUID('componentModel');
	        },
	
	
	        init: function (option, parentModel, ecModel, extraOpt) {
	            this.mergeDefaultAndTheme(option, ecModel);
	        },
	
	        mergeDefaultAndTheme: function (option, ecModel) {
	            var layoutMode = this.layoutMode;
	            var inputPositionParams = layoutMode
	                ? layout.getLayoutParams(option) : {};
	
	            var themeModel = ecModel.getTheme();
	            zrUtil.merge(option, themeModel.get(this.mainType));
	            zrUtil.merge(option, this.getDefaultOption());
	
	            if (layoutMode) {
	                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);
	            }
	        },
	
	        mergeOption: function (option) {
	            zrUtil.merge(this.option, option, true);
	
	            var layoutMode = this.layoutMode;
	            if (layoutMode) {
	                layout.mergeLayoutParam(this.option, option, layoutMode);
	            }
	        },
	
	        // Hooker after init or mergeOption
	        optionUpdated: function (newCptOption, isInit) {},
	
	        getDefaultOption: function () {
	            if (!this.hasOwnProperty('__defaultOption')) {
	                var optList = [];
	                var Class = this.constructor;
	                while (Class) {
	                    var opt = Class.prototype.defaultOption;
	                    opt && optList.push(opt);
	                    Class = Class.superClass;
	                }
	
	                var defaultOption = {};
	                for (var i = optList.length - 1; i >= 0; i--) {
	                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);
	                }
	                this.__defaultOption = defaultOption;
	            }
	            return this.__defaultOption;
	        }
	
	    });
	
	    // Reset ComponentModel.extend, add preConstruct.
	    // clazzUtil.enableClassExtend(
	    //     ComponentModel,
	    //     function (option, parentModel, ecModel, extraOpt) {
	    //         // Set dependentModels, componentIndex, name, id, mainType, subType.
	    //         zrUtil.extend(this, extraOpt);
	
	    //         this.uid = componentUtil.getUID('componentModel');
	
	    //         // this.setReadOnly([
	    //         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',
	    //         //     'dependentModels', 'componentIndex'
	    //         // ]);
	    //     }
	    // );
	
	    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.
	    clazzUtil.enableClassManagement(
	        ComponentModel, {registerWhenExtend: true}
	    );
	    componentUtil.enableSubTypeDefaulter(ComponentModel);
	
	    // Add capability of ComponentModel.topologicalTravel.
	    componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);
	
	    function getDependencies(componentType) {
	        var deps = [];
	        zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {
	            arrayPush.apply(deps, Clazz.prototype.dependencies || []);
	        });
	        // Ensure main type
	        return zrUtil.map(deps, function (type) {
	            return clazzUtil.parseClassType(type).main;
	        });
	    }
	
	    zrUtil.mixin(ComponentModel, __webpack_require__(26));
	
	    return ComponentModel;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
	
	    var zrUtil = __webpack_require__(8);
	    var clazz = __webpack_require__(17);
	
	    var parseClassType = clazz.parseClassType;
	
	    var base = 0;
	
	    var componentUtil = {};
	
	    var DELIMITER = '_';
	
	    /**
	     * @public
	     * @param {string} type
	     * @return {string}
	     */
	    componentUtil.getUID = function (type) {
	        // Considering the case of crossing js context,
	        // use Math.random to make id as unique as possible.
	        return [(type || ''), base++, Math.random()].join(DELIMITER);
	    };
	
	    /**
	     * @inner
	     */
	    componentUtil.enableSubTypeDefaulter = function (entity) {
	
	        var subTypeDefaulters = {};
	
	        entity.registerSubTypeDefaulter = function (componentType, defaulter) {
	            componentType = parseClassType(componentType);
	            subTypeDefaulters[componentType.main] = defaulter;
	        };
	
	        entity.determineSubType = function (componentType, option) {
	            var type = option.type;
	            if (!type) {
	                var componentTypeMain = parseClassType(componentType).main;
	                if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {
	                    type = subTypeDefaulters[componentTypeMain](option);
	                }
	            }
	            return type;
	        };
	
	        return entity;
	    };
	
	    /**
	     * Topological travel on Activity Network (Activity On Vertices).
	     * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].
	     *
	     * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.
	     *
	     * If there is circle dependencey, Error will be thrown.
	     *
	     */
	    componentUtil.enableTopologicalTravel = function (entity, dependencyGetter) {
	
	        /**
	         * @public
	         * @param {Array.<string>} targetNameList Target Component type list.
	         *                                           Can be ['aa', 'bb', 'aa.xx']
	         * @param {Array.<string>} fullNameList By which we can build dependency graph.
	         * @param {Function} callback Params: componentType, dependencies.
	         * @param {Object} context Scope of callback.
	         */
	        entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {
	            if (!targetNameList.length) {
	                return;
	            }
	
	            var result = makeDepndencyGraph(fullNameList);
	            var graph = result.graph;
	            var stack = result.noEntryList;
	
	            var targetNameSet = {};
	            zrUtil.each(targetNameList, function (name) {
	                targetNameSet[name] = true;
	            });
	
	            while (stack.length) {
	                var currComponentType = stack.pop();
	                var currVertex = graph[currComponentType];
	                var isInTargetNameSet = !!targetNameSet[currComponentType];
	                if (isInTargetNameSet) {
	                    callback.call(context, currComponentType, currVertex.originalDeps.slice());
	                    delete targetNameSet[currComponentType];
	                }
	                zrUtil.each(
	                    currVertex.successor,
	                    isInTargetNameSet ? removeEdgeAndAdd : removeEdge
	                );
	            }
	
	            zrUtil.each(targetNameSet, function () {
	                throw new Error('Circle dependency may exists');
	            });
	
	            function removeEdge(succComponentType) {
	                graph[succComponentType].entryCount--;
	                if (graph[succComponentType].entryCount === 0) {
	                    stack.push(succComponentType);
	                }
	            }
	
	            // Consider this case: legend depends on series, and we call
	            // chart.setOption({series: [...]}), where only series is in option.
	            // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will
	            // not be called, but only sereis.mergeOption is called. Thus legend
	            // have no chance to update its local record about series (like which
	            // name of series is available in legend).
	            function removeEdgeAndAdd(succComponentType) {
	                targetNameSet[succComponentType] = true;
	                removeEdge(succComponentType);
	            }
	        };
	
	        /**
	         * DepndencyGraph: {Object}
	         * key: conponentType,
	         * value: {
	         *     successor: [conponentTypes...],
	         *     originalDeps: [conponentTypes...],
	         *     entryCount: {number}
	         * }
	         */
	        function makeDepndencyGraph(fullNameList) {
	            var graph = {};
	            var noEntryList = [];
	
	            zrUtil.each(fullNameList, function (name) {
	
	                var thisItem = createDependencyGraphItem(graph, name);
	                var originalDeps = thisItem.originalDeps = dependencyGetter(name);
	
	                var availableDeps = getAvailableDependencies(originalDeps, fullNameList);
	                thisItem.entryCount = availableDeps.length;
	                if (thisItem.entryCount === 0) {
	                    noEntryList.push(name);
	                }
	
	                zrUtil.each(availableDeps, function (dependentName) {
	                    if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {
	                        thisItem.predecessor.push(dependentName);
	                    }
	                    var thatItem = createDependencyGraphItem(graph, dependentName);
	                    if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {
	                        thatItem.successor.push(name);
	                    }
	                });
	            });
	
	            return {graph: graph, noEntryList: noEntryList};
	        }
	
	        function createDependencyGraphItem(graph, name) {
	            if (!graph[name]) {
	                graph[name] = {predecessor: [], successor: []};
	            }
	            return graph[name];
	        }
	
	        function getAvailableDependencies(originalDeps, fullNameList) {
	            var availableDeps = [];
	            zrUtil.each(originalDeps, function (dep) {
	                zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);
	            });
	            return availableDeps;
	        }
	    };
	
	    return componentUtil;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;// Layout helpers for each component positioning
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
	    'use strict';
	
	    var zrUtil = __webpack_require__(8);
	    var BoundingRect = __webpack_require__(13);
	    var numberUtil = __webpack_require__(11);
	    var formatUtil = __webpack_require__(10);
	    var parsePercent = numberUtil.parsePercent;
	    var each = zrUtil.each;
	
	    var layout = {};
	
	    var LOCATION_PARAMS = ['left', 'right', 'top', 'bottom', 'width', 'height'];
	
	    function boxLayout(orient, group, gap, maxWidth, maxHeight) {
	        var x = 0;
	        var y = 0;
	        if (maxWidth == null) {
	            maxWidth = Infinity;
	        }
	        if (maxHeight == null) {
	            maxHeight = Infinity;
	        }
	        var currentLineMaxSize = 0;
	        group.eachChild(function (child, idx) {
	            var position = child.position;
	            var rect = child.getBoundingRect();
	            var nextChild = group.childAt(idx + 1);
	            var nextChildRect = nextChild && nextChild.getBoundingRect();
	            var nextX;
	            var nextY;
	            if (orient === 'horizontal') {
	                var moveX = rect.width + (nextChildRect ? (-nextChildRect.x + rect.x) : 0);
	                nextX = x + moveX;
	                // Wrap when width exceeds maxWidth or meet a `newline` group
	                if (nextX > maxWidth || child.newline) {
	                    x = 0;
	                    nextX = moveX;
	                    y += currentLineMaxSize + gap;
	                    currentLineMaxSize = rect.height;
	                }
	                else {
	                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);
	                }
	            }
	            else {
	                var moveY = rect.height + (nextChildRect ? (-nextChildRect.y + rect.y) : 0);
	                nextY = y + moveY;
	                // Wrap when width exceeds maxHeight or meet a `newline` group
	                if (nextY > maxHeight || child.newline) {
	                    x += currentLineMaxSize + gap;
	                    y = 0;
	                    nextY = moveY;
	                    currentLineMaxSize = rect.width;
	                }
	                else {
	                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);
	                }
	            }
	
	            if (child.newline) {
	                return;
	            }
	
	            position[0] = x;
	            position[1] = y;
	
	            orient === 'horizontal'
	                ? (x = nextX + gap)
	                : (y = nextY + gap);
	        });
	    }
	
	    /**
	     * VBox or HBox layouting
	     * @param {string} orient
	     * @param {module:zrender/container/Group} group
	     * @param {number} gap
	     * @param {number} [width=Infinity]
	     * @param {number} [height=Infinity]
	     */
	    layout.box = boxLayout;
	
	    /**
	     * VBox layouting
	     * @param {module:zrender/container/Group} group
	     * @param {number} gap
	     * @param {number} [width=Infinity]
	     * @param {number} [height=Infinity]
	     */
	    layout.vbox = zrUtil.curry(boxLayout, 'vertical');
	
	    /**
	     * HBox layouting
	     * @param {module:zrender/container/Group} group
	     * @param {number} gap
	     * @param {number} [width=Infinity]
	     * @param {number} [height=Infinity]
	     */
	    layout.hbox = zrUtil.curry(boxLayout, 'horizontal');
	
	    /**
	     * If x or x2 is not specified or 'center' 'left' 'right',
	     * the width would be as long as possible.
	     * If y or y2 is not specified or 'middle' 'top' 'bottom',
	     * the height would be as long as possible.
	     *
	     * @param {Object} positionInfo
	     * @param {number|string} [positionInfo.x]
	     * @param {number|string} [positionInfo.y]
	     * @param {number|string} [positionInfo.x2]
	     * @param {number|string} [positionInfo.y2]
	     * @param {Object} containerRect
	     * @param {string|number} margin
	     * @return {Object} {width, height}
	     */
	    layout.getAvailableSize = function (positionInfo, containerRect, margin) {
	        var containerWidth = containerRect.width;
	        var containerHeight = containerRect.height;
	
	        var x = parsePercent(positionInfo.x, containerWidth);
	        var y = parsePercent(positionInfo.y, containerHeight);
	        var x2 = parsePercent(positionInfo.x2, containerWidth);
	        var y2 = parsePercent(positionInfo.y2, containerHeight);
	
	        (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);
	        (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);
	        (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);
	        (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);
	
	        margin = formatUtil.normalizeCssArray(margin || 0);
	
	        return {
	            width: Math.max(x2 - x - margin[1] - margin[3], 0),
	            height: Math.max(y2 - y - margin[0] - margin[2], 0)
	        };
	    };
	
	    /**
	     * Parse position info.
	     *
	     * @param {Object} positionInfo
	     * @param {number|string} [positionInfo.left]
	     * @param {number|string} [positionInfo.top]
	     * @param {number|string} [positionInfo.right]
	     * @param {number|string} [positionInfo.bottom]
	     * @param {number|string} [positionInfo.width]
	     * @param {number|string} [positionInfo.height]
	     * @param {number|string} [positionInfo.aspect] Aspect is width / height
	     * @param {Object} containerRect
	     * @param {string|number} [margin]
	     *
	     * @return {module:zrender/core/BoundingRect}
	     */
	    layout.getLayoutRect = function (
	        positionInfo, containerRect, margin
	    ) {
	        margin = formatUtil.normalizeCssArray(margin || 0);
	
	        var containerWidth = containerRect.width;
	        var containerHeight = containerRect.height;
	
	        var left = parsePercent(positionInfo.left, containerWidth);
	        var top = parsePercent(positionInfo.top, containerHeight);
	        var right = parsePercent(positionInfo.right, containerWidth);
	        var bottom = parsePercent(positionInfo.bottom, containerHeight);
	        var width = parsePercent(positionInfo.width, containerWidth);
	        var height = parsePercent(positionInfo.height, containerHeight);
	
	        var verticalMargin = margin[2] + margin[0];
	        var horizontalMargin = margin[1] + margin[3];
	        var aspect = positionInfo.aspect;
	
	        // If width is not specified, calculate width from left and right
	        if (isNaN(width)) {
	            width = containerWidth - right - horizontalMargin - left;
	        }
	        if (isNaN(height)) {
	            height = containerHeight - bottom - verticalMargin - top;
	        }
	
	        // If width and height are not given
	        // 1. Graph should not exceeds the container
	        // 2. Aspect must be keeped
	        // 3. Graph should take the space as more as possible
	        if (isNaN(width) && isNaN(height)) {
	            if (aspect > containerWidth / containerHeight) {
	                width = containerWidth * 0.8;
	            }
	            else {
	                height = containerHeight * 0.8;
	            }
	        }
	
	        if (aspect != null) {
	            // Calculate width or height with given aspect
	            if (isNaN(width)) {
	                width = aspect * height;
	            }
	            if (isNaN(height)) {
	                height = width / aspect;
	            }
	        }
	
	        // If left is not specified, calculate left from right and width
	        if (isNaN(left)) {
	            left = containerWidth - right - width - horizontalMargin;
	        }
	        if (isNaN(top)) {
	            top = containerHeight - bottom - height - verticalMargin;
	        }
	
	        // Align left and top
	        switch (positionInfo.left || positionInfo.right) {
	            case 'center':
	                left = containerWidth / 2 - width / 2 - margin[3];
	                break;
	            case 'right':
	                left = containerWidth - width - horizontalMargin;
	                break;
	        }
	        switch (positionInfo.top || positionInfo.bottom) {
	            case 'middle':
	            case 'center':
	                top = containerHeight / 2 - height / 2 - margin[0];
	                break;
	            case 'bottom':
	                top = containerHeight - height - verticalMargin;
	                break;
	        }
	        // If something is wrong and left, top, width, height are calculated as NaN
	        left = left || 0;
	        top = top || 0;
	        if (isNaN(width)) {
	            // Width may be NaN if only one value is given except width
	            width = containerWidth - left - (right || 0);
	        }
	        if (isNaN(height)) {
	            // Height may be NaN if only one value is given except height
	            height = containerHeight - top - (bottom || 0);
	        }
	
	        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);
	        rect.margin = margin;
	        return rect;
	    };
	
	    /**
	     * Position group of component in viewport
	     *  Group position is specified by either
	     *  {left, top}, {right, bottom}
	     *  If all properties exists, right and bottom will be igonred.
	     *
	     * @param {module:zrender/container/Group} group
	     * @param {Object} positionInfo
	     * @param {number|string} [positionInfo.left]
	     * @param {number|string} [positionInfo.top]
	     * @param {number|string} [positionInfo.right]
	     * @param {number|string} [positionInfo.bottom]
	     * @param {Object} containerRect
	     * @param {string|number} margin
	     */
	    layout.positionGroup = function (
	        group, positionInfo, containerRect, margin
	    ) {
	        var groupRect = group.getBoundingRect();
	
	        positionInfo = zrUtil.extend(zrUtil.clone(positionInfo), {
	            width: groupRect.width,
	            height: groupRect.height
	        });
	
	        positionInfo = layout.getLayoutRect(
	            positionInfo, containerRect, margin
	        );
	
	        group.attr('position', [
	            positionInfo.x - groupRect.x,
	            positionInfo.y - groupRect.y
	        ]);
	    };
	
	    /**
	     * Consider Case:
	     * When defulat option has {left: 0, width: 100}, and we set {right: 0}
	     * through setOption or media query, using normal zrUtil.merge will cause
	     * {right: 0} does not take effect.
	     *
	     * @example
	     * ComponentModel.extend({
	     *     init: function () {
	     *         ...
	     *         var inputPositionParams = layout.getLayoutParams(option);
	     *         this.mergeOption(inputPositionParams);
	     *     },
	     *     mergeOption: function (newOption) {
	     *         newOption && zrUtil.merge(thisOption, newOption, true);
	     *         layout.mergeLayoutParam(thisOption, newOption);
	     *     }
	     * });
	     *
	     * @param {Object} targetOption
	     * @param {Object} newOption
	     * @param {Object|string} [opt]
	     * @param {boolean} [opt.ignoreSize=false] Some component must has width and height.
	     */
	    layout.mergeLayoutParam = function (targetOption, newOption, opt) {
	        !zrUtil.isObject(opt) && (opt = {});
	        var hNames = ['width', 'left', 'right']; // Order by priority.
	        var vNames = ['height', 'top', 'bottom']; // Order by priority.
	        var hResult = merge(hNames);
	        var vResult = merge(vNames);
	
	        copy(hNames, targetOption, hResult);
	        copy(vNames, targetOption, vResult);
	
	        function merge(names) {
	            var newParams = {};
	            var newValueCount = 0;
	            var merged = {};
	            var mergedValueCount = 0;
	            var enoughParamNumber = opt.ignoreSize ? 1 : 2;
	
	            each(names, function (name) {
	                merged[name] = targetOption[name];
	            });
	            each(names, function (name) {
	                // Consider case: newOption.width is null, which is
	                // set by user for removing width setting.
	                hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);
	                hasValue(newParams, name) && newValueCount++;
	                hasValue(merged, name) && mergedValueCount++;
	            });
	
	            // Case: newOption: {width: ..., right: ...},
	            // or targetOption: {right: ...} and newOption: {width: ...},
	            // There is no conflict when merged only has params count
	            // little than enoughParamNumber.
	            if (mergedValueCount === enoughParamNumber || !newValueCount) {
	                return merged;
	            }
	            // Case: newOption: {width: ..., right: ...},
	            // Than we can make sure user only want those two, and ignore
	            // all origin params in targetOption.
	            else if (newValueCount >= enoughParamNumber) {
	                return newParams;
	            }
	            else {
	                // Chose another param from targetOption by priority.
	                // When 'ignoreSize', enoughParamNumber is 1 and those will not happen.
	                for (var i = 0; i < names.length; i++) {
	                    var name = names[i];
	                    if (!hasProp(newParams, name) && hasProp(targetOption, name)) {
	                        newParams[name] = targetOption[name];
	                        break;
	                    }
	                }
	                return newParams;
	            }
	        }
	
	        function hasProp(obj, name) {
	            return obj.hasOwnProperty(name);
	        }
	
	        function hasValue(obj, name) {
	            return obj[name] != null && obj[name] !== 'auto';
	        }
	
	        function copy(names, target, source) {
	            each(names, function (name) {
	                target[name] = source[name];
	            });
	        }
	    };
	
	    /**
	     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.
	     * @param {Object} source
	     * @return {Object} Result contains those props.
	     */
	    layout.getLayoutParams = function (source) {
	        return layout.copyLayoutParams({}, source);
	    };
	
	    /**
	     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.
	     * @param {Object} source
	     * @return {Object} Result contains those props.
	     */
	    layout.copyLayoutParams = function (target, source) {
	        source && target && each(LOCATION_PARAMS, function (name) {
	            source.hasOwnProperty(name) && (target[name] = source[name]);
	        });
	        return target;
	    };
	
	    return layout;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    return {
	        getBoxLayoutParams: function () {
	            return {
	                left: this.get('left'),
	                top: this.get('top'),
	                right: this.get('right'),
	                bottom: this.get('bottom'),
	                width: this.get('width'),
	                height: this.get('height')
	            };
	        }
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var platform = '';
	    // Navigator not exists in node
	    if (typeof navigator !== 'undefined') {
	        platform = navigator.platform || '';
	    }
	    return {
	        // 全图默认背景
	        // backgroundColor: 'rgba(0,0,0,0)',
	
	        // https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization
	        // color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'],
	        // 浅色
	        // color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'],
	        // color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'],
	        // 深色
	        color: ['#c23531','#2f4554', '#61a0a8', '#d48265', '#91c7ae','#749f83',  '#ca8622', '#bda29a','#6e7074', '#546570', '#c4ccd3'],
	
	        // 默认需要 Grid 配置项
	        // grid: {},
	        // 主题，主题
	        textStyle: {
	            // color: '#000',
	            // decoration: 'none',
	            // PENDING
	            fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',
	            // fontFamily: 'Arial, Verdana, sans-serif',
	            fontSize: 12,
	            fontStyle: 'normal',
	            fontWeight: 'normal'
	        },
	
	        // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/
	        // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
	        // Default is source-over
	        blendMode: null,
	
	        animation: true,
	        animationDuration: 1000,
	        animationDurationUpdate: 300,
	        animationEasing: 'exponentialOut',
	        animationEasingUpdate: 'cubicOut',
	
	        animationThreshold: 2000,
	        // Configuration for progressive/incremental rendering
	        progressiveThreshold: 3000,
	        progressive: 400,
	
	        // Threshold of if use single hover layer to optimize.
	        hoverLayerThreshold: 3000
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return {
	        clearColorPalette: function () {
	            this._colorIdx = 0;
	            this._colorNameMap = {};
	        },
	
	        getColorFromPalette: function (name, scope) {
	            scope = scope || this;
	            var colorIdx = scope._colorIdx || 0;
	            var colorNameMap = scope._colorNameMap || (scope._colorNameMap = {});
	            if (colorNameMap[name]) {
	                return colorNameMap[name];
	            }
	            var colorPalette = this.get('color', true) || [];
	            if (!colorPalette.length) {
	                return;
	            }
	
	            var color = colorPalette[colorIdx];
	            if (name) {
	                colorNameMap[name] = color;
	            }
	            scope._colorIdx = (colorIdx + 1) % colorPalette.length;
	
	            return color;
	        }
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
	
	    'use strict';
	
	    var zrUtil = __webpack_require__(8);
	
	    var echartsAPIList = [
	        'getDom', 'getZr', 'getWidth', 'getHeight', 'dispatchAction', 'isDisposed',
	        'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption'
	    ];
	
	    function ExtensionAPI(chartInstance) {
	        zrUtil.each(echartsAPIList, function (name) {
	            this[name] = zrUtil.bind(chartInstance[name], chartInstance);
	        }, this);
	    }
	
	    return ExtensionAPI;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
	
	    'use strict';
	
	    var coordinateSystemCreators = {};
	
	    function CoordinateSystemManager() {
	
	        this._coordinateSystems = [];
	    }
	
	    CoordinateSystemManager.prototype = {
	
	        constructor: CoordinateSystemManager,
	
	        create: function (ecModel, api) {
	            var coordinateSystems = [];
	            for (var type in coordinateSystemCreators) {
	                var list = coordinateSystemCreators[type].create(ecModel, api);
	                list && (coordinateSystems = coordinateSystems.concat(list));
	            }
	
	            this._coordinateSystems = coordinateSystems;
	        },
	
	        update: function (ecModel, api) {
	            var coordinateSystems = this._coordinateSystems;
	            for (var i = 0; i < coordinateSystems.length; i++) {
	                // FIXME MUST have
	                coordinateSystems[i].update && coordinateSystems[i].update(ecModel, api);
	            }
	        }
	    };
	
	    CoordinateSystemManager.register = function (type, coordinateSystemCreator) {
	        coordinateSystemCreators[type] = coordinateSystemCreator;
	    };
	
	    CoordinateSystemManager.get = function (type) {
	        return coordinateSystemCreators[type];
	    };
	
	    return CoordinateSystemManager;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * ECharts option manager
	 *
	 * @module {echarts/model/OptionManager}
	 */
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var zrUtil = __webpack_require__(8);
	    var modelUtil = __webpack_require__(9);
	    var ComponentModel = __webpack_require__(23);
	    var each = zrUtil.each;
	    var clone = zrUtil.clone;
	    var map = zrUtil.map;
	    var merge = zrUtil.merge;
	
	    var QUERY_REG = /^(min|max)?(.+)$/;
	
	    /**
	     * TERM EXPLANATIONS:
	     *
	     * [option]:
	     *
	     *     An object that contains definitions of components. For example:
	     *     var option = {
	     *         title: {...},
	     *         legend: {...},
	     *         visualMap: {...},
	     *         series: [
	     *             {data: [...]},
	     *             {data: [...]},
	     *             ...
	     *         ]
	     *     };
	     *
	     * [rawOption]:
	     *
	     *     An object input to echarts.setOption. 'rawOption' may be an
	     *     'option', or may be an object contains multi-options. For example:
	     *     var option = {
	     *         baseOption: {
	     *             title: {...},
	     *             legend: {...},
	     *             series: [
	     *                 {data: [...]},
	     *                 {data: [...]},
	     *                 ...
	     *             ]
	     *         },
	     *         timeline: {...},
	     *         options: [
	     *             {title: {...}, series: {data: [...]}},
	     *             {title: {...}, series: {data: [...]}},
	     *             ...
	     *         ],
	     *         media: [
	     *             {
	     *                 query: {maxWidth: 320},
	     *                 option: {series: {x: 20}, visualMap: {show: false}}
	     *             },
	     *             {
	     *                 query: {minWidth: 320, maxWidth: 720},
	     *                 option: {series: {x: 500}, visualMap: {show: true}}
	     *             },
	     *             {
	     *                 option: {series: {x: 1200}, visualMap: {show: true}}
	     *             }
	     *         ]
	     *     };
	     *
	     * @alias module:echarts/model/OptionManager
	     * @param {module:echarts/ExtensionAPI} api
	     */
	    function OptionManager(api) {
	
	        /**
	         * @private
	         * @type {module:echarts/ExtensionAPI}
	         */
	        this._api = api;
	
	        /**
	         * @private
	         * @type {Array.<number>}
	         */
	        this._timelineOptions = [];
	
	        /**
	         * @private
	         * @type {Array.<Object>}
	         */
	        this._mediaList = [];
	
	        /**
	         * @private
	         * @type {Object}
	         */
	        this._mediaDefault;
	
	        /**
	         * -1, means default.
	         * empty means no media.
	         * @private
	         * @type {Array.<number>}
	         */
	        this._currentMediaIndices = [];
	
	        /**
	         * @private
	         * @type {Object}
	         */
	        this._optionBackup;
	
	        /**
	         * @private
	         * @type {Object}
	         */
	        this._newBaseOption;
	    }
	
	    // timeline.notMerge is not supported in ec3. Firstly there is rearly
	    // case that notMerge is needed. Secondly supporting 'notMerge' requires
	    // rawOption cloned and backuped when timeline changed, which does no
	    // good to performance. What's more, that both timeline and setOption
	    // method supply 'notMerge' brings complex and some problems.
	    // Consider this case:
	    // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);
	    // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);
	
	    OptionManager.prototype = {
	
	        constructor: OptionManager,
	
	        /**
	         * @public
	         * @param {Object} rawOption Raw option.
	         * @param {module:echarts/model/Global} ecModel
	         * @param {Array.<Function>} optionPreprocessorFuncs
	         * @return {Object} Init option
	         */
	        setOption: function (rawOption, optionPreprocessorFuncs) {
	            rawOption = clone(rawOption, true);
	
	            // FIXME
	            // 如果 timeline options 或者 media 中设置了某个属性，而baseOption中没有设置，则进行警告。
	
	            var oldOptionBackup = this._optionBackup;
	            var newParsedOption = parseRawOption.call(
	                this, rawOption, optionPreprocessorFuncs, !oldOptionBackup
	            );
	            this._newBaseOption = newParsedOption.baseOption;
	
	            // For setOption at second time (using merge mode);
	            if (oldOptionBackup) {
	                // Only baseOption can be merged.
	                mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption);
	
	                // For simplicity, timeline options and media options do not support merge,
	                // that is, if you `setOption` twice and both has timeline options, the latter
	                // timeline opitons will not be merged to the formers, but just substitude them.
	                if (newParsedOption.timelineOptions.length) {
	                    oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;
	                }
	                if (newParsedOption.mediaList.length) {
	                    oldOptionBackup.mediaList = newParsedOption.mediaList;
	                }
	                if (newParsedOption.mediaDefault) {
	                    oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;
	                }
	            }
	            else {
	                this._optionBackup = newParsedOption;
	            }
	        },
	
	        /**
	         * @param {boolean} isRecreate
	         * @return {Object}
	         */
	        mountOption: function (isRecreate) {
	            var optionBackup = this._optionBackup;
	
	            // TODO
	            // 如果没有reset功能则不clone。
	
	            this._timelineOptions = map(optionBackup.timelineOptions, clone);
	            this._mediaList = map(optionBackup.mediaList, clone);
	            this._mediaDefault = clone(optionBackup.mediaDefault);
	            this._currentMediaIndices = [];
	
	            return clone(isRecreate
	                // this._optionBackup.baseOption, which is created at the first `setOption`
	                // called, and is merged into every new option by inner method `mergeOption`
	                // each time `setOption` called, can be only used in `isRecreate`, because
	                // its reliability is under suspicion. In other cases option merge is
	                // proformed by `model.mergeOption`.
	                ? optionBackup.baseOption : this._newBaseOption
	            );
	        },
	
	        /**
	         * @param {module:echarts/model/Global} ecModel
	         * @return {Object}
	         */
	        getTimelineOption: function (ecModel) {
	            var option;
	            var timelineOptions = this._timelineOptions;
	
	            if (timelineOptions.length) {
	                // getTimelineOption can only be called after ecModel inited,
	                // so we can get currentIndex from timelineModel.
	                var timelineModel = ecModel.getComponent('timeline');
	                if (timelineModel) {
	                    option = clone(
	                        timelineOptions[timelineModel.getCurrentIndex()],
	                        true
	                    );
	                }
	            }
	
	            return option;
	        },
	
	        /**
	         * @param {module:echarts/model/Global} ecModel
	         * @return {Array.<Object>}
	         */
	        getMediaOption: function (ecModel) {
	            var ecWidth = this._api.getWidth();
	            var ecHeight = this._api.getHeight();
	            var mediaList = this._mediaList;
	            var mediaDefault = this._mediaDefault;
	            var indices = [];
	            var result = [];
	
	            // No media defined.
	            if (!mediaList.length && !mediaDefault) {
	                return result;
	            }
	
	            // Multi media may be applied, the latter defined media has higher priority.
	            for (var i = 0, len = mediaList.length; i < len; i++) {
	                if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {
	                    indices.push(i);
	                }
	            }
	
	            // FIXME
	            // 是否mediaDefault应该强制用户设置，否则可能修改不能回归。
	            if (!indices.length && mediaDefault) {
	                indices = [-1];
	            }
	
	            if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {
	                result = map(indices, function (index) {
	                    return clone(
	                        index === -1 ? mediaDefault.option : mediaList[index].option
	                    );
	                });
	            }
	            // Otherwise return nothing.
	
	            this._currentMediaIndices = indices;
	
	            return result;
	        }
	    };
	
	    function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {
	        var timelineOptions = [];
	        var mediaList = [];
	        var mediaDefault;
	        var baseOption;
	
	        // Compatible with ec2.
	        var timelineOpt = rawOption.timeline;
	
	        if (rawOption.baseOption) {
	            baseOption = rawOption.baseOption;
	        }
	
	        // For timeline
	        if (timelineOpt || rawOption.options) {
	            baseOption = baseOption || {};
	            timelineOptions = (rawOption.options || []).slice();
	        }
	
	        // For media query
	        if (rawOption.media) {
	            baseOption = baseOption || {};
	            var media = rawOption.media;
	            each(media, function (singleMedia) {
	                if (singleMedia && singleMedia.option) {
	                    if (singleMedia.query) {
	                        mediaList.push(singleMedia);
	                    }
	                    else if (!mediaDefault) {
	                        // Use the first media default.
	                        mediaDefault = singleMedia;
	                    }
	                }
	            });
	        }
	
	        // For normal option
	        if (!baseOption) {
	            baseOption = rawOption;
	        }
	
	        // Set timelineOpt to baseOption in ec3,
	        // which is convenient for merge option.
	        if (!baseOption.timeline) {
	            baseOption.timeline = timelineOpt;
	        }
	
	        // Preprocess.
	        each([baseOption].concat(timelineOptions)
	            .concat(zrUtil.map(mediaList, function (media) {
	                return media.option;
	            })),
	            function (option) {
	                each(optionPreprocessorFuncs, function (preProcess) {
	                    preProcess(option, isNew);
	                });
	            }
	        );
	
	        return {
	            baseOption: baseOption,
	            timelineOptions: timelineOptions,
	            mediaDefault: mediaDefault,
	            mediaList: mediaList
	        };
	    }
	
	    /**
	     * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>
	     * Support: width, height, aspectRatio
	     * Can use max or min as prefix.
	     */
	    function applyMediaQuery(query, ecWidth, ecHeight) {
	        var realMap = {
	            width: ecWidth,
	            height: ecHeight,
	            aspectratio: ecWidth / ecHeight // lowser case for convenientce.
	        };
	
	        var applicatable = true;
	
	        zrUtil.each(query, function (value, attr) {
	            var matched = attr.match(QUERY_REG);
	
	            if (!matched || !matched[1] || !matched[2]) {
	                return;
	            }
	
	            var operator = matched[1];
	            var realAttr = matched[2].toLowerCase();
	
	            if (!compare(realMap[realAttr], value, operator)) {
	                applicatable = false;
	            }
	        });
	
	        return applicatable;
	    }
	
	    function compare(real, expect, operator) {
	        if (operator === 'min') {
	            return real >= expect;
	        }
	        else if (operator === 'max') {
	            return real <= expect;
	        }
	        else { // Equals
	            return real === expect;
	        }
	    }
	
	    function indicesEquals(indices1, indices2) {
	        // indices is always order by asc and has only finite number.
	        return indices1.join(',') === indices2.join(',');
	    }
	
	    /**
	     * Consider case:
	     * `chart.setOption(opt1);`
	     * Then user do some interaction like dataZoom, dataView changing.
	     * `chart.setOption(opt2);`
	     * Then user press 'reset button' in toolbox.
	     *
	     * After doing that all of the interaction effects should be reset, the
	     * chart should be the same as the result of invoke
	     * `chart.setOption(opt1); chart.setOption(opt2);`.
	     *
	     * Although it is not able ensure that
	     * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to
	     * `chart.setOption(merge(opt1, opt2));` exactly,
	     * this might be the only simple way to implement that feature.
	     *
	     * MEMO: We've considered some other approaches:
	     * 1. Each model handle its self restoration but not uniform treatment.
	     *     (Too complex in logic and error-prone)
	     * 2. Use a shadow ecModel. (Performace expensive)
	     */
	    function mergeOption(oldOption, newOption) {
	        newOption = newOption || {};
	
	        each(newOption, function (newCptOpt, mainType) {
	            if (newCptOpt == null) {
	                return;
	            }
	
	            var oldCptOpt = oldOption[mainType];
	
	            if (!ComponentModel.hasClass(mainType)) {
	                oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);
	            }
	            else {
	                newCptOpt = modelUtil.normalizeToArray(newCptOpt);
	                oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);
	
	                var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);
	
	                oldOption[mainType] = map(mapResult, function (item) {
	                    return (item.option && item.exist)
	                        ? merge(item.exist, item.option, true)
	                        : (item.exist || item.option);
	                });
	            }
	        });
	    }
	
	    return OptionManager;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
	
	    'use strict';
	
	    var zrUtil = __webpack_require__(8);
	    var formatUtil = __webpack_require__(10);
	    var modelUtil = __webpack_require__(9);
	    var ComponentModel = __webpack_require__(23);
	    var colorPaletteMixin = __webpack_require__(28);
	    var env = __webpack_require__(6);
	
	    var encodeHTML = formatUtil.encodeHTML;
	    var addCommas = formatUtil.addCommas;
	
	    var SeriesModel = ComponentModel.extend({
	
	        type: 'series.__base__',
	
	        /**
	         * @readOnly
	         */
	        seriesIndex: 0,
	
	        // coodinateSystem will be injected in the echarts/CoordinateSystem
	        coordinateSystem: null,
	
	        /**
	         * @type {Object}
	         * @protected
	         */
	        defaultOption: null,
	
	        /**
	         * Data provided for legend
	         * @type {Function}
	         */
	        // PENDING
	        legendDataProvider: null,
	
	        /**
	         * Access path of color for visual
	         */
	        visualColorAccessPath: 'itemStyle.normal.color',
	
	        init: function (option, parentModel, ecModel, extraOpt) {
	
	            /**
	             * @type {number}
	             * @readOnly
	             */
	            this.seriesIndex = this.componentIndex;
	
	            this.mergeDefaultAndTheme(option, ecModel);
	
	            /**
	             * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}
	             * @private
	             */
	            this._dataBeforeProcessed = this.getInitialData(option, ecModel);
	
	            // If we reverse the order (make this._data firstly, and then make
	            // this._dataBeforeProcessed by cloneShallow), cloneShallow will
	            // cause this._data.graph.data !== this._data when using
	            // module:echarts/data/Graph or module:echarts/data/Tree.
	            // See module:echarts/data/helper/linkList
	            this._data = this._dataBeforeProcessed.cloneShallow();
	        },
	
	        /**
	         * Util for merge default and theme to option
	         * @param  {Object} option
	         * @param  {module:echarts/model/Global} ecModel
	         */
	        mergeDefaultAndTheme: function (option, ecModel) {
	            zrUtil.merge(
	                option,
	                ecModel.getTheme().get(this.subType)
	            );
	            zrUtil.merge(option, this.getDefaultOption());
	
	            // Default label emphasis `position` and `show`
	            // FIXME Set label in mergeOption
	            modelUtil.defaultEmphasis(option.label, modelUtil.LABEL_OPTIONS);
	
	            this.fillDataTextStyle(option.data);
	        },
	
	        mergeOption: function (newSeriesOption, ecModel) {
	            newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);
	            this.fillDataTextStyle(newSeriesOption.data);
	
	            var data = this.getInitialData(newSeriesOption, ecModel);
	            // TODO Merge data?
	            if (data) {
	                this._data = data;
	                this._dataBeforeProcessed = data.cloneShallow();
	            }
	        },
	
	        fillDataTextStyle: function (data) {
	            // Default data label emphasis `position` and `show`
	            // FIXME Tree structure data ?
	            // FIXME Performance ?
	            if (data) {
	                for (var i = 0; i < data.length; i++) {
	                    if (data[i] && data[i].label) {
	                        modelUtil.defaultEmphasis(data[i].label, modelUtil.LABEL_OPTIONS);
	                    }
	                }
	            }
	        },
	
	        /**
	         * Init a data structure from data related option in series
	         * Must be overwritten
	         */
	        getInitialData: function () {},
	
	        /**
	         * @param {string} [dataType]
	         * @return {module:echarts/data/List}
	         */
	        getData: function (dataType) {
	            return dataType == null ? this._data : this._data.getLinkedData(dataType);
	        },
	
	        /**
	         * @param {module:echarts/data/List} data
	         */
	        setData: function (data) {
	            this._data = data;
	        },
	
	        /**
	         * Get data before processed
	         * @return {module:echarts/data/List}
	         */
	        getRawData: function () {
	            return this._dataBeforeProcessed;
	        },
	
	        /**
	         * Coord dimension to data dimension.
	         *
	         * By default the result is the same as dimensions of series data.
	         * But in some series data dimensions are different from coord dimensions (i.e.
	         * candlestick and boxplot). Override this method to handle those cases.
	         *
	         * Coord dimension to data dimension can be one-to-many
	         *
	         * @param {string} coordDim
	         * @return {Array.<string>} dimensions on the axis.
	         */
	        coordDimToDataDim: function (coordDim) {
	            return [coordDim];
	        },
	
	        /**
	         * Convert data dimension to coord dimension.
	         *
	         * @param {string|number} dataDim
	         * @return {string}
	         */
	        dataDimToCoordDim: function (dataDim) {
	            return dataDim;
	        },
	
	        /**
	         * Get base axis if has coordinate system and has axis.
	         * By default use coordSys.getBaseAxis();
	         * Can be overrided for some chart.
	         * @return {type} description
	         */
	        getBaseAxis: function () {
	            var coordSys = this.coordinateSystem;
	            return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();
	        },
	
	        // FIXME
	        /**
	         * Default tooltip formatter
	         *
	         * @param {number} dataIndex
	         * @param {boolean} [multipleSeries=false]
	         * @param {number} [dataType]
	         */
	        formatTooltip: function (dataIndex, multipleSeries, dataType) {
	            function formatArrayValue(value) {
	                return zrUtil.map(value, function (val, idx) {
	                    var dimInfo = data.getDimensionInfo(idx);
	                    var dimType = dimInfo && dimInfo.type;
	                    if (dimType === 'ordinal') {
	                        return val;
	                    }
	                    else if (dimType === 'time') {
	                        return multipleSeries ? '' : formatUtil.formatTime('yyyy/mm/dd hh:mm:ss', val);
	                    }
	                    else {
	                        return addCommas(val);
	                    }
	                }).filter(function (val) {
	                    return !!val;
	                }).join(', ');
	            }
	
	            var data = this._data;
	
	            var value = this.getRawValue(dataIndex);
	            var formattedValue = zrUtil.isArray(value)
	                ? formatArrayValue(value) : addCommas(value);
	            var name = data.getName(dataIndex);
	            var color = data.getItemVisual(dataIndex, 'color');
	            var colorEl = '<span style="display:inline-block;margin-right:5px;'
	                + 'border-radius:10px;width:9px;height:9px;background-color:' + color + '"></span>';
	
	            var seriesName = this.name;
	            // FIXME
	            if (seriesName === '\0-') {
	                // Not show '-'
	                seriesName = '';
	            }
	            return !multipleSeries
	                ? ((seriesName && encodeHTML(seriesName) + '<br />') + colorEl
	                    + (name
	                        ? encodeHTML(name) + ' : ' + formattedValue
	                        : formattedValue)
	                  )
	                : (colorEl + encodeHTML(this.name) + ' : ' + formattedValue);
	        },
	
	        /**
	         * @return {boolean}
	         */
	        ifEnableAnimation: function () {
	            if (env.node) {
	                return false;
	            }
	
	            var animationEnabled = this.getShallow('animation');
	            if (animationEnabled) {
	                if (this.getData().count() > this.getShallow('animationThreshold')) {
	                    animationEnabled = false;
	                }
	            }
	            return animationEnabled;
	        },
	
	        restoreData: function () {
	            this._data = this._dataBeforeProcessed.cloneShallow();
	        },
	
	        getColorFromPalette: function (name, scope) {
	            var ecModel = this.ecModel;
	            // PENDING
	            var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);
	            if (!color) {
	                color = ecModel.getColorFromPalette(name, scope);
	            }
	            return color;
	        },
	
	        getAxisTooltipDataIndex: null
	    });
	
	    zrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);
	    zrUtil.mixin(SeriesModel, colorPaletteMixin);
	
	    return SeriesModel;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var Group = __webpack_require__(34);
	    var componentUtil = __webpack_require__(24);
	    var clazzUtil = __webpack_require__(17);
	
	    var Component = function () {
	        /**
	         * @type {module:zrender/container/Group}
	         * @readOnly
	         */
	        this.group = new Group();
	
	        /**
	         * @type {string}
	         * @readOnly
	         */
	        this.uid = componentUtil.getUID('viewComponent');
	    };
	
	    Component.prototype = {
	
	        constructor: Component,
	
	        init: function (ecModel, api) {},
	
	        render: function (componentModel, ecModel, api, payload) {},
	
	        dispose: function () {}
	    };
	
	    var componentProto = Component.prototype;
	    componentProto.updateView
	        = componentProto.updateLayout
	        = componentProto.updateVisual
	        = function (seriesModel, ecModel, api, payload) {
	            // Do nothing;
	        };
	    // Enable Component.extend.
	    clazzUtil.enableClassExtend(Component);
	
	    // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.
	    clazzUtil.enableClassManagement(Component, {registerWhenExtend: true});
	
	    return Component;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上
	 * @module zrender/graphic/Group
	 * @example
	 *     var Group = require('zrender/container/Group');
	 *     var Circle = require('zrender/graphic/shape/Circle');
	 *     var g = new Group();
	 *     g.position[0] = 100;
	 *     g.position[1] = 100;
	 *     g.add(new Circle({
	 *         style: {
	 *             x: 100,
	 *             y: 100,
	 *             r: 20,
	 *         }
	 *     }));
	 *     zr.add(g);
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var zrUtil = __webpack_require__(8);
	    var Element = __webpack_require__(35);
	    var BoundingRect = __webpack_require__(13);
	
	    /**
	     * @alias module:zrender/graphic/Group
	     * @constructor
	     * @extends module:zrender/mixin/Transformable
	     * @extends module:zrender/mixin/Eventful
	     */
	    var Group = function (opts) {
	
	        opts = opts || {};
	
	        Element.call(this, opts);
	
	        for (var key in opts) {
	            this[key] = opts[key];
	        }
	
	        this._children = [];
	
	        this.__storage = null;
	
	        this.__dirty = true;
	    };
	
	    Group.prototype = {
	
	        constructor: Group,
	
	        isGroup: true,
	
	        /**
	         * @type {string}
	         */
	        type: 'group',
	
	        /**
	         * 所有子孙元素是否响应鼠标事件
	         * @name module:/zrender/container/Group#silent
	         * @type {boolean}
	         * @default false
	         */
	        silent: false,
	
	        /**
	         * @return {Array.<module:zrender/Element>}
	         */
	        children: function () {
	            return this._children.slice();
	        },
	
	        /**
	         * 获取指定 index 的儿子节点
	         * @param  {number} idx
	         * @return {module:zrender/Element}
	         */
	        childAt: function (idx) {
	            return this._children[idx];
	        },
	
	        /**
	         * 获取指定名字的儿子节点
	         * @param  {string} name
	         * @return {module:zrender/Element}
	         */
	        childOfName: function (name) {
	            var children = this._children;
	            for (var i = 0; i < children.length; i++) {
	                if (children[i].name === name) {
	                    return children[i];
	                }
	             }
	        },
	
	        /**
	         * @return {number}
	         */
	        childCount: function () {
	            return this._children.length;
	        },
	
	        /**
	         * 添加子节点到最后
	         * @param {module:zrender/Element} child
	         */
	        add: function (child) {
	            if (child && child !== this && child.parent !== this) {
	
	                this._children.push(child);
	
	                this._doAdd(child);
	            }
	
	            return this;
	        },
	
	        /**
	         * 添加子节点在 nextSibling 之前
	         * @param {module:zrender/Element} child
	         * @param {module:zrender/Element} nextSibling
	         */
	        addBefore: function (child, nextSibling) {
	            if (child && child !== this && child.parent !== this
	                && nextSibling && nextSibling.parent === this) {
	
	                var children = this._children;
	                var idx = children.indexOf(nextSibling);
	
	                if (idx >= 0) {
	                    children.splice(idx, 0, child);
	                    this._doAdd(child);
	                }
	            }
	
	            return this;
	        },
	
	        _doAdd: function (child) {
	            if (child.parent) {
	                child.parent.remove(child);
	            }
	
	            child.parent = this;
	
	            var storage = this.__storage;
	            var zr = this.__zr;
	            if (storage && storage !== child.__storage) {
	
	                storage.addToMap(child);
	
	                if (child instanceof Group) {
	                    child.addChildrenToStorage(storage);
	                }
	            }
	
	            zr && zr.refresh();
	        },
	
	        /**
	         * 移除子节点
	         * @param {module:zrender/Element} child
	         */
	        remove: function (child) {
	            var zr = this.__zr;
	            var storage = this.__storage;
	            var children = this._children;
	
	            var idx = zrUtil.indexOf(children, child);
	            if (idx < 0) {
	                return this;
	            }
	            children.splice(idx, 1);
	
	            child.parent = null;
	
	            if (storage) {
	
	                storage.delFromMap(child.id);
	
	                if (child instanceof Group) {
	                    child.delChildrenFromStorage(storage);
	                }
	            }
	
	            zr && zr.refresh();
	
	            return this;
	        },
	
	        /**
	         * 移除所有子节点
	         */
	        removeAll: function () {
	            var children = this._children;
	            var storage = this.__storage;
	            var child;
	            var i;
	            for (i = 0; i < children.length; i++) {
	                child = children[i];
	                if (storage) {
	                    storage.delFromMap(child.id);
	                    if (child instanceof Group) {
	                        child.delChildrenFromStorage(storage);
	                    }
	                }
	                child.parent = null;
	            }
	            children.length = 0;
	
	            return this;
	        },
	
	        /**
	         * 遍历所有子节点
	         * @param  {Function} cb
	         * @param  {}   context
	         */
	        eachChild: function (cb, context) {
	            var children = this._children;
	            for (var i = 0; i < children.length; i++) {
	                var child = children[i];
	                cb.call(context, child, i);
	            }
	            return this;
	        },
	
	        /**
	         * 深度优先遍历所有子孙节点
	         * @param  {Function} cb
	         * @param  {}   context
	         */
	        traverse: function (cb, context) {
	            for (var i = 0; i < this._children.length; i++) {
	                var child = this._children[i];
	                cb.call(context, child);
	
	                if (child.type === 'group') {
	                    child.traverse(cb, context);
	                }
	            }
	            return this;
	        },
	
	        addChildrenToStorage: function (storage) {
	            for (var i = 0; i < this._children.length; i++) {
	                var child = this._children[i];
	                storage.addToMap(child);
	                if (child instanceof Group) {
	                    child.addChildrenToStorage(storage);
	                }
	            }
	        },
	
	        delChildrenFromStorage: function (storage) {
	            for (var i = 0; i < this._children.length; i++) {
	                var child = this._children[i];
	                storage.delFromMap(child.id);
	                if (child instanceof Group) {
	                    child.delChildrenFromStorage(storage);
	                }
	            }
	        },
	
	        dirty: function () {
	            this.__dirty = true;
	            this.__zr && this.__zr.refresh();
	            return this;
	        },
	
	        /**
	         * @return {module:zrender/core/BoundingRect}
	         */
	        getBoundingRect: function (includeChildren) {
	            // TODO Caching
	            // TODO Transform
	            var rect = null;
	            var tmpRect = new BoundingRect(0, 0, 0, 0);
	            var children = includeChildren || this._children;
	            var tmpMat = [];
	
	            for (var i = 0; i < children.length; i++) {
	                var child = children[i];
	                if (child.ignore || child.invisible) {
	                    continue;
	                }
	
	                var childRect = child.getBoundingRect();
	                var transform = child.getLocalTransform(tmpMat);
	                if (transform) {
	                    tmpRect.copy(childRect);
	                    tmpRect.applyTransform(transform);
	                    rect = rect || tmpRect.clone();
	                    rect.union(tmpRect);
	                }
	                else {
	                    rect = rect || childRect.clone();
	                    rect.union(childRect);
	                }
	            }
	            return rect || tmpRect;
	        }
	    };
	
	    zrUtil.inherits(Group, Element);
	
	    return Group;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * @module zrender/Element
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
	    'use strict';
	
	    var guid = __webpack_require__(36);
	    var Eventful = __webpack_require__(37);
	    var Transformable = __webpack_require__(38);
	    var Animatable = __webpack_require__(39);
	    var zrUtil = __webpack_require__(8);
	
	    /**
	     * @alias module:zrender/Element
	     * @constructor
	     * @extends {module:zrender/mixin/Animatable}
	     * @extends {module:zrender/mixin/Transformable}
	     * @extends {module:zrender/mixin/Eventful}
	     */
	    var Element = function (opts) {
	
	        Transformable.call(this, opts);
	        Eventful.call(this, opts);
	        Animatable.call(this, opts);
	
	        /**
	         * 画布元素ID
	         * @type {string}
	         */
	        this.id = opts.id || guid();
	    };
	
	    Element.prototype = {
	
	        /**
	         * 元素类型
	         * Element type
	         * @type {string}
	         */
	        type: 'element',
	
	        /**
	         * 元素名字
	         * Element name
	         * @type {string}
	         */
	        name: '',
	
	        /**
	         * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值
	         * ZRender instance will be assigned when element is associated with zrender
	         * @name module:/zrender/Element#__zr
	         * @type {module:zrender/ZRender}
	         */
	        __zr: null,
	
	        /**
	         * 图形是否忽略，为true时忽略图形的绘制以及事件触发
	         * If ignore drawing and events of the element object
	         * @name module:/zrender/Element#ignore
	         * @type {boolean}
	         * @default false
	         */
	        ignore: false,
	
	        /**
	         * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪
	         * 该路径会继承被裁减对象的变换
	         * @type {module:zrender/graphic/Path}
	         * @see http://www.w3.org/TR/2dcontext/#clipping-region
	         * @readOnly
	         */
	        clipPath: null,
	
	        /**
	         * Drift element
	         * @param  {number} dx dx on the global space
	         * @param  {number} dy dy on the global space
	         */
	        drift: function (dx, dy) {
	            switch (this.draggable) {
	                case 'horizontal':
	                    dy = 0;
	                    break;
	                case 'vertical':
	                    dx = 0;
	                    break;
	            }
	
	            var m = this.transform;
	            if (!m) {
	                m = this.transform = [1, 0, 0, 1, 0, 0];
	            }
	            m[4] += dx;
	            m[5] += dy;
	
	            this.decomposeTransform();
	            this.dirty(false);
	        },
	
	        /**
	         * Hook before update
	         */
	        beforeUpdate: function () {},
	        /**
	         * Hook after update
	         */
	        afterUpdate: function () {},
	        /**
	         * Update each frame
	         */
	        update: function () {
	            this.updateTransform();
	        },
	
	        /**
	         * @param  {Function} cb
	         * @param  {}   context
	         */
	        traverse: function (cb, context) {},
	
	        /**
	         * @protected
	         */
	        attrKV: function (key, value) {
	            if (key === 'position' || key === 'scale' || key === 'origin') {
	                // Copy the array
	                if (value) {
	                    var target = this[key];
	                    if (!target) {
	                        target = this[key] = [];
	                    }
	                    target[0] = value[0];
	                    target[1] = value[1];
	                }
	            }
	            else {
	                this[key] = value;
	            }
	        },
	
	        /**
	         * Hide the element
	         */
	        hide: function () {
	            this.ignore = true;
	            this.__zr && this.__zr.refresh();
	        },
	
	        /**
	         * Show the element
	         */
	        show: function () {
	            this.ignore = false;
	            this.__zr && this.__zr.refresh();
	        },
	
	        /**
	         * @param {string|Object} key
	         * @param {*} value
	         */
	        attr: function (key, value) {
	            if (typeof key === 'string') {
	                this.attrKV(key, value);
	            }
	            else if (zrUtil.isObject(key)) {
	                for (var name in key) {
	                    if (key.hasOwnProperty(name)) {
	                        this.attrKV(name, key[name]);
	                    }
	                }
	            }
	
	            this.dirty(false);
	
	            return this;
	        },
	
	        /**
	         * @param {module:zrender/graphic/Path} clipPath
	         */
	        setClipPath: function (clipPath) {
	            var zr = this.__zr;
	            if (zr) {
	                clipPath.addSelfToZr(zr);
	            }
	
	            // Remove previous clip path
	            if (this.clipPath && this.clipPath !== clipPath) {
	                this.removeClipPath();
	            }
	
	            this.clipPath = clipPath;
	            clipPath.__zr = zr;
	            clipPath.__clipTarget = this;
	
	            this.dirty(false);
	        },
	
	        /**
	         */
	        removeClipPath: function () {
	            var clipPath = this.clipPath;
	            if (clipPath) {
	                if (clipPath.__zr) {
	                    clipPath.removeSelfFromZr(clipPath.__zr);
	                }
	
	                clipPath.__zr = null;
	                clipPath.__clipTarget = null;
	                this.clipPath = null;
	
	                this.dirty(false);
	            }
	        },
	
	        /**
	         * Add self from zrender instance.
	         * Not recursively because it will be invoked when element added to storage.
	         * @param {module:zrender/ZRender} zr
	         */
	        addSelfToZr: function (zr) {
	            this.__zr = zr;
	            // 添加动画
	            var animators = this.animators;
	            if (animators) {
	                for (var i = 0; i < animators.length; i++) {
	                    zr.animation.addAnimator(animators[i]);
	                }
	            }
	
	            if (this.clipPath) {
	                this.clipPath.addSelfToZr(zr);
	            }
	        },
	
	        /**
	         * Remove self from zrender instance.
	         * Not recursively because it will be invoked when element added to storage.
	         * @param {module:zrender/ZRender} zr
	         */
	        removeSelfFromZr: function (zr) {
	            this.__zr = null;
	            // 移除动画
	            var animators = this.animators;
	            if (animators) {
	                for (var i = 0; i < animators.length; i++) {
	                    zr.animation.removeAnimator(animators[i]);
	                }
	            }
	
	            if (this.clipPath) {
	                this.clipPath.removeSelfFromZr(zr);
	            }
	        }
	    };
	
	    zrUtil.mixin(Element, Animatable);
	    zrUtil.mixin(Element, Transformable);
	    zrUtil.mixin(Element, Eventful);
	
	    return Element;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * zrender: 生成唯一id
	 *
	 * @author errorrik (errorrik@gmail.com)
	 */
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	    var idStart = 0x0907;
	
	    return function () {
	        return idStart++;
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * 事件扩展
	 * @module zrender/mixin/Eventful
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         pissang (https://www.github.com/pissang)
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var arrySlice = Array.prototype.slice;
	
	    /**
	     * 事件分发器
	     * @alias module:zrender/mixin/Eventful
	     * @constructor
	     */
	    var Eventful = function () {
	        this._$handlers = {};
	    };
	
	    Eventful.prototype = {
	
	        constructor: Eventful,
	
	        /**
	         * 单次触发绑定，trigger后销毁
	         *
	         * @param {string} event 事件名
	         * @param {Function} handler 响应函数
	         * @param {Object} context
	         */
	        one: function (event, handler, context) {
	            var _h = this._$handlers;
	
	            if (!handler || !event) {
	                return this;
	            }
	
	            if (!_h[event]) {
	                _h[event] = [];
	            }
	
	            for (var i = 0; i < _h[event].length; i++) {
	                if (_h[event][i].h === handler) {
	                    return this;
	                }
	            }
	
	            _h[event].push({
	                h: handler,
	                one: true,
	                ctx: context || this
	            });
	
	            return this;
	        },
	
	        /**
	         * 绑定事件
	         * @param {string} event 事件名
	         * @param {Function} handler 事件处理函数
	         * @param {Object} [context]
	         */
	        on: function (event, handler, context) {
	            var _h = this._$handlers;
	
	            if (!handler || !event) {
	                return this;
	            }
	
	            if (!_h[event]) {
	                _h[event] = [];
	            }
	
	            for (var i = 0; i < _h[event].length; i++) {
	                if (_h[event][i].h === handler) {
	                    return this;
	                }
	            }
	
	            _h[event].push({
	                h: handler,
	                one: false,
	                ctx: context || this
	            });
	
	            return this;
	        },
	
	        /**
	         * 是否绑定了事件
	         * @param  {string}  event
	         * @return {boolean}
	         */
	        isSilent: function (event) {
	            var _h = this._$handlers;
	            return _h[event] && _h[event].length;
	        },
	
	        /**
	         * 解绑事件
	         * @param {string} event 事件名
	         * @param {Function} [handler] 事件处理函数
	         */
	        off: function (event, handler) {
	            var _h = this._$handlers;
	
	            if (!event) {
	                this._$handlers = {};
	                return this;
	            }
	
	            if (handler) {
	                if (_h[event]) {
	                    var newList = [];
	                    for (var i = 0, l = _h[event].length; i < l; i++) {
	                        if (_h[event][i]['h'] != handler) {
	                            newList.push(_h[event][i]);
	                        }
	                    }
	                    _h[event] = newList;
	                }
	
	                if (_h[event] && _h[event].length === 0) {
	                    delete _h[event];
	                }
	            }
	            else {
	                delete _h[event];
	            }
	
	            return this;
	        },
	
	        /**
	         * 事件分发
	         *
	         * @param {string} type 事件类型
	         */
	        trigger: function (type) {
	            if (this._$handlers[type]) {
	                var args = arguments;
	                var argLen = args.length;
	
	                if (argLen > 3) {
	                    args = arrySlice.call(args, 1);
	                }
	
	                var _h = this._$handlers[type];
	                var len = _h.length;
	                for (var i = 0; i < len;) {
	                    // Optimize advise from backbone
	                    switch (argLen) {
	                        case 1:
	                            _h[i]['h'].call(_h[i]['ctx']);
	                            break;
	                        case 2:
	                            _h[i]['h'].call(_h[i]['ctx'], args[1]);
	                            break;
	                        case 3:
	                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);
	                            break;
	                        default:
	                            // have more than 2 given arguments
	                            _h[i]['h'].apply(_h[i]['ctx'], args);
	                            break;
	                    }
	
	                    if (_h[i]['one']) {
	                        _h.splice(i, 1);
	                        len--;
	                    }
	                    else {
	                        i++;
	                    }
	                }
	            }
	
	            return this;
	        },
	
	        /**
	         * 带有context的事件分发, 最后一个参数是事件回调的context
	         * @param {string} type 事件类型
	         */
	        triggerWithContext: function (type) {
	            if (this._$handlers[type]) {
	                var args = arguments;
	                var argLen = args.length;
	
	                if (argLen > 4) {
	                    args = arrySlice.call(args, 1, args.length - 1);
	                }
	                var ctx = args[args.length - 1];
	
	                var _h = this._$handlers[type];
	                var len = _h.length;
	                for (var i = 0; i < len;) {
	                    // Optimize advise from backbone
	                    switch (argLen) {
	                        case 1:
	                            _h[i]['h'].call(ctx);
	                            break;
	                        case 2:
	                            _h[i]['h'].call(ctx, args[1]);
	                            break;
	                        case 3:
	                            _h[i]['h'].call(ctx, args[1], args[2]);
	                            break;
	                        default:
	                            // have more than 2 given arguments
	                            _h[i]['h'].apply(ctx, args);
	                            break;
	                    }
	
	                    if (_h[i]['one']) {
	                        _h.splice(i, 1);
	                        len--;
	                    }
	                    else {
	                        i++;
	                    }
	                }
	            }
	
	            return this;
	        }
	    };
	
	    // 对象可以通过 onxxxx 绑定事件
	    /**
	     * @event module:zrender/mixin/Eventful#onclick
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmouseover
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmouseout
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmousemove
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmousewheel
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmousedown
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmouseup
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondragstart
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondragend
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondragenter
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondragleave
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondragover
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondrop
	     * @type {Function}
	     * @default null
	     */
	
	    return Eventful;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * 提供变换扩展
	 * @module zrender/mixin/Transformable
	 * @author pissang (https://www.github.com/pissang)
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    'use strict';
	
	    var matrix = __webpack_require__(15);
	    var vector = __webpack_require__(14);
	    var mIdentity = matrix.identity;
	
	    var EPSILON = 5e-5;
	
	    function isNotAroundZero(val) {
	        return val > EPSILON || val < -EPSILON;
	    }
	
	    /**
	     * @alias module:zrender/mixin/Transformable
	     * @constructor
	     */
	    var Transformable = function (opts) {
	        opts = opts || {};
	        // If there are no given position, rotation, scale
	        if (!opts.position) {
	            /**
	             * 平移
	             * @type {Array.<number>}
	             * @default [0, 0]
	             */
	            this.position = [0, 0];
	        }
	        if (opts.rotation == null) {
	            /**
	             * 旋转
	             * @type {Array.<number>}
	             * @default 0
	             */
	            this.rotation = 0;
	        }
	        if (!opts.scale) {
	            /**
	             * 缩放
	             * @type {Array.<number>}
	             * @default [1, 1]
	             */
	            this.scale = [1, 1];
	        }
	        /**
	         * 旋转和缩放的原点
	         * @type {Array.<number>}
	         * @default null
	         */
	        this.origin = this.origin || null;
	    };
	
	    var transformableProto = Transformable.prototype;
	    transformableProto.transform = null;
	
	    /**
	     * 判断是否需要有坐标变换
	     * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵
	     */
	    transformableProto.needLocalTransform = function () {
	        return isNotAroundZero(this.rotation)
	            || isNotAroundZero(this.position[0])
	            || isNotAroundZero(this.position[1])
	            || isNotAroundZero(this.scale[0] - 1)
	            || isNotAroundZero(this.scale[1] - 1);
	    };
	
	    transformableProto.updateTransform = function () {
	        var parent = this.parent;
	        var parentHasTransform = parent && parent.transform;
	        var needLocalTransform = this.needLocalTransform();
	
	        var m = this.transform;
	        if (!(needLocalTransform || parentHasTransform)) {
	            m && mIdentity(m);
	            return;
	        }
	
	        m = m || matrix.create();
	
	        if (needLocalTransform) {
	            this.getLocalTransform(m);
	        }
	        else {
	            mIdentity(m);
	        }
	
	        // 应用父节点变换
	        if (parentHasTransform) {
	            if (needLocalTransform) {
	                matrix.mul(m, parent.transform, m);
	            }
	            else {
	                matrix.copy(m, parent.transform);
	            }
	        }
	        // 保存这个变换矩阵
	        this.transform = m;
	
	        this.invTransform = this.invTransform || matrix.create();
	        matrix.invert(this.invTransform, m);
	    };
	
	    transformableProto.getLocalTransform = function (m) {
	        m = m || [];
	        mIdentity(m);
	
	        var origin = this.origin;
	
	        var scale = this.scale;
	        var rotation = this.rotation;
	        var position = this.position;
	        if (origin) {
	            // Translate to origin
	            m[4] -= origin[0];
	            m[5] -= origin[1];
	        }
	        matrix.scale(m, m, scale);
	        if (rotation) {
	            matrix.rotate(m, m, rotation);
	        }
	        if (origin) {
	            // Translate back from origin
	            m[4] += origin[0];
	            m[5] += origin[1];
	        }
	
	        m[4] += position[0];
	        m[5] += position[1];
	
	        return m;
	    };
	    /**
	     * 将自己的transform应用到context上
	     * @param {Context2D} ctx
	     */
	    transformableProto.setTransform = function (ctx) {
	        var m = this.transform;
	        var dpr = ctx.dpr || 1;
	        if (m) {
	            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);
	        }
	        else {
	            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
	        }
	    };
	
	    transformableProto.restoreTransform = function (ctx) {
	        var m = this.transform;
	        var dpr = ctx.dpr || 1;
	        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
	    }
	
	    var tmpTransform = [];
	
	    /**
	     * 分解`transform`矩阵到`position`, `rotation`, `scale`
	     */
	    transformableProto.decomposeTransform = function () {
	        if (!this.transform) {
	            return;
	        }
	        var parent = this.parent;
	        var m = this.transform;
	        if (parent && parent.transform) {
	            // Get local transform and decompose them to position, scale, rotation
	            matrix.mul(tmpTransform, parent.invTransform, m);
	            m = tmpTransform;
	        }
	        var sx = m[0] * m[0] + m[1] * m[1];
	        var sy = m[2] * m[2] + m[3] * m[3];
	        var position = this.position;
	        var scale = this.scale;
	        if (isNotAroundZero(sx - 1)) {
	            sx = Math.sqrt(sx);
	        }
	        if (isNotAroundZero(sy - 1)) {
	            sy = Math.sqrt(sy);
	        }
	        if (m[0] < 0) {
	            sx = -sx;
	        }
	        if (m[3] < 0) {
	            sy = -sy;
	        }
	        position[0] = m[4];
	        position[1] = m[5];
	        scale[0] = sx;
	        scale[1] = sy;
	        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);
	    };
	
	    /**
	     * Get global scale
	     * @return {Array.<number>}
	     */
	    transformableProto.getGlobalScale = function () {
	        var m = this.transform;
	        if (!m) {
	            return [1, 1];
	        }
	        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);
	        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);
	        if (m[0] < 0) {
	            sx = -sx;
	        }
	        if (m[3] < 0) {
	            sy = -sy;
	        }
	        return [sx, sy];
	    };
	    /**
	     * 变换坐标位置到 shape 的局部坐标空间
	     * @method
	     * @param {number} x
	     * @param {number} y
	     * @return {Array.<number>}
	     */
	    transformableProto.transformCoordToLocal = function (x, y) {
	        var v2 = [x, y];
	        var invTransform = this.invTransform;
	        if (invTransform) {
	            vector.applyTransform(v2, v2, invTransform);
	        }
	        return v2;
	    };
	
	    /**
	     * 变换局部坐标位置到全局坐标空间
	     * @method
	     * @param {number} x
	     * @param {number} y
	     * @return {Array.<number>}
	     */
	    transformableProto.transformCoordToGlobal = function (x, y) {
	        var v2 = [x, y];
	        var transform = this.transform;
	        if (transform) {
	            vector.applyTransform(v2, v2, transform);
	        }
	        return v2;
	    };
	
	    return Transformable;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * @module zrender/mixin/Animatable
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
	
	    'use strict';
	
	    var Animator = __webpack_require__(40);
	    var util = __webpack_require__(8);
	    var isString = util.isString;
	    var isFunction = util.isFunction;
	    var isObject = util.isObject;
	    var log = __webpack_require__(44);
	
	    /**
	     * @alias modue:zrender/mixin/Animatable
	     * @constructor
	     */
	    var Animatable = function () {
	
	        /**
	         * @type {Array.<module:zrender/animation/Animator>}
	         * @readOnly
	         */
	        this.animators = [];
	    };
	
	    Animatable.prototype = {
	
	        constructor: Animatable,
	
	        /**
	         * 动画
	         *
	         * @param {string} path 需要添加动画的属性获取路径，可以通过a.b.c来获取深层的属性
	         * @param {boolean} [loop] 动画是否循环
	         * @return {module:zrender/animation/Animator}
	         * @example:
	         *     el.animate('style', false)
	         *         .when(1000, {x: 10} )
	         *         .done(function(){ // Animation done })
	         *         .start()
	         */
	        animate: function (path, loop) {
	            var target;
	            var animatingShape = false;
	            var el = this;
	            var zr = this.__zr;
	            if (path) {
	                var pathSplitted = path.split('.');
	                var prop = el;
	                // If animating shape
	                animatingShape = pathSplitted[0] === 'shape';
	                for (var i = 0, l = pathSplitted.length; i < l; i++) {
	                    if (!prop) {
	                        continue;
	                    }
	                    prop = prop[pathSplitted[i]];
	                }
	                if (prop) {
	                    target = prop;
	                }
	            }
	            else {
	                target = el;
	            }
	
	            if (!target) {
	                log(
	                    'Property "'
	                    + path
	                    + '" is not existed in element '
	                    + el.id
	                );
	                return;
	            }
	
	            var animators = el.animators;
	
	            var animator = new Animator(target, loop);
	
	            animator.during(function (target) {
	                el.dirty(animatingShape);
	            })
	            .done(function () {
	                // FIXME Animator will not be removed if use `Animator#stop` to stop animation
	                animators.splice(util.indexOf(animators, animator), 1);
	            });
	
	            animators.push(animator);
	
	            // If animate after added to the zrender
	            if (zr) {
	                zr.animation.addAnimator(animator);
	            }
	
	            return animator;
	        },
	
	        /**
	         * 停止动画
	         * @param {boolean} forwardToLast If move to last frame before stop
	         */
	        stopAnimation: function (forwardToLast) {
	            var animators = this.animators;
	            var len = animators.length;
	            for (var i = 0; i < len; i++) {
	                animators[i].stop(forwardToLast);
	            }
	            animators.length = 0;
	
	            return this;
	        },
	
	        /**
	         * @param {Object} target
	         * @param {number} [time=500] Time in ms
	         * @param {string} [easing='linear']
	         * @param {number} [delay=0]
	         * @param {Function} [callback]
	         *
	         * @example
	         *  // Animate position
	         *  el.animateTo({
	         *      position: [10, 10]
	         *  }, function () { // done })
	         *
	         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing
	         *  el.animateTo({
	         *      shape: {
	         *          width: 500
	         *      },
	         *      style: {
	         *          fill: 'red'
	         *      }
	         *      position: [10, 10]
	         *  }, 100, 100, 'cubicOut', function () { // done })
	         */
	         // TODO Return animation key
	        animateTo: function (target, time, delay, easing, callback) {
	            // animateTo(target, time, easing, callback);
	            if (isString(delay)) {
	                callback = easing;
	                easing = delay;
	                delay = 0;
	            }
	            // animateTo(target, time, delay, callback);
	            else if (isFunction(easing)) {
	                callback = easing;
	                easing = 'linear';
	                delay = 0;
	            }
	            // animateTo(target, time, callback);
	            else if (isFunction(delay)) {
	                callback = delay;
	                delay = 0;
	            }
	            // animateTo(target, callback)
	            else if (isFunction(time)) {
	                callback = time;
	                time = 500;
	            }
	            // animateTo(target)
	            else if (!time) {
	                time = 500;
	            }
	            // Stop all previous animations
	            this.stopAnimation();
	            this._animateToShallow('', this, target, time, delay, easing, callback);
	
	            // Animators may be removed immediately after start
	            // if there is nothing to animate
	            var animators = this.animators.slice();
	            var count = animators.length;
	            function done() {
	                count--;
	                if (!count) {
	                    callback && callback();
	                }
	            }
	
	            // No animators. This should be checked before animators[i].start(),
	            // because 'done' may be executed immediately if no need to animate.
	            if (!count) {
	                callback && callback();
	            }
	            // Start after all animators created
	            // Incase any animator is done immediately when all animation properties are not changed
	            for (var i = 0; i < animators.length; i++) {
	                animators[i]
	                    .done(done)
	                    .start(easing);
	            }
	        },
	
	        /**
	         * @private
	         * @param {string} path=''
	         * @param {Object} source=this
	         * @param {Object} target
	         * @param {number} [time=500]
	         * @param {number} [delay=0]
	         *
	         * @example
	         *  // Animate position
	         *  el._animateToShallow({
	         *      position: [10, 10]
	         *  })
	         *
	         *  // Animate shape, style and position in 100ms, delayed 100ms
	         *  el._animateToShallow({
	         *      shape: {
	         *          width: 500
	         *      },
	         *      style: {
	         *          fill: 'red'
	         *      }
	         *      position: [10, 10]
	         *  }, 100, 100)
	         */
	        _animateToShallow: function (path, source, target, time, delay) {
	            var objShallow = {};
	            var propertyCount = 0;
	            for (var name in target) {
	                if (source[name] != null) {
	                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {
	                        this._animateToShallow(
	                            path ? path + '.' + name : name,
	                            source[name],
	                            target[name],
	                            time,
	                            delay
	                        );
	                    }
	                    else {
	                        objShallow[name] = target[name];
	                        propertyCount++;
	                    }
	                }
	                else if (target[name] != null) {
	                    // Attr directly if not has property
	                    // FIXME, if some property not needed for element ?
	                    if (!path) {
	                        this.attr(name, target[name]);
	                    }
	                    else {  // Shape or style
	                        var props = {};
	                        props[path] = {};
	                        props[path][name] = target[name];
	                        this.attr(props);
	                    }
	                }
	            }
	
	            if (propertyCount > 0) {
	                this.animate(path, false)
	                    .when(time == null ? 500 : time, objShallow)
	                    .delay(delay || 0);
	            }
	
	            return this;
	        }
	    };
	
	    return Animatable;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * @module echarts/animation/Animator
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var Clip = __webpack_require__(41);
	    var color = __webpack_require__(43);
	    var util = __webpack_require__(8);
	    var isArrayLike = util.isArrayLike;
	
	    var arraySlice = Array.prototype.slice;
	
	    function defaultGetter(target, key) {
	        return target[key];
	    }
	
	    function defaultSetter(target, key, value) {
	        target[key] = value;
	    }
	
	    /**
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} percent
	     * @return {number}
	     */
	    function interpolateNumber(p0, p1, percent) {
	        return (p1 - p0) * percent + p0;
	    }
	
	    /**
	     * @param  {string} p0
	     * @param  {string} p1
	     * @param  {number} percent
	     * @return {string}
	     */
	    function interpolateString(p0, p1, percent) {
	        return percent > 0.5 ? p1 : p0;
	    }
	
	    /**
	     * @param  {Array} p0
	     * @param  {Array} p1
	     * @param  {number} percent
	     * @param  {Array} out
	     * @param  {number} arrDim
	     */
	    function interpolateArray(p0, p1, percent, out, arrDim) {
	        var len = p0.length;
	        if (arrDim == 1) {
	            for (var i = 0; i < len; i++) {
	                out[i] = interpolateNumber(p0[i], p1[i], percent);
	            }
	        }
	        else {
	            var len2 = p0[0].length;
	            for (var i = 0; i < len; i++) {
	                for (var j = 0; j < len2; j++) {
	                    out[i][j] = interpolateNumber(
	                        p0[i][j], p1[i][j], percent
	                    );
	                }
	            }
	        }
	    }
	
	    // arr0 is source array, arr1 is target array.
	    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1
	    function fillArr(arr0, arr1, arrDim) {
	        var arr0Len = arr0.length;
	        var arr1Len = arr1.length;
	        if (arr0Len !== arr1Len) {
	            // FIXME Not work for TypedArray
	            var isPreviousLarger = arr0Len > arr1Len;
	            if (isPreviousLarger) {
	                // Cut the previous
	                arr0.length = arr1Len;
	            }
	            else {
	                // Fill the previous
	                for (var i = arr0Len; i < arr1Len; i++) {
	                    arr0.push(
	                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])
	                    );
	                }
	            }
	        }
	        // Handling NaN value
	        var len2 = arr0[0] && arr0[0].length;
	        for (var i = 0; i < arr0.length; i++) {
	            if (arrDim === 1) {
	                if (isNaN(arr0[i])) {
	                    arr0[i] = arr1[i];
	                }
	            }
	            else {
	                for (var j = 0; j < len2; j++) {
	                    if (isNaN(arr0[i][j])) {
	                        arr0[i][j] = arr1[i][j];
	                    }
	                }
	            }
	        }
	    }
	
	    /**
	     * @param  {Array} arr0
	     * @param  {Array} arr1
	     * @param  {number} arrDim
	     * @return {boolean}
	     */
	    function isArraySame(arr0, arr1, arrDim) {
	        if (arr0 === arr1) {
	            return true;
	        }
	        var len = arr0.length;
	        if (len !== arr1.length) {
	            return false;
	        }
	        if (arrDim === 1) {
	            for (var i = 0; i < len; i++) {
	                if (arr0[i] !== arr1[i]) {
	                    return false;
	                }
	            }
	        }
	        else {
	            var len2 = arr0[0].length;
	            for (var i = 0; i < len; i++) {
	                for (var j = 0; j < len2; j++) {
	                    if (arr0[i][j] !== arr1[i][j]) {
	                        return false;
	                    }
	                }
	            }
	        }
	        return true;
	    }
	
	    /**
	     * Catmull Rom interpolate array
	     * @param  {Array} p0
	     * @param  {Array} p1
	     * @param  {Array} p2
	     * @param  {Array} p3
	     * @param  {number} t
	     * @param  {number} t2
	     * @param  {number} t3
	     * @param  {Array} out
	     * @param  {number} arrDim
	     */
	    function catmullRomInterpolateArray(
	        p0, p1, p2, p3, t, t2, t3, out, arrDim
	    ) {
	        var len = p0.length;
	        if (arrDim == 1) {
	            for (var i = 0; i < len; i++) {
	                out[i] = catmullRomInterpolate(
	                    p0[i], p1[i], p2[i], p3[i], t, t2, t3
	                );
	            }
	        }
	        else {
	            var len2 = p0[0].length;
	            for (var i = 0; i < len; i++) {
	                for (var j = 0; j < len2; j++) {
	                    out[i][j] = catmullRomInterpolate(
	                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],
	                        t, t2, t3
	                    );
	                }
	            }
	        }
	    }
	
	    /**
	     * Catmull Rom interpolate number
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} t
	     * @param  {number} t2
	     * @param  {number} t3
	     * @return {number}
	     */
	    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {
	        var v0 = (p2 - p0) * 0.5;
	        var v1 = (p3 - p1) * 0.5;
	        return (2 * (p1 - p2) + v0 + v1) * t3
	                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2
	                + v0 * t + p1;
	    }
	
	    function cloneValue(value) {
	        if (isArrayLike(value)) {
	            var len = value.length;
	            if (isArrayLike(value[0])) {
	                var ret = [];
	                for (var i = 0; i < len; i++) {
	                    ret.push(arraySlice.call(value[i]));
	                }
	                return ret;
	            }
	
	            return arraySlice.call(value);
	        }
	
	        return value;
	    }
	
	    function rgba2String(rgba) {
	        rgba[0] = Math.floor(rgba[0]);
	        rgba[1] = Math.floor(rgba[1]);
	        rgba[2] = Math.floor(rgba[2]);
	
	        return 'rgba(' + rgba.join(',') + ')';
	    }
	
	    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {
	        var getter = animator._getter;
	        var setter = animator._setter;
	        var useSpline = easing === 'spline';
	
	        var trackLen = keyframes.length;
	        if (!trackLen) {
	            return;
	        }
	        // Guess data type
	        var firstVal = keyframes[0].value;
	        var isValueArray = isArrayLike(firstVal);
	        var isValueColor = false;
	        var isValueString = false;
	
	        // For vertices morphing
	        var arrDim = (
	                isValueArray
	                && isArrayLike(firstVal[0])
	            )
	            ? 2 : 1;
	        var trackMaxTime;
	        // Sort keyframe as ascending
	        keyframes.sort(function(a, b) {
	            return a.time - b.time;
	        });
	
	        trackMaxTime = keyframes[trackLen - 1].time;
	        // Percents of each keyframe
	        var kfPercents = [];
	        // Value of each keyframe
	        var kfValues = [];
	        var prevValue = keyframes[0].value;
	        var isAllValueEqual = true;
	        for (var i = 0; i < trackLen; i++) {
	            kfPercents.push(keyframes[i].time / trackMaxTime);
	            // Assume value is a color when it is a string
	            var value = keyframes[i].value;
	
	            // Check if value is equal, deep check if value is array
	            if (!((isValueArray && isArraySame(value, prevValue, arrDim))
	                || (!isValueArray && value === prevValue))) {
	                isAllValueEqual = false;
	            }
	            prevValue = value;
	
	            // Try converting a string to a color array
	            if (typeof value == 'string') {
	                var colorArray = color.parse(value);
	                if (colorArray) {
	                    value = colorArray;
	                    isValueColor = true;
	                }
	                else {
	                    isValueString = true;
	                }
	            }
	            kfValues.push(value);
	        }
	        if (isAllValueEqual) {
	            return;
	        }
	
	        var lastValue = kfValues[trackLen - 1];
	        // Polyfill array and NaN value
	        for (var i = 0; i < trackLen - 1; i++) {
	            if (isValueArray) {
	                fillArr(kfValues[i], lastValue, arrDim);
	            }
	            else {
	                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {
	                    kfValues[i] = lastValue;
	                }
	            }
	        }
	        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);
	
	        // Cache the key of last frame to speed up when
	        // animation playback is sequency
	        var lastFrame = 0;
	        var lastFramePercent = 0;
	        var start;
	        var w;
	        var p0;
	        var p1;
	        var p2;
	        var p3;
	
	        if (isValueColor) {
	            var rgba = [0, 0, 0, 0];
	        }
	
	        var onframe = function (target, percent) {
	            // Find the range keyframes
	            // kf1-----kf2---------current--------kf3
	            // find kf2 and kf3 and do interpolation
	            var frame;
	            // In the easing function like elasticOut, percent may less than 0
	            if (percent < 0) {
	                frame = 0;
	            }
	            else if (percent < lastFramePercent) {
	                // Start from next key
	                // PENDING start from lastFrame ?
	                start = Math.min(lastFrame + 1, trackLen - 1);
	                for (frame = start; frame >= 0; frame--) {
	                    if (kfPercents[frame] <= percent) {
	                        break;
	                    }
	                }
	                // PENDING really need to do this ?
	                frame = Math.min(frame, trackLen - 2);
	            }
	            else {
	                for (frame = lastFrame; frame < trackLen; frame++) {
	                    if (kfPercents[frame] > percent) {
	                        break;
	                    }
	                }
	                frame = Math.min(frame - 1, trackLen - 2);
	            }
	            lastFrame = frame;
	            lastFramePercent = percent;
	
	            var range = (kfPercents[frame + 1] - kfPercents[frame]);
	            if (range === 0) {
	                return;
	            }
	            else {
	                w = (percent - kfPercents[frame]) / range;
	            }
	            if (useSpline) {
	                p1 = kfValues[frame];
	                p0 = kfValues[frame === 0 ? frame : frame - 1];
	                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];
	                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];
	                if (isValueArray) {
	                    catmullRomInterpolateArray(
	                        p0, p1, p2, p3, w, w * w, w * w * w,
	                        getter(target, propName),
	                        arrDim
	                    );
	                }
	                else {
	                    var value;
	                    if (isValueColor) {
	                        value = catmullRomInterpolateArray(
	                            p0, p1, p2, p3, w, w * w, w * w * w,
	                            rgba, 1
	                        );
	                        value = rgba2String(rgba);
	                    }
	                    else if (isValueString) {
	                        // String is step(0.5)
	                        return interpolateString(p1, p2, w);
	                    }
	                    else {
	                        value = catmullRomInterpolate(
	                            p0, p1, p2, p3, w, w * w, w * w * w
	                        );
	                    }
	                    setter(
	                        target,
	                        propName,
	                        value
	                    );
	                }
	            }
	            else {
	                if (isValueArray) {
	                    interpolateArray(
	                        kfValues[frame], kfValues[frame + 1], w,
	                        getter(target, propName),
	                        arrDim
	                    );
	                }
	                else {
	                    var value;
	                    if (isValueColor) {
	                        interpolateArray(
	                            kfValues[frame], kfValues[frame + 1], w,
	                            rgba, 1
	                        );
	                        value = rgba2String(rgba);
	                    }
	                    else if (isValueString) {
	                        // String is step(0.5)
	                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);
	                    }
	                    else {
	                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);
	                    }
	                    setter(
	                        target,
	                        propName,
	                        value
	                    );
	                }
	            }
	        };
	
	        var clip = new Clip({
	            target: animator._target,
	            life: trackMaxTime,
	            loop: animator._loop,
	            delay: animator._delay,
	            onframe: onframe,
	            ondestroy: oneTrackDone
	        });
	
	        if (easing && easing !== 'spline') {
	            clip.easing = easing;
	        }
	
	        return clip;
	    }
	
	    /**
	     * @alias module:zrender/animation/Animator
	     * @constructor
	     * @param {Object} target
	     * @param {boolean} loop
	     * @param {Function} getter
	     * @param {Function} setter
	     */
	    var Animator = function(target, loop, getter, setter) {
	        this._tracks = {};
	        this._target = target;
	
	        this._loop = loop || false;
	
	        this._getter = getter || defaultGetter;
	        this._setter = setter || defaultSetter;
	
	        this._clipCount = 0;
	
	        this._delay = 0;
	
	        this._doneList = [];
	
	        this._onframeList = [];
	
	        this._clipList = [];
	    };
	
	    Animator.prototype = {
	        /**
	         * 设置动画关键帧
	         * @param  {number} time 关键帧时间，单位是ms
	         * @param  {Object} props 关键帧的属性值，key-value表示
	         * @return {module:zrender/animation/Animator}
	         */
	        when: function(time /* ms */, props) {
	            var tracks = this._tracks;
	            for (var propName in props) {
	                if (!tracks[propName]) {
	                    tracks[propName] = [];
	                    // Invalid value
	                    var value = this._getter(this._target, propName);
	                    if (value == null) {
	                        // zrLog('Invalid property ' + propName);
	                        continue;
	                    }
	                    // If time is 0
	                    //  Then props is given initialize value
	                    // Else
	                    //  Initialize value from current prop value
	                    if (time !== 0) {
	                        tracks[propName].push({
	                            time: 0,
	                            value: cloneValue(value)
	                        });
	                    }
	                }
	                tracks[propName].push({
	                    time: time,
	                    value: props[propName]
	                });
	            }
	            return this;
	        },
	        /**
	         * 添加动画每一帧的回调函数
	         * @param  {Function} callback
	         * @return {module:zrender/animation/Animator}
	         */
	        during: function (callback) {
	            this._onframeList.push(callback);
	            return this;
	        },
	
	        _doneCallback: function () {
	            // Clear all tracks
	            this._tracks = {};
	            // Clear all clips
	            this._clipList.length = 0;
	
	            var doneList = this._doneList;
	            var len = doneList.length;
	            for (var i = 0; i < len; i++) {
	                doneList[i].call(this);
	            }
	        },
	        /**
	         * 开始执行动画
	         * @param  {string|Function} easing
	         *         动画缓动函数，详见{@link module:zrender/animation/easing}
	         * @return {module:zrender/animation/Animator}
	         */
	        start: function (easing) {
	
	            var self = this;
	            var clipCount = 0;
	
	            var oneTrackDone = function() {
	                clipCount--;
	                if (!clipCount) {
	                    self._doneCallback();
	                }
	            };
	
	            var lastClip;
	            for (var propName in this._tracks) {
	                var clip = createTrackClip(
	                    this, easing, oneTrackDone,
	                    this._tracks[propName], propName
	                );
	                if (clip) {
	                    this._clipList.push(clip);
	                    clipCount++;
	
	                    // If start after added to animation
	                    if (this.animation) {
	                        this.animation.addClip(clip);
	                    }
	
	                    lastClip = clip;
	                }
	            }
	
	            // Add during callback on the last clip
	            if (lastClip) {
	                var oldOnFrame = lastClip.onframe;
	                lastClip.onframe = function (target, percent) {
	                    oldOnFrame(target, percent);
	
	                    for (var i = 0; i < self._onframeList.length; i++) {
	                        self._onframeList[i](target, percent);
	                    }
	                };
	            }
	
	            if (!clipCount) {
	                this._doneCallback();
	            }
	            return this;
	        },
	        /**
	         * 停止动画
	         * @param {boolean} forwardToLast If move to last frame before stop
	         */
	        stop: function (forwardToLast) {
	            var clipList = this._clipList;
	            var animation = this.animation;
	            for (var i = 0; i < clipList.length; i++) {
	                var clip = clipList[i];
	                if (forwardToLast) {
	                    // Move to last frame before stop
	                    clip.onframe(this._target, 1);
	                }
	                animation && animation.removeClip(clip);
	            }
	            clipList.length = 0;
	        },
	        /**
	         * 设置动画延迟开始的时间
	         * @param  {number} time 单位ms
	         * @return {module:zrender/animation/Animator}
	         */
	        delay: function (time) {
	            this._delay = time;
	            return this;
	        },
	        /**
	         * 添加动画结束的回调
	         * @param  {Function} cb
	         * @return {module:zrender/animation/Animator}
	         */
	        done: function(cb) {
	            if (cb) {
	                this._doneList.push(cb);
	            }
	            return this;
	        },
	
	        /**
	         * @return {Array.<module:zrender/animation/Clip>}
	         */
	        getClips: function () {
	            return this._clipList;
	        }
	    };
	
	    return Animator;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * 动画主控制器
	 * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件
	 * @config life(1000) 动画时长
	 * @config delay(0) 动画延迟时间
	 * @config loop(true)
	 * @config gap(0) 循环的间隔时间
	 * @config onframe
	 * @config easing(optional)
	 * @config ondestroy(optional)
	 * @config onrestart(optional)
	 *
	 * TODO pause
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
	
	    var easingFuncs = __webpack_require__(42);
	
	    function Clip(options) {
	
	        this._target = options.target;
	
	        // 生命周期
	        this._life = options.life || 1000;
	        // 延时
	        this._delay = options.delay || 0;
	        // 开始时间
	        // this._startTime = new Date().getTime() + this._delay;// 单位毫秒
	        this._initialized = false;
	
	        // 是否循环
	        this.loop = options.loop == null ? false : options.loop;
	
	        this.gap = options.gap || 0;
	
	        this.easing = options.easing || 'Linear';
	
	        this.onframe = options.onframe;
	        this.ondestroy = options.ondestroy;
	        this.onrestart = options.onrestart;
	    }
	
	    Clip.prototype = {
	
	        constructor: Clip,
	
	        step: function (globalTime) {
	            // Set startTime on first step, or _startTime may has milleseconds different between clips
	            // PENDING
	            if (!this._initialized) {
	                this._startTime = globalTime + this._delay;
	                this._initialized = true;
	            }
	
	            var percent = (globalTime - this._startTime) / this._life;
	
	            // 还没开始
	            if (percent < 0) {
	                return;
	            }
	
	            percent = Math.min(percent, 1);
	
	            var easing = this.easing;
	            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;
	            var schedule = typeof easingFunc === 'function'
	                ? easingFunc(percent)
	                : percent;
	
	            this.fire('frame', schedule);
	
	            // 结束
	            if (percent == 1) {
	                if (this.loop) {
	                    this.restart (globalTime);
	                    // 重新开始周期
	                    // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件
	                    return 'restart';
	                }
	
	                // 动画完成将这个控制器标识为待删除
	                // 在Animation.update中进行批量删除
	                this._needsRemove = true;
	                return 'destroy';
	            }
	
	            return null;
	        },
	
	        restart: function (globalTime) {
	            var remainder = (globalTime - this._startTime) % this._life;
	            this._startTime = globalTime - remainder + this.gap;
	
	            this._needsRemove = false;
	        },
	
	        fire: function(eventType, arg) {
	            eventType = 'on' + eventType;
	            if (this[eventType]) {
	                this[eventType](this._target, arg);
	            }
	        }
	    };
	
	    return Clip;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js
	 * @see http://sole.github.io/tween.js/examples/03_graphs.html
	 * @exports zrender/animation/easing
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var easing = {
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        linear: function (k) {
	            return k;
	        },
	
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quadraticIn: function (k) {
	            return k * k;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quadraticOut: function (k) {
	            return k * (2 - k);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quadraticInOut: function (k) {
	            if ((k *= 2) < 1) {
	                return 0.5 * k * k;
	            }
	            return -0.5 * (--k * (k - 2) - 1);
	        },
	
	        // 三次方的缓动（t^3）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        cubicIn: function (k) {
	            return k * k * k;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        cubicOut: function (k) {
	            return --k * k * k + 1;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        cubicInOut: function (k) {
	            if ((k *= 2) < 1) {
	                return 0.5 * k * k * k;
	            }
	            return 0.5 * ((k -= 2) * k * k + 2);
	        },
	
	        // 四次方的缓动（t^4）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quarticIn: function (k) {
	            return k * k * k * k;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quarticOut: function (k) {
	            return 1 - (--k * k * k * k);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quarticInOut: function (k) {
	            if ((k *= 2) < 1) {
	                return 0.5 * k * k * k * k;
	            }
	            return -0.5 * ((k -= 2) * k * k * k - 2);
	        },
	
	        // 五次方的缓动（t^5）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quinticIn: function (k) {
	            return k * k * k * k * k;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quinticOut: function (k) {
	            return --k * k * k * k * k + 1;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quinticInOut: function (k) {
	            if ((k *= 2) < 1) {
	                return 0.5 * k * k * k * k * k;
	            }
	            return 0.5 * ((k -= 2) * k * k * k * k + 2);
	        },
	
	        // 正弦曲线的缓动（sin(t)）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        sinusoidalIn: function (k) {
	            return 1 - Math.cos(k * Math.PI / 2);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        sinusoidalOut: function (k) {
	            return Math.sin(k * Math.PI / 2);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        sinusoidalInOut: function (k) {
	            return 0.5 * (1 - Math.cos(Math.PI * k));
	        },
	
	        // 指数曲线的缓动（2^t）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        exponentialIn: function (k) {
	            return k === 0 ? 0 : Math.pow(1024, k - 1);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        exponentialOut: function (k) {
	            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        exponentialInOut: function (k) {
	            if (k === 0) {
	                return 0;
	            }
	            if (k === 1) {
	                return 1;
	            }
	            if ((k *= 2) < 1) {
	                return 0.5 * Math.pow(1024, k - 1);
	            }
	            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
	        },
	
	        // 圆形曲线的缓动（sqrt(1-t^2)）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        circularIn: function (k) {
	            return 1 - Math.sqrt(1 - k * k);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        circularOut: function (k) {
	            return Math.sqrt(1 - (--k * k));
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        circularInOut: function (k) {
	            if ((k *= 2) < 1) {
	                return -0.5 * (Math.sqrt(1 - k * k) - 1);
	            }
	            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
	        },
	
	        // 创建类似于弹簧在停止前来回振荡的动画
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        elasticIn: function (k) {
	            var s;
	            var a = 0.1;
	            var p = 0.4;
	            if (k === 0) {
	                return 0;
	            }
	            if (k === 1) {
	                return 1;
	            }
	            if (!a || a < 1) {
	                a = 1; s = p / 4;
	            }
	            else {
	                s = p * Math.asin(1 / a) / (2 * Math.PI);
	            }
	            return -(a * Math.pow(2, 10 * (k -= 1)) *
	                        Math.sin((k - s) * (2 * Math.PI) / p));
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        elasticOut: function (k) {
	            var s;
	            var a = 0.1;
	            var p = 0.4;
	            if (k === 0) {
	                return 0;
	            }
	            if (k === 1) {
	                return 1;
	            }
	            if (!a || a < 1) {
	                a = 1; s = p / 4;
	            }
	            else {
	                s = p * Math.asin(1 / a) / (2 * Math.PI);
	            }
	            return (a * Math.pow(2, -10 * k) *
	                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        elasticInOut: function (k) {
	            var s;
	            var a = 0.1;
	            var p = 0.4;
	            if (k === 0) {
	                return 0;
	            }
	            if (k === 1) {
	                return 1;
	            }
	            if (!a || a < 1) {
	                a = 1; s = p / 4;
	            }
	            else {
	                s = p * Math.asin(1 / a) / (2 * Math.PI);
	            }
	            if ((k *= 2) < 1) {
	                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))
	                    * Math.sin((k - s) * (2 * Math.PI) / p));
	            }
	            return a * Math.pow(2, -10 * (k -= 1))
	                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
	
	        },
	
	        // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        backIn: function (k) {
	            var s = 1.70158;
	            return k * k * ((s + 1) * k - s);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        backOut: function (k) {
	            var s = 1.70158;
	            return --k * k * ((s + 1) * k + s) + 1;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        backInOut: function (k) {
	            var s = 1.70158 * 1.525;
	            if ((k *= 2) < 1) {
	                return 0.5 * (k * k * ((s + 1) * k - s));
	            }
	            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
	        },
	
	        // 创建弹跳效果
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        bounceIn: function (k) {
	            return 1 - easing.bounceOut(1 - k);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        bounceOut: function (k) {
	            if (k < (1 / 2.75)) {
	                return 7.5625 * k * k;
	            }
	            else if (k < (2 / 2.75)) {
	                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
	            }
	            else if (k < (2.5 / 2.75)) {
	                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
	            }
	            else {
	                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
	            }
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        bounceInOut: function (k) {
	            if (k < 0.5) {
	                return easing.bounceIn(k * 2) * 0.5;
	            }
	            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;
	        }
	    };
	
	    return easing;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * @module zrender/tool/color
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
	
	    var kCSSColorTable = {
	        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],
	        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],
	        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],
	        'beige': [245,245,220,1], 'bisque': [255,228,196,1],
	        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],
	        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],
	        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],
	        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],
	        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],
	        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],
	        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],
	        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],
	        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],
	        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],
	        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],
	        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],
	        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],
	        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],
	        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],
	        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],
	        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],
	        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],
	        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],
	        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],
	        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],
	        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],
	        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],
	        'gray': [128,128,128,1], 'green': [0,128,0,1],
	        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],
	        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],
	        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],
	        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],
	        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],
	        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],
	        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],
	        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],
	        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],
	        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],
	        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],
	        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],
	        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],
	        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],
	        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],
	        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],
	        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],
	        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],
	        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],
	        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],
	        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],
	        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],
	        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],
	        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],
	        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],
	        'orange': [255,165,0,1], 'orangered': [255,69,0,1],
	        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],
	        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],
	        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],
	        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],
	        'pink': [255,192,203,1], 'plum': [221,160,221,1],
	        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],
	        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],
	        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],
	        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],
	        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],
	        'sienna': [160,82,45,1], 'silver': [192,192,192,1],
	        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],
	        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],
	        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],
	        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],
	        'teal': [0,128,128,1], 'thistle': [216,191,216,1],
	        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],
	        'violet': [238,130,238,1], 'wheat': [245,222,179,1],
	        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],
	        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]
	    };
	
	    function clampCssByte(i) {  // Clamp to integer 0 .. 255.
	        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
	        return i < 0 ? 0 : i > 255 ? 255 : i;
	    }
	
	    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.
	        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
	        return i < 0 ? 0 : i > 360 ? 360 : i;
	    }
	
	    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.
	        return f < 0 ? 0 : f > 1 ? 1 : f;
	    }
	
	    function parseCssInt(str) {  // int or percentage.
	        if (str.length && str.charAt(str.length - 1) === '%') {
	            return clampCssByte(parseFloat(str) / 100 * 255);
	        }
	        return clampCssByte(parseInt(str, 10));
	    }
	
	    function parseCssFloat(str) {  // float or percentage.
	        if (str.length && str.charAt(str.length - 1) === '%') {
	            return clampCssFloat(parseFloat(str) / 100);
	        }
	        return clampCssFloat(parseFloat(str));
	    }
	
	    function cssHueToRgb(m1, m2, h) {
	        if (h < 0) {
	            h += 1;
	        }
	        else if (h > 1) {
	            h -= 1;
	        }
	
	        if (h * 6 < 1) {
	            return m1 + (m2 - m1) * h * 6;
	        }
	        if (h * 2 < 1) {
	            return m2;
	        }
	        if (h * 3 < 2) {
	            return m1 + (m2 - m1) * (2/3 - h) * 6;
	        }
	        return m1;
	    }
	
	    function lerp(a, b, p) {
	        return a + (b - a) * p;
	    }
	
	    /**
	     * @param {string} colorStr
	     * @return {Array.<number>}
	     * @memberOf module:zrender/util/color
	     */
	    function parse(colorStr) {
	        if (!colorStr) {
	            return;
	        }
	        // colorStr may be not string
	        colorStr = colorStr + '';
	        // Remove all whitespace, not compliant, but should just be more accepting.
	        var str = colorStr.replace(/ /g, '').toLowerCase();
	
	        // Color keywords (and transparent) lookup.
	        if (str in kCSSColorTable) {
	            return kCSSColorTable[str].slice();  // dup.
	        }
	
	        // #abc and #abc123 syntax.
	        if (str.charAt(0) === '#') {
	            if (str.length === 4) {
	                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
	                if (!(iv >= 0 && iv <= 0xfff)) {
	                    return;  // Covers NaN.
	                }
	                return [
	                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
	                    (iv & 0xf0) | ((iv & 0xf0) >> 4),
	                    (iv & 0xf) | ((iv & 0xf) << 4),
	                    1
	                ];
	            }
	            else if (str.length === 7) {
	                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
	                if (!(iv >= 0 && iv <= 0xffffff)) {
	                    return;  // Covers NaN.
	                }
	                return [
	                    (iv & 0xff0000) >> 16,
	                    (iv & 0xff00) >> 8,
	                    iv & 0xff,
	                    1
	                ];
	            }
	
	            return;
	        }
	        var op = str.indexOf('('), ep = str.indexOf(')');
	        if (op !== -1 && ep + 1 === str.length) {
	            var fname = str.substr(0, op);
	            var params = str.substr(op + 1, ep - (op + 1)).split(',');
	            var alpha = 1;  // To allow case fallthrough.
	            switch (fname) {
	                case 'rgba':
	                    if (params.length !== 4) {
	                        return;
	                    }
	                    alpha = parseCssFloat(params.pop()); // jshint ignore:line
	                // Fall through.
	                case 'rgb':
	                    if (params.length !== 3) {
	                        return;
	                    }
	                    return [
	                        parseCssInt(params[0]),
	                        parseCssInt(params[1]),
	                        parseCssInt(params[2]),
	                        alpha
	                    ];
	                case 'hsla':
	                    if (params.length !== 4) {
	                        return;
	                    }
	                    params[3] = parseCssFloat(params[3]);
	                    return hsla2rgba(params);
	                case 'hsl':
	                    if (params.length !== 3) {
	                        return;
	                    }
	                    return hsla2rgba(params);
	                default:
	                    return;
	            }
	        }
	
	        return;
	    }
	
	    /**
	     * @param {Array.<number>} hsla
	     * @return {Array.<number>} rgba
	     */
	    function hsla2rgba(hsla) {
	        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1
	        // NOTE(deanm): According to the CSS spec s/l should only be
	        // percentages, but we don't bother and let float or percentage.
	        var s = parseCssFloat(hsla[1]);
	        var l = parseCssFloat(hsla[2]);
	        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
	        var m1 = l * 2 - m2;
	
	        var rgba = [
	            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),
	            clampCssByte(cssHueToRgb(m1, m2, h) * 255),
	            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255)
	        ];
	
	        if (hsla.length === 4) {
	            rgba[3] = hsla[3];
	        }
	
	        return rgba;
	    }
	
	    /**
	     * @param {Array.<number>} rgba
	     * @return {Array.<number>} hsla
	     */
	    function rgba2hsla(rgba) {
	        if (!rgba) {
	            return;
	        }
	
	        // RGB from 0 to 255
	        var R = rgba[0] / 255;
	        var G = rgba[1] / 255;
	        var B = rgba[2] / 255;
	
	        var vMin = Math.min(R, G, B); // Min. value of RGB
	        var vMax = Math.max(R, G, B); // Max. value of RGB
	        var delta = vMax - vMin; // Delta RGB value
	
	        var L = (vMax + vMin) / 2;
	        var H;
	        var S;
	        // HSL results from 0 to 1
	        if (delta === 0) {
	            H = 0;
	            S = 0;
	        }
	        else {
	            if (L < 0.5) {
	                S = delta / (vMax + vMin);
	            }
	            else {
	                S = delta / (2 - vMax - vMin);
	            }
	
	            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;
	            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;
	            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;
	
	            if (R === vMax) {
	                H = deltaB - deltaG;
	            }
	            else if (G === vMax) {
	                H = (1 / 3) + deltaR - deltaB;
	            }
	            else if (B === vMax) {
	                H = (2 / 3) + deltaG - deltaR;
	            }
	
	            if (H < 0) {
	                H += 1;
	            }
	
	            if (H > 1) {
	                H -= 1;
	            }
	        }
	
	        var hsla = [H * 360, S, L];
	
	        if (rgba[3] != null) {
	            hsla.push(rgba[3]);
	        }
	
	        return hsla;
	    }
	
	    /**
	     * @param {string} color
	     * @param {number} level
	     * @return {string}
	     * @memberOf module:zrender/util/color
	     */
	    function lift(color, level) {
	        var colorArr = parse(color);
	        if (colorArr) {
	            for (var i = 0; i < 3; i++) {
	                if (level < 0) {
	                    colorArr[i] = colorArr[i] * (1 - level) | 0;
	                }
	                else {
	                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;
	                }
	            }
	            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');
	        }
	    }
	
	    /**
	     * @param {string} color
	     * @return {string}
	     * @memberOf module:zrender/util/color
	     */
	    function toHex(color, level) {
	        var colorArr = parse(color);
	        if (colorArr) {
	            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);
	        }
	    }
	
	    /**
	     * Map value to color. Faster than mapToColor methods because color is represented by rgba array
	     * @param {number} normalizedValue A float between 0 and 1.
	     * @param {Array.<Array.<number>>} colors List of rgba color array
	     * @param {Array.<number>} [out] Mapped gba color array
	     * @return {Array.<number>}
	     */
	    function fastMapToColor(normalizedValue, colors, out) {
	        if (!(colors && colors.length)
	            || !(normalizedValue >= 0 && normalizedValue <= 1)
	        ) {
	            return;
	        }
	        out = out || [0, 0, 0, 0];
	        var value = normalizedValue * (colors.length - 1);
	        var leftIndex = Math.floor(value);
	        var rightIndex = Math.ceil(value);
	        var leftColor = colors[leftIndex];
	        var rightColor = colors[rightIndex];
	        var dv = value - leftIndex;
	        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));
	        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));
	        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));
	        out[3] = clampCssByte(lerp(leftColor[3], rightColor[3], dv));
	        return out;
	    }
	    /**
	     * @param {number} normalizedValue A float between 0 and 1.
	     * @param {Array.<string>} colors Color list.
	     * @param {boolean=} fullOutput Default false.
	     * @return {(string|Object)} Result color. If fullOutput,
	     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},
	     * @memberOf module:zrender/util/color
	     */
	    function mapToColor(normalizedValue, colors, fullOutput) {
	        if (!(colors && colors.length)
	            || !(normalizedValue >= 0 && normalizedValue <= 1)
	        ) {
	            return;
	        }
	
	        var value = normalizedValue * (colors.length - 1);
	        var leftIndex = Math.floor(value);
	        var rightIndex = Math.ceil(value);
	        var leftColor = parse(colors[leftIndex]);
	        var rightColor = parse(colors[rightIndex]);
	        var dv = value - leftIndex;
	
	        var color = stringify(
	            [
	                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),
	                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),
	                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),
	                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))
	            ],
	            'rgba'
	        );
	
	        return fullOutput
	            ? {
	                color: color,
	                leftIndex: leftIndex,
	                rightIndex: rightIndex,
	                value: value
	            }
	            : color;
	    }
	
	    /**
	     * @param {string} color
	     * @param {number=} h 0 ~ 360, ignore when null.
	     * @param {number=} s 0 ~ 1, ignore when null.
	     * @param {number=} l 0 ~ 1, ignore when null.
	     * @return {string} Color string in rgba format.
	     * @memberOf module:zrender/util/color
	     */
	    function modifyHSL(color, h, s, l) {
	        color = parse(color);
	
	        if (color) {
	            color = rgba2hsla(color);
	            h != null && (color[0] = clampCssAngle(h));
	            s != null && (color[1] = parseCssFloat(s));
	            l != null && (color[2] = parseCssFloat(l));
	
	            return stringify(hsla2rgba(color), 'rgba');
	        }
	    }
	
	    /**
	     * @param {string} color
	     * @param {number=} alpha 0 ~ 1
	     * @return {string} Color string in rgba format.
	     * @memberOf module:zrender/util/color
	     */
	    function modifyAlpha(color, alpha) {
	        color = parse(color);
	
	        if (color && alpha != null) {
	            color[3] = clampCssFloat(alpha);
	            return stringify(color, 'rgba');
	        }
	    }
	
	    /**
	     * @param {Array.<string>} colors Color list.
	     * @param {string} type 'rgba', 'hsva', ...
	     * @return {string} Result color.
	     */
	    function stringify(arrColor, type) {
	        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];
	        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {
	            colorStr += ',' + arrColor[3];
	        }
	        return type + '(' + colorStr + ')';
	    }
	
	    return {
	        parse: parse,
	        lift: lift,
	        toHex: toHex,
	        fastMapToColor: fastMapToColor,
	        mapToColor: mapToColor,
	        modifyHSL: modifyHSL,
	        modifyAlpha: modifyAlpha,
	        stringify: stringify
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	        var config = __webpack_require__(45);
	
	        /**
	         * @exports zrender/tool/log
	         * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	         */
	        return function() {
	            if (config.debugMode === 0) {
	                return;
	            }
	            else if (config.debugMode == 1) {
	                for (var k in arguments) {
	                    throw new Error(arguments[k]);
	                }
	            }
	            else if (config.debugMode > 1) {
	                for (var k in arguments) {
	                    console.log(arguments[k]);
	                }
	            }
	        };
	
	        /* for debug
	        return function(mes) {
	            document.getElementById('wrong-message').innerHTML =
	                mes + ' ' + (new Date() - 0)
	                + '<br/>' 
	                + document.getElementById('wrong-message').innerHTML;
	        };
	        */
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var dpr = 1;
	    // If in browser environment
	    if (typeof window !== 'undefined') {
	        dpr = Math.max(window.devicePixelRatio || 1, 1);
	    }
	    /**
	     * config默认配置项
	     * @exports zrender/config
	     * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	     */
	    var config = {
	        /**
	         * debug日志选项：catchBrushException为true下有效
	         * 0 : 不生成debug数据，发布用
	         * 1 : 异常抛出，调试用
	         * 2 : 控制台输出，调试用
	         */
	        debugMode: 0,
	
	        // retina 屏幕优化
	        devicePixelRatio: dpr
	    };
	    return config;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var Group = __webpack_require__(34);
	    var componentUtil = __webpack_require__(24);
	    var clazzUtil = __webpack_require__(17);
	
	    function Chart() {
	
	        /**
	         * @type {module:zrender/container/Group}
	         * @readOnly
	         */
	        this.group = new Group();
	
	        /**
	         * @type {string}
	         * @readOnly
	         */
	        this.uid = componentUtil.getUID('viewChart');
	    }
	
	    Chart.prototype = {
	
	        type: 'chart',
	
	        /**
	         * Init the chart
	         * @param  {module:echarts/model/Global} ecModel
	         * @param  {module:echarts/ExtensionAPI} api
	         */
	        init: function (ecModel, api) {},
	
	        /**
	         * Render the chart
	         * @param  {module:echarts/model/Series} seriesModel
	         * @param  {module:echarts/model/Global} ecModel
	         * @param  {module:echarts/ExtensionAPI} api
	         * @param  {Object} payload
	         */
	        render: function (seriesModel, ecModel, api, payload) {},
	
	        /**
	         * Highlight series or specified data item
	         * @param  {module:echarts/model/Series} seriesModel
	         * @param  {module:echarts/model/Global} ecModel
	         * @param  {module:echarts/ExtensionAPI} api
	         * @param  {Object} payload
	         */
	        highlight: function (seriesModel, ecModel, api, payload) {
	            toggleHighlight(seriesModel.getData(), payload, 'emphasis');
	        },
	
	        /**
	         * Downplay series or specified data item
	         * @param  {module:echarts/model/Series} seriesModel
	         * @param  {module:echarts/model/Global} ecModel
	         * @param  {module:echarts/ExtensionAPI} api
	         * @param  {Object} payload
	         */
	        downplay: function (seriesModel, ecModel, api, payload) {
	            toggleHighlight(seriesModel.getData(), payload, 'normal');
	        },
	
	        /**
	         * Remove self
	         * @param  {module:echarts/model/Global} ecModel
	         * @param  {module:echarts/ExtensionAPI} api
	         */
	        remove: function (ecModel, api) {
	            this.group.removeAll();
	        },
	
	        /**
	         * Dispose self
	         * @param  {module:echarts/model/Global} ecModel
	         * @param  {module:echarts/ExtensionAPI} api
	         */
	        dispose: function () {}
	    };
	
	    var chartProto = Chart.prototype;
	    chartProto.updateView
	        = chartProto.updateLayout
	        = chartProto.updateVisual
	        = function (seriesModel, ecModel, api, payload) {
	            this.render(seriesModel, ecModel, api, payload);
	        };
	
	    /**
	     * Set state of single element
	     * @param  {module:zrender/Element} el
	     * @param  {string} state
	     */
	    function elSetState(el, state) {
	        if (el) {
	            el.trigger(state);
	            if (el.type === 'group') {
	                for (var i = 0; i < el.childCount(); i++) {
	                    elSetState(el.childAt(i), state);
	                }
	            }
	        }
	    }
	    /**
	     * @param  {module:echarts/data/List} data
	     * @param  {Object} payload
	     * @param  {string} state 'normal'|'emphasis'
	     * @inner
	     */
	    function toggleHighlight(data, payload, state) {
	        var dataIndex = payload && payload.dataIndex;
	        var name = payload && payload.name;
	
	        if (dataIndex != null) {
	            var dataIndices = dataIndex instanceof Array ? dataIndex : [dataIndex];
	            for (var i = 0, len = dataIndices.length; i < len; i++) {
	                elSetState(data.getItemGraphicEl(dataIndices[i]), state);
	            }
	        }
	        else if (name) {
	            var names = name instanceof Array ? name : [name];
	            for (var i = 0, len = names.length; i < len; i++) {
	                var dataIndex = data.indexOfName(names[i]);
	                elSetState(data.getItemGraphicEl(dataIndex), state);
	            }
	        }
	        else {
	            data.eachItemGraphicEl(function (el) {
	                elSetState(el, state);
	            });
	        }
	    }
	
	    // Enable Chart.extend.
	    clazzUtil.enableClassExtend(Chart);
	
	    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.
	    clazzUtil.enableClassManagement(Chart, {registerWhenExtend: true});
	
	    return Chart;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
	
	    'use strict';
	
	    var zrUtil = __webpack_require__(8);
	
	    var pathTool = __webpack_require__(48);
	    var round = Math.round;
	    var Path = __webpack_require__(49);
	    var colorTool = __webpack_require__(43);
	    var matrix = __webpack_require__(15);
	    var vector = __webpack_require__(14);
	    var Gradient = __webpack_require__(65);
	
	    var graphic = {};
	
	    graphic.Group = __webpack_require__(34);
	
	    graphic.Image = __webpack_require__(66);
	
	    graphic.Text = __webpack_require__(68);
	
	    graphic.Circle = __webpack_require__(69);
	
	    graphic.Sector = __webpack_require__(70);
	
	    graphic.Ring = __webpack_require__(71);
	
	    graphic.Polygon = __webpack_require__(72);
	
	    graphic.Polyline = __webpack_require__(76);
	
	    graphic.Rect = __webpack_require__(77);
	
	    graphic.Line = __webpack_require__(79);
	
	    graphic.BezierCurve = __webpack_require__(80);
	
	    graphic.Arc = __webpack_require__(81);
	
	    graphic.CompoundPath = __webpack_require__(82);
	
	    graphic.LinearGradient = __webpack_require__(83);
	
	    graphic.RadialGradient = __webpack_require__(84);
	
	    graphic.BoundingRect = __webpack_require__(13);
	
	    /**
	     * Extend shape with parameters
	     */
	    graphic.extendShape = function (opts) {
	        return Path.extend(opts);
	    };
	
	    /**
	     * Extend path
	     */
	    graphic.extendPath = function (pathData, opts) {
	        return pathTool.extendFromString(pathData, opts);
	    };
	
	    /**
	     * Create a path element from path data string
	     * @param {string} pathData
	     * @param {Object} opts
	     * @param {module:zrender/core/BoundingRect} rect
	     * @param {string} [layout=cover] 'center' or 'cover'
	     */
	    graphic.makePath = function (pathData, opts, rect, layout) {
	        var path = pathTool.createFromString(pathData, opts);
	        var boundingRect = path.getBoundingRect();
	        if (rect) {
	            var aspect = boundingRect.width / boundingRect.height;
	
	            if (layout === 'center') {
	                // Set rect to center, keep width / height ratio.
	                var width = rect.height * aspect;
	                var height;
	                if (width <= rect.width) {
	                    height = rect.height;
	                }
	                else {
	                    width = rect.width;
	                    height = width / aspect;
	                }
	                var cx = rect.x + rect.width / 2;
	                var cy = rect.y + rect.height / 2;
	
	                rect.x = cx - width / 2;
	                rect.y = cy - height / 2;
	                rect.width = width;
	                rect.height = height;
	            }
	
	            this.resizePath(path, rect);
	        }
	        return path;
	    };
	
	    graphic.mergePath = pathTool.mergePath,
	
	    /**
	     * Resize a path to fit the rect
	     * @param {module:zrender/graphic/Path} path
	     * @param {Object} rect
	     */
	    graphic.resizePath = function (path, rect) {
	        if (!path.applyTransform) {
	            return;
	        }
	
	        var pathRect = path.getBoundingRect();
	
	        var m = pathRect.calculateTransform(rect);
	
	        path.applyTransform(m);
	    };
	
	    /**
	     * Sub pixel optimize line for canvas
	     *
	     * @param {Object} param
	     * @param {Object} [param.shape]
	     * @param {number} [param.shape.x1]
	     * @param {number} [param.shape.y1]
	     * @param {number} [param.shape.x2]
	     * @param {number} [param.shape.y2]
	     * @param {Object} [param.style]
	     * @param {number} [param.style.lineWidth]
	     * @return {Object} Modified param
	     */
	    graphic.subPixelOptimizeLine = function (param) {
	        var subPixelOptimize = graphic.subPixelOptimize;
	        var shape = param.shape;
	        var lineWidth = param.style.lineWidth;
	
	        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {
	            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);
	        }
	        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {
	            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);
	        }
	        return param;
	    };
	
	    /**
	     * Sub pixel optimize rect for canvas
	     *
	     * @param {Object} param
	     * @param {Object} [param.shape]
	     * @param {number} [param.shape.x]
	     * @param {number} [param.shape.y]
	     * @param {number} [param.shape.width]
	     * @param {number} [param.shape.height]
	     * @param {Object} [param.style]
	     * @param {number} [param.style.lineWidth]
	     * @return {Object} Modified param
	     */
	    graphic.subPixelOptimizeRect = function (param) {
	        var subPixelOptimize = graphic.subPixelOptimize;
	        var shape = param.shape;
	        var lineWidth = param.style.lineWidth;
	        var originX = shape.x;
	        var originY = shape.y;
	        var originWidth = shape.width;
	        var originHeight = shape.height;
	        shape.x = subPixelOptimize(shape.x, lineWidth, true);
	        shape.y = subPixelOptimize(shape.y, lineWidth, true);
	        shape.width = Math.max(
	            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,
	            originWidth === 0 ? 0 : 1
	        );
	        shape.height = Math.max(
	            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,
	            originHeight === 0 ? 0 : 1
	        );
	        return param;
	    };
	
	    /**
	     * Sub pixel optimize for canvas
	     *
	     * @param {number} position Coordinate, such as x, y
	     * @param {number} lineWidth Should be nonnegative integer.
	     * @param {boolean=} positiveOrNegative Default false (negative).
	     * @return {number} Optimized position.
	     */
	    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {
	        // Assure that (position + lineWidth / 2) is near integer edge,
	        // otherwise line will be fuzzy in canvas.
	        var doubledPosition = round(position * 2);
	        return (doubledPosition + round(lineWidth)) % 2 === 0
	            ? doubledPosition / 2
	            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
	    };
	
	    function hasFillOrStroke(fillOrStroke) {
	        return fillOrStroke != null && fillOrStroke != 'none';
	    }
	
	    function liftColor(color) {
	        return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;
	    }
	
	    /**
	     * @private
	     */
	    function cacheElementStl(el) {
	        if (el.__hoverStlDirty) {
	            var stroke = el.style.stroke;
	            var fill = el.style.fill;
	
	            // Create hoverStyle on mouseover
	            var hoverStyle = el.__hoverStl;
	            hoverStyle.fill = hoverStyle.fill
	                || (hasFillOrStroke(fill) ? liftColor(fill) : null);
	            hoverStyle.stroke = hoverStyle.stroke
	                || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);
	
	            var normalStyle = {};
	            for (var name in hoverStyle) {
	                if (hoverStyle.hasOwnProperty(name)) {
	                    normalStyle[name] = el.style[name];
	                }
	            }
	
	            el.__normalStl = normalStyle;
	
	            el.__hoverStlDirty = false;
	        }
	    }
	
	    /**
	     * @private
	     */
	    function doSingleEnterHover(el) {
	        if (el.__isHover) {
	            return;
	        }
	
	        cacheElementStl(el);
	
	        if (el.useHoverLayer) {
	            el.__zr && el.__zr.addHover(el, el.__hoverStl);
	        }
	        else {
	            el.setStyle(el.__hoverStl);
	            el.z2 += 1;
	        }
	
	        el.__isHover = true;
	    }
	
	    /**
	     * @inner
	     */
	    function doSingleLeaveHover(el) {
	        if (!el.__isHover) {
	            return;
	        }
	
	        var normalStl = el.__normalStl;
	        if (el.useHoverLayer) {
	            el.__zr && el.__zr.removeHover(el);
	        }
	        else {
	            normalStl && el.setStyle(normalStl);
	            el.z2 -= 1;
	        }
	
	        el.__isHover = false;
	    }
	
	    /**
	     * @inner
	     */
	    function doEnterHover(el) {
	        el.type === 'group'
	            ? el.traverse(function (child) {
	                if (child.type !== 'group') {
	                    doSingleEnterHover(child);
	                }
	            })
	            : doSingleEnterHover(el);
	    }
	
	    function doLeaveHover(el) {
	        el.type === 'group'
	            ? el.traverse(function (child) {
	                if (child.type !== 'group') {
	                    doSingleLeaveHover(child);
	                }
	            })
	            : doSingleLeaveHover(el);
	    }
	
	    /**
	     * @inner
	     */
	    function setElementHoverStl(el, hoverStl) {
	        // If element has sepcified hoverStyle, then use it instead of given hoverStyle
	        // Often used when item group has a label element and it's hoverStyle is different
	        el.__hoverStl = el.hoverStyle || hoverStl || {};
	        el.__hoverStlDirty = true;
	
	        if (el.__isHover) {
	            cacheElementStl(el);
	        }
	    }
	
	    /**
	     * @inner
	     */
	    function onElementMouseOver() {
	        // Only if element is not in emphasis status
	        !this.__isEmphasis && doEnterHover(this);
	    }
	
	    /**
	     * @inner
	     */
	    function onElementMouseOut() {
	        // Only if element is not in emphasis status
	        !this.__isEmphasis && doLeaveHover(this);
	    }
	
	    /**
	     * @inner
	     */
	    function enterEmphasis() {
	        this.__isEmphasis = true;
	        doEnterHover(this);
	    }
	
	    /**
	     * @inner
	     */
	    function leaveEmphasis() {
	        this.__isEmphasis = false;
	        doLeaveHover(this);
	    }
	
	    /**
	     * Set hover style of element
	     * @param {module:zrender/Element} el
	     * @param {Object} [hoverStyle]
	     */
	    graphic.setHoverStyle = function (el, hoverStyle) {
	        el.type === 'group'
	            ? el.traverse(function (child) {
	                if (child.type !== 'group') {
	                    setElementHoverStl(child, hoverStyle);
	                }
	            })
	            : setElementHoverStl(el, hoverStyle);
	        // Remove previous bound handlers
	        el.on('mouseover', onElementMouseOver)
	          .on('mouseout', onElementMouseOut);
	
	        // Emphasis, normal can be triggered manually
	        el.on('emphasis', enterEmphasis)
	          .on('normal', leaveEmphasis);
	    };
	
	    /**
	     * Set text option in the style
	     * @param {Object} textStyle
	     * @param {module:echarts/model/Model} labelModel
	     * @param {string} color
	     */
	    graphic.setText = function (textStyle, labelModel, color) {
	        var labelPosition = labelModel.getShallow('position') || 'inside';
	        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;
	        var textStyleModel = labelModel.getModel('textStyle');
	        zrUtil.extend(textStyle, {
	            textDistance: labelModel.getShallow('distance') || 5,
	            textFont: textStyleModel.getFont(),
	            textPosition: labelPosition,
	            textFill: textStyleModel.getTextColor() || labelColor
	        });
	    };
	
	    function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {
	        if (typeof dataIndex === 'function') {
	            cb = dataIndex;
	            dataIndex = null;
	        }
	        var animationEnabled = animatableModel
	            && (
	                animatableModel.ifEnableAnimation
	                ? animatableModel.ifEnableAnimation()
	                // Directly use animation property
	                : animatableModel.getShallow('animation')
	            );
	
	        if (animationEnabled) {
	            var postfix = isUpdate ? 'Update' : '';
	            var duration = animatableModel
	                && animatableModel.getShallow('animationDuration' + postfix);
	            var animationEasing = animatableModel
	                && animatableModel.getShallow('animationEasing' + postfix);
	            var animationDelay = animatableModel
	                && animatableModel.getShallow('animationDelay' + postfix);
	            if (typeof animationDelay === 'function') {
	                animationDelay = animationDelay(dataIndex);
	            }
	            duration > 0
	                ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb)
	                : (el.attr(props), cb && cb());
	        }
	        else {
	            el.attr(props);
	            cb && cb();
	        }
	    }
	    /**
	     * Update graphic element properties with or without animation according to the configuration in series
	     * @param {module:zrender/Element} el
	     * @param {Object} props
	     * @param {module:echarts/model/Model} [animatableModel]
	     * @param {number} [dataIndex]
	     * @param {Function} [cb]
	     * @example
	     *     graphic.updateProps(el, {
	     *         position: [100, 100]
	     *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });
	     *     // Or
	     *     graphic.updateProps(el, {
	     *         position: [100, 100]
	     *     }, seriesModel, function () { console.log('Animation done!'); });
	     */
	    graphic.updateProps = function (el, props, animatableModel, dataIndex, cb) {
	        animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);
	    };
	
	    /**
	     * Init graphic element properties with or without animation according to the configuration in series
	     * @param {module:zrender/Element} el
	     * @param {Object} props
	     * @param {module:echarts/model/Model} [animatableModel]
	     * @param {number} [dataIndex]
	     * @param {Function} cb
	     */
	    graphic.initProps = function (el, props, animatableModel, dataIndex, cb) {
	        animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);
	    };
	
	    /**
	     * Get transform matrix of target (param target),
	     * in coordinate of its ancestor (param ancestor)
	     *
	     * @param {module:zrender/mixin/Transformable} target
	     * @param {module:zrender/mixin/Transformable} [ancestor]
	     */
	    graphic.getTransform = function (target, ancestor) {
	        var mat = matrix.identity([]);
	
	        while (target && target !== ancestor) {
	            matrix.mul(mat, target.getLocalTransform(), mat);
	            target = target.parent;
	        }
	
	        return mat;
	    };
	
	    /**
	     * Apply transform to an vertex.
	     * @param {Array.<number>} vertex [x, y]
	     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]
	     * @param {boolean=} invert Whether use invert matrix.
	     * @return {Array.<number>} [x, y]
	     */
	    graphic.applyTransform = function (vertex, transform, invert) {
	        if (invert) {
	            transform = matrix.invert([], transform);
	        }
	        return vector.applyTransform([], vertex, transform);
	    };
	
	    /**
	     * @param {string} direction 'left' 'right' 'top' 'bottom'
	     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]
	     * @param {boolean=} invert Whether use invert matrix.
	     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'
	     */
	    graphic.transformDirection = function (direction, transform, invert) {
	
	        // Pick a base, ensure that transform result will not be (0, 0).
	        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)
	            ? 1 : Math.abs(2 * transform[4] / transform[0]);
	        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)
	            ? 1 : Math.abs(2 * transform[4] / transform[2]);
	
	        var vertex = [
	            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,
	            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0
	        ];
	
	        vertex = graphic.applyTransform(vertex, transform, invert);
	
	        return Math.abs(vertex[0]) > Math.abs(vertex[1])
	            ? (vertex[0] > 0 ? 'right' : 'left')
	            : (vertex[1] > 0 ? 'bottom' : 'top');
	    };
	
	    /**
	     * Apply group transition animation from g1 to g2
	     */
	    graphic.groupTransition = function (g1, g2, animatableModel, cb) {
	        if (!g1 || !g2) {
	            return;
	        }
	
	        function getElMap(g) {
	            var elMap = {};
	            g.traverse(function (el) {
	                if (!el.isGroup && el.anid) {
	                    elMap[el.anid] = el;
	                }
	            });
	            return elMap;
	        }
	        function getAnimatableProps(el) {
	            var obj = {
	                position: vector.clone(el.position),
	                rotation: el.rotation
	            };
	            if (el.shape) {
	                obj.shape = zrUtil.extend({}, el.shape);
	            }
	            return obj;
	        }
	        var elMap1 = getElMap(g1);
	
	        g2.traverse(function (el) {
	            if (!el.isGroup && el.anid) {
	                var oldEl = elMap1[el.anid];
	                if (oldEl) {
	                    var newProp = getAnimatableProps(el);
	                    el.attr(getAnimatableProps(oldEl));
	                    graphic.updateProps(el, newProp, animatableModel, el.dataIndex);
	                }
	                // else {
	                //     if (el.previousProps) {
	                //         graphic.updateProps
	                //     }
	                // }
	            }
	        });
	    };
	
	    return graphic;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var Path = __webpack_require__(49);
	    var PathProxy = __webpack_require__(53);
	    var transformPath = __webpack_require__(64);
	    var matrix = __webpack_require__(15);
	
	    // command chars
	    var cc = [
	        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',
	        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'
	    ];
	
	    var mathSqrt = Math.sqrt;
	    var mathSin = Math.sin;
	    var mathCos = Math.cos;
	    var PI = Math.PI;
	
	    var vMag = function(v) {
	        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
	    };
	    var vRatio = function(u, v) {
	        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
	    };
	    var vAngle = function(u, v) {
	        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)
	                * Math.acos(vRatio(u, v));
	    };
	
	    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
	        var psi = psiDeg * (PI / 180.0);
	        var xp = mathCos(psi) * (x1 - x2) / 2.0
	                 + mathSin(psi) * (y1 - y2) / 2.0;
	        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0
	                 + mathCos(psi) * (y1 - y2) / 2.0;
	
	        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);
	
	        if (lambda > 1) {
	            rx *= mathSqrt(lambda);
	            ry *= mathSqrt(lambda);
	        }
	
	        var f = (fa === fs ? -1 : 1)
	            * mathSqrt((((rx * rx) * (ry * ry))
	                    - ((rx * rx) * (yp * yp))
	                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)
	                    + (ry * ry) * (xp * xp))
	                ) || 0;
	
	        var cxp = f * rx * yp / ry;
	        var cyp = f * -ry * xp / rx;
	
	        var cx = (x1 + x2) / 2.0
	                 + mathCos(psi) * cxp
	                 - mathSin(psi) * cyp;
	        var cy = (y1 + y2) / 2.0
	                + mathSin(psi) * cxp
	                + mathCos(psi) * cyp;
	
	        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);
	        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];
	        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];
	        var dTheta = vAngle(u, v);
	
	        if (vRatio(u, v) <= -1) {
	            dTheta = PI;
	        }
	        if (vRatio(u, v) >= 1) {
	            dTheta = 0;
	        }
	        if (fs === 0 && dTheta > 0) {
	            dTheta = dTheta - 2 * PI;
	        }
	        if (fs === 1 && dTheta < 0) {
	            dTheta = dTheta + 2 * PI;
	        }
	
	        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
	    }
	
	    function createPathProxyFromString(data) {
	        if (!data) {
	            return [];
	        }
	
	        // command string
	        var cs = data.replace(/-/g, ' -')
	            .replace(/  /g, ' ')
	            .replace(/ /g, ',')
	            .replace(/,,/g, ',');
	
	        var n;
	        // create pipes so that we can split the data
	        for (n = 0; n < cc.length; n++) {
	            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
	        }
	
	        // create array
	        var arr = cs.split('|');
	        // init context point
	        var cpx = 0;
	        var cpy = 0;
	
	        var path = new PathProxy();
	        var CMD = PathProxy.CMD;
	
	        var prevCmd;
	        for (n = 1; n < arr.length; n++) {
	            var str = arr[n];
	            var c = str.charAt(0);
	            var off = 0;
	            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');
	            var cmd;
	
	            if (p.length > 0 && p[0] === '') {
	                p.shift();
	            }
	
	            for (var i = 0; i < p.length; i++) {
	                p[i] = parseFloat(p[i]);
	            }
	            while (off < p.length && !isNaN(p[off])) {
	                if (isNaN(p[0])) {
	                    break;
	                }
	                var ctlPtx;
	                var ctlPty;
	
	                var rx;
	                var ry;
	                var psi;
	                var fa;
	                var fs;
	
	                var x1 = cpx;
	                var y1 = cpy;
	
	                // convert l, H, h, V, and v to L
	                switch (c) {
	                    case 'l':
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'L':
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'm':
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        cmd = CMD.M;
	                        path.addData(cmd, cpx, cpy);
	                        c = 'l';
	                        break;
	                    case 'M':
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        cmd = CMD.M;
	                        path.addData(cmd, cpx, cpy);
	                        c = 'L';
	                        break;
	                    case 'h':
	                        cpx += p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'H':
	                        cpx = p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'v':
	                        cpy += p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'V':
	                        cpy = p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'C':
	                        cmd = CMD.C;
	                        path.addData(
	                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]
	                        );
	                        cpx = p[off - 2];
	                        cpy = p[off - 1];
	                        break;
	                    case 'c':
	                        cmd = CMD.C;
	                        path.addData(
	                            cmd,
	                            p[off++] + cpx, p[off++] + cpy,
	                            p[off++] + cpx, p[off++] + cpy,
	                            p[off++] + cpx, p[off++] + cpy
	                        );
	                        cpx += p[off - 2];
	                        cpy += p[off - 1];
	                        break;
	                    case 'S':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        var len = path.len();
	                        var pathData = path.data;
	                        if (prevCmd === CMD.C) {
	                            ctlPtx += cpx - pathData[len - 4];
	                            ctlPty += cpy - pathData[len - 3];
	                        }
	                        cmd = CMD.C;
	                        x1 = p[off++];
	                        y1 = p[off++];
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
	                        break;
	                    case 's':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        var len = path.len();
	                        var pathData = path.data;
	                        if (prevCmd === CMD.C) {
	                            ctlPtx += cpx - pathData[len - 4];
	                            ctlPty += cpy - pathData[len - 3];
	                        }
	                        cmd = CMD.C;
	                        x1 = cpx + p[off++];
	                        y1 = cpy + p[off++];
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
	                        break;
	                    case 'Q':
	                        x1 = p[off++];
	                        y1 = p[off++];
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        cmd = CMD.Q;
	                        path.addData(cmd, x1, y1, cpx, cpy);
	                        break;
	                    case 'q':
	                        x1 = p[off++] + cpx;
	                        y1 = p[off++] + cpy;
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        cmd = CMD.Q;
	                        path.addData(cmd, x1, y1, cpx, cpy);
	                        break;
	                    case 'T':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        var len = path.len();
	                        var pathData = path.data;
	                        if (prevCmd === CMD.Q) {
	                            ctlPtx += cpx - pathData[len - 4];
	                            ctlPty += cpy - pathData[len - 3];
	                        }
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        cmd = CMD.Q;
	                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
	                        break;
	                    case 't':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        var len = path.len();
	                        var pathData = path.data;
	                        if (prevCmd === CMD.Q) {
	                            ctlPtx += cpx - pathData[len - 4];
	                            ctlPty += cpy - pathData[len - 3];
	                        }
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        cmd = CMD.Q;
	                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
	                        break;
	                    case 'A':
	                        rx = p[off++];
	                        ry = p[off++];
	                        psi = p[off++];
	                        fa = p[off++];
	                        fs = p[off++];
	
	                        x1 = cpx, y1 = cpy;
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        cmd = CMD.A;
	                        processArc(
	                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path
	                        );
	                        break;
	                    case 'a':
	                        rx = p[off++];
	                        ry = p[off++];
	                        psi = p[off++];
	                        fa = p[off++];
	                        fs = p[off++];
	
	                        x1 = cpx, y1 = cpy;
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        cmd = CMD.A;
	                        processArc(
	                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path
	                        );
	                        break;
	                }
	            }
	
	            if (c === 'z' || c === 'Z') {
	                cmd = CMD.Z;
	                path.addData(cmd);
	            }
	
	            prevCmd = cmd;
	        }
	
	        path.toStatic();
	
	        return path;
	    }
	
	    // TODO Optimize double memory cost problem
	    function createPathOptions(str, opts) {
	        var pathProxy = createPathProxyFromString(str);
	        var transform;
	        opts = opts || {};
	        opts.buildPath = function (path) {
	            path.setData(pathProxy.data);
	            transform && transformPath(path, transform);
	            // Svg and vml renderer don't have context
	            var ctx = path.getContext();
	            if (ctx) {
	                path.rebuildPath(ctx);
	            }
	        };
	
	        opts.applyTransform = function (m) {
	            if (!transform) {
	                transform = matrix.create();
	            }
	            matrix.mul(transform, m, transform);
	            this.dirty(true);
	        };
	
	        return opts;
	    }
	
	    return {
	        /**
	         * Create a Path object from path string data
	         * http://www.w3.org/TR/SVG/paths.html#PathData
	         * @param  {Object} opts Other options
	         */
	        createFromString: function (str, opts) {
	            return new Path(createPathOptions(str, opts));
	        },
	
	        /**
	         * Create a Path class from path string data
	         * @param  {string} str
	         * @param  {Object} opts Other options
	         */
	        extendFromString: function (str, opts) {
	            return Path.extend(createPathOptions(str, opts));
	        },
	
	        /**
	         * Merge multiple paths
	         */
	        // TODO Apply transform
	        // TODO stroke dash
	        // TODO Optimize double memory cost problem
	        mergePath: function (pathEls, opts) {
	            var pathList = [];
	            var len = pathEls.length;
	            for (var i = 0; i < len; i++) {
	                var pathEl = pathEls[i];
	                if (pathEl.__dirty) {
	                    pathEl.buildPath(pathEl.path, pathEl.shape, true);
	                }
	                pathList.push(pathEl.path);
	            }
	
	            var pathBundle = new Path(opts);
	            pathBundle.buildPath = function (path) {
	                path.appendPath(pathList);
	                // Svg and vml renderer don't have context
	                var ctx = path.getContext();
	                if (ctx) {
	                    path.rebuildPath(ctx);
	                }
	            };
	
	            return pathBundle;
	        }
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Path element
	 * @module zrender/graphic/Path
	 */
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var Displayable = __webpack_require__(50);
	    var zrUtil = __webpack_require__(8);
	    var PathProxy = __webpack_require__(53);
	    var pathContain = __webpack_require__(56);
	
	    var Pattern = __webpack_require__(63);
	    var getCanvasPattern = Pattern.prototype.getCanvasPattern;
	
	    var abs = Math.abs;
	
	    /**
	     * @alias module:zrender/graphic/Path
	     * @extends module:zrender/graphic/Displayable
	     * @constructor
	     * @param {Object} opts
	     */
	    function Path(opts) {
	        Displayable.call(this, opts);
	
	        /**
	         * @type {module:zrender/core/PathProxy}
	         * @readOnly
	         */
	        this.path = new PathProxy();
	    }
	
	    Path.prototype = {
	
	        constructor: Path,
	
	        type: 'path',
	
	        __dirtyPath: true,
	
	        strokeContainThreshold: 5,
	
	        brush: function (ctx, prevEl) {
	            var style = this.style;
	            var path = this.path;
	            var hasStroke = style.hasStroke();
	            var hasFill = style.hasFill();
	            var fill = style.fill;
	            var stroke = style.stroke;
	            var hasFillGradient = hasFill && !!(fill.colorStops);
	            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);
	            var hasFillPattern = hasFill && !!(fill.image);
	            var hasStrokePattern = hasStroke && !!(stroke.image);
	
	            style.bind(ctx, this, prevEl);
	            this.setTransform(ctx);
	
	            if (this.__dirty) {
	                var rect = this.getBoundingRect();
	                // Update gradient because bounding rect may changed
	                if (hasFillGradient) {
	                    this._fillGradient = style.getGradient(ctx, fill, rect);
	                }
	                if (hasStrokeGradient) {
	                    this._strokeGradient = style.getGradient(ctx, stroke, rect);
	                }
	            }
	            // Use the gradient or pattern
	            if (hasFillGradient) {
	                // PENDING If may have affect the state
	                ctx.fillStyle = this._fillGradient;
	            }
	            else if (hasFillPattern) {
	                ctx.fillStyle = getCanvasPattern.call(fill, ctx);
	            }
	            if (hasStrokeGradient) {
	                ctx.strokeStyle = this._strokeGradient;
	            }
	            else if (hasStrokePattern) {
	                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);
	            }
	
	            var lineDash = style.lineDash;
	            var lineDashOffset = style.lineDashOffset;
	
	            var ctxLineDash = !!ctx.setLineDash;
	
	            // Update path sx, sy
	            var scale = this.getGlobalScale();
	            path.setScale(scale[0], scale[1]);
	
	            // Proxy context
	            // Rebuild path in following 2 cases
	            // 1. Path is dirty
	            // 2. Path needs javascript implemented lineDash stroking.
	            //    In this case, lineDash information will not be saved in PathProxy
	            if (this.__dirtyPath || (
	                lineDash && !ctxLineDash && hasStroke
	            )) {
	                path = this.path.beginPath(ctx);
	
	                // Setting line dash before build path
	                if (lineDash && !ctxLineDash) {
	                    path.setLineDash(lineDash);
	                    path.setLineDashOffset(lineDashOffset);
	                }
	
	                this.buildPath(path, this.shape, false);
	
	                // Clear path dirty flag
	                this.__dirtyPath = false;
	            }
	            else {
	                // Replay path building
	                ctx.beginPath();
	                this.path.rebuildPath(ctx);
	            }
	
	            hasFill && path.fill(ctx);
	
	            if (lineDash && ctxLineDash) {
	                ctx.setLineDash(lineDash);
	                ctx.lineDashOffset = lineDashOffset;
	            }
	
	            hasStroke && path.stroke(ctx);
	
	            if (lineDash && ctxLineDash) {
	                // PENDING
	                // Remove lineDash
	                ctx.setLineDash([]);
	            }
	
	
	            this.restoreTransform(ctx);
	
	            // Draw rect text
	            if (style.text || style.text === 0) {
	                // var rect = this.getBoundingRect();
	                this.drawRectText(ctx, this.getBoundingRect());
	            }
	        },
	
	        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath
	        // Like in circle
	        buildPath: function (ctx, shapeCfg, inBundle) {},
	
	        getBoundingRect: function () {
	            var rect = this._rect;
	            var style = this.style;
	            var needsUpdateRect = !rect;
	            if (needsUpdateRect) {
	                var path = this.path;
	                if (this.__dirtyPath) {
	                    path.beginPath();
	                    this.buildPath(path, this.shape, false);
	                }
	                rect = path.getBoundingRect();
	            }
	            this._rect = rect;
	
	            if (style.hasStroke()) {
	                // Needs update rect with stroke lineWidth when
	                // 1. Element changes scale or lineWidth
	                // 2. Shape is changed
	                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());
	                if (this.__dirty || needsUpdateRect) {
	                    rectWithStroke.copy(rect);
	                    // FIXME Must after updateTransform
	                    var w = style.lineWidth;
	                    // PENDING, Min line width is needed when line is horizontal or vertical
	                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
	
	                    // Only add extra hover lineWidth when there are no fill
	                    if (!style.hasFill()) {
	                        w = Math.max(w, this.strokeContainThreshold || 4);
	                    }
	                    // Consider line width
	                    // Line scale can't be 0;
	                    if (lineScale > 1e-10) {
	                        rectWithStroke.width += w / lineScale;
	                        rectWithStroke.height += w / lineScale;
	                        rectWithStroke.x -= w / lineScale / 2;
	                        rectWithStroke.y -= w / lineScale / 2;
	                    }
	                }
	
	                // Return rect with stroke
	                return rectWithStroke;
	            }
	
	            return rect;
	        },
	
	        contain: function (x, y) {
	            var localPos = this.transformCoordToLocal(x, y);
	            var rect = this.getBoundingRect();
	            var style = this.style;
	            x = localPos[0];
	            y = localPos[1];
	
	            if (rect.contain(x, y)) {
	                var pathData = this.path.data;
	                if (style.hasStroke()) {
	                    var lineWidth = style.lineWidth;
	                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
	                    // Line scale can't be 0;
	                    if (lineScale > 1e-10) {
	                        // Only add extra hover lineWidth when there are no fill
	                        if (!style.hasFill()) {
	                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
	                        }
	                        if (pathContain.containStroke(
	                            pathData, lineWidth / lineScale, x, y
	                        )) {
	                            return true;
	                        }
	                    }
	                }
	                if (style.hasFill()) {
	                    return pathContain.contain(pathData, x, y);
	                }
	            }
	            return false;
	        },
	
	        /**
	         * @param  {boolean} dirtyPath
	         */
	        dirty: function (dirtyPath) {
	            if (dirtyPath == null) {
	                dirtyPath = true;
	            }
	            // Only mark dirty, not mark clean
	            if (dirtyPath) {
	                this.__dirtyPath = dirtyPath;
	                this._rect = null;
	            }
	
	            this.__dirty = true;
	
	            this.__zr && this.__zr.refresh();
	
	            // Used as a clipping path
	            if (this.__clipTarget) {
	                this.__clipTarget.dirty();
	            }
	        },
	
	        /**
	         * Alias for animate('shape')
	         * @param {boolean} loop
	         */
	        animateShape: function (loop) {
	            return this.animate('shape', loop);
	        },
	
	        // Overwrite attrKV
	        attrKV: function (key, value) {
	            // FIXME
	            if (key === 'shape') {
	                this.setShape(value);
	                this.__dirtyPath = true;
	                this._rect = null;
	            }
	            else {
	                Displayable.prototype.attrKV.call(this, key, value);
	            }
	        },
	
	        /**
	         * @param {Object|string} key
	         * @param {*} value
	         */
	        setShape: function (key, value) {
	            var shape = this.shape;
	            // Path from string may not have shape
	            if (shape) {
	                if (zrUtil.isObject(key)) {
	                    for (var name in key) {
	                        shape[name] = key[name];
	                    }
	                }
	                else {
	                    shape[key] = value;
	                }
	                this.dirty(true);
	            }
	            return this;
	        },
	
	        getLineScale: function () {
	            var m = this.transform;
	            // Get the line scale.
	            // Determinant of `m` means how much the area is enlarged by the
	            // transformation. So its square root can be used as a scale factor
	            // for width.
	            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10
	                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))
	                : 1;
	        }
	    };
	
	    /**
	     * 扩展一个 Path element, 比如星形，圆等。
	     * Extend a path element
	     * @param {Object} props
	     * @param {string} props.type Path type
	     * @param {Function} props.init Initialize
	     * @param {Function} props.buildPath Overwrite buildPath method
	     * @param {Object} [props.style] Extended default style config
	     * @param {Object} [props.shape] Extended default shape config
	     */
	    Path.extend = function (defaults) {
	        var Sub = function (opts) {
	            Path.call(this, opts);
	
	            if (defaults.style) {
	                // Extend default style
	                this.style.extendFrom(defaults.style, false);
	            }
	
	            // Extend default shape
	            var defaultShape = defaults.shape;
	            if (defaultShape) {
	                this.shape = this.shape || {};
	                var thisShape = this.shape;
	                for (var name in defaultShape) {
	                    if (
	                        ! thisShape.hasOwnProperty(name)
	                        && defaultShape.hasOwnProperty(name)
	                    ) {
	                        thisShape[name] = defaultShape[name];
	                    }
	                }
	            }
	
	            defaults.init && defaults.init.call(this, opts);
	        };
	
	        zrUtil.inherits(Sub, Path);
	
	        // FIXME 不能 extend position, rotation 等引用对象
	        for (var name in defaults) {
	            // Extending prototype values and methods
	            if (name !== 'style' && name !== 'shape') {
	                Sub.prototype[name] = defaults[name];
	            }
	        }
	
	        return Sub;
	    };
	
	    zrUtil.inherits(Path, Displayable);
	
	    return Path;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * 可绘制的图形基类
	 * Base class of all displayable graphic objects
	 * @module zrender/graphic/Displayable
	 */
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var zrUtil = __webpack_require__(8);
	
	    var Style = __webpack_require__(51);
	
	    var Element = __webpack_require__(35);
	    var RectText = __webpack_require__(52);
	    // var Stateful = require('./mixin/Stateful');
	
	    /**
	     * @alias module:zrender/graphic/Displayable
	     * @extends module:zrender/Element
	     * @extends module:zrender/graphic/mixin/RectText
	     */
	    function Displayable(opts) {
	
	        opts = opts || {};
	
	        Element.call(this, opts);
	
	        // Extend properties
	        for (var name in opts) {
	            if (
	                opts.hasOwnProperty(name) &&
	                name !== 'style'
	            ) {
	                this[name] = opts[name];
	            }
	        }
	
	        /**
	         * @type {module:zrender/graphic/Style}
	         */
	        this.style = new Style(opts.style);
	
	        this._rect = null;
	        // Shapes for cascade clipping.
	        this.__clipPaths = [];
	
	        // FIXME Stateful must be mixined after style is setted
	        // Stateful.call(this, opts);
	    }
	
	    Displayable.prototype = {
	
	        constructor: Displayable,
	
	        type: 'displayable',
	
	        /**
	         * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制
	         * Dirty flag. From which painter will determine if this displayable object needs brush
	         * @name module:zrender/graphic/Displayable#__dirty
	         * @type {boolean}
	         */
	        __dirty: true,
	
	        /**
	         * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件
	         * If ignore drawing of the displayable object. Mouse event will still be triggered
	         * @name module:/zrender/graphic/Displayable#invisible
	         * @type {boolean}
	         * @default false
	         */
	        invisible: false,
	
	        /**
	         * @name module:/zrender/graphic/Displayable#z
	         * @type {number}
	         * @default 0
	         */
	        z: 0,
	
	        /**
	         * @name module:/zrender/graphic/Displayable#z
	         * @type {number}
	         * @default 0
	         */
	        z2: 0,
	
	        /**
	         * z层level，决定绘画在哪层canvas中
	         * @name module:/zrender/graphic/Displayable#zlevel
	         * @type {number}
	         * @default 0
	         */
	        zlevel: 0,
	
	        /**
	         * 是否可拖拽
	         * @name module:/zrender/graphic/Displayable#draggable
	         * @type {boolean}
	         * @default false
	         */
	        draggable: false,
	
	        /**
	         * 是否正在拖拽
	         * @name module:/zrender/graphic/Displayable#draggable
	         * @type {boolean}
	         * @default false
	         */
	        dragging: false,
	
	        /**
	         * 是否相应鼠标事件
	         * @name module:/zrender/graphic/Displayable#silent
	         * @type {boolean}
	         * @default false
	         */
	        silent: false,
	
	        /**
	         * If enable culling
	         * @type {boolean}
	         * @default false
	         */
	        culling: false,
	
	        /**
	         * Mouse cursor when hovered
	         * @name module:/zrender/graphic/Displayable#cursor
	         * @type {string}
	         */
	        cursor: 'pointer',
	
	        /**
	         * If hover area is bounding rect
	         * @name module:/zrender/graphic/Displayable#rectHover
	         * @type {string}
	         */
	        rectHover: false,
	
	        /**
	         * Render the element progressively when the value >= 0,
	         * usefull for large data.
	         * @type {number}
	         */
	        progressive: -1,
	
	        beforeBrush: function (ctx) {},
	
	        afterBrush: function (ctx) {},
	
	        /**
	         * 图形绘制方法
	         * @param {Canvas2DRenderingContext} ctx
	         */
	        // Interface
	        brush: function (ctx, prevEl) {},
	
	        /**
	         * 获取最小包围盒
	         * @return {module:zrender/core/BoundingRect}
	         */
	        // Interface
	        getBoundingRect: function () {},
	
	        /**
	         * 判断坐标 x, y 是否在图形上
	         * If displayable element contain coord x, y
	         * @param  {number} x
	         * @param  {number} y
	         * @return {boolean}
	         */
	        contain: function (x, y) {
	            return this.rectContain(x, y);
	        },
	
	        /**
	         * @param  {Function} cb
	         * @param  {}   context
	         */
	        traverse: function (cb, context) {
	            cb.call(context, this);
	        },
	
	        /**
	         * 判断坐标 x, y 是否在图形的包围盒上
	         * If bounding rect of element contain coord x, y
	         * @param  {number} x
	         * @param  {number} y
	         * @return {boolean}
	         */
	        rectContain: function (x, y) {
	            var coord = this.transformCoordToLocal(x, y);
	            var rect = this.getBoundingRect();
	            return rect.contain(coord[0], coord[1]);
	        },
	
	        /**
	         * 标记图形元素为脏，并且在下一帧重绘
	         * Mark displayable element dirty and refresh next frame
	         */
	        dirty: function () {
	            this.__dirty = true;
	
	            this._rect = null;
	
	            this.__zr && this.__zr.refresh();
	        },
	
	        /**
	         * 图形是否会触发事件
	         * If displayable object binded any event
	         * @return {boolean}
	         */
	        // TODO, 通过 bind 绑定的事件
	        // isSilent: function () {
	        //     return !(
	        //         this.hoverable || this.draggable
	        //         || this.onmousemove || this.onmouseover || this.onmouseout
	        //         || this.onmousedown || this.onmouseup || this.onclick
	        //         || this.ondragenter || this.ondragover || this.ondragleave
	        //         || this.ondrop
	        //     );
	        // },
	        /**
	         * Alias for animate('style')
	         * @param {boolean} loop
	         */
	        animateStyle: function (loop) {
	            return this.animate('style', loop);
	        },
	
	        attrKV: function (key, value) {
	            if (key !== 'style') {
	                Element.prototype.attrKV.call(this, key, value);
	            }
	            else {
	                this.style.set(value);
	            }
	        },
	
	        /**
	         * @param {Object|string} key
	         * @param {*} value
	         */
	        setStyle: function (key, value) {
	            this.style.set(key, value);
	            this.dirty(false);
	            return this;
	        },
	
	        /**
	         * Use given style object
	         * @param  {Object} obj
	         */
	        useStyle: function (obj) {
	            this.style = new Style(obj);
	            this.dirty(false);
	            return this;
	        }
	    };
	
	    zrUtil.inherits(Displayable, Element);
	
	    zrUtil.mixin(Displayable, RectText);
	    // zrUtil.mixin(Displayable, Stateful);
	
	    return Displayable;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * @module zrender/graphic/Style
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var STYLE_COMMON_PROPS = [
	        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],
	        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]
	    ];
	
	    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);
	    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);
	
	    var Style = function (opts) {
	        this.extendFrom(opts);
	    };
	
	    function createLinearGradient(ctx, obj, rect) {
	        // var size =
	        var x = obj.x;
	        var x2 = obj.x2;
	        var y = obj.y;
	        var y2 = obj.y2;
	
	        if (!obj.global) {
	            x = x * rect.width + rect.x;
	            x2 = x2 * rect.width + rect.x;
	            y = y * rect.height + rect.y;
	            y2 = y2 * rect.height + rect.y;
	        }
	
	        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);
	
	        return canvasGradient;
	    }
	
	    function createRadialGradient(ctx, obj, rect) {
	        var width = rect.width;
	        var height = rect.height;
	        var min = Math.min(width, height);
	
	        var x = obj.x;
	        var y = obj.y;
	        var r = obj.r;
	        if (!obj.global) {
	            x = x * width + rect.x;
	            y = y * height + rect.y;
	            r = r * min;
	        }
	
	        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);
	
	        return canvasGradient;
	    }
	
	
	    Style.prototype = {
	
	        constructor: Style,
	
	        /**
	         * @type {string}
	         */
	        fill: '#000000',
	
	        /**
	         * @type {string}
	         */
	        stroke: null,
	
	        /**
	         * @type {number}
	         */
	        opacity: 1,
	
	        /**
	         * @type {Array.<number>}
	         */
	        lineDash: null,
	
	        /**
	         * @type {number}
	         */
	        lineDashOffset: 0,
	
	        /**
	         * @type {number}
	         */
	        shadowBlur: 0,
	
	        /**
	         * @type {number}
	         */
	        shadowOffsetX: 0,
	
	        /**
	         * @type {number}
	         */
	        shadowOffsetY: 0,
	
	        /**
	         * @type {number}
	         */
	        lineWidth: 1,
	
	        /**
	         * If stroke ignore scale
	         * @type {Boolean}
	         */
	        strokeNoScale: false,
	
	        // Bounding rect text configuration
	        // Not affected by element transform
	        /**
	         * @type {string}
	         */
	        text: null,
	
	        /**
	         * @type {string}
	         */
	        textFill: '#000',
	
	        /**
	         * @type {string}
	         */
	        textStroke: null,
	
	        /**
	         * 'inside', 'left', 'right', 'top', 'bottom'
	         * [x, y]
	         * @type {string|Array.<number>}
	         * @default 'inside'
	         */
	        textPosition: 'inside',
	
	        /**
	         * @type {string}
	         */
	        textBaseline: null,
	
	        /**
	         * @type {string}
	         */
	        textAlign: null,
	
	        /**
	         * @type {string}
	         */
	        textVerticalAlign: null,
	
	        /**
	         * Only useful in Path and Image element
	         * @type {number}
	         */
	        textDistance: 5,
	
	        /**
	         * Only useful in Path and Image element
	         * @type {number}
	         */
	        textShadowBlur: 0,
	
	        /**
	         * Only useful in Path and Image element
	         * @type {number}
	         */
	        textShadowOffsetX: 0,
	
	        /**
	         * Only useful in Path and Image element
	         * @type {number}
	         */
	        textShadowOffsetY: 0,
	
	        /**
	         * If transform text
	         * Only useful in Path and Image element
	         * @type {boolean}
	         */
	        textTransform: false,
	
	        /**
	         * Text rotate around position of Path or Image
	         * Only useful in Path and Image element and textTransform is false.
	         */
	        textRotation: 0,
	
	        /**
	         * @type {string}
	         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
	         */
	        blend: null,
	
	        /**
	         * @param {CanvasRenderingContext2D} ctx
	         */
	        bind: function (ctx, el, prevEl) {
	            var style = this;
	            var prevStyle = prevEl && prevEl.style;
	            var firstDraw = !prevStyle;
	
	            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
	                var prop = STYLE_COMMON_PROPS[i];
	                var styleName = prop[0];
	
	                if (firstDraw || style[styleName] !== prevStyle[styleName]) {
	                    // FIXME Invalid property value will cause style leak from previous element.
	                    ctx[styleName] = style[styleName] || prop[1];
	                }
	            }
	
	            if ((firstDraw || style.fill !== prevStyle.fill)) {
	                ctx.fillStyle = style.fill;
	            }
	            if ((firstDraw || style.stroke !== prevStyle.stroke)) {
	                ctx.strokeStyle = style.stroke;
	            }
	            if ((firstDraw || style.opacity !== prevStyle.opacity)) {
	                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
	            }
	
	            if ((firstDraw || style.blend !== prevStyle.blend)) {
	                ctx.globalCompositeOperation = style.blend || 'source-over';
	            }
	            if (this.hasStroke()) {
	                var lineWidth = style.lineWidth;
	                ctx.lineWidth = lineWidth / (
	                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1
	                );
	            }
	        },
	
	        hasFill: function () {
	            var fill = this.fill;
	            return fill != null && fill !== 'none';
	        },
	
	        hasStroke: function () {
	            var stroke = this.stroke;
	            return stroke != null && stroke !== 'none' && this.lineWidth > 0;
	        },
	
	        /**
	         * Extend from other style
	         * @param {zrender/graphic/Style} otherStyle
	         * @param {boolean} overwrite
	         */
	        extendFrom: function (otherStyle, overwrite) {
	            if (otherStyle) {
	                var target = this;
	                for (var name in otherStyle) {
	                    if (otherStyle.hasOwnProperty(name)
	                        && (overwrite || ! target.hasOwnProperty(name))
	                    ) {
	                        target[name] = otherStyle[name];
	                    }
	                }
	            }
	        },
	
	        /**
	         * Batch setting style with a given object
	         * @param {Object|string} obj
	         * @param {*} [obj]
	         */
	        set: function (obj, value) {
	            if (typeof obj === 'string') {
	                this[obj] = value;
	            }
	            else {
	                this.extendFrom(obj, true);
	            }
	        },
	
	        /**
	         * Clone
	         * @return {zrender/graphic/Style} [description]
	         */
	        clone: function () {
	            var newStyle = new this.constructor();
	            newStyle.extendFrom(this, true);
	            return newStyle;
	        },
	
	        getGradient: function (ctx, obj, rect) {
	            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;
	            var canvasGradient = method(ctx, obj, rect);
	            var colorStops = obj.colorStops;
	            for (var i = 0; i < colorStops.length; i++) {
	                canvasGradient.addColorStop(
	                    colorStops[i].offset, colorStops[i].color
	                );
	            }
	            return canvasGradient;
	        }
	    };
	
	    var styleProto = Style.prototype;
	    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
	        var prop = STYLE_COMMON_PROPS[i];
	        if (!(prop[0] in styleProto)) {
	            styleProto[prop[0]] = prop[1];
	        }
	    }
	
	    // Provide for others
	    Style.getGradient = styleProto.getGradient;
	
	    return Style;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Mixin for drawing text in a element bounding rect
	 * @module zrender/mixin/RectText
	 */
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var textContain = __webpack_require__(12);
	    var BoundingRect = __webpack_require__(13);
	
	    var tmpRect = new BoundingRect();
	
	    var RectText = function () {};
	
	    function parsePercent(value, maxValue) {
	        if (typeof value === 'string') {
	            if (value.lastIndexOf('%') >= 0) {
	                return parseFloat(value) / 100 * maxValue;
	            }
	            return parseFloat(value);
	        }
	        return value;
	    }
	
	    RectText.prototype = {
	
	        constructor: RectText,
	
	        /**
	         * Draw text in a rect with specified position.
	         * @param  {CanvasRenderingContext} ctx
	         * @param  {Object} rect Displayable rect
	         * @return {Object} textRect Alternative precalculated text bounding rect
	         */
	        drawRectText: function (ctx, rect, textRect) {
	            var style = this.style;
	            var text = style.text;
	            // Convert to string
	            text != null && (text += '');
	            if (!text) {
	                return;
	            }
	
	            // FIXME
	            ctx.save();
	
	            var x;
	            var y;
	            var textPosition = style.textPosition;
	            var distance = style.textDistance;
	            var align = style.textAlign;
	            var font = style.textFont || style.font;
	            var baseline = style.textBaseline;
	            var verticalAlign = style.textVerticalAlign;
	
	            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);
	
	            // Transform rect to view space
	            var transform = this.transform;
	            if (!style.textTransform) {
	                if (transform) {
	                    tmpRect.copy(rect);
	                    tmpRect.applyTransform(transform);
	                    rect = tmpRect;
	                }
	            }
	            else {
	                this.setTransform(ctx);
	            }
	
	            // Text position represented by coord
	            if (textPosition instanceof Array) {
	                // Percent
	                x = rect.x + parsePercent(textPosition[0], rect.width);
	                y = rect.y + parsePercent(textPosition[1], rect.height);
	                align = align || 'left';
	                baseline = baseline || 'top';
	
	                if (verticalAlign) {
	                    switch (verticalAlign) {
	                        case 'middle':
	                            y -= textRect.height / 2 - textRect.lineHeight / 2;
	                            break;
	                        case 'bottom':
	                            y -= textRect.height - textRect.lineHeight / 2;
	                            break;
	                        default:
	                            y += textRect.lineHeight / 2;
	                    }
	                    // Force bseline to be middle
	                    baseline = 'middle';
	                }
	            }
	            else {
	                var res = textContain.adjustTextPositionOnRect(
	                    textPosition, rect, textRect, distance
	                );
	                x = res.x;
	                y = res.y;
	                // Default align and baseline when has textPosition
	                align = align || res.textAlign;
	                baseline = baseline || res.textBaseline;
	            }
	
	            // Use canvas default left textAlign. Giving invalid value will cause state not change
	            ctx.textAlign = align || 'left';
	            // Use canvas default alphabetic baseline
	            ctx.textBaseline = baseline || 'alphabetic';
	
	            var textFill = style.textFill;
	            var textStroke = style.textStroke;
	            textFill && (ctx.fillStyle = textFill);
	            textStroke && (ctx.strokeStyle = textStroke);
	
	            // TODO Invalid font
	            ctx.font = font || '12px sans-serif';
	
	            // Text shadow
	            // Always set shadowBlur and shadowOffset to avoid leak from displayable
	            ctx.shadowBlur = style.textShadowBlur;
	            ctx.shadowColor = style.textShadowColor || 'transparent';
	            ctx.shadowOffsetX = style.textShadowOffsetX;
	            ctx.shadowOffsetY = style.textShadowOffsetY;
	
	            var textLines = text.split('\n');
	
	            if (style.textRotation) {
	                transform && ctx.translate(transform[4], transform[5]);
	                ctx.rotate(style.textRotation);
	                transform && ctx.translate(-transform[4], -transform[5]);
	            }
	
	            for (var i = 0; i < textLines.length; i++) {
	                textFill && ctx.fillText(textLines[i], x, y);
	                textStroke && ctx.strokeText(textLines[i], x, y);
	                y += textRect.lineHeight;
	            }
	
	            ctx.restore();
	        }
	    };
	
	    return RectText;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中
	 * 可以用于 isInsidePath 判断以及获取boundingRect
	 *
	 * @module zrender/core/PathProxy
	 * @author Yi Shen (http://www.github.com/pissang)
	 */
	
	 // TODO getTotalLength, getPointAtLength
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	    'use strict';
	
	    var curve = __webpack_require__(54);
	    var vec2 = __webpack_require__(14);
	    var bbox = __webpack_require__(55);
	    var BoundingRect = __webpack_require__(13);
	    var dpr = __webpack_require__(45).devicePixelRatio;
	
	    var CMD = {
	        M: 1,
	        L: 2,
	        C: 3,
	        Q: 4,
	        A: 5,
	        Z: 6,
	        // Rect
	        R: 7
	    };
	
	    var min = [];
	    var max = [];
	    var min2 = [];
	    var max2 = [];
	    var mathMin = Math.min;
	    var mathMax = Math.max;
	    var mathCos = Math.cos;
	    var mathSin = Math.sin;
	    var mathSqrt = Math.sqrt;
	    var mathAbs = Math.abs;
	
	    var hasTypedArray = typeof Float32Array != 'undefined';
	
	    /**
	     * @alias module:zrender/core/PathProxy
	     * @constructor
	     */
	    var PathProxy = function () {
	
	        /**
	         * Path data. Stored as flat array
	         * @type {Array.<Object>}
	         */
	        this.data = [];
	
	        this._len = 0;
	
	        this._ctx = null;
	
	        this._xi = 0;
	        this._yi = 0;
	
	        this._x0 = 0;
	        this._y0 = 0;
	
	        // Unit x, Unit y. Provide for avoiding drawing that too short line segment
	        this._ux = 0;
	        this._uy = 0;
	    };
	
	    /**
	     * 快速计算Path包围盒（并不是最小包围盒）
	     * @return {Object}
	     */
	    PathProxy.prototype = {
	
	        constructor: PathProxy,
	
	        _lineDash: null,
	
	        _dashOffset: 0,
	
	        _dashIdx: 0,
	
	        _dashSum: 0,
	
	        /**
	         * @readOnly
	         */
	        setScale: function (sx, sy) {
	            this._ux = mathAbs(1 / dpr / sx) || 0;
	            this._uy = mathAbs(1 / dpr / sy) || 0;
	        },
	
	        getContext: function () {
	            return this._ctx;
	        },
	
	        /**
	         * @param  {CanvasRenderingContext2D} ctx
	         * @return {module:zrender/core/PathProxy}
	         */
	        beginPath: function (ctx) {
	
	            this._ctx = ctx;
	
	            ctx && ctx.beginPath();
	
	            ctx && (this.dpr = ctx.dpr);
	
	            // Reset
	            this._len = 0;
	
	            if (this._lineDash) {
	                this._lineDash = null;
	
	                this._dashOffset = 0;
	            }
	
	            return this;
	        },
	
	        /**
	         * @param  {number} x
	         * @param  {number} y
	         * @return {module:zrender/core/PathProxy}
	         */
	        moveTo: function (x, y) {
	            this.addData(CMD.M, x, y);
	            this._ctx && this._ctx.moveTo(x, y);
	
	            // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用
	            // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。
	            // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要
	            // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持
	            this._x0 = x;
	            this._y0 = y;
	
	            this._xi = x;
	            this._yi = y;
	
	            return this;
	        },
	
	        /**
	         * @param  {number} x
	         * @param  {number} y
	         * @return {module:zrender/core/PathProxy}
	         */
	        lineTo: function (x, y) {
	            var exceedUnit = mathAbs(x - this._xi) > this._ux
	                || mathAbs(y - this._yi) > this._uy
	                // Force draw the first segment
	                || this._len < 5;
	
	            this.addData(CMD.L, x, y);
	
	            if (this._ctx && exceedUnit) {
	                this._needsDash() ? this._dashedLineTo(x, y)
	                    : this._ctx.lineTo(x, y);
	            }
	            if (exceedUnit) {
	                this._xi = x;
	                this._yi = y;
	            }
	
	            return this;
	        },
	
	        /**
	         * @param  {number} x1
	         * @param  {number} y1
	         * @param  {number} x2
	         * @param  {number} y2
	         * @param  {number} x3
	         * @param  {number} y3
	         * @return {module:zrender/core/PathProxy}
	         */
	        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {
	            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);
	            if (this._ctx) {
	                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)
	                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
	            }
	            this._xi = x3;
	            this._yi = y3;
	            return this;
	        },
	
	        /**
	         * @param  {number} x1
	         * @param  {number} y1
	         * @param  {number} x2
	         * @param  {number} y2
	         * @return {module:zrender/core/PathProxy}
	         */
	        quadraticCurveTo: function (x1, y1, x2, y2) {
	            this.addData(CMD.Q, x1, y1, x2, y2);
	            if (this._ctx) {
	                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)
	                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);
	            }
	            this._xi = x2;
	            this._yi = y2;
	            return this;
	        },
	
	        /**
	         * @param  {number} cx
	         * @param  {number} cy
	         * @param  {number} r
	         * @param  {number} startAngle
	         * @param  {number} endAngle
	         * @param  {boolean} anticlockwise
	         * @return {module:zrender/core/PathProxy}
	         */
	        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {
	            this.addData(
	                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1
	            );
	            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
	
	            this._xi = mathCos(endAngle) * r + cx;
	            this._xi = mathSin(endAngle) * r + cx;
	            return this;
	        },
	
	        // TODO
	        arcTo: function (x1, y1, x2, y2, radius) {
	            if (this._ctx) {
	                this._ctx.arcTo(x1, y1, x2, y2, radius);
	            }
	            return this;
	        },
	
	        // TODO
	        rect: function (x, y, w, h) {
	            this._ctx && this._ctx.rect(x, y, w, h);
	            this.addData(CMD.R, x, y, w, h);
	            return this;
	        },
	
	        /**
	         * @return {module:zrender/core/PathProxy}
	         */
	        closePath: function () {
	            this.addData(CMD.Z);
	
	            var ctx = this._ctx;
	            var x0 = this._x0;
	            var y0 = this._y0;
	            if (ctx) {
	                this._needsDash() && this._dashedLineTo(x0, y0);
	                ctx.closePath();
	            }
	
	            this._xi = x0;
	            this._yi = y0;
	            return this;
	        },
	
	        /**
	         * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。
	         * stroke 同样
	         * @param {CanvasRenderingContext2D} ctx
	         * @return {module:zrender/core/PathProxy}
	         */
	        fill: function (ctx) {
	            ctx && ctx.fill();
	            this.toStatic();
	        },
	
	        /**
	         * @param {CanvasRenderingContext2D} ctx
	         * @return {module:zrender/core/PathProxy}
	         */
	        stroke: function (ctx) {
	            ctx && ctx.stroke();
	            this.toStatic();
	        },
	
	        /**
	         * 必须在其它绘制命令前调用
	         * Must be invoked before all other path drawing methods
	         * @return {module:zrender/core/PathProxy}
	         */
	        setLineDash: function (lineDash) {
	            if (lineDash instanceof Array) {
	                this._lineDash = lineDash;
	
	                this._dashIdx = 0;
	
	                var lineDashSum = 0;
	                for (var i = 0; i < lineDash.length; i++) {
	                    lineDashSum += lineDash[i];
	                }
	                this._dashSum = lineDashSum;
	            }
	            return this;
	        },
	
	        /**
	         * 必须在其它绘制命令前调用
	         * Must be invoked before all other path drawing methods
	         * @return {module:zrender/core/PathProxy}
	         */
	        setLineDashOffset: function (offset) {
	            this._dashOffset = offset;
	            return this;
	        },
	
	        /**
	         *
	         * @return {boolean}
	         */
	        len: function () {
	            return this._len;
	        },
	
	        /**
	         * 直接设置 Path 数据
	         */
	        setData: function (data) {
	
	            var len = data.length;
	
	            if (! (this.data && this.data.length == len) && hasTypedArray) {
	                this.data = new Float32Array(len);
	            }
	
	            for (var i = 0; i < len; i++) {
	                this.data[i] = data[i];
	            }
	
	            this._len = len;
	        },
	
	        /**
	         * 添加子路径
	         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path
	         */
	        appendPath: function (path) {
	            if (!(path instanceof Array)) {
	                path = [path];
	            }
	            var len = path.length;
	            var appendSize = 0;
	            var offset = this._len;
	            for (var i = 0; i < len; i++) {
	                appendSize += path[i].len();
	            }
	            if (hasTypedArray && (this.data instanceof Float32Array)) {
	                this.data = new Float32Array(offset + appendSize);
	            }
	            for (var i = 0; i < len; i++) {
	                var appendPathData = path[i].data;
	                for (var k = 0; k < appendPathData.length; k++) {
	                    this.data[offset++] = appendPathData[k];
	                }
	            }
	            this._len = offset;
	        },
	
	        /**
	         * 填充 Path 数据。
	         * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。
	         */
	        addData: function (cmd) {
	            var data = this.data;
	            if (this._len + arguments.length > data.length) {
	                // 因为之前的数组已经转换成静态的 Float32Array
	                // 所以不够用时需要扩展一个新的动态数组
	                this._expandData();
	                data = this.data;
	            }
	            for (var i = 0; i < arguments.length; i++) {
	                data[this._len++] = arguments[i];
	            }
	
	            this._prevCmd = cmd;
	        },
	
	        _expandData: function () {
	            // Only if data is Float32Array
	            if (!(this.data instanceof Array)) {
	                var newData = [];
	                for (var i = 0; i < this._len; i++) {
	                    newData[i] = this.data[i];
	                }
	                this.data = newData;
	            }
	        },
	
	        /**
	         * If needs js implemented dashed line
	         * @return {boolean}
	         * @private
	         */
	        _needsDash: function () {
	            return this._lineDash;
	        },
	
	        _dashedLineTo: function (x1, y1) {
	            var dashSum = this._dashSum;
	            var offset = this._dashOffset;
	            var lineDash = this._lineDash;
	            var ctx = this._ctx;
	
	            var x0 = this._xi;
	            var y0 = this._yi;
	            var dx = x1 - x0;
	            var dy = y1 - y0;
	            var dist = mathSqrt(dx * dx + dy * dy);
	            var x = x0;
	            var y = y0;
	            var dash;
	            var nDash = lineDash.length;
	            var idx;
	            dx /= dist;
	            dy /= dist;
	
	            if (offset < 0) {
	                // Convert to positive offset
	                offset = dashSum + offset;
	            }
	            offset %= dashSum;
	            x -= offset * dx;
	            y -= offset * dy;
	
	            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)
	            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {
	                idx = this._dashIdx;
	                dash = lineDash[idx];
	                x += dx * dash;
	                y += dy * dash;
	                this._dashIdx = (idx + 1) % nDash;
	                // Skip positive offset
	                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {
	                    continue;
	                }
	                ctx[idx % 2 ? 'moveTo' : 'lineTo'](
	                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),
	                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)
	                );
	            }
	            // Offset for next lineTo
	            dx = x - x1;
	            dy = y - y1;
	            this._dashOffset = -mathSqrt(dx * dx + dy * dy);
	        },
	
	        // Not accurate dashed line to
	        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {
	            var dashSum = this._dashSum;
	            var offset = this._dashOffset;
	            var lineDash = this._lineDash;
	            var ctx = this._ctx;
	
	            var x0 = this._xi;
	            var y0 = this._yi;
	            var t;
	            var dx;
	            var dy;
	            var cubicAt = curve.cubicAt;
	            var bezierLen = 0;
	            var idx = this._dashIdx;
	            var nDash = lineDash.length;
	
	            var x;
	            var y;
	
	            var tmpLen = 0;
	
	            if (offset < 0) {
	                // Convert to positive offset
	                offset = dashSum + offset;
	            }
	            offset %= dashSum;
	            // Bezier approx length
	            for (t = 0; t < 1; t += 0.1) {
	                dx = cubicAt(x0, x1, x2, x3, t + 0.1)
	                    - cubicAt(x0, x1, x2, x3, t);
	                dy = cubicAt(y0, y1, y2, y3, t + 0.1)
	                    - cubicAt(y0, y1, y2, y3, t);
	                bezierLen += mathSqrt(dx * dx + dy * dy);
	            }
	
	            // Find idx after add offset
	            for (; idx < nDash; idx++) {
	                tmpLen += lineDash[idx];
	                if (tmpLen > offset) {
	                    break;
	                }
	            }
	            t = (tmpLen - offset) / bezierLen;
	
	            while (t <= 1) {
	
	                x = cubicAt(x0, x1, x2, x3, t);
	                y = cubicAt(y0, y1, y2, y3, t);
	
	                // Use line to approximate dashed bezier
	                // Bad result if dash is long
	                idx % 2 ? ctx.moveTo(x, y)
	                    : ctx.lineTo(x, y);
	
	                t += lineDash[idx] / bezierLen;
	
	                idx = (idx + 1) % nDash;
	            }
	
	            // Finish the last segment and calculate the new offset
	            (idx % 2 !== 0) && ctx.lineTo(x3, y3);
	            dx = x3 - x;
	            dy = y3 - y;
	            this._dashOffset = -mathSqrt(dx * dx + dy * dy);
	        },
	
	        _dashedQuadraticTo: function (x1, y1, x2, y2) {
	            // Convert quadratic to cubic using degree elevation
	            var x3 = x2;
	            var y3 = y2;
	            x2 = (x2 + 2 * x1) / 3;
	            y2 = (y2 + 2 * y1) / 3;
	            x1 = (this._xi + 2 * x1) / 3;
	            y1 = (this._yi + 2 * y1) / 3;
	
	            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);
	        },
	
	        /**
	         * 转成静态的 Float32Array 减少堆内存占用
	         * Convert dynamic array to static Float32Array
	         */
	        toStatic: function () {
	            var data = this.data;
	            if (data instanceof Array) {
	                data.length = this._len;
	                if (hasTypedArray) {
	                    this.data = new Float32Array(data);
	                }
	            }
	        },
	
	        /**
	         * @return {module:zrender/core/BoundingRect}
	         */
	        getBoundingRect: function () {
	            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;
	            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;
	
	            var data = this.data;
	            var xi = 0;
	            var yi = 0;
	            var x0 = 0;
	            var y0 = 0;
	
	            for (var i = 0; i < data.length;) {
	                var cmd = data[i++];
	
	                if (i == 1) {
	                    // 如果第一个命令是 L, C, Q
	                    // 则 previous point 同绘制命令的第一个 point
	                    //
	                    // 第一个命令为 Arc 的情况下会在后面特殊处理
	                    xi = data[i];
	                    yi = data[i + 1];
	
	                    x0 = xi;
	                    y0 = yi;
	                }
	
	                switch (cmd) {
	                    case CMD.M:
	                        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
	                        // 在 closePath 的时候使用
	                        x0 = data[i++];
	                        y0 = data[i++];
	                        xi = x0;
	                        yi = y0;
	                        min2[0] = x0;
	                        min2[1] = y0;
	                        max2[0] = x0;
	                        max2[1] = y0;
	                        break;
	                    case CMD.L:
	                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);
	                        xi = data[i++];
	                        yi = data[i++];
	                        break;
	                    case CMD.C:
	                        bbox.fromCubic(
	                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],
	                            min2, max2
	                        );
	                        xi = data[i++];
	                        yi = data[i++];
	                        break;
	                    case CMD.Q:
	                        bbox.fromQuadratic(
	                            xi, yi, data[i++], data[i++], data[i], data[i + 1],
	                            min2, max2
	                        );
	                        xi = data[i++];
	                        yi = data[i++];
	                        break;
	                    case CMD.A:
	                        // TODO Arc 判断的开销比较大
	                        var cx = data[i++];
	                        var cy = data[i++];
	                        var rx = data[i++];
	                        var ry = data[i++];
	                        var startAngle = data[i++];
	                        var endAngle = data[i++] + startAngle;
	                        // TODO Arc 旋转
	                        var psi = data[i++];
	                        var anticlockwise = 1 - data[i++];
	
	                        if (i == 1) {
	                            // 直接使用 arc 命令
	                            // 第一个命令起点还未定义
	                            x0 = mathCos(startAngle) * rx + cx;
	                            y0 = mathSin(startAngle) * ry + cy;
	                        }
	
	                        bbox.fromArc(
	                            cx, cy, rx, ry, startAngle, endAngle,
	                            anticlockwise, min2, max2
	                        );
	
	                        xi = mathCos(endAngle) * rx + cx;
	                        yi = mathSin(endAngle) * ry + cy;
	                        break;
	                    case CMD.R:
	                        x0 = xi = data[i++];
	                        y0 = yi = data[i++];
	                        var width = data[i++];
	                        var height = data[i++];
	                        // Use fromLine
	                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);
	                        break;
	                    case CMD.Z:
	                        xi = x0;
	                        yi = y0;
	                        break;
	                }
	
	                // Union
	                vec2.min(min, min, min2);
	                vec2.max(max, max, max2);
	            }
	
	            // No data
	            if (i === 0) {
	                min[0] = min[1] = max[0] = max[1] = 0;
	            }
	
	            return new BoundingRect(
	                min[0], min[1], max[0] - min[0], max[1] - min[1]
	            );
	        },
	
	        /**
	         * Rebuild path from current data
	         * Rebuild path will not consider javascript implemented line dash.
	         * @param {CanvasRenderingContext} ctx
	         */
	        rebuildPath: function (ctx) {
	            var d = this.data;
	            var x0, y0;
	            var xi, yi;
	            var x, y;
	            var ux = this._ux;
	            var uy = this._uy;
	            var len = this._len;
	            for (var i = 0; i < len;) {
	                var cmd = d[i++];
	
	                if (i == 1) {
	                    // 如果第一个命令是 L, C, Q
	                    // 则 previous point 同绘制命令的第一个 point
	                    //
	                    // 第一个命令为 Arc 的情况下会在后面特殊处理
	                    xi = d[i];
	                    yi = d[i + 1];
	
	                    x0 = xi;
	                    y0 = yi;
	                }
	                switch (cmd) {
	                    case CMD.M:
	                        x0 = xi = d[i++];
	                        y0 = yi = d[i++];
	                        ctx.moveTo(xi, yi);
	                        break;
	                    case CMD.L:
	                        x = d[i++];
	                        y = d[i++];
	                        // Not draw too small seg between
	                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {
	                            ctx.lineTo(x, y);
	                            xi = x;
	                            yi = y;
	                        }
	                        break;
	                    case CMD.C:
	                        ctx.bezierCurveTo(
	                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]
	                        );
	                        xi = d[i - 2];
	                        yi = d[i - 1];
	                        break;
	                    case CMD.Q:
	                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);
	                        xi = d[i - 2];
	                        yi = d[i - 1];
	                        break;
	                    case CMD.A:
	                        var cx = d[i++];
	                        var cy = d[i++];
	                        var rx = d[i++];
	                        var ry = d[i++];
	                        var theta = d[i++];
	                        var dTheta = d[i++];
	                        var psi = d[i++];
	                        var fs = d[i++];
	                        var r = (rx > ry) ? rx : ry;
	                        var scaleX = (rx > ry) ? 1 : rx / ry;
	                        var scaleY = (rx > ry) ? ry / rx : 1;
	                        var isEllipse = Math.abs(rx - ry) > 1e-3;
	                        var endAngle = theta + dTheta;
	                        if (isEllipse) {
	                            ctx.translate(cx, cy);
	                            ctx.rotate(psi);
	                            ctx.scale(scaleX, scaleY);
	                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);
	                            ctx.scale(1 / scaleX, 1 / scaleY);
	                            ctx.rotate(-psi);
	                            ctx.translate(-cx, -cy);
	                        }
	                        else {
	                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);
	                        }
	
	                        if (i == 1) {
	                            // 直接使用 arc 命令
	                            // 第一个命令起点还未定义
	                            x0 = mathCos(theta) * rx + cx;
	                            y0 = mathSin(theta) * ry + cy;
	                        }
	                        xi = mathCos(endAngle) * rx + cx;
	                        yi = mathSin(endAngle) * ry + cy;
	                        break;
	                    case CMD.R:
	                        x0 = xi = d[i];
	                        y0 = yi = d[i + 1];
	                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);
	                        break;
	                    case CMD.Z:
	                        ctx.closePath();
	                        xi = x0;
	                        yi = y0;
	                }
	            }
	        }
	    };
	
	    PathProxy.CMD = CMD;
	
	    return PathProxy;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * 曲线辅助模块
	 * @module zrender/core/curve
	 * @author pissang(https://www.github.com/pissang)
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
	
	    'use strict';
	
	    var vec2 = __webpack_require__(14);
	    var v2Create = vec2.create;
	    var v2DistSquare = vec2.distSquare;
	    var mathPow = Math.pow;
	    var mathSqrt = Math.sqrt;
	
	    var EPSILON = 1e-8;
	    var EPSILON_NUMERIC = 1e-4;
	
	    var THREE_SQRT = mathSqrt(3);
	    var ONE_THIRD = 1 / 3;
	
	    // 临时变量
	    var _v0 = v2Create();
	    var _v1 = v2Create();
	    var _v2 = v2Create();
	    // var _v3 = vec2.create();
	
	    function isAroundZero(val) {
	        return val > -EPSILON && val < EPSILON;
	    }
	    function isNotAroundZero(val) {
	        return val > EPSILON || val < -EPSILON;
	    }
	    /**
	     * 计算三次贝塞尔值
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} t
	     * @return {number}
	     */
	    function cubicAt(p0, p1, p2, p3, t) {
	        var onet = 1 - t;
	        return onet * onet * (onet * p0 + 3 * t * p1)
	             + t * t * (t * p3 + 3 * onet * p2);
	    }
	
	    /**
	     * 计算三次贝塞尔导数值
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} t
	     * @return {number}
	     */
	    function cubicDerivativeAt(p0, p1, p2, p3, t) {
	        var onet = 1 - t;
	        return 3 * (
	            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet
	            + (p3 - p2) * t * t
	        );
	    }
	
	    /**
	     * 计算三次贝塞尔方程根，使用盛金公式
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} val
	     * @param  {Array.<number>} roots
	     * @return {number} 有效根数目
	     */
	    function cubicRootAt(p0, p1, p2, p3, val, roots) {
	        // Evaluate roots of cubic functions
	        var a = p3 + 3 * (p1 - p2) - p0;
	        var b = 3 * (p2 - p1 * 2 + p0);
	        var c = 3 * (p1  - p0);
	        var d = p0 - val;
	
	        var A = b * b - 3 * a * c;
	        var B = b * c - 9 * a * d;
	        var C = c * c - 3 * b * d;
	
	        var n = 0;
	
	        if (isAroundZero(A) && isAroundZero(B)) {
	            if (isAroundZero(b)) {
	                roots[0] = 0;
	            }
	            else {
	                var t1 = -c / b;  //t1, t2, t3, b is not zero
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	            }
	        }
	        else {
	            var disc = B * B - 4 * A * C;
	
	            if (isAroundZero(disc)) {
	                var K = B / A;
	                var t1 = -b / a + K;  // t1, a is not zero
	                var t2 = -K / 2;  // t2, t3
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	                if (t2 >= 0 && t2 <= 1) {
	                    roots[n++] = t2;
	                }
	            }
	            else if (disc > 0) {
	                var discSqrt = mathSqrt(disc);
	                var Y1 = A * b + 1.5 * a * (-B + discSqrt);
	                var Y2 = A * b + 1.5 * a * (-B - discSqrt);
	                if (Y1 < 0) {
	                    Y1 = -mathPow(-Y1, ONE_THIRD);
	                }
	                else {
	                    Y1 = mathPow(Y1, ONE_THIRD);
	                }
	                if (Y2 < 0) {
	                    Y2 = -mathPow(-Y2, ONE_THIRD);
	                }
	                else {
	                    Y2 = mathPow(Y2, ONE_THIRD);
	                }
	                var t1 = (-b - (Y1 + Y2)) / (3 * a);
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	            }
	            else {
	                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));
	                var theta = Math.acos(T) / 3;
	                var ASqrt = mathSqrt(A);
	                var tmp = Math.cos(theta);
	
	                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
	                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
	                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	                if (t2 >= 0 && t2 <= 1) {
	                    roots[n++] = t2;
	                }
	                if (t3 >= 0 && t3 <= 1) {
	                    roots[n++] = t3;
	                }
	            }
	        }
	        return n;
	    }
	
	    /**
	     * 计算三次贝塞尔方程极限值的位置
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {Array.<number>} extrema
	     * @return {number} 有效数目
	     */
	    function cubicExtrema(p0, p1, p2, p3, extrema) {
	        var b = 6 * p2 - 12 * p1 + 6 * p0;
	        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
	        var c = 3 * p1 - 3 * p0;
	
	        var n = 0;
	        if (isAroundZero(a)) {
	            if (isNotAroundZero(b)) {
	                var t1 = -c / b;
	                if (t1 >= 0 && t1 <=1) {
	                    extrema[n++] = t1;
	                }
	            }
	        }
	        else {
	            var disc = b * b - 4 * a * c;
	            if (isAroundZero(disc)) {
	                extrema[0] = -b / (2 * a);
	            }
	            else if (disc > 0) {
	                var discSqrt = mathSqrt(disc);
	                var t1 = (-b + discSqrt) / (2 * a);
	                var t2 = (-b - discSqrt) / (2 * a);
	                if (t1 >= 0 && t1 <= 1) {
	                    extrema[n++] = t1;
	                }
	                if (t2 >= 0 && t2 <= 1) {
	                    extrema[n++] = t2;
	                }
	            }
	        }
	        return n;
	    }
	
	    /**
	     * 细分三次贝塞尔曲线
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} t
	     * @param  {Array.<number>} out
	     */
	    function cubicSubdivide(p0, p1, p2, p3, t, out) {
	        var p01 = (p1 - p0) * t + p0;
	        var p12 = (p2 - p1) * t + p1;
	        var p23 = (p3 - p2) * t + p2;
	
	        var p012 = (p12 - p01) * t + p01;
	        var p123 = (p23 - p12) * t + p12;
	
	        var p0123 = (p123 - p012) * t + p012;
	        // Seg0
	        out[0] = p0;
	        out[1] = p01;
	        out[2] = p012;
	        out[3] = p0123;
	        // Seg1
	        out[4] = p0123;
	        out[5] = p123;
	        out[6] = p23;
	        out[7] = p3;
	    }
	
	    /**
	     * 投射点到三次贝塞尔曲线上，返回投射距离。
	     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {number} x2
	     * @param {number} y2
	     * @param {number} x3
	     * @param {number} y3
	     * @param {number} x
	     * @param {number} y
	     * @param {Array.<number>} [out] 投射点
	     * @return {number}
	     */
	    function cubicProjectPoint(
	        x0, y0, x1, y1, x2, y2, x3, y3,
	        x, y, out
	    ) {
	        // http://pomax.github.io/bezierinfo/#projections
	        var t;
	        var interval = 0.005;
	        var d = Infinity;
	        var prev;
	        var next;
	        var d1;
	        var d2;
	
	        _v0[0] = x;
	        _v0[1] = y;
	
	        // 先粗略估计一下可能的最小距离的 t 值
	        // PENDING
	        for (var _t = 0; _t < 1; _t += 0.05) {
	            _v1[0] = cubicAt(x0, x1, x2, x3, _t);
	            _v1[1] = cubicAt(y0, y1, y2, y3, _t);
	            d1 = v2DistSquare(_v0, _v1);
	            if (d1 < d) {
	                t = _t;
	                d = d1;
	            }
	        }
	        d = Infinity;
	
	        // At most 32 iteration
	        for (var i = 0; i < 32; i++) {
	            if (interval < EPSILON_NUMERIC) {
	                break;
	            }
	            prev = t - interval;
	            next = t + interval;
	            // t - interval
	            _v1[0] = cubicAt(x0, x1, x2, x3, prev);
	            _v1[1] = cubicAt(y0, y1, y2, y3, prev);
	
	            d1 = v2DistSquare(_v1, _v0);
	
	            if (prev >= 0 && d1 < d) {
	                t = prev;
	                d = d1;
	            }
	            else {
	                // t + interval
	                _v2[0] = cubicAt(x0, x1, x2, x3, next);
	                _v2[1] = cubicAt(y0, y1, y2, y3, next);
	                d2 = v2DistSquare(_v2, _v0);
	
	                if (next <= 1 && d2 < d) {
	                    t = next;
	                    d = d2;
	                }
	                else {
	                    interval *= 0.5;
	                }
	            }
	        }
	        // t
	        if (out) {
	            out[0] = cubicAt(x0, x1, x2, x3, t);
	            out[1] = cubicAt(y0, y1, y2, y3, t);
	        }
	        // console.log(interval, i);
	        return mathSqrt(d);
	    }
	
	    /**
	     * 计算二次方贝塞尔值
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} t
	     * @return {number}
	     */
	    function quadraticAt(p0, p1, p2, t) {
	        var onet = 1 - t;
	        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
	    }
	
	    /**
	     * 计算二次方贝塞尔导数值
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} t
	     * @return {number}
	     */
	    function quadraticDerivativeAt(p0, p1, p2, t) {
	        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
	    }
	
	    /**
	     * 计算二次方贝塞尔方程根
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} t
	     * @param  {Array.<number>} roots
	     * @return {number} 有效根数目
	     */
	    function quadraticRootAt(p0, p1, p2, val, roots) {
	        var a = p0 - 2 * p1 + p2;
	        var b = 2 * (p1 - p0);
	        var c = p0 - val;
	
	        var n = 0;
	        if (isAroundZero(a)) {
	            if (isNotAroundZero(b)) {
	                var t1 = -c / b;
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	            }
	        }
	        else {
	            var disc = b * b - 4 * a * c;
	            if (isAroundZero(disc)) {
	                var t1 = -b / (2 * a);
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	            }
	            else if (disc > 0) {
	                var discSqrt = mathSqrt(disc);
	                var t1 = (-b + discSqrt) / (2 * a);
	                var t2 = (-b - discSqrt) / (2 * a);
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	                if (t2 >= 0 && t2 <= 1) {
	                    roots[n++] = t2;
	                }
	            }
	        }
	        return n;
	    }
	
	    /**
	     * 计算二次贝塞尔方程极限值
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @return {number}
	     */
	    function quadraticExtremum(p0, p1, p2) {
	        var divider = p0 + p2 - 2 * p1;
	        if (divider === 0) {
	            // p1 is center of p0 and p2
	            return 0.5;
	        }
	        else {
	            return (p0 - p1) / divider;
	        }
	    }
	
	    /**
	     * 细分二次贝塞尔曲线
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} t
	     * @param  {Array.<number>} out
	     */
	    function quadraticSubdivide(p0, p1, p2, t, out) {
	        var p01 = (p1 - p0) * t + p0;
	        var p12 = (p2 - p1) * t + p1;
	        var p012 = (p12 - p01) * t + p01;
	
	        // Seg0
	        out[0] = p0;
	        out[1] = p01;
	        out[2] = p012;
	
	        // Seg1
	        out[3] = p012;
	        out[4] = p12;
	        out[5] = p2;
	    }
	
	    /**
	     * 投射点到二次贝塞尔曲线上，返回投射距离。
	     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {number} x2
	     * @param {number} y2
	     * @param {number} x
	     * @param {number} y
	     * @param {Array.<number>} out 投射点
	     * @return {number}
	     */
	    function quadraticProjectPoint(
	        x0, y0, x1, y1, x2, y2,
	        x, y, out
	    ) {
	        // http://pomax.github.io/bezierinfo/#projections
	        var t;
	        var interval = 0.005;
	        var d = Infinity;
	
	        _v0[0] = x;
	        _v0[1] = y;
	
	        // 先粗略估计一下可能的最小距离的 t 值
	        // PENDING
	        for (var _t = 0; _t < 1; _t += 0.05) {
	            _v1[0] = quadraticAt(x0, x1, x2, _t);
	            _v1[1] = quadraticAt(y0, y1, y2, _t);
	            var d1 = v2DistSquare(_v0, _v1);
	            if (d1 < d) {
	                t = _t;
	                d = d1;
	            }
	        }
	        d = Infinity;
	
	        // At most 32 iteration
	        for (var i = 0; i < 32; i++) {
	            if (interval < EPSILON_NUMERIC) {
	                break;
	            }
	            var prev = t - interval;
	            var next = t + interval;
	            // t - interval
	            _v1[0] = quadraticAt(x0, x1, x2, prev);
	            _v1[1] = quadraticAt(y0, y1, y2, prev);
	
	            var d1 = v2DistSquare(_v1, _v0);
	
	            if (prev >= 0 && d1 < d) {
	                t = prev;
	                d = d1;
	            }
	            else {
	                // t + interval
	                _v2[0] = quadraticAt(x0, x1, x2, next);
	                _v2[1] = quadraticAt(y0, y1, y2, next);
	                var d2 = v2DistSquare(_v2, _v0);
	                if (next <= 1 && d2 < d) {
	                    t = next;
	                    d = d2;
	                }
	                else {
	                    interval *= 0.5;
	                }
	            }
	        }
	        // t
	        if (out) {
	            out[0] = quadraticAt(x0, x1, x2, t);
	            out[1] = quadraticAt(y0, y1, y2, t);
	        }
	        // console.log(interval, i);
	        return mathSqrt(d);
	    }
	
	    return {
	
	        cubicAt: cubicAt,
	
	        cubicDerivativeAt: cubicDerivativeAt,
	
	        cubicRootAt: cubicRootAt,
	
	        cubicExtrema: cubicExtrema,
	
	        cubicSubdivide: cubicSubdivide,
	
	        cubicProjectPoint: cubicProjectPoint,
	
	        quadraticAt: quadraticAt,
	
	        quadraticDerivativeAt: quadraticDerivativeAt,
	
	        quadraticRootAt: quadraticRootAt,
	
	        quadraticExtremum: quadraticExtremum,
	
	        quadraticSubdivide: quadraticSubdivide,
	
	        quadraticProjectPoint: quadraticProjectPoint
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * @author Yi Shen(https://github.com/pissang)
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var vec2 = __webpack_require__(14);
	    var curve = __webpack_require__(54);
	
	    var bbox = {};
	    var mathMin = Math.min;
	    var mathMax = Math.max;
	    var mathSin = Math.sin;
	    var mathCos = Math.cos;
	
	    var start = vec2.create();
	    var end = vec2.create();
	    var extremity = vec2.create();
	
	    var PI2 = Math.PI * 2;
	    /**
	     * 从顶点数组中计算出最小包围盒，写入`min`和`max`中
	     * @module zrender/core/bbox
	     * @param {Array<Object>} points 顶点数组
	     * @param {number} min
	     * @param {number} max
	     */
	    bbox.fromPoints = function(points, min, max) {
	        if (points.length === 0) {
	            return;
	        }
	        var p = points[0];
	        var left = p[0];
	        var right = p[0];
	        var top = p[1];
	        var bottom = p[1];
	        var i;
	
	        for (i = 1; i < points.length; i++) {
	            p = points[i];
	            left = mathMin(left, p[0]);
	            right = mathMax(right, p[0]);
	            top = mathMin(top, p[1]);
	            bottom = mathMax(bottom, p[1]);
	        }
	
	        min[0] = left;
	        min[1] = top;
	        max[0] = right;
	        max[1] = bottom;
	    };
	
	    /**
	     * @memberOf module:zrender/core/bbox
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {Array.<number>} min
	     * @param {Array.<number>} max
	     */
	    bbox.fromLine = function (x0, y0, x1, y1, min, max) {
	        min[0] = mathMin(x0, x1);
	        min[1] = mathMin(y0, y1);
	        max[0] = mathMax(x0, x1);
	        max[1] = mathMax(y0, y1);
	    };
	
	    var xDim = [];
	    var yDim = [];
	    /**
	     * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中
	     * @memberOf module:zrender/core/bbox
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {number} x2
	     * @param {number} y2
	     * @param {number} x3
	     * @param {number} y3
	     * @param {Array.<number>} min
	     * @param {Array.<number>} max
	     */
	    bbox.fromCubic = function(
	        x0, y0, x1, y1, x2, y2, x3, y3, min, max
	    ) {
	        var cubicExtrema = curve.cubicExtrema;
	        var cubicAt = curve.cubicAt;
	        var i;
	        var n = cubicExtrema(x0, x1, x2, x3, xDim);
	        min[0] = Infinity;
	        min[1] = Infinity;
	        max[0] = -Infinity;
	        max[1] = -Infinity;
	
	        for (i = 0; i < n; i++) {
	            var x = cubicAt(x0, x1, x2, x3, xDim[i]);
	            min[0] = mathMin(x, min[0]);
	            max[0] = mathMax(x, max[0]);
	        }
	        n = cubicExtrema(y0, y1, y2, y3, yDim);
	        for (i = 0; i < n; i++) {
	            var y = cubicAt(y0, y1, y2, y3, yDim[i]);
	            min[1] = mathMin(y, min[1]);
	            max[1] = mathMax(y, max[1]);
	        }
	
	        min[0] = mathMin(x0, min[0]);
	        max[0] = mathMax(x0, max[0]);
	        min[0] = mathMin(x3, min[0]);
	        max[0] = mathMax(x3, max[0]);
	
	        min[1] = mathMin(y0, min[1]);
	        max[1] = mathMax(y0, max[1]);
	        min[1] = mathMin(y3, min[1]);
	        max[1] = mathMax(y3, max[1]);
	    };
	
	    /**
	     * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中
	     * @memberOf module:zrender/core/bbox
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {number} x2
	     * @param {number} y2
	     * @param {Array.<number>} min
	     * @param {Array.<number>} max
	     */
	    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {
	        var quadraticExtremum = curve.quadraticExtremum;
	        var quadraticAt = curve.quadraticAt;
	        // Find extremities, where derivative in x dim or y dim is zero
	        var tx =
	            mathMax(
	                mathMin(quadraticExtremum(x0, x1, x2), 1), 0
	            );
	        var ty =
	            mathMax(
	                mathMin(quadraticExtremum(y0, y1, y2), 1), 0
	            );
	
	        var x = quadraticAt(x0, x1, x2, tx);
	        var y = quadraticAt(y0, y1, y2, ty);
	
	        min[0] = mathMin(x0, x2, x);
	        min[1] = mathMin(y0, y2, y);
	        max[0] = mathMax(x0, x2, x);
	        max[1] = mathMax(y0, y2, y);
	    };
	
	    /**
	     * 从圆弧中计算出最小包围盒，写入`min`和`max`中
	     * @method
	     * @memberOf module:zrender/core/bbox
	     * @param {number} x
	     * @param {number} y
	     * @param {number} rx
	     * @param {number} ry
	     * @param {number} startAngle
	     * @param {number} endAngle
	     * @param {number} anticlockwise
	     * @param {Array.<number>} min
	     * @param {Array.<number>} max
	     */
	    bbox.fromArc = function (
	        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max
	    ) {
	        var vec2Min = vec2.min;
	        var vec2Max = vec2.max;
	
	        var diff = Math.abs(startAngle - endAngle);
	
	
	        if (diff % PI2 < 1e-4 && diff > 1e-4) {
	            // Is a circle
	            min[0] = x - rx;
	            min[1] = y - ry;
	            max[0] = x + rx;
	            max[1] = y + ry;
	            return;
	        }
	
	        start[0] = mathCos(startAngle) * rx + x;
	        start[1] = mathSin(startAngle) * ry + y;
	
	        end[0] = mathCos(endAngle) * rx + x;
	        end[1] = mathSin(endAngle) * ry + y;
	
	        vec2Min(min, start, end);
	        vec2Max(max, start, end);
	
	        // Thresh to [0, Math.PI * 2]
	        startAngle = startAngle % (PI2);
	        if (startAngle < 0) {
	            startAngle = startAngle + PI2;
	        }
	        endAngle = endAngle % (PI2);
	        if (endAngle < 0) {
	            endAngle = endAngle + PI2;
	        }
	
	        if (startAngle > endAngle && !anticlockwise) {
	            endAngle += PI2;
	        }
	        else if (startAngle < endAngle && anticlockwise) {
	            startAngle += PI2;
	        }
	        if (anticlockwise) {
	            var tmp = endAngle;
	            endAngle = startAngle;
	            startAngle = tmp;
	        }
	
	        // var number = 0;
	        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;
	        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
	            if (angle > startAngle) {
	                extremity[0] = mathCos(angle) * rx + x;
	                extremity[1] = mathSin(angle) * ry + y;
	
	                vec2Min(min, extremity, min);
	                vec2Max(max, extremity, max);
	            }
	        }
	    };
	
	    return bbox;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    'use strict';
	
	    var CMD = __webpack_require__(53).CMD;
	    var line = __webpack_require__(57);
	    var cubic = __webpack_require__(58);
	    var quadratic = __webpack_require__(59);
	    var arc = __webpack_require__(60);
	    var normalizeRadian = __webpack_require__(61).normalizeRadian;
	    var curve = __webpack_require__(54);
	
	    var windingLine = __webpack_require__(62);
	
	    var containStroke = line.containStroke;
	
	    var PI2 = Math.PI * 2;
	
	    var EPSILON = 1e-4;
	
	    function isAroundEqual(a, b) {
	        return Math.abs(a - b) < EPSILON;
	    }
	
	    // 临时数组
	    var roots = [-1, -1, -1];
	    var extrema = [-1, -1];
	
	    function swapExtrema() {
	        var tmp = extrema[0];
	        extrema[0] = extrema[1];
	        extrema[1] = tmp;
	    }
	
	    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
	        // Quick reject
	        if (
	            (y > y0 && y > y1 && y > y2 && y > y3)
	            || (y < y0 && y < y1 && y < y2 && y < y3)
	        ) {
	            return 0;
	        }
	        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);
	        if (nRoots === 0) {
	            return 0;
	        }
	        else {
	            var w = 0;
	            var nExtrema = -1;
	            var y0_, y1_;
	            for (var i = 0; i < nRoots; i++) {
	                var t = roots[i];
	
	                // Avoid winding error when intersection point is the connect point of two line of polygon
	                var unit = (t === 0 || t === 1) ? 0.5 : 1;
	
	                var x_ = curve.cubicAt(x0, x1, x2, x3, t);
	                if (x_ < x) { // Quick reject
	                    continue;
	                }
	                if (nExtrema < 0) {
	                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);
	                    if (extrema[1] < extrema[0] && nExtrema > 1) {
	                        swapExtrema();
	                    }
	                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);
	                    if (nExtrema > 1) {
	                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);
	                    }
	                }
	                if (nExtrema == 2) {
	                    // 分成三段单调函数
	                    if (t < extrema[0]) {
	                        w += y0_ < y0 ? unit : -unit;
	                    }
	                    else if (t < extrema[1]) {
	                        w += y1_ < y0_ ? unit : -unit;
	                    }
	                    else {
	                        w += y3 < y1_ ? unit : -unit;
	                    }
	                }
	                else {
	                    // 分成两段单调函数
	                    if (t < extrema[0]) {
	                        w += y0_ < y0 ? unit : -unit;
	                    }
	                    else {
	                        w += y3 < y0_ ? unit : -unit;
	                    }
	                }
	            }
	            return w;
	        }
	    }
	
	    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
	        // Quick reject
	        if (
	            (y > y0 && y > y1 && y > y2)
	            || (y < y0 && y < y1 && y < y2)
	        ) {
	            return 0;
	        }
	        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);
	        if (nRoots === 0) {
	            return 0;
	        }
	        else {
	            var t = curve.quadraticExtremum(y0, y1, y2);
	            if (t >= 0 && t <= 1) {
	                var w = 0;
	                var y_ = curve.quadraticAt(y0, y1, y2, t);
	                for (var i = 0; i < nRoots; i++) {
	                    // Remove one endpoint.
	                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;
	
	                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);
	                    if (x_ < x) {   // Quick reject
	                        continue;
	                    }
	                    if (roots[i] < t) {
	                        w += y_ < y0 ? unit : -unit;
	                    }
	                    else {
	                        w += y2 < y_ ? unit : -unit;
	                    }
	                }
	                return w;
	            }
	            else {
	                // Remove one endpoint.
	                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;
	
	                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);
	                if (x_ < x) {   // Quick reject
	                    return 0;
	                }
	                return y2 < y0 ? unit : -unit;
	            }
	        }
	    }
	
	    // TODO
	    // Arc 旋转
	    function windingArc(
	        cx, cy, r, startAngle, endAngle, anticlockwise, x, y
	    ) {
	        y -= cy;
	        if (y > r || y < -r) {
	            return 0;
	        }
	        var tmp = Math.sqrt(r * r - y * y);
	        roots[0] = -tmp;
	        roots[1] = tmp;
	
	        var diff = Math.abs(startAngle - endAngle);
	        if (diff < 1e-4) {
	            return 0;
	        }
	        if (diff % PI2 < 1e-4) {
	            // Is a circle
	            startAngle = 0;
	            endAngle = PI2;
	            var dir = anticlockwise ? 1 : -1;
	            if (x >= roots[0] + cx && x <= roots[1] + cx) {
	                return dir;
	            } else {
	                return 0;
	            }
	        }
	
	        if (anticlockwise) {
	            var tmp = startAngle;
	            startAngle = normalizeRadian(endAngle);
	            endAngle = normalizeRadian(tmp);
	        }
	        else {
	            startAngle = normalizeRadian(startAngle);
	            endAngle = normalizeRadian(endAngle);
	        }
	        if (startAngle > endAngle) {
	            endAngle += PI2;
	        }
	
	        var w = 0;
	        for (var i = 0; i < 2; i++) {
	            var x_ = roots[i];
	            if (x_ + cx > x) {
	                var angle = Math.atan2(y, x_);
	                var dir = anticlockwise ? 1 : -1;
	                if (angle < 0) {
	                    angle = PI2 + angle;
	                }
	                if (
	                    (angle >= startAngle && angle <= endAngle)
	                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)
	                ) {
	                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
	                        dir = -dir;
	                    }
	                    w += dir;
	                }
	            }
	        }
	        return w;
	    }
	
	    function containPath(data, lineWidth, isStroke, x, y) {
	        var w = 0;
	        var xi = 0;
	        var yi = 0;
	        var x0 = 0;
	        var y0 = 0;
	
	        for (var i = 0; i < data.length;) {
	            var cmd = data[i++];
	            // Begin a new subpath
	            if (cmd === CMD.M && i > 1) {
	                // Close previous subpath
	                if (!isStroke) {
	                    w += windingLine(xi, yi, x0, y0, x, y);
	                }
	                // 如果被任何一个 subpath 包含
	                // if (w !== 0) {
	                //     return true;
	                // }
	            }
	
	            if (i == 1) {
	                // 如果第一个命令是 L, C, Q
	                // 则 previous point 同绘制命令的第一个 point
	                //
	                // 第一个命令为 Arc 的情况下会在后面特殊处理
	                xi = data[i];
	                yi = data[i + 1];
	
	                x0 = xi;
	                y0 = yi;
	            }
	
	            switch (cmd) {
	                case CMD.M:
	                    // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
	                    // 在 closePath 的时候使用
	                    x0 = data[i++];
	                    y0 = data[i++];
	                    xi = x0;
	                    yi = y0;
	                    break;
	                case CMD.L:
	                    if (isStroke) {
	                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {
	                            return true;
	                        }
	                    }
	                    else {
	                        // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN
	                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;
	                    }
	                    xi = data[i++];
	                    yi = data[i++];
	                    break;
	                case CMD.C:
	                    if (isStroke) {
	                        if (cubic.containStroke(xi, yi,
	                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],
	                            lineWidth, x, y
	                        )) {
	                            return true;
	                        }
	                    }
	                    else {
	                        w += windingCubic(
	                            xi, yi,
	                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],
	                            x, y
	                        ) || 0;
	                    }
	                    xi = data[i++];
	                    yi = data[i++];
	                    break;
	                case CMD.Q:
	                    if (isStroke) {
	                        if (quadratic.containStroke(xi, yi,
	                            data[i++], data[i++], data[i], data[i + 1],
	                            lineWidth, x, y
	                        )) {
	                            return true;
	                        }
	                    }
	                    else {
	                        w += windingQuadratic(
	                            xi, yi,
	                            data[i++], data[i++], data[i], data[i + 1],
	                            x, y
	                        ) || 0;
	                    }
	                    xi = data[i++];
	                    yi = data[i++];
	                    break;
	                case CMD.A:
	                    // TODO Arc 判断的开销比较大
	                    var cx = data[i++];
	                    var cy = data[i++];
	                    var rx = data[i++];
	                    var ry = data[i++];
	                    var theta = data[i++];
	                    var dTheta = data[i++];
	                    // TODO Arc 旋转
	                    var psi = data[i++];
	                    var anticlockwise = 1 - data[i++];
	                    var x1 = Math.cos(theta) * rx + cx;
	                    var y1 = Math.sin(theta) * ry + cy;
	                    // 不是直接使用 arc 命令
	                    if (i > 1) {
	                        w += windingLine(xi, yi, x1, y1, x, y);
	                    }
	                    else {
	                        // 第一个命令起点还未定义
	                        x0 = x1;
	                        y0 = y1;
	                    }
	                    // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放
	                    var _x = (x - cx) * ry / rx + cx;
	                    if (isStroke) {
	                        if (arc.containStroke(
	                            cx, cy, ry, theta, theta + dTheta, anticlockwise,
	                            lineWidth, _x, y
	                        )) {
	                            return true;
	                        }
	                    }
	                    else {
	                        w += windingArc(
	                            cx, cy, ry, theta, theta + dTheta, anticlockwise,
	                            _x, y
	                        );
	                    }
	                    xi = Math.cos(theta + dTheta) * rx + cx;
	                    yi = Math.sin(theta + dTheta) * ry + cy;
	                    break;
	                case CMD.R:
	                    x0 = xi = data[i++];
	                    y0 = yi = data[i++];
	                    var width = data[i++];
	                    var height = data[i++];
	                    var x1 = x0 + width;
	                    var y1 = y0 + height;
	                    if (isStroke) {
	                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)
	                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)
	                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)
	                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)
	                        ) {
	                            return true;
	                        }
	                    }
	                    else {
	                        // FIXME Clockwise ?
	                        w += windingLine(x1, y0, x1, y1, x, y);
	                        w += windingLine(x0, y1, x0, y0, x, y);
	                    }
	                    break;
	                case CMD.Z:
	                    if (isStroke) {
	                        if (containStroke(
	                            xi, yi, x0, y0, lineWidth, x, y
	                        )) {
	                            return true;
	                        }
	                    }
	                    else {
	                        // Close a subpath
	                        w += windingLine(xi, yi, x0, y0, x, y);
	                        // 如果被任何一个 subpath 包含
	                        // FIXME subpaths may overlap
	                        // if (w !== 0) {
	                        //     return true;
	                        // }
	                    }
	                    xi = x0;
	                    yi = y0;
	                    break;
	            }
	        }
	        if (!isStroke && !isAroundEqual(yi, y0)) {
	            w += windingLine(xi, yi, x0, y0, x, y) || 0;
	        }
	        return w !== 0;
	    }
	
	    return {
	        contain: function (pathData, x, y) {
	            return containPath(pathData, 0, false, x, y);
	        },
	
	        containStroke: function (pathData, lineWidth, x, y) {
	            return containPath(pathData, lineWidth, true, x, y);
	        }
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return {
	        /**
	         * 线段包含判断
	         * @param  {number}  x0
	         * @param  {number}  y0
	         * @param  {number}  x1
	         * @param  {number}  y1
	         * @param  {number}  lineWidth
	         * @param  {number}  x
	         * @param  {number}  y
	         * @return {boolean}
	         */
	        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {
	            if (lineWidth === 0) {
	                return false;
	            }
	            var _l = lineWidth;
	            var _a = 0;
	            var _b = x0;
	            // Quick reject
	            if (
	                (y > y0 + _l && y > y1 + _l)
	                || (y < y0 - _l && y < y1 - _l)
	                || (x > x0 + _l && x > x1 + _l)
	                || (x < x0 - _l && x < x1 - _l)
	            ) {
	                return false;
	            }
	
	            if (x0 !== x1) {
	                _a = (y0 - y1) / (x0 - x1);
	                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;
	            }
	            else {
	                return Math.abs(x - x0) <= _l / 2;
	            }
	            var tmp = _a * x - y + _b;
	            var _s = tmp * tmp / (_a * _a + 1);
	            return _s <= _l / 2 * _l / 2;
	        }
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var curve = __webpack_require__(54);
	
	    return {
	        /**
	         * 三次贝塞尔曲线描边包含判断
	         * @param  {number}  x0
	         * @param  {number}  y0
	         * @param  {number}  x1
	         * @param  {number}  y1
	         * @param  {number}  x2
	         * @param  {number}  y2
	         * @param  {number}  x3
	         * @param  {number}  y3
	         * @param  {number}  lineWidth
	         * @param  {number}  x
	         * @param  {number}  y
	         * @return {boolean}
	         */
	        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
	            if (lineWidth === 0) {
	                return false;
	            }
	            var _l = lineWidth;
	            // Quick reject
	            if (
	                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)
	                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)
	                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)
	                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)
	            ) {
	                return false;
	            }
	            var d = curve.cubicProjectPoint(
	                x0, y0, x1, y1, x2, y2, x3, y3,
	                x, y, null
	            );
	            return d <= _l / 2;
	        }
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var curve = __webpack_require__(54);
	
	    return {
	        /**
	         * 二次贝塞尔曲线描边包含判断
	         * @param  {number}  x0
	         * @param  {number}  y0
	         * @param  {number}  x1
	         * @param  {number}  y1
	         * @param  {number}  x2
	         * @param  {number}  y2
	         * @param  {number}  lineWidth
	         * @param  {number}  x
	         * @param  {number}  y
	         * @return {boolean}
	         */
	        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
	            if (lineWidth === 0) {
	                return false;
	            }
	            var _l = lineWidth;
	            // Quick reject
	            if (
	                (y > y0 + _l && y > y1 + _l && y > y2 + _l)
	                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)
	                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)
	                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)
	            ) {
	                return false;
	            }
	            var d = curve.quadraticProjectPoint(
	                x0, y0, x1, y1, x2, y2,
	                x, y, null
	            );
	            return d <= _l / 2;
	        }
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var normalizeRadian = __webpack_require__(61).normalizeRadian;
	    var PI2 = Math.PI * 2;
	
	    return {
	        /**
	         * 圆弧描边包含判断
	         * @param  {number}  cx
	         * @param  {number}  cy
	         * @param  {number}  r
	         * @param  {number}  startAngle
	         * @param  {number}  endAngle
	         * @param  {boolean}  anticlockwise
	         * @param  {number} lineWidth
	         * @param  {number}  x
	         * @param  {number}  y
	         * @return {Boolean}
	         */
	        containStroke: function (
	            cx, cy, r, startAngle, endAngle, anticlockwise,
	            lineWidth, x, y
	        ) {
	
	            if (lineWidth === 0) {
	                return false;
	            }
	            var _l = lineWidth;
	
	            x -= cx;
	            y -= cy;
	            var d = Math.sqrt(x * x + y * y);
	
	            if ((d - _l > r) || (d + _l < r)) {
	                return false;
	            }
	            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {
	                // Is a circle
	                return true;
	            }
	            if (anticlockwise) {
	                var tmp = startAngle;
	                startAngle = normalizeRadian(endAngle);
	                endAngle = normalizeRadian(tmp);
	            } else {
	                startAngle = normalizeRadian(startAngle);
	                endAngle = normalizeRadian(endAngle);
	            }
	            if (startAngle > endAngle) {
	                endAngle += PI2;
	            }
	
	            var angle = Math.atan2(y, x);
	            if (angle < 0) {
	                angle += PI2;
	            }
	            return (angle >= startAngle && angle <= endAngle)
	                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);
	        }
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var PI2 = Math.PI * 2;
	    return {
	        normalizeRadian: function(angle) {
	            angle %= PI2;
	            if (angle < 0) {
	                angle += PI2;
	            }
	            return angle;
	        }
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return function windingLine(x0, y0, x1, y1, x, y) {
	        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {
	            return 0;
	        }
	        // Ignore horizontal line
	        if (y1 === y0) {
	            return 0;
	        }
	        var dir = y1 < y0 ? 1 : -1;
	        var t = (y - y0) / (y1 - y0);
	
	        // Avoid winding error when intersection point is the connect point of two line of polygon
	        if (t === 1 || t === 0) {
	            dir = y1 < y0 ? 0.5 : -0.5;
	        }
	
	        var x_ = t * (x1 - x0) + x0;
	
	        return x_ > x ? dir : 0;
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var Pattern = function (image, repeat) {
	        this.image = image;
	        this.repeat = repeat;
	
	        // Can be cloned
	        this.type = 'pattern';
	    };
	
	    Pattern.prototype.getCanvasPattern = function (ctx) {
	
	        return this._canvasPattern
	            || (this._canvasPattern = ctx.createPattern(this.image, this.repeat));
	    };
	
	    return Pattern;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var CMD = __webpack_require__(53).CMD;
	    var vec2 = __webpack_require__(14);
	    var v2ApplyTransform = vec2.applyTransform;
	
	    var points = [[], [], []];
	    var mathSqrt = Math.sqrt;
	    var mathAtan2 = Math.atan2;
	    function transformPath(path, m) {
	        var data = path.data;
	        var cmd;
	        var nPoint;
	        var i;
	        var j;
	        var k;
	        var p;
	
	        var M = CMD.M;
	        var C = CMD.C;
	        var L = CMD.L;
	        var R = CMD.R;
	        var A = CMD.A;
	        var Q = CMD.Q;
	
	        for (i = 0, j = 0; i < data.length;) {
	            cmd = data[i++];
	            j = i;
	            nPoint = 0;
	
	            switch (cmd) {
	                case M:
	                    nPoint = 1;
	                    break;
	                case L:
	                    nPoint = 1;
	                    break;
	                case C:
	                    nPoint = 3;
	                    break;
	                case Q:
	                    nPoint = 2;
	                    break;
	                case A:
	                    var x = m[4];
	                    var y = m[5];
	                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);
	                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);
	                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);
	                    // cx
	                    data[i++] += x;
	                    // cy
	                    data[i++] += y;
	                    // Scale rx and ry
	                    // FIXME Assume psi is 0 here
	                    data[i++] *= sx;
	                    data[i++] *= sy;
	
	                    // Start angle
	                    data[i++] += angle;
	                    // end angle
	                    data[i++] += angle;
	                    // FIXME psi
	                    i += 2;
	                    j = i;
	                    break;
	                case R:
	                    // x0, y0
	                    p[0] = data[i++];
	                    p[1] = data[i++];
	                    v2ApplyTransform(p, p, m);
	                    data[j++] = p[0];
	                    data[j++] = p[1];
	                    // x1, y1
	                    p[0] += data[i++];
	                    p[1] += data[i++];
	                    v2ApplyTransform(p, p, m);
	                    data[j++] = p[0];
	                    data[j++] = p[1];
	            }
	
	            for (k = 0; k < nPoint; k++) {
	                var p = points[k];
	                p[0] = data[i++];
	                p[1] = data[i++];
	
	                v2ApplyTransform(p, p, m);
	                // Write back
	                data[j++] = p[0];
	                data[j++] = p[1];
	            }
	        }
	    }
	
	    return transformPath;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    /**
	     * @param {Array.<Object>} colorStops
	     */
	    var Gradient = function (colorStops) {
	
	        this.colorStops = colorStops || [];
	    };
	
	    Gradient.prototype = {
	
	        constructor: Gradient,
	
	        addColorStop: function (offset, color) {
	            this.colorStops.push({
	
	                offset: offset,
	
	                color: color
	            });
	        }
	    };
	
	    return Gradient;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Image element
	 * @module zrender/graphic/Image
	 */
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var Displayable = __webpack_require__(50);
	    var BoundingRect = __webpack_require__(13);
	    var zrUtil = __webpack_require__(8);
	
	    var LRU = __webpack_require__(67);
	    var globalImageCache = new LRU(50);
	    /**
	     * @alias zrender/graphic/Image
	     * @extends module:zrender/graphic/Displayable
	     * @constructor
	     * @param {Object} opts
	     */
	    function ZImage(opts) {
	        Displayable.call(this, opts);
	    }
	
	    ZImage.prototype = {
	
	        constructor: ZImage,
	
	        type: 'image',
	
	        brush: function (ctx, prevEl) {
	            var style = this.style;
	            var src = style.image;
	            var image;
	
	            // Must bind each time
	            style.bind(ctx, this, prevEl);
	            // style.image is a url string
	            if (typeof src === 'string') {
	                image = this._image;
	            }
	            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas
	            else {
	                image = src;
	            }
	            // FIXME Case create many images with src
	            if (!image && src) {
	                // Try get from global image cache
	                var cachedImgObj = globalImageCache.get(src);
	                if (!cachedImgObj) {
	                    // Create a new image
	                    image = new Image();
	                    image.onload = function () {
	                        image.onload = null;
	                        for (var i = 0; i < cachedImgObj.pending.length; i++) {
	                            cachedImgObj.pending[i].dirty();
	                        }
	                    };
	                    cachedImgObj = {
	                        image: image,
	                        pending: [this]
	                    };
	                    image.src = src;
	                    globalImageCache.put(src, cachedImgObj);
	                    this._image = image;
	                    return;
	                }
	                else {
	                    image = cachedImgObj.image;
	                    this._image = image;
	                    // Image is not complete finish, add to pending list
	                    if (!image.width || !image.height) {
	                        cachedImgObj.pending.push(this);
	                        return;
	                    }
	                }
	            }
	
	            if (image) {
	                // 图片已经加载完成
	                // if (image.nodeName.toUpperCase() == 'IMG') {
	                //     if (!image.complete) {
	                //         return;
	                //     }
	                // }
	                // Else is canvas
	
	                var width = style.width || image.width;
	                var height = style.height || image.height;
	                var x = style.x || 0;
	                var y = style.y || 0;
	                // 图片加载失败
	                if (!image.width || !image.height) {
	                    return;
	                }
	
	                // 设置transform
	                this.setTransform(ctx);
	
	
	                if (style.sWidth && style.sHeight) {
	                    var sx = style.sx || 0;
	                    var sy = style.sy || 0;
	                    ctx.drawImage(
	                        image,
	                        sx, sy, style.sWidth, style.sHeight,
	                        x, y, width, height
	                    );
	                }
	                else if (style.sx && style.sy) {
	                    var sx = style.sx;
	                    var sy = style.sy;
	                    var sWidth = width - sx;
	                    var sHeight = height - sy;
	                    ctx.drawImage(
	                        image,
	                        sx, sy, sWidth, sHeight,
	                        x, y, width, height
	                    );
	                }
	                else {
	                    ctx.drawImage(image, x, y, width, height);
	                }
	
	                // 如果没设置宽和高的话自动根据图片宽高设置
	                if (style.width == null) {
	                    style.width = width;
	                }
	                if (style.height == null) {
	                    style.height = height;
	                }
	
	                this.restoreTransform(ctx);
	
	                // Draw rect text
	                if (style.text != null) {
	                    this.drawRectText(ctx, this.getBoundingRect());
	                }
	
	            }
	        },
	
	        getBoundingRect: function () {
	            var style = this.style;
	            if (! this._rect) {
	                this._rect = new BoundingRect(
	                    style.x || 0, style.y || 0, style.width || 0, style.height || 0
	                );
	            }
	            return this._rect;
	        }
	    };
	
	    zrUtil.inherits(ZImage, Displayable);
	
	    return ZImage;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;// Simple LRU cache use doubly linked list
	// @module zrender/core/LRU
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
	
	    /**
	     * Simple double linked list. Compared with array, it has O(1) remove operation.
	     * @constructor
	     */
	    var LinkedList = function() {
	
	        /**
	         * @type {module:zrender/core/LRU~Entry}
	         */
	        this.head = null;
	
	        /**
	         * @type {module:zrender/core/LRU~Entry}
	         */
	        this.tail = null;
	
	        this._len = 0;
	    };
	
	    var linkedListProto = LinkedList.prototype;
	    /**
	     * Insert a new value at the tail
	     * @param  {} val
	     * @return {module:zrender/core/LRU~Entry}
	     */
	    linkedListProto.insert = function(val) {
	        var entry = new Entry(val);
	        this.insertEntry(entry);
	        return entry;
	    };
	
	    /**
	     * Insert an entry at the tail
	     * @param  {module:zrender/core/LRU~Entry} entry
	     */
	    linkedListProto.insertEntry = function(entry) {
	        if (!this.head) {
	            this.head = this.tail = entry;
	        }
	        else {
	            this.tail.next = entry;
	            entry.prev = this.tail;
	            this.tail = entry;
	        }
	        this._len++;
	    };
	
	    /**
	     * Remove entry.
	     * @param  {module:zrender/core/LRU~Entry} entry
	     */
	    linkedListProto.remove = function(entry) {
	        var prev = entry.prev;
	        var next = entry.next;
	        if (prev) {
	            prev.next = next;
	        }
	        else {
	            // Is head
	            this.head = next;
	        }
	        if (next) {
	            next.prev = prev;
	        }
	        else {
	            // Is tail
	            this.tail = prev;
	        }
	        entry.next = entry.prev = null;
	        this._len--;
	    };
	
	    /**
	     * @return {number}
	     */
	    linkedListProto.len = function() {
	        return this._len;
	    };
	
	    /**
	     * @constructor
	     * @param {} val
	     */
	    var Entry = function(val) {
	        /**
	         * @type {}
	         */
	        this.value = val;
	
	        /**
	         * @type {module:zrender/core/LRU~Entry}
	         */
	        this.next;
	
	        /**
	         * @type {module:zrender/core/LRU~Entry}
	         */
	        this.prev;
	    };
	
	    /**
	     * LRU Cache
	     * @constructor
	     * @alias module:zrender/core/LRU
	     */
	    var LRU = function(maxSize) {
	
	        this._list = new LinkedList();
	
	        this._map = {};
	
	        this._maxSize = maxSize || 10;
	    };
	
	    var LRUProto = LRU.prototype;
	
	    /**
	     * @param  {string} key
	     * @param  {} value
	     */
	    LRUProto.put = function(key, value) {
	        var list = this._list;
	        var map = this._map;
	        if (map[key] == null) {
	            var len = list.len();
	            if (len >= this._maxSize && len > 0) {
	                // Remove the least recently used
	                var leastUsedEntry = list.head;
	                list.remove(leastUsedEntry);
	                delete map[leastUsedEntry.key];
	            }
	
	            var entry = list.insert(value);
	            entry.key = key;
	            map[key] = entry;
	        }
	    };
	
	    /**
	     * @param  {string} key
	     * @return {}
	     */
	    LRUProto.get = function(key) {
	        var entry = this._map[key];
	        var list = this._list;
	        if (entry != null) {
	            // Put the latest used entry in the tail
	            if (entry !== list.tail) {
	                list.remove(entry);
	                list.insertEntry(entry);
	            }
	
	            return entry.value;
	        }
	    };
	
	    /**
	     * Clear the cache
	     */
	    LRUProto.clear = function() {
	        this._list.clear();
	        this._map = {};
	    };
	
	    return LRU;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Text element
	 * @module zrender/graphic/Text
	 *
	 * TODO Wrapping
	 *
	 * Text not support gradient
	 */
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var Displayable = __webpack_require__(50);
	    var zrUtil = __webpack_require__(8);
	    var textContain = __webpack_require__(12);
	
	    /**
	     * @alias zrender/graphic/Text
	     * @extends module:zrender/graphic/Displayable
	     * @constructor
	     * @param {Object} opts
	     */
	    var Text = function (opts) {
	        Displayable.call(this, opts);
	    };
	
	    Text.prototype = {
	
	        constructor: Text,
	
	        type: 'text',
	
	        brush: function (ctx, prevEl) {
	            var style = this.style;
	            var x = style.x || 0;
	            var y = style.y || 0;
	            // Convert to string
	            var text = style.text;
	
	            // Convert to string
	            text != null && (text += '');
	
	            // Always bind style
	            style.bind(ctx, this, prevEl);
	
	            if (text) {
	
	                this.setTransform(ctx);
	
	                var textBaseline;
	                var textAlign = style.textAlign;
	                var font = style.textFont || style.font;
	                if (style.textVerticalAlign) {
	                    var rect = textContain.getBoundingRect(
	                        text, font, style.textAlign, 'top'
	                    );
	                    // Ignore textBaseline
	                    textBaseline = 'middle';
	                    switch (style.textVerticalAlign) {
	                        case 'middle':
	                            y -= rect.height / 2 - rect.lineHeight / 2;
	                            break;
	                        case 'bottom':
	                            y -= rect.height - rect.lineHeight / 2;
	                            break;
	                        default:
	                            y += rect.lineHeight / 2;
	                    }
	                }
	                else {
	                    textBaseline = style.textBaseline;
	                }
	
	                // TODO Invalid font
	                ctx.font = font || '12px sans-serif';
	                ctx.textAlign = textAlign || 'left';
	                // Use canvas default left textAlign. Giving invalid value will cause state not change
	                if (ctx.textAlign !== textAlign) {
	                    ctx.textAlign = 'left';
	                }
	                ctx.textBaseline = textBaseline || 'alphabetic';
	                // Use canvas default alphabetic baseline
	                if (ctx.textBaseline !== textBaseline) {
	                    ctx.textBaseline = 'alphabetic';
	                }
	
	                var lineHeight = textContain.measureText('国', ctx.font).width;
	
	                var textLines = text.split('\n');
	                for (var i = 0; i < textLines.length; i++) {
	                    style.hasFill() && ctx.fillText(textLines[i], x, y);
	                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);
	                    y += lineHeight;
	                }
	
	                this.restoreTransform(ctx);
	            }
	        },
	
	        getBoundingRect: function () {
	            if (!this._rect) {
	                var style = this.style;
	                var textVerticalAlign = style.textVerticalAlign;
	                var rect = textContain.getBoundingRect(
	                    style.text + '', style.textFont || style.font, style.textAlign,
	                    textVerticalAlign ? 'top' : style.textBaseline
	                );
	                switch (textVerticalAlign) {
	                    case 'middle':
	                        rect.y -= rect.height / 2;
	                        break;
	                    case 'bottom':
	                        rect.y -= rect.height;
	                        break;
	                }
	                rect.x += style.x || 0;
	                rect.y += style.y || 0;
	                this._rect = rect;
	            }
	            return this._rect;
	        }
	    };
	
	    zrUtil.inherits(Text, Displayable);
	
	    return Text;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * 圆形
	 * @module zrender/shape/Circle
	 */
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	    'use strict';
	
	    return __webpack_require__(49).extend({
	
	        type: 'circle',
	
	        shape: {
	            cx: 0,
	            cy: 0,
	            r: 0
	        },
	
	
	        buildPath : function (ctx, shape, inBundle) {
	            // Better stroking in ShapeBundle
	            // Always do it may have performence issue ( fill may be 2x more cost)
	            if (inBundle) {
	                ctx.moveTo(shape.cx + shape.r, shape.cy);
	            }
	            // Better stroking in ShapeBundle
	            // ctx.moveTo(shape.cx + shape.r, shape.cy);
	            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);
	        }
	    });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * 扇形
	 * @module zrender/graphic/shape/Sector
	 */
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    return __webpack_require__(49).extend({
	
	        type: 'sector',
	
	        shape: {
	
	            cx: 0,
	
	            cy: 0,
	
	            r0: 0,
	
	            r: 0,
	
	            startAngle: 0,
	
	            endAngle: Math.PI * 2,
	
	            clockwise: true
	        },
	
	        buildPath: function (ctx, shape) {
	
	            var x = shape.cx;
	            var y = shape.cy;
	            var r0 = Math.max(shape.r0 || 0, 0);
	            var r = Math.max(shape.r, 0);
	            var startAngle = shape.startAngle;
	            var endAngle = shape.endAngle;
	            var clockwise = shape.clockwise;
	
	            var unitX = Math.cos(startAngle);
	            var unitY = Math.sin(startAngle);
	
	            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);
	
	            ctx.lineTo(unitX * r + x, unitY * r + y);
	
	            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
	
	            ctx.lineTo(
	                Math.cos(endAngle) * r0 + x,
	                Math.sin(endAngle) * r0 + y
	            );
	
	            if (r0 !== 0) {
	                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
	            }
	
	            ctx.closePath();
	        }
	    });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * 圆环
	 * @module zrender/graphic/shape/Ring
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    return __webpack_require__(49).extend({
	
	        type: 'ring',
	
	        shape: {
	            cx: 0,
	            cy: 0,
	            r: 0,
	            r0: 0
	        },
	
	        buildPath: function (ctx, shape) {
	            var x = shape.cx;
	            var y = shape.cy;
	            var PI2 = Math.PI * 2;
	            ctx.moveTo(x + shape.r, y);
	            ctx.arc(x, y, shape.r, 0, PI2, false);
	            ctx.moveTo(x + shape.r0, y);
	            ctx.arc(x, y, shape.r0, 0, PI2, true);
	        }
	    });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * 多边形
	 * @module zrender/shape/Polygon
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var polyHelper = __webpack_require__(73);
	
	    return __webpack_require__(49).extend({
	        
	        type: 'polygon',
	
	        shape: {
	            points: null,
	
	            smooth: false,
	
	            smoothConstraint: null
	        },
	
	        buildPath: function (ctx, shape) {
	            polyHelper.buildPath(ctx, shape, true);
	        }
	    });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var smoothSpline = __webpack_require__(74);
	    var smoothBezier = __webpack_require__(75);
	
	    return {
	        buildPath: function (ctx, shape, closePath) {
	            var points = shape.points;
	            var smooth = shape.smooth;
	            if (points && points.length >= 2) {
	                if (smooth && smooth !== 'spline') {
	                    var controlPoints = smoothBezier(
	                        points, smooth, closePath, shape.smoothConstraint
	                    );
	
	                    ctx.moveTo(points[0][0], points[0][1]);
	                    var len = points.length;
	                    for (var i = 0; i < (closePath ? len : len - 1); i++) {
	                        var cp1 = controlPoints[i * 2];
	                        var cp2 = controlPoints[i * 2 + 1];
	                        var p = points[(i + 1) % len];
	                        ctx.bezierCurveTo(
	                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]
	                        );
	                    }
	                }
	                else {
	                    if (smooth === 'spline') {
	                        points = smoothSpline(points, closePath);
	                    }
	
	                    ctx.moveTo(points[0][0], points[0][1]);
	                    for (var i = 1, l = points.length; i < l; i++) {
	                        ctx.lineTo(points[i][0], points[i][1]);
	                    }
	                }
	
	                closePath && ctx.closePath();
	            }
	        }
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Catmull-Rom spline 插值折线
	 * @module zrender/shape/util/smoothSpline
	 * @author pissang (https://www.github.com/pissang)
	 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	    var vec2 = __webpack_require__(14);
	
	    /**
	     * @inner
	     */
	    function interpolate(p0, p1, p2, p3, t, t2, t3) {
	        var v0 = (p2 - p0) * 0.5;
	        var v1 = (p3 - p1) * 0.5;
	        return (2 * (p1 - p2) + v0 + v1) * t3
	                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2
	                + v0 * t + p1;
	    }
	
	    /**
	     * @alias module:zrender/shape/util/smoothSpline
	     * @param {Array} points 线段顶点数组
	     * @param {boolean} isLoop
	     * @return {Array}
	     */
	    return function (points, isLoop) {
	        var len = points.length;
	        var ret = [];
	
	        var distance = 0;
	        for (var i = 1; i < len; i++) {
	            distance += vec2.distance(points[i - 1], points[i]);
	        }
	
	        var segs = distance / 2;
	        segs = segs < len ? len : segs;
	        for (var i = 0; i < segs; i++) {
	            var pos = i / (segs - 1) * (isLoop ? len : len - 1);
	            var idx = Math.floor(pos);
	
	            var w = pos - idx;
	
	            var p0;
	            var p1 = points[idx % len];
	            var p2;
	            var p3;
	            if (!isLoop) {
	                p0 = points[idx === 0 ? idx : idx - 1];
	                p2 = points[idx > len - 2 ? len - 1 : idx + 1];
	                p3 = points[idx > len - 3 ? len - 1 : idx + 2];
	            }
	            else {
	                p0 = points[(idx - 1 + len) % len];
	                p2 = points[(idx + 1) % len];
	                p3 = points[(idx + 2) % len];
	            }
	
	            var w2 = w * w;
	            var w3 = w * w2;
	
	            ret.push([
	                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),
	                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)
	            ]);
	        }
	        return ret;
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * 贝塞尔平滑曲线
	 * @module zrender/shape/util/smoothBezier
	 * @author pissang (https://www.github.com/pissang)
	 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var vec2 = __webpack_require__(14);
	    var v2Min = vec2.min;
	    var v2Max = vec2.max;
	    var v2Scale = vec2.scale;
	    var v2Distance = vec2.distance;
	    var v2Add = vec2.add;
	
	    /**
	     * 贝塞尔平滑曲线
	     * @alias module:zrender/shape/util/smoothBezier
	     * @param {Array} points 线段顶点数组
	     * @param {number} smooth 平滑等级, 0-1
	     * @param {boolean} isLoop
	     * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内
	     *                           比如 [[0, 0], [100, 100]], 这个包围盒会与
	     *                           整个折线的包围盒做一个并集用来约束控制点。
	     * @param {Array} 计算出来的控制点数组
	     */
	    return function (points, smooth, isLoop, constraint) {
	        var cps = [];
	
	        var v = [];
	        var v1 = [];
	        var v2 = [];
	        var prevPoint;
	        var nextPoint;
	
	        var min, max;
	        if (constraint) {
	            min = [Infinity, Infinity];
	            max = [-Infinity, -Infinity];
	            for (var i = 0, len = points.length; i < len; i++) {
	                v2Min(min, min, points[i]);
	                v2Max(max, max, points[i]);
	            }
	            // 与指定的包围盒做并集
	            v2Min(min, min, constraint[0]);
	            v2Max(max, max, constraint[1]);
	        }
	
	        for (var i = 0, len = points.length; i < len; i++) {
	            var point = points[i];
	
	            if (isLoop) {
	                prevPoint = points[i ? i - 1 : len - 1];
	                nextPoint = points[(i + 1) % len];
	            }
	            else {
	                if (i === 0 || i === len - 1) {
	                    cps.push(vec2.clone(points[i]));
	                    continue;
	                }
	                else {
	                    prevPoint = points[i - 1];
	                    nextPoint = points[i + 1];
	                }
	            }
	
	            vec2.sub(v, nextPoint, prevPoint);
	
	            // use degree to scale the handle length
	            v2Scale(v, v, smooth);
	
	            var d0 = v2Distance(point, prevPoint);
	            var d1 = v2Distance(point, nextPoint);
	            var sum = d0 + d1;
	            if (sum !== 0) {
	                d0 /= sum;
	                d1 /= sum;
	            }
	
	            v2Scale(v1, v, -d0);
	            v2Scale(v2, v, d1);
	            var cp0 = v2Add([], point, v1);
	            var cp1 = v2Add([], point, v2);
	            if (constraint) {
	                v2Max(cp0, cp0, min);
	                v2Min(cp0, cp0, max);
	                v2Max(cp1, cp1, min);
	                v2Min(cp1, cp1, max);
	            }
	            cps.push(cp0);
	            cps.push(cp1);
	        }
	
	        if (isLoop) {
	            cps.push(cps.shift());
	        }
	
	        return cps;
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * @module zrender/graphic/shape/Polyline
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var polyHelper = __webpack_require__(73);
	
	    return __webpack_require__(49).extend({
	        
	        type: 'polyline',
	
	        shape: {
	            points: null,
	
	            smooth: false,
	
	            smoothConstraint: null
	        },
	
	        style: {
	            stroke: '#000',
	
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	            polyHelper.buildPath(ctx, shape, false);
	        }
	    });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * 矩形
	 * @module zrender/graphic/shape/Rect
	 */
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	    var roundRectHelper = __webpack_require__(78);
	
	    return __webpack_require__(49).extend({
	
	        type: 'rect',
	
	        shape: {
	            // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4
	            // r缩写为1         相当于 [1, 1, 1, 1]
	            // r缩写为[1]       相当于 [1, 1, 1, 1]
	            // r缩写为[1, 2]    相当于 [1, 2, 1, 2]
	            // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]
	            r: 0,
	
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	        },
	
	        buildPath: function (ctx, shape) {
	            var x = shape.x;
	            var y = shape.y;
	            var width = shape.width;
	            var height = shape.height;
	            if (!shape.r) {
	                ctx.rect(x, y, width, height);
	            }
	            else {
	                roundRectHelper.buildPath(ctx, shape);
	            }
	            ctx.closePath();
	            return;
	        }
	    });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    return {
	        buildPath: function (ctx, shape) {
	            var x = shape.x;
	            var y = shape.y;
	            var width = shape.width;
	            var height = shape.height;
	            var r = shape.r;
	            var r1;
	            var r2;
	            var r3;
	            var r4;
	
	            // Convert width and height to positive for better borderRadius
	            if (width < 0) {
	                x = x + width;
	                width = -width;
	            }
	            if (height < 0) {
	                y = y + height;
	                height = -height;
	            }
	
	            if (typeof r === 'number') {
	                r1 = r2 = r3 = r4 = r;
	            }
	            else if (r instanceof Array) {
	                if (r.length === 1) {
	                    r1 = r2 = r3 = r4 = r[0];
	                }
	                else if (r.length === 2) {
	                    r1 = r3 = r[0];
	                    r2 = r4 = r[1];
	                }
	                else if (r.length === 3) {
	                    r1 = r[0];
	                    r2 = r4 = r[1];
	                    r3 = r[2];
	                }
	                else {
	                    r1 = r[0];
	                    r2 = r[1];
	                    r3 = r[2];
	                    r4 = r[3];
	                }
	            }
	            else {
	                r1 = r2 = r3 = r4 = 0;
	            }
	
	            var total;
	            if (r1 + r2 > width) {
	                total = r1 + r2;
	                r1 *= width / total;
	                r2 *= width / total;
	            }
	            if (r3 + r4 > width) {
	                total = r3 + r4;
	                r3 *= width / total;
	                r4 *= width / total;
	            }
	            if (r2 + r3 > height) {
	                total = r2 + r3;
	                r2 *= height / total;
	                r3 *= height / total;
	            }
	            if (r1 + r4 > height) {
	                total = r1 + r4;
	                r1 *= height / total;
	                r4 *= height / total;
	            }
	            ctx.moveTo(x + r1, y);
	            ctx.lineTo(x + width - r2, y);
	            r2 !== 0 && ctx.quadraticCurveTo(
	                x + width, y, x + width, y + r2
	            );
	            ctx.lineTo(x + width, y + height - r3);
	            r3 !== 0 && ctx.quadraticCurveTo(
	                x + width, y + height, x + width - r3, y + height
	            );
	            ctx.lineTo(x + r4, y + height);
	            r4 !== 0 && ctx.quadraticCurveTo(
	                x, y + height, x, y + height - r4
	            );
	            ctx.lineTo(x, y + r1);
	            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);
	        }
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * 直线
	 * @module zrender/graphic/shape/Line
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	    return __webpack_require__(49).extend({
	
	        type: 'line',
	
	        shape: {
	            // Start point
	            x1: 0,
	            y1: 0,
	            // End point
	            x2: 0,
	            y2: 0,
	
	            percent: 1
	        },
	
	        style: {
	            stroke: '#000',
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	            var x1 = shape.x1;
	            var y1 = shape.y1;
	            var x2 = shape.x2;
	            var y2 = shape.y2;
	            var percent = shape.percent;
	
	            if (percent === 0) {
	                return;
	            }
	
	            ctx.moveTo(x1, y1);
	
	            if (percent < 1) {
	                x2 = x1 * (1 - percent) + x2 * percent;
	                y2 = y1 * (1 - percent) + y2 * percent;
	            }
	            ctx.lineTo(x2, y2);
	        },
	
	        /**
	         * Get point at percent
	         * @param  {number} percent
	         * @return {Array.<number>}
	         */
	        pointAt: function (p) {
	            var shape = this.shape;
	            return [
	                shape.x1 * (1 - p) + shape.x2 * p,
	                shape.y1 * (1 - p) + shape.y2 * p
	            ];
	        }
	    });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * 贝塞尔曲线
	 * @module zrender/shape/BezierCurve
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	    'use strict';
	
	    var curveTool = __webpack_require__(54);
	    var vec2 = __webpack_require__(14);
	    var quadraticSubdivide = curveTool.quadraticSubdivide;
	    var cubicSubdivide = curveTool.cubicSubdivide;
	    var quadraticAt = curveTool.quadraticAt;
	    var cubicAt = curveTool.cubicAt;
	    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;
	    var cubicDerivativeAt = curveTool.cubicDerivativeAt;
	
	    var out = [];
	
	    function someVectorAt(shape, t, isTangent) {
	        var cpx2 = shape.cpx2;
	        var cpy2 = shape.cpy2;
	        if (cpx2 === null || cpy2 === null) {
	            return [
	                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),
	                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)
	            ];
	        }
	        else {
	            return [
	                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),
	                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)
	            ];
	        }
	    }
	    return __webpack_require__(49).extend({
	
	        type: 'bezier-curve',
	
	        shape: {
	            x1: 0,
	            y1: 0,
	            x2: 0,
	            y2: 0,
	            cpx1: 0,
	            cpy1: 0,
	            // cpx2: 0,
	            // cpy2: 0
	
	            // Curve show percent, for animating
	            percent: 1
	        },
	
	        style: {
	            stroke: '#000',
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	            var x1 = shape.x1;
	            var y1 = shape.y1;
	            var x2 = shape.x2;
	            var y2 = shape.y2;
	            var cpx1 = shape.cpx1;
	            var cpy1 = shape.cpy1;
	            var cpx2 = shape.cpx2;
	            var cpy2 = shape.cpy2;
	            var percent = shape.percent;
	            if (percent === 0) {
	                return;
	            }
	
	            ctx.moveTo(x1, y1);
	
	            if (cpx2 == null || cpy2 == null) {
	                if (percent < 1) {
	                    quadraticSubdivide(
	                        x1, cpx1, x2, percent, out
	                    );
	                    cpx1 = out[1];
	                    x2 = out[2];
	                    quadraticSubdivide(
	                        y1, cpy1, y2, percent, out
	                    );
	                    cpy1 = out[1];
	                    y2 = out[2];
	                }
	
	                ctx.quadraticCurveTo(
	                    cpx1, cpy1,
	                    x2, y2
	                );
	            }
	            else {
	                if (percent < 1) {
	                    cubicSubdivide(
	                        x1, cpx1, cpx2, x2, percent, out
	                    );
	                    cpx1 = out[1];
	                    cpx2 = out[2];
	                    x2 = out[3];
	                    cubicSubdivide(
	                        y1, cpy1, cpy2, y2, percent, out
	                    );
	                    cpy1 = out[1];
	                    cpy2 = out[2];
	                    y2 = out[3];
	                }
	                ctx.bezierCurveTo(
	                    cpx1, cpy1,
	                    cpx2, cpy2,
	                    x2, y2
	                );
	            }
	        },
	
	        /**
	         * Get point at percent
	         * @param  {number} t
	         * @return {Array.<number>}
	         */
	        pointAt: function (t) {
	            return someVectorAt(this.shape, t, false);
	        },
	
	        /**
	         * Get tangent at percent
	         * @param  {number} t
	         * @return {Array.<number>}
	         */
	        tangentAt: function (t) {
	            var p = someVectorAt(this.shape, t, true);
	            return vec2.normalize(p, p);
	        }
	    });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * 圆弧
	 * @module zrender/graphic/shape/Arc
	 */
	 !(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    return __webpack_require__(49).extend({
	
	        type: 'arc',
	
	        shape: {
	
	            cx: 0,
	
	            cy: 0,
	
	            r: 0,
	
	            startAngle: 0,
	
	            endAngle: Math.PI * 2,
	
	            clockwise: true
	        },
	
	        style: {
	
	            stroke: '#000',
	
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	
	            var x = shape.cx;
	            var y = shape.cy;
	            var r = Math.max(shape.r, 0);
	            var startAngle = shape.startAngle;
	            var endAngle = shape.endAngle;
	            var clockwise = shape.clockwise;
	
	            var unitX = Math.cos(startAngle);
	            var unitY = Math.sin(startAngle);
	
	            ctx.moveTo(unitX * r + x, unitY * r + y);
	            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
	        }
	    });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;// CompoundPath to improve performance
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var Path = __webpack_require__(49);
	    return Path.extend({
	
	        type: 'compound',
	
	        shape: {
	
	            paths: null
	        },
	
	        _updatePathDirty: function () {
	            var dirtyPath = this.__dirtyPath;
	            var paths = this.shape.paths;
	            for (var i = 0; i < paths.length; i++) {
	                // Mark as dirty if any subpath is dirty
	                dirtyPath = dirtyPath || paths[i].__dirtyPath;
	            }
	            this.__dirtyPath = dirtyPath;
	            this.__dirty = this.__dirty || dirtyPath;
	        },
	
	        beforeBrush: function () {
	            this._updatePathDirty();
	            var paths = this.shape.paths || [];
	            var scale = this.getGlobalScale();
	            // Update path scale
	            for (var i = 0; i < paths.length; i++) {
	                paths[i].path.setScale(scale[0], scale[1]);
	            }
	        },
	
	        buildPath: function (ctx, shape) {
	            var paths = shape.paths || [];
	            for (var i = 0; i < paths.length; i++) {
	                paths[i].buildPath(ctx, paths[i].shape, true);
	            }
	        },
	
	        afterBrush: function () {
	            var paths = this.shape.paths;
	            for (var i = 0; i < paths.length; i++) {
	                paths[i].__dirtyPath = false;
	            }
	        },
	
	        getBoundingRect: function () {
	            this._updatePathDirty();
	            return Path.prototype.getBoundingRect.call(this);
	        }
	    });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
	    'use strict';
	
	    var zrUtil = __webpack_require__(8);
	
	    var Gradient = __webpack_require__(65);
	
	    /**
	     * x, y, x2, y2 are all percent from 0 to 1
	     * @param {number} [x=0]
	     * @param {number} [y=0]
	     * @param {number} [x2=1]
	     * @param {number} [y2=0]
	     * @param {Array.<Object>} colorStops
	     * @param {boolean} [globalCoord=false]
	     */
	    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {
	        this.x = x == null ? 0 : x;
	
	        this.y = y == null ? 0 : y;
	
	        this.x2 = x2 == null ? 1 : x2;
	
	        this.y2 = y2 == null ? 0 : y2;
	
	        // Can be cloned
	        this.type = 'linear';
	
	        // If use global coord
	        this.global = globalCoord || false;
	
	        Gradient.call(this, colorStops);
	    };
	
	    LinearGradient.prototype = {
	
	        constructor: LinearGradient
	    };
	
	    zrUtil.inherits(LinearGradient, Gradient);
	
	    return LinearGradient;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
	    'use strict';
	
	    var zrUtil = __webpack_require__(8);
	
	    var Gradient = __webpack_require__(65);
	
	    /**
	     * x, y, r are all percent from 0 to 1
	     * @param {number} [x=0.5]
	     * @param {number} [y=0.5]
	     * @param {number} [r=0.5]
	     * @param {Array.<Object>} [colorStops]
	     * @param {boolean} [globalCoord=false]
	     */
	    var RadialGradient = function (x, y, r, colorStops, globalCoord) {
	        this.x = x == null ? 0.5 : x;
	
	        this.y = y == null ? 0.5 : y;
	
	        this.r = r == null ? 0.5 : r;
	
	        // Can be cloned
	        this.type = 'radial';
	
	        // If use global coord
	        this.global = globalCoord || false;
	
	        Gradient.call(this, colorStops);
	    };
	
	    RadialGradient.prototype = {
	
	        constructor: RadialGradient
	    };
	
	    zrUtil.inherits(RadialGradient, Gradient);
	
	    return RadialGradient;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * ZRender, a high performance 2d drawing library.
	 *
	 * Copyright (c) 2013, Baidu Inc.
	 * All rights reserved.
	 *
	 * LICENSE
	 * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
	 */
	// Global defines
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
	    var guid = __webpack_require__(36);
	    var env = __webpack_require__(6);
	
	    var Handler = __webpack_require__(86);
	    var Storage = __webpack_require__(88);
	    var Animation = __webpack_require__(90);
	    var HandlerProxy = __webpack_require__(93);
	
	    var useVML = !env.canvasSupported;
	
	    var painterCtors = {
	        canvas: __webpack_require__(95)
	    };
	
	    var instances = {};    // ZRender实例map索引
	
	    var zrender = {};
	    /**
	     * @type {string}
	     */
	    zrender.version = '3.1.3';
	
	    /**
	     * Initializing a zrender instance
	     * @param {HTMLElement} dom
	     * @param {Object} opts
	     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
	     * @param {number} [opts.devicePixelRatio]
	     * @return {module:zrender/ZRender}
	     */
	    zrender.init = function(dom, opts) {
	        var zr = new ZRender(guid(), dom, opts);
	        instances[zr.id] = zr;
	        return zr;
	    };
	
	    /**
	     * Dispose zrender instance
	     * @param {module:zrender/ZRender} zr
	     */
	    zrender.dispose = function (zr) {
	        if (zr) {
	            zr.dispose();
	        }
	        else {
	            for (var key in instances) {
	                instances[key].dispose();
	            }
	            instances = {};
	        }
	
	        return zrender;
	    };
	
	    /**
	     * Get zrender instance by id
	     * @param {string} id zrender instance id
	     * @return {module:zrender/ZRender}
	     */
	    zrender.getInstance = function (id) {
	        return instances[id];
	    };
	
	    zrender.registerPainter = function (name, Ctor) {
	        painterCtors[name] = Ctor;
	    };
	
	    function delInstance(id) {
	        delete instances[id];
	    }
	
	    /**
	     * @module zrender/ZRender
	     */
	    /**
	     * @constructor
	     * @alias module:zrender/ZRender
	     * @param {string} id
	     * @param {HTMLDomElement} dom
	     * @param {Object} opts
	     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
	     * @param {number} [opts.devicePixelRatio]
	     */
	    var ZRender = function(id, dom, opts) {
	
	        opts = opts || {};
	
	        /**
	         * @type {HTMLDomElement}
	         */
	        this.dom = dom;
	
	        /**
	         * @type {string}
	         */
	        this.id = id;
	
	        var self = this;
	        var storage = new Storage();
	
	        var rendererType = opts.renderer;
	        if (useVML) {
	            if (!painterCtors.vml) {
	                throw new Error('You need to require \'zrender/vml/vml\' to support IE8');
	            }
	            rendererType = 'vml';
	        }
	        else if (!rendererType || !painterCtors[rendererType]) {
	            rendererType = 'canvas';
	        }
	        var painter = new painterCtors[rendererType](dom, storage, opts);
	
	        this.storage = storage;
	        this.painter = painter;
	
	        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;
	        this.handler = new Handler(storage, painter, handerProxy);
	
	        /**
	         * @type {module:zrender/animation/Animation}
	         */
	        this.animation = new Animation({
	            stage: {
	                update: function () {
	                    if (self._needsRefresh) {
	                        self.refreshImmediately();
	                    }
	                    if (self._needsRefreshHover) {
	                        self.refreshHoverImmediately();
	                    }
	                }
	            }
	        });
	        this.animation.start();
	
	        /**
	         * @type {boolean}
	         * @private
	         */
	        this._needsRefresh;
	
	        // 修改 storage.delFromMap, 每次删除元素之前删除动画
	        // FIXME 有点ugly
	        var oldDelFromMap = storage.delFromMap;
	        var oldAddToMap = storage.addToMap;
	
	        storage.delFromMap = function (elId) {
	            var el = storage.get(elId);
	
	            oldDelFromMap.call(storage, elId);
	
	            el && el.removeSelfFromZr(self);
	        };
	
	        storage.addToMap = function (el) {
	            oldAddToMap.call(storage, el);
	
	            el.addSelfToZr(self);
	        };
	    };
	
	    ZRender.prototype = {
	
	        constructor: ZRender,
	        /**
	         * 获取实例唯一标识
	         * @return {string}
	         */
	        getId: function () {
	            return this.id;
	        },
	
	        /**
	         * 添加元素
	         * @param  {module:zrender/Element} el
	         */
	        add: function (el) {
	            this.storage.addRoot(el);
	            this._needsRefresh = true;
	        },
	
	        /**
	         * 删除元素
	         * @param  {module:zrender/Element} el
	         */
	        remove: function (el) {
	            this.storage.delRoot(el);
	            this._needsRefresh = true;
	        },
	
	        /**
	         * Change configuration of layer
	         * @param {string} zLevel
	         * @param {Object} config
	         * @param {string} [config.clearColor=0] Clear color
	         * @param {string} [config.motionBlur=false] If enable motion blur
	         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer
	        */
	        configLayer: function (zLevel, config) {
	            this.painter.configLayer(zLevel, config);
	            this._needsRefresh = true;
	        },
	
	        /**
	         * Repaint the canvas immediately
	         */
	        refreshImmediately: function () {
	            // Clear needsRefresh ahead to avoid something wrong happens in refresh
	            // Or it will cause zrender refreshes again and again.
	            this._needsRefresh = false;
	            this.painter.refresh();
	            /**
	             * Avoid trigger zr.refresh in Element#beforeUpdate hook
	             */
	            this._needsRefresh = false;
	        },
	
	        /**
	         * Mark and repaint the canvas in the next frame of browser
	         */
	        refresh: function() {
	            this._needsRefresh = true;
	        },
	
	        /**
	         * Add element to hover layer
	         * @param  {module:zrender/Element} el
	         * @param {Object} style
	         */
	        addHover: function (el, style) {
	            if (this.painter.addHover) {
	                this.painter.addHover(el, style);
	                this.refreshHover();
	            }
	        },
	
	        /**
	         * Add element from hover layer
	         * @param  {module:zrender/Element} el
	         */
	        removeHover: function (el) {
	            if (this.painter.removeHover) {
	                this.painter.removeHover(el);
	                this.refreshHover();
	            }
	        },
	
	        /**
	         * Clear all hover elements in hover layer
	         * @param  {module:zrender/Element} el
	         */
	        clearHover: function () {
	            if (this.painter.clearHover) {
	                this.painter.clearHover();
	                this.refreshHover();
	            }
	        },
	
	        /**
	         * Refresh hover in next frame
	         */
	        refreshHover: function () {
	            this._needsRefreshHover = true;
	        },
	
	        /**
	         * Refresh hover immediately
	         */
	        refreshHoverImmediately: function () {
	            this._needsRefreshHover = false;
	            this.painter.refreshHover && this.painter.refreshHover();
	        },
	
	        /**
	         * Resize the canvas.
	         * Should be invoked when container size is changed
	         */
	        resize: function() {
	            this.painter.resize();
	            this.handler.resize();
	        },
	
	        /**
	         * Stop and clear all animation immediately
	         */
	        clearAnimation: function () {
	            this.animation.clear();
	        },
	
	        /**
	         * Get container width
	         */
	        getWidth: function() {
	            return this.painter.getWidth();
	        },
	
	        /**
	         * Get container height
	         */
	        getHeight: function() {
	            return this.painter.getHeight();
	        },
	
	        /**
	         * Export the canvas as Base64 URL
	         * @param {string} type
	         * @param {string} [backgroundColor='#fff']
	         * @return {string} Base64 URL
	         */
	        // toDataURL: function(type, backgroundColor) {
	        //     return this.painter.getRenderedCanvas({
	        //         backgroundColor: backgroundColor
	        //     }).toDataURL(type);
	        // },
	
	        /**
	         * Converting a path to image.
	         * It has much better performance of drawing image rather than drawing a vector path.
	         * @param {module:zrender/graphic/Path} e
	         * @param {number} width
	         * @param {number} height
	         */
	        pathToImage: function(e, width, height) {
	            var id = guid();
	            return this.painter.pathToImage(id, e, width, height);
	        },
	
	        /**
	         * Set default cursor
	         * @param {string} [cursorStyle='default'] 例如 crosshair
	         */
	        setCursorStyle: function (cursorStyle) {
	            this.handler.setCursorStyle(cursorStyle);
	        },
	
	        /**
	         * Bind event
	         *
	         * @param {string} eventName Event name
	         * @param {Function} eventHandler Handler function
	         * @param {Object} [context] Context object
	         */
	        on: function(eventName, eventHandler, context) {
	            this.handler.on(eventName, eventHandler, context);
	        },
	
	        /**
	         * Unbind event
	         * @param {string} eventName Event name
	         * @param {Function} [eventHandler] Handler function
	         */
	        off: function(eventName, eventHandler) {
	            this.handler.off(eventName, eventHandler);
	        },
	
	        /**
	         * Trigger event manually
	         *
	         * @param {string} eventName Event name
	         * @param {event=} event Event object
	         */
	        trigger: function (eventName, event) {
	            this.handler.trigger(eventName, event);
	        },
	
	
	        /**
	         * Clear all objects and the canvas.
	         */
	        clear: function () {
	            this.storage.delRoot();
	            this.painter.clear();
	        },
	
	        /**
	         * Dispose self.
	         */
	        dispose: function () {
	            this.animation.stop();
	
	            this.clear();
	            this.storage.dispose();
	            this.painter.dispose();
	            this.handler.dispose();
	
	            this.animation =
	            this.storage =
	            this.painter =
	            this.handler = null;
	
	            delInstance(this.id);
	        }
	    };
	
	    return zrender;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Handler
	 * @module zrender/Handler
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 *         pissang (shenyi.914@gmail.com)
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    'use strict';
	
	    var util = __webpack_require__(8);
	    var Draggable = __webpack_require__(87);
	
	    var Eventful = __webpack_require__(37);
	
	    function makeEventPacket(eveType, target, event) {
	        return {
	            type: eveType,
	            event: event,
	            target: target,
	            cancelBubble: false,
	            offsetX: event.zrX,
	            offsetY: event.zrY,
	            gestureEvent: event.gestureEvent,
	            pinchX: event.pinchX,
	            pinchY: event.pinchY,
	            pinchScale: event.pinchScale,
	            wheelDelta: event.zrDelta
	        };
	    }
	
	    function EmptyProxy () {}
	    EmptyProxy.prototype.dispose = function () {};
	
	    var handlerNames = [
	        'click', 'dblclick', 'mousewheel', 'mouseout',
	        'mouseup', 'mousedown', 'mousemove'
	    ];
	    /**
	     * @alias module:zrender/Handler
	     * @constructor
	     * @extends module:zrender/mixin/Eventful
	     * @param {HTMLElement} root Main HTML element for painting.
	     * @param {module:zrender/Storage} storage Storage instance.
	     * @param {module:zrender/Painter} painter Painter instance.
	     */
	    var Handler = function(storage, painter, proxy) {
	        Eventful.call(this);
	
	        this.storage = storage;
	
	        this.painter = painter;
	
	        proxy = proxy || new EmptyProxy();
	        /**
	         * Proxy of event. can be Dom, WebGLSurface, etc.
	         */
	        this.proxy = proxy;
	
	        // Attach handler
	        proxy.handler = this;
	
	        /**
	         * @private
	         * @type {boolean}
	         */
	        this._hovered;
	
	        /**
	         * @private
	         * @type {Date}
	         */
	        this._lastTouchMoment;
	
	        /**
	         * @private
	         * @type {number}
	         */
	        this._lastX;
	
	        /**
	         * @private
	         * @type {number}
	         */
	        this._lastY;
	
	
	        Draggable.call(this);
	
	        util.each(handlerNames, function (name) {
	            proxy.on && proxy.on(name, this[name], this);
	        }, this);
	    };
	
	    Handler.prototype = {
	
	        constructor: Handler,
	
	        mousemove: function (event) {
	            var x = event.zrX;
	            var y = event.zrY;
	
	            var hovered = this.findHover(x, y, null);
	            var lastHovered = this._hovered;
	            var proxy = this.proxy;
	
	            this._hovered = hovered;
	
	            proxy.setCursor && proxy.setCursor(hovered ? hovered.cursor : 'default');
	
	            // Mouse out on previous hovered element
	            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {
	                this.dispatchToElement(lastHovered, 'mouseout', event);
	            }
	
	            // Mouse moving on one element
	            this.dispatchToElement(hovered, 'mousemove', event);
	
	            // Mouse over on a new element
	            if (hovered && hovered !== lastHovered) {
	                this.dispatchToElement(hovered, 'mouseover', event);
	            }
	        },
	
	        mouseout: function (event) {
	            this.dispatchToElement(this._hovered, 'mouseout', event);
	
	            this.trigger('globalout', {
	                event: event
	            });
	        },
	
	        /**
	         * Resize
	         */
	        resize: function (event) {
	            this._hovered = null;
	        },
	
	        /**
	         * Dispatch event
	         * @param {string} eventName
	         * @param {event=} eventArgs
	         */
	        dispatch: function (eventName, eventArgs) {
	            var handler = this[eventName];
	            handler && handler.call(this, eventArgs);
	        },
	
	        /**
	         * Dispose
	         */
	        dispose: function () {
	
	            this.proxy.dispose();
	
	            this.storage =
	            this.proxy =
	            this.painter = null;
	        },
	
	        /**
	         * 设置默认的cursor style
	         * @param {string} [cursorStyle='default'] 例如 crosshair
	         */
	        setCursorStyle: function (cursorStyle) {
	            var proxy = this.proxy;
	            proxy.setCursor && proxy.setCursor(cursorStyle);
	        },
	
	        /**
	         * 事件分发代理
	         *
	         * @private
	         * @param {Object} targetEl 目标图形元素
	         * @param {string} eventName 事件名称
	         * @param {Object} event 事件对象
	         */
	        dispatchToElement: function (targetEl, eventName, event) {
	            var eventHandler = 'on' + eventName;
	            var eventPacket = makeEventPacket(eventName, targetEl, event);
	
	            var el = targetEl;
	
	            while (el) {
	                el[eventHandler]
	                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));
	
	                el.trigger(eventName, eventPacket);
	
	                el = el.parent;
	
	                if (eventPacket.cancelBubble) {
	                    break;
	                }
	            }
	
	            if (!eventPacket.cancelBubble) {
	                // 冒泡到顶级 zrender 对象
	                this.trigger(eventName, eventPacket);
	                // 分发事件到用户自定义层
	                // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在
	                this.painter && this.painter.eachOtherLayer(function (layer) {
	                    if (typeof(layer[eventHandler]) == 'function') {
	                        layer[eventHandler].call(layer, eventPacket);
	                    }
	                    if (layer.trigger) {
	                        layer.trigger(eventName, eventPacket);
	                    }
	                });
	            }
	        },
	
	        /**
	         * @private
	         * @param {number} x
	         * @param {number} y
	         * @param {module:zrender/graphic/Displayable} exclude
	         * @method
	         */
	        findHover: function(x, y, exclude) {
	            var list = this.storage.getDisplayList();
	            for (var i = list.length - 1; i >= 0 ; i--) {
	                if (!list[i].silent
	                 && list[i] !== exclude
	                 // getDisplayList may include ignored item in VML mode
	                 && !list[i].ignore
	                 && isHover(list[i], x, y)) {
	                    return list[i];
	                }
	            }
	        }
	    };
	
	    // Common handlers
	    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick'], function (name) {
	        Handler.prototype[name] = function (event) {
	            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover
	            var hovered = this.findHover(event.zrX, event.zrY, null);
	
	            if (name === 'mousedown') {
	                this._downel = hovered;
	                // In case click triggered before mouseup
	                this._upel = hovered;
	            }
	            else if (name === 'mosueup') {
	                this._upel = hovered;
	            }
	            else if (name === 'click') {
	                if (this._downel !== this._upel) {
	                    return;
	                }
	            }
	
	            this.dispatchToElement(hovered, name, event);
	        };
	    });
	
	    function isHover(displayable, x, y) {
	        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {
	            var el = displayable;
	            while (el) {
	                // If ancestor is silent or clipped by ancestor
	                if (el.silent || (el.clipPath && !el.clipPath.contain(x, y)))  {
	                    return false;
	                }
	                el = el.parent;
	            }
	            return true;
	        }
	
	        return false;
	    }
	
	    util.mixin(Handler, Eventful);
	    util.mixin(Handler, Draggable);
	
	    return Handler;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;// TODO Draggable for group
	// FIXME Draggable on element which has parent rotation or scale
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	    function Draggable() {
	
	        this.on('mousedown', this._dragStart, this);
	        this.on('mousemove', this._drag, this);
	        this.on('mouseup', this._dragEnd, this);
	        this.on('globalout', this._dragEnd, this);
	        // this._dropTarget = null;
	        // this._draggingTarget = null;
	
	        // this._x = 0;
	        // this._y = 0;
	    }
	
	    Draggable.prototype = {
	
	        constructor: Draggable,
	
	        _dragStart: function (e) {
	            var draggingTarget = e.target;
	            if (draggingTarget && draggingTarget.draggable) {
	                this._draggingTarget = draggingTarget;
	                draggingTarget.dragging = true;
	                this._x = e.offsetX;
	                this._y = e.offsetY;
	
	                this.dispatchToElement(draggingTarget, 'dragstart', e.event);
	            }
	        },
	
	        _drag: function (e) {
	            var draggingTarget = this._draggingTarget;
	            if (draggingTarget) {
	
	                var x = e.offsetX;
	                var y = e.offsetY;
	
	                var dx = x - this._x;
	                var dy = y - this._y;
	                this._x = x;
	                this._y = y;
	
	                draggingTarget.drift(dx, dy, e);
	                this.dispatchToElement(draggingTarget, 'drag', e.event);
	
	                var dropTarget = this.findHover(x, y, draggingTarget);
	                var lastDropTarget = this._dropTarget;
	                this._dropTarget = dropTarget;
	
	                if (draggingTarget !== dropTarget) {
	                    if (lastDropTarget && dropTarget !== lastDropTarget) {
	                        this.dispatchToElement(lastDropTarget, 'dragleave', e.event);
	                    }
	                    if (dropTarget && dropTarget !== lastDropTarget) {
	                        this.dispatchToElement(dropTarget, 'dragenter', e.event);
	                    }
	                }
	            }
	        },
	
	        _dragEnd: function (e) {
	            var draggingTarget = this._draggingTarget;
	
	            if (draggingTarget) {
	                draggingTarget.dragging = false;
	            }
	
	            this.dispatchToElement(draggingTarget, 'dragend', e.event);
	
	            if (this._dropTarget) {
	                this.dispatchToElement(this._dropTarget, 'drop', e.event);
	            }
	
	            this._draggingTarget = null;
	            this._dropTarget = null;
	        }
	
	    };
	
	    return Draggable;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Storage内容仓库模块
	 * @module zrender/Storage
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 * @author errorrik (errorrik@gmail.com)
	 * @author pissang (https://github.com/pissang/)
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    'use strict';
	
	    var util = __webpack_require__(8);
	    var env = __webpack_require__(6);
	
	    var Group = __webpack_require__(34);
	
	    // Use timsort because in most case elements are partially sorted
	    // https://jsfiddle.net/pissang/jr4x7mdm/8/
	    var timsort = __webpack_require__(89);
	
	    function shapeCompareFunc(a, b) {
	        if (a.zlevel === b.zlevel) {
	            if (a.z === b.z) {
	                // if (a.z2 === b.z2) {
	                //     // FIXME Slow has renderidx compare
	                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement
	                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012
	                //     return a.__renderidx - b.__renderidx;
	                // }
	                return a.z2 - b.z2;
	            }
	            return a.z - b.z;
	        }
	        return a.zlevel - b.zlevel;
	    }
	    /**
	     * 内容仓库 (M)
	     * @alias module:zrender/Storage
	     * @constructor
	     */
	    var Storage = function () {
	        // 所有常规形状，id索引的map
	        this._elements = {};
	
	        this._roots = [];
	
	        this._displayList = [];
	
	        this._displayListLen = 0;
	    };
	
	    Storage.prototype = {
	
	        constructor: Storage,
	
	        /**
	         * @param  {Function} cb
	         *
	         */
	        traverse: function (cb, context) {
	            for (var i = 0; i < this._roots.length; i++) {
	                this._roots[i].traverse(cb, context);
	            }
	        },
	
	        /**
	         * 返回所有图形的绘制队列
	         * @param {boolean} [update=false] 是否在返回前更新该数组
	         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效
	         *
	         * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}
	         * @return {Array.<module:zrender/graphic/Displayable>}
	         */
	        getDisplayList: function (update, includeIgnore) {
	            includeIgnore = includeIgnore || false;
	            if (update) {
	                this.updateDisplayList(includeIgnore);
	            }
	            return this._displayList;
	        },
	
	        /**
	         * 更新图形的绘制队列。
	         * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，
	         * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列
	         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组
	         */
	        updateDisplayList: function (includeIgnore) {
	            this._displayListLen = 0;
	            var roots = this._roots;
	            var displayList = this._displayList;
	            for (var i = 0, len = roots.length; i < len; i++) {
	                this._updateAndAddDisplayable(roots[i], null, includeIgnore);
	            }
	            displayList.length = this._displayListLen;
	
	            // for (var i = 0, len = displayList.length; i < len; i++) {
	            //     displayList[i].__renderidx = i;
	            // }
	
	            // displayList.sort(shapeCompareFunc);
	            env.canvasSupported && timsort(displayList, shapeCompareFunc);
	        },
	
	        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {
	
	            if (el.ignore && !includeIgnore) {
	                return;
	            }
	
	            el.beforeUpdate();
	
	            if (el.__dirty) {
	
	                el.update();
	
	            }
	
	            el.afterUpdate();
	
	            var clipPath = el.clipPath;
	            if (clipPath) {
	                // clipPath 的变换是基于 group 的变换
	                clipPath.parent = el;
	                clipPath.updateTransform();
	
	                // FIXME 效率影响
	                if (clipPaths) {
	                    clipPaths = clipPaths.slice();
	                    clipPaths.push(clipPath);
	                }
	                else {
	                    clipPaths = [clipPath];
	                }
	            }
	
	            if (el.isGroup) {
	                var children = el._children;
	
	                for (var i = 0; i < children.length; i++) {
	                    var child = children[i];
	
	                    // Force to mark as dirty if group is dirty
	                    // FIXME __dirtyPath ?
	                    if (el.__dirty) {
	                        child.__dirty = true;
	                    }
	
	                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
	                }
	
	                // Mark group clean here
	                el.__dirty = false;
	
	            }
	            else {
	                el.__clipPaths = clipPaths;
	
	                this._displayList[this._displayListLen++] = el;
	            }
	        },
	
	        /**
	         * 添加图形(Shape)或者组(Group)到根节点
	         * @param {module:zrender/Element} el
	         */
	        addRoot: function (el) {
	            // Element has been added
	            if (this._elements[el.id]) {
	                return;
	            }
	
	            if (el instanceof Group) {
	                el.addChildrenToStorage(this);
	            }
	
	            this.addToMap(el);
	            this._roots.push(el);
	        },
	
	        /**
	         * 删除指定的图形(Shape)或者组(Group)
	         * @param {string|Array.<string>} [elId] 如果为空清空整个Storage
	         */
	        delRoot: function (elId) {
	            if (elId == null) {
	                // 不指定elId清空
	                for (var i = 0; i < this._roots.length; i++) {
	                    var root = this._roots[i];
	                    if (root instanceof Group) {
	                        root.delChildrenFromStorage(this);
	                    }
	                }
	
	                this._elements = {};
	                this._roots = [];
	                this._displayList = [];
	                this._displayListLen = 0;
	
	                return;
	            }
	
	            if (elId instanceof Array) {
	                for (var i = 0, l = elId.length; i < l; i++) {
	                    this.delRoot(elId[i]);
	                }
	                return;
	            }
	
	            var el;
	            if (typeof(elId) == 'string') {
	                el = this._elements[elId];
	            }
	            else {
	                el = elId;
	            }
	
	            var idx = util.indexOf(this._roots, el);
	            if (idx >= 0) {
	                this.delFromMap(el.id);
	                this._roots.splice(idx, 1);
	                if (el instanceof Group) {
	                    el.delChildrenFromStorage(this);
	                }
	            }
	        },
	
	        addToMap: function (el) {
	            if (el instanceof Group) {
	                el.__storage = this;
	            }
	            el.dirty(false);
	
	            this._elements[el.id] = el;
	
	            return this;
	        },
	
	        get: function (elId) {
	            return this._elements[elId];
	        },
	
	        delFromMap: function (elId) {
	            var elements = this._elements;
	            var el = elements[elId];
	            if (el) {
	                delete elements[elId];
	                if (el instanceof Group) {
	                    el.__storage = null;
	                }
	            }
	
	            return this;
	        },
	
	        /**
	         * 清空并且释放Storage
	         */
	        dispose: function () {
	            this._elements =
	            this._renderList =
	            this._roots = null;
	        },
	
	        displayableSortFunc: shapeCompareFunc
	    };
	
	    return Storage;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;// https://github.com/mziccard/node-timsort
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    var DEFAULT_MIN_MERGE = 32;
	
	    var DEFAULT_MIN_GALLOPING = 7;
	
	    var DEFAULT_TMP_STORAGE_LENGTH = 256;
	
	    function minRunLength(n) {
	        var r = 0;
	
	        while (n >= DEFAULT_MIN_MERGE) {
	            r |= n & 1;
	            n >>= 1;
	        }
	
	        return n + r;
	    }
	
	    function makeAscendingRun(array, lo, hi, compare) {
	        var runHi = lo + 1;
	
	        if (runHi === hi) {
	            return 1;
	        }
	
	        if (compare(array[runHi++], array[lo]) < 0) {
	            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
	                runHi++;
	            }
	
	            reverseRun(array, lo, runHi);
	        }
	        else {
	            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
	                runHi++;
	            }
	        }
	
	        return runHi - lo;
	    }
	
	    function reverseRun(array, lo, hi) {
	        hi--;
	
	        while (lo < hi) {
	            var t = array[lo];
	            array[lo++] = array[hi];
	            array[hi--] = t;
	        }
	    }
	
	    function binaryInsertionSort(array, lo, hi, start, compare) {
	        if (start === lo) {
	            start++;
	        }
	
	        for (; start < hi; start++) {
	            var pivot = array[start];
	
	            var left = lo;
	            var right = start;
	            var mid;
	
	            while (left < right) {
	                mid = left + right >>> 1;
	
	                if (compare(pivot, array[mid]) < 0) {
	                    right = mid;
	                }
	                else {
	                    left = mid + 1;
	                }
	            }
	
	            var n = start - left;
	
	            switch (n) {
	                case 3:
	                    array[left + 3] = array[left + 2];
	
	                case 2:
	                    array[left + 2] = array[left + 1];
	
	                case 1:
	                    array[left + 1] = array[left];
	                    break;
	                default:
	                    while (n > 0) {
	                        array[left + n] = array[left + n - 1];
	                        n--;
	                    }
	            }
	
	            array[left] = pivot;
	        }
	    }
	
	    function gallopLeft(value, array, start, length, hint, compare) {
	        var lastOffset = 0;
	        var maxOffset = 0;
	        var offset = 1;
	
	        if (compare(value, array[start + hint]) > 0) {
	            maxOffset = length - hint;
	
	            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
	                lastOffset = offset;
	                offset = (offset << 1) + 1;
	
	                if (offset <= 0) {
	                    offset = maxOffset;
	                }
	            }
	
	            if (offset > maxOffset) {
	                offset = maxOffset;
	            }
	
	            lastOffset += hint;
	            offset += hint;
	        }
	        else {
	            maxOffset = hint + 1;
	            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
	                lastOffset = offset;
	                offset = (offset << 1) + 1;
	
	                if (offset <= 0) {
	                    offset = maxOffset;
	                }
	            }
	            if (offset > maxOffset) {
	                offset = maxOffset;
	            }
	
	            var tmp = lastOffset;
	            lastOffset = hint - offset;
	            offset = hint - tmp;
	        }
	
	        lastOffset++;
	        while (lastOffset < offset) {
	            var m = lastOffset + (offset - lastOffset >>> 1);
	
	            if (compare(value, array[start + m]) > 0) {
	                lastOffset = m + 1;
	            }
	            else {
	                offset = m;
	            }
	        }
	        return offset;
	    }
	
	    function gallopRight(value, array, start, length, hint, compare) {
	        var lastOffset = 0;
	        var maxOffset = 0;
	        var offset = 1;
	
	        if (compare(value, array[start + hint]) < 0) {
	            maxOffset = hint + 1;
	
	            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
	                lastOffset = offset;
	                offset = (offset << 1) + 1;
	
	                if (offset <= 0) {
	                    offset = maxOffset;
	                }
	            }
	
	            if (offset > maxOffset) {
	                offset = maxOffset;
	            }
	
	            var tmp = lastOffset;
	            lastOffset = hint - offset;
	            offset = hint - tmp;
	        }
	        else {
	            maxOffset = length - hint;
	
	            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
	                lastOffset = offset;
	                offset = (offset << 1) + 1;
	
	                if (offset <= 0) {
	                    offset = maxOffset;
	                }
	            }
	
	            if (offset > maxOffset) {
	                offset = maxOffset;
	            }
	
	            lastOffset += hint;
	            offset += hint;
	        }
	
	        lastOffset++;
	
	        while (lastOffset < offset) {
	            var m = lastOffset + (offset - lastOffset >>> 1);
	
	            if (compare(value, array[start + m]) < 0) {
	                offset = m;
	            }
	            else {
	                lastOffset = m + 1;
	            }
	        }
	
	        return offset;
	    }
	
	    function TimSort(array, compare) {
	        var minGallop = DEFAULT_MIN_GALLOPING;
	        var length = 0;
	        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;
	        var stackLength = 0;
	        var runStart;
	        var runLength;
	        var stackSize = 0;
	
	        length = array.length;
	
	        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {
	            tmpStorageLength = length >>> 1;
	        }
	
	        var tmp = [];
	
	        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;
	
	        runStart = [];
	        runLength = [];
	
	        function pushRun(_runStart, _runLength) {
	            runStart[stackSize] = _runStart;
	            runLength[stackSize] = _runLength;
	            stackSize += 1;
	        }
	
	        function mergeRuns() {
	            while (stackSize > 1) {
	                var n = stackSize - 2;
	
	                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {
	                    if (runLength[n - 1] < runLength[n + 1]) {
	                        n--;
	                    }
	                }
	                else if (runLength[n] > runLength[n + 1]) {
	                    break;
	                }
	                mergeAt(n);
	            }
	        }
	
	        function forceMergeRuns() {
	            while (stackSize > 1) {
	                var n = stackSize - 2;
	
	                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {
	                    n--;
	                }
	
	                mergeAt(n);
	            }
	        }
	
	        function mergeAt(i) {
	            var start1 = runStart[i];
	            var length1 = runLength[i];
	            var start2 = runStart[i + 1];
	            var length2 = runLength[i + 1];
	
	            runLength[i] = length1 + length2;
	
	            if (i === stackSize - 3) {
	                runStart[i + 1] = runStart[i + 2];
	                runLength[i + 1] = runLength[i + 2];
	            }
	
	            stackSize--;
	
	            var k = gallopRight(array[start2], array, start1, length1, 0, compare);
	            start1 += k;
	            length1 -= k;
	
	            if (length1 === 0) {
	                return;
	            }
	
	            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);
	
	            if (length2 === 0) {
	                return;
	            }
	
	            if (length1 <= length2) {
	                mergeLow(start1, length1, start2, length2);
	            }
	            else {
	                mergeHigh(start1, length1, start2, length2);
	            }
	        }
	
	        function mergeLow(start1, length1, start2, length2) {
	            var i = 0;
	
	            for (i = 0; i < length1; i++) {
	                tmp[i] = array[start1 + i];
	            }
	
	            var cursor1 = 0;
	            var cursor2 = start2;
	            var dest = start1;
	
	            array[dest++] = array[cursor2++];
	
	            if (--length2 === 0) {
	                for (i = 0; i < length1; i++) {
	                    array[dest + i] = tmp[cursor1 + i];
	                }
	                return;
	            }
	
	            if (length1 === 1) {
	                for (i = 0; i < length2; i++) {
	                    array[dest + i] = array[cursor2 + i];
	                }
	                array[dest + length2] = tmp[cursor1];
	                return;
	            }
	
	            var _minGallop = minGallop;
	            var count1, count2, exit;
	
	            while (1) {
	                count1 = 0;
	                count2 = 0;
	                exit = false;
	
	                do {
	                    if (compare(array[cursor2], tmp[cursor1]) < 0) {
	                        array[dest++] = array[cursor2++];
	                        count2++;
	                        count1 = 0;
	
	                        if (--length2 === 0) {
	                            exit = true;
	                            break;
	                        }
	                    }
	                    else {
	                        array[dest++] = tmp[cursor1++];
	                        count1++;
	                        count2 = 0;
	                        if (--length1 === 1) {
	                            exit = true;
	                            break;
	                        }
	                    }
	                } while ((count1 | count2) < _minGallop);
	
	                if (exit) {
	                    break;
	                }
	
	                do {
	                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);
	
	                    if (count1 !== 0) {
	                        for (i = 0; i < count1; i++) {
	                            array[dest + i] = tmp[cursor1 + i];
	                        }
	
	                        dest += count1;
	                        cursor1 += count1;
	                        length1 -= count1;
	                        if (length1 <= 1) {
	                            exit = true;
	                            break;
	                        }
	                    }
	
	                    array[dest++] = array[cursor2++];
	
	                    if (--length2 === 0) {
	                        exit = true;
	                        break;
	                    }
	
	                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);
	
	                    if (count2 !== 0) {
	                        for (i = 0; i < count2; i++) {
	                            array[dest + i] = array[cursor2 + i];
	                        }
	
	                        dest += count2;
	                        cursor2 += count2;
	                        length2 -= count2;
	
	                        if (length2 === 0) {
	                            exit = true;
	                            break;
	                        }
	                    }
	                    array[dest++] = tmp[cursor1++];
	
	                    if (--length1 === 1) {
	                        exit = true;
	                        break;
	                    }
	
	                    _minGallop--;
	                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
	
	                if (exit) {
	                    break;
	                }
	
	                if (_minGallop < 0) {
	                    _minGallop = 0;
	                }
	
	                _minGallop += 2;
	            }
	
	            minGallop = _minGallop;
	
	            minGallop < 1 && (minGallop = 1);
	
	            if (length1 === 1) {
	                for (i = 0; i < length2; i++) {
	                    array[dest + i] = array[cursor2 + i];
	                }
	                array[dest + length2] = tmp[cursor1];
	            }
	            else if (length1 === 0) {
	                throw new Error();
	                // throw new Error('mergeLow preconditions were not respected');
	            }
	            else {
	                for (i = 0; i < length1; i++) {
	                    array[dest + i] = tmp[cursor1 + i];
	                }
	            }
	        }
	
	        function mergeHigh (start1, length1, start2, length2) {
	            var i = 0;
	
	            for (i = 0; i < length2; i++) {
	                tmp[i] = array[start2 + i];
	            }
	
	            var cursor1 = start1 + length1 - 1;
	            var cursor2 = length2 - 1;
	            var dest = start2 + length2 - 1;
	            var customCursor = 0;
	            var customDest = 0;
	
	            array[dest--] = array[cursor1--];
	
	            if (--length1 === 0) {
	                customCursor = dest - (length2 - 1);
	
	                for (i = 0; i < length2; i++) {
	                    array[customCursor + i] = tmp[i];
	                }
	
	                return;
	            }
	
	            if (length2 === 1) {
	                dest -= length1;
	                cursor1 -= length1;
	                customDest = dest + 1;
	                customCursor = cursor1 + 1;
	
	                for (i = length1 - 1; i >= 0; i--) {
	                    array[customDest + i] = array[customCursor + i];
	                }
	
	                array[dest] = tmp[cursor2];
	                return;
	            }
	
	            var _minGallop = minGallop;
	
	            while (true) {
	                var count1 = 0;
	                var count2 = 0;
	                var exit = false;
	
	                do {
	                    if (compare(tmp[cursor2], array[cursor1]) < 0) {
	                        array[dest--] = array[cursor1--];
	                        count1++;
	                        count2 = 0;
	                        if (--length1 === 0) {
	                            exit = true;
	                            break;
	                        }
	                    }
	                    else {
	                        array[dest--] = tmp[cursor2--];
	                        count2++;
	                        count1 = 0;
	                        if (--length2 === 1) {
	                            exit = true;
	                            break;
	                        }
	                    }
	                } while ((count1 | count2) < _minGallop);
	
	                if (exit) {
	                    break;
	                }
	
	                do {
	                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);
	
	                    if (count1 !== 0) {
	                        dest -= count1;
	                        cursor1 -= count1;
	                        length1 -= count1;
	                        customDest = dest + 1;
	                        customCursor = cursor1 + 1;
	
	                        for (i = count1 - 1; i >= 0; i--) {
	                            array[customDest + i] = array[customCursor + i];
	                        }
	
	                        if (length1 === 0) {
	                            exit = true;
	                            break;
	                        }
	                    }
	
	                    array[dest--] = tmp[cursor2--];
	
	                    if (--length2 === 1) {
	                        exit = true;
	                        break;
	                    }
	
	                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);
	
	                    if (count2 !== 0) {
	                        dest -= count2;
	                        cursor2 -= count2;
	                        length2 -= count2;
	                        customDest = dest + 1;
	                        customCursor = cursor2 + 1;
	
	                        for (i = 0; i < count2; i++) {
	                            array[customDest + i] = tmp[customCursor + i];
	                        }
	
	                        if (length2 <= 1) {
	                            exit = true;
	                            break;
	                        }
	                    }
	
	                    array[dest--] = array[cursor1--];
	
	                    if (--length1 === 0) {
	                        exit = true;
	                        break;
	                    }
	
	                    _minGallop--;
	                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
	
	                if (exit) {
	                    break;
	                }
	
	                if (_minGallop < 0) {
	                    _minGallop = 0;
	                }
	
	                _minGallop += 2;
	            }
	
	            minGallop = _minGallop;
	
	            if (minGallop < 1) {
	                minGallop = 1;
	            }
	
	            if (length2 === 1) {
	                dest -= length1;
	                cursor1 -= length1;
	                customDest = dest + 1;
	                customCursor = cursor1 + 1;
	
	                for (i = length1 - 1; i >= 0; i--) {
	                    array[customDest + i] = array[customCursor + i];
	                }
	
	                array[dest] = tmp[cursor2];
	            }
	            else if (length2 === 0) {
	                throw new Error();
	                // throw new Error('mergeHigh preconditions were not respected');
	            }
	            else {
	                customCursor = dest - (length2 - 1);
	                for (i = 0; i < length2; i++) {
	                    array[customCursor + i] = tmp[i];
	                }
	            }
	        }
	
	        this.mergeRuns = mergeRuns;
	        this.forceMergeRuns = forceMergeRuns;
	        this.pushRun = pushRun;
	    }
	
	    function sort(array, compare, lo, hi) {
	        if (!lo) {
	            lo = 0;
	        }
	        if (!hi) {
	            hi = array.length;
	        }
	
	        var remaining = hi - lo;
	
	        if (remaining < 2) {
	            return;
	        }
	
	        var runLength = 0;
	
	        if (remaining < DEFAULT_MIN_MERGE) {
	            runLength = makeAscendingRun(array, lo, hi, compare);
	            binaryInsertionSort(array, lo, hi, lo + runLength, compare);
	            return;
	        }
	
	        var ts = new TimSort(array, compare);
	
	        var minRun = minRunLength(remaining);
	
	        do {
	            runLength = makeAscendingRun(array, lo, hi, compare);
	            if (runLength < minRun) {
	                var force = remaining;
	                if (force > minRun) {
	                    force = minRun;
	                }
	
	                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
	                runLength = force;
	            }
	
	            ts.pushRun(lo, runLength);
	            ts.mergeRuns();
	
	            remaining -= runLength;
	            lo += runLength;
	        } while (remaining !== 0);
	
	        ts.forceMergeRuns();
	    }
	
	    return sort;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * 动画主类, 调度和管理所有动画控制器
	 *
	 * @module zrender/animation/Animation
	 * @author pissang(https://github.com/pissang)
	 */
	// TODO Additive animation
	// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/
	// https://developer.apple.com/videos/wwdc2014/#236
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
	
	    'use strict';
	
	    var util = __webpack_require__(8);
	    var Dispatcher = __webpack_require__(91).Dispatcher;
	
	    var requestAnimationFrame = __webpack_require__(92);
	
	    var Animator = __webpack_require__(40);
	    /**
	     * @typedef {Object} IZRenderStage
	     * @property {Function} update
	     */
	
	    /**
	     * @alias module:zrender/animation/Animation
	     * @constructor
	     * @param {Object} [options]
	     * @param {Function} [options.onframe]
	     * @param {IZRenderStage} [options.stage]
	     * @example
	     *     var animation = new Animation();
	     *     var obj = {
	     *         x: 100,
	     *         y: 100
	     *     };
	     *     animation.animate(node.position)
	     *         .when(1000, {
	     *             x: 500,
	     *             y: 500
	     *         })
	     *         .when(2000, {
	     *             x: 100,
	     *             y: 100
	     *         })
	     *         .start('spline');
	     */
	    var Animation = function (options) {
	
	        options = options || {};
	
	        this.stage = options.stage || {};
	
	        this.onframe = options.onframe || function() {};
	
	        // private properties
	        this._clips = [];
	
	        this._running = false;
	
	        this._time;
	
	        this._pausedTime;
	
	        this._pauseStart;
	
	        this._paused = false;
	
	        Dispatcher.call(this);
	    };
	
	    Animation.prototype = {
	
	        constructor: Animation,
	        /**
	         * 添加 clip
	         * @param {module:zrender/animation/Clip} clip
	         */
	        addClip: function (clip) {
	            this._clips.push(clip);
	        },
	        /**
	         * 添加 animator
	         * @param {module:zrender/animation/Animator} animator
	         */
	        addAnimator: function (animator) {
	            animator.animation = this;
	            var clips = animator.getClips();
	            for (var i = 0; i < clips.length; i++) {
	                this.addClip(clips[i]);
	            }
	        },
	        /**
	         * 删除动画片段
	         * @param {module:zrender/animation/Clip} clip
	         */
	        removeClip: function(clip) {
	            var idx = util.indexOf(this._clips, clip);
	            if (idx >= 0) {
	                this._clips.splice(idx, 1);
	            }
	        },
	
	        /**
	         * 删除动画片段
	         * @param {module:zrender/animation/Animator} animator
	         */
	        removeAnimator: function (animator) {
	            var clips = animator.getClips();
	            for (var i = 0; i < clips.length; i++) {
	                this.removeClip(clips[i]);
	            }
	            animator.animation = null;
	        },
	
	        _update: function() {
	
	            var time = new Date().getTime() - this._pausedTime;
	            var delta = time - this._time;
	            var clips = this._clips;
	            var len = clips.length;
	
	            var deferredEvents = [];
	            var deferredClips = [];
	            for (var i = 0; i < len; i++) {
	                var clip = clips[i];
	                var e = clip.step(time);
	                // Throw out the events need to be called after
	                // stage.update, like destroy
	                if (e) {
	                    deferredEvents.push(e);
	                    deferredClips.push(clip);
	                }
	            }
	
	            // Remove the finished clip
	            for (var i = 0; i < len;) {
	                if (clips[i]._needsRemove) {
	                    clips[i] = clips[len - 1];
	                    clips.pop();
	                    len--;
	                }
	                else {
	                    i++;
	                }
	            }
	
	            len = deferredEvents.length;
	            for (var i = 0; i < len; i++) {
	                deferredClips[i].fire(deferredEvents[i]);
	            }
	
	            this._time = time;
	
	            this.onframe(delta);
	
	            this.trigger('frame', delta);
	
	            if (this.stage.update) {
	                this.stage.update();
	            }
	        },
	
	        _startLoop: function () {
	            var self = this;
	
	            this._running = true;
	
	            function step() {
	                if (self._running) {
	
	                    requestAnimationFrame(step);
	
	                    !self._paused && self._update();
	                }
	            }
	
	            requestAnimationFrame(step);
	        },
	
	        /**
	         * 开始运行动画
	         */
	        start: function () {
	
	            this._time = new Date().getTime();
	            this._pausedTime = 0;
	
	            this._startLoop();
	        },
	        /**
	         * 停止运行动画
	         */
	        stop: function () {
	            this._running = false;
	        },
	
	        /**
	         * Pause
	         */
	        pause: function () {
	            if (!this._paused) {
	                this._pauseStart = new Date().getTime();
	                this._paused = true;
	            }
	        },
	
	        /**
	         * Resume
	         */
	        resume: function () {
	            if (this._paused) {
	                this._pausedTime += (new Date().getTime()) - this._pauseStart;
	                this._paused = false;
	            }
	        },
	
	        /**
	         * 清除所有动画片段
	         */
	        clear: function () {
	            this._clips = [];
	        },
	        /**
	         * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画
	         * @param  {Object} target
	         * @param  {Object} options
	         * @param  {boolean} [options.loop=false] 是否循环播放动画
	         * @param  {Function} [options.getter=null]
	         *         如果指定getter函数，会通过getter函数取属性值
	         * @param  {Function} [options.setter=null]
	         *         如果指定setter函数，会通过setter函数设置属性值
	         * @return {module:zrender/animation/Animation~Animator}
	         */
	        // TODO Gap
	        animate: function (target, options) {
	            options = options || {};
	            var animator = new Animator(
	                target,
	                options.loop,
	                options.getter,
	                options.setter
	            );
	
	            return animator;
	        }
	    };
	
	    util.mixin(Animation, Dispatcher);
	
	    return Animation;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * 事件辅助类
	 * @module zrender/core/event
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
	
	    'use strict';
	
	    var Eventful = __webpack_require__(37);
	
	    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;
	
	    function getBoundingClientRect(el) {
	        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect
	        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};
	    }
	
	    function clientToLocal(el, e, out) {
	        // clientX/clientY is according to view port.
	        var box = getBoundingClientRect(el);
	        out = out || {};
	        out.zrX = e.clientX - box.left;
	        out.zrY = e.clientY - box.top;
	        return out;
	    }
	
	    /**
	     * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标
	     */
	    function normalizeEvent(el, e) {
	
	        e = e || window.event;
	
	        if (e.zrX != null) {
	            return e;
	        }
	
	        var eventType = e.type;
	        var isTouch = eventType && eventType.indexOf('touch') >= 0;
	
	        if (!isTouch) {
	            clientToLocal(el, e, e);
	            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
	        }
	        else {
	            var touch = eventType != 'touchend'
	                ? e.targetTouches[0]
	                : e.changedTouches[0];
	            touch && clientToLocal(el, touch, e);
	        }
	
	        return e;
	    }
	
	    function addEventListener(el, name, handler) {
	        if (isDomLevel2) {
	            el.addEventListener(name, handler);
	        }
	        else {
	            el.attachEvent('on' + name, handler);
	        }
	    }
	
	    function removeEventListener(el, name, handler) {
	        if (isDomLevel2) {
	            el.removeEventListener(name, handler);
	        }
	        else {
	            el.detachEvent('on' + name, handler);
	        }
	    }
	
	    /**
	     * 停止冒泡和阻止默认行为
	     * @memberOf module:zrender/core/event
	     * @method
	     * @param {Event} e : event对象
	     */
	    var stop = isDomLevel2
	        ? function (e) {
	            e.preventDefault();
	            e.stopPropagation();
	            e.cancelBubble = true;
	        }
	        : function (e) {
	            e.returnValue = false;
	            e.cancelBubble = true;
	        };
	
	    return {
	        clientToLocal: clientToLocal,
	        normalizeEvent: normalizeEvent,
	        addEventListener: addEventListener,
	        removeEventListener: removeEventListener,
	
	        stop: stop,
	        // 做向上兼容
	        Dispatcher: Eventful
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
	
	    return (typeof window !== 'undefined' &&
	                                    (window.requestAnimationFrame
	                                    || window.msRequestAnimationFrame
	                                    || window.mozRequestAnimationFrame
	                                    || window.webkitRequestAnimationFrame))
	                                || function (func) {
	                                    setTimeout(func, 16);
	                                };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var eventTool = __webpack_require__(91);
	    var zrUtil = __webpack_require__(8);
	    var Eventful = __webpack_require__(37);
	    var env = __webpack_require__(6);
	    var GestureMgr = __webpack_require__(94);
	
	    var addEventListener = eventTool.addEventListener;
	    var removeEventListener = eventTool.removeEventListener;
	    var normalizeEvent = eventTool.normalizeEvent;
	
	    var TOUCH_CLICK_DELAY = 300;
	
	    var mouseHandlerNames = [
	        'click', 'dblclick', 'mousewheel', 'mouseout',
	        'mouseup', 'mousedown', 'mousemove'
	    ];
	
	    var touchHandlerNames = [
	        'touchstart', 'touchend', 'touchmove'
	    ];
	
	    function eventNameFix(name) {
	        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;
	    }
	
	    function processGesture(proxy, event, stage) {
	        var gestureMgr = proxy._gestureMgr;
	
	        stage === 'start' && gestureMgr.clear();
	
	        var gestureInfo = gestureMgr.recognize(
	            event,
	            proxy.handler.findHover(event.zrX, event.zrY, null),
	            proxy.dom
	        );
	
	        stage === 'end' && gestureMgr.clear();
	
	        if (gestureInfo) {
	            // eventTool.stop(event);
	            var type = gestureInfo.type;
	            event.gestureEvent = type;
	
	            proxy.handler.dispatchToElement(gestureInfo.target, type, gestureInfo.event);
	        }
	    }
	
	    /**
	     * Prevent mouse event from being dispatched after Touch Events action
	     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>
	     * 1. Mobile browsers dispatch mouse events 300ms after touchend.
	     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms
	     * Result: Blocking Mouse Events for 700ms.
	     */
	    function setTouchTimer(instance) {
	        instance._touching = true;
	        clearTimeout(instance._touchTimer);
	        instance._touchTimer = setTimeout(function () {
	            instance._touching = false;
	        }, 700);
	    }
	
	    function useTouchEvent() {
	        return env.touchEventsSupported;
	    }
	
	    var domHandlers = {
	        /**
	         * Mouse move handler
	         * @inner
	         * @param {Event} event
	         */
	        mousemove: function (event) {
	            event = normalizeEvent(this.dom, event);
	
	            this.trigger('mousemove', event);
	        },
	
	        /**
	         * Mouse out handler
	         * @inner
	         * @param {Event} event
	         */
	        mouseout: function (event) {
	            event = normalizeEvent(this.dom, event);
	
	            var element = event.toElement || event.relatedTarget;
	            if (element != this.dom) {
	                while (element && element.nodeType != 9) {
	                    // 忽略包含在root中的dom引起的mouseOut
	                    if (element === this.dom) {
	                        return;
	                    }
	
	                    element = element.parentNode;
	                }
	            }
	
	            this.trigger('mouseout', event);
	        },
	
	        /**
	         * Touch开始响应函数
	         * @inner
	         * @param {Event} event
	         */
	        touchstart: function (event) {
	            // Default mouse behaviour should not be disabled here.
	            // For example, page may needs to be slided.
	
	            event = normalizeEvent(this.dom, event);
	
	            this._lastTouchMoment = new Date();
	
	            processGesture(this, event, 'start');
	
	            // 平板补充一次findHover
	            // this._mobileFindFixed(event);
	            // Trigger mousemove and mousedown
	            domHandlers.mousemove.call(this, event);
	
	            domHandlers.mousedown.call(this, event);
	
	            setTouchTimer(this);
	        },
	
	        /**
	         * Touch移动响应函数
	         * @inner
	         * @param {Event} event
	         */
	        touchmove: function (event) {
	
	            event = normalizeEvent(this.dom, event);
	
	            processGesture(this, event, 'change');
	
	            // Mouse move should always be triggered no matter whether
	            // there is gestrue event, because mouse move and pinch may
	            // be used at the same time.
	            domHandlers.mousemove.call(this, event);
	
	            setTouchTimer(this);
	        },
	
	        /**
	         * Touch结束响应函数
	         * @inner
	         * @param {Event} event
	         */
	        touchend: function (event) {
	
	            event = normalizeEvent(this.dom, event);
	
	            processGesture(this, event, 'end');
	
	            domHandlers.mouseup.call(this, event);
	
	            // click event should always be triggered no matter whether
	            // there is gestrue event. System click can not be prevented.
	            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {
	                domHandlers.click.call(this, event);
	            }
	
	            setTouchTimer(this);
	        }
	    };
	
	    // Common handlers
	    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick'], function (name) {
	        domHandlers[name] = function (event) {
	            event = normalizeEvent(this.dom, event);
	            this.trigger(name, event);
	        };
	    });
	
	    /**
	     * 为控制类实例初始化dom 事件处理函数
	     *
	     * @inner
	     * @param {module:zrender/Handler} instance 控制类实例
	     */
	    function initDomHandler(instance) {
	        for (var i = 0; i < touchHandlerNames.length; i++) {
	            var name = touchHandlerNames[i];
	            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);
	        }
	
	        for (var i = 0; i < mouseHandlerNames.length; i++) {
	            var name = mouseHandlerNames[i];
	            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);
	        }
	
	        function makeMouseHandler(fn, instance) {
	            return function () {
	                if (instance._touching) {
	                    return;
	                }
	                return fn.apply(instance, arguments);
	            };
	        }
	    }
	
	
	    function HandlerDomProxy(dom) {
	        Eventful.call(this);
	
	        this.dom = dom;
	
	        /**
	         * @private
	         * @type {boolean}
	         */
	        this._touching = false;
	
	        /**
	         * @private
	         * @type {number}
	         */
	        this._touchTimer;
	
	        /**
	         * @private
	         * @type {module:zrender/core/GestureMgr}
	         */
	        this._gestureMgr = new GestureMgr();
	
	        this._handlers = {};
	
	        initDomHandler(this);
	
	        if (useTouchEvent()) {
	            mountHandlers(touchHandlerNames, this);
	
	            // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.
	            // addEventListener(root, 'mouseout', this._mouseoutHandler);
	        }
	
	        // Considering some devices that both enable touch and mouse event (like MS Surface
	        // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise
	        // mouse event can not be handle in those devices.
	        mountHandlers(mouseHandlerNames, this);
	
	        function mountHandlers(handlerNames, instance) {
	            zrUtil.each(handlerNames, function (name) {
	                addEventListener(dom, eventNameFix(name), instance._handlers[name]);
	            }, instance);
	        }
	    }
	
	    var handlerDomProxyProto = HandlerDomProxy.prototype;
	    handlerDomProxyProto.dispose = function () {
	        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);
	
	        for (var i = 0; i < handlerNames.length; i++) {
	            var name = handlerNames[i];
	            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);
	        }
	    };
	
	    handlerDomProxyProto.setCursor = function (cursorStyle) {
	        this.dom.style.cursor = cursorStyle || 'default';
	    };
	
	    zrUtil.mixin(HandlerDomProxy, Eventful);
	
	    return HandlerDomProxy;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Only implements needed gestures for mobile.
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
	
	    'use strict';
	
	    var eventUtil = __webpack_require__(91);
	
	    var GestureMgr = function () {
	
	        /**
	         * @private
	         * @type {Array.<Object>}
	         */
	        this._track = [];
	    };
	
	    GestureMgr.prototype = {
	
	        constructor: GestureMgr,
	
	        recognize: function (event, target, root) {
	            this._doTrack(event, target, root);
	            return this._recognize(event);
	        },
	
	        clear: function () {
	            this._track.length = 0;
	            return this;
	        },
	
	        _doTrack: function (event, target, root) {
	            var touches = event.touches;
	
	            if (!touches) {
	                return;
	            }
	
	            var trackItem = {
	                points: [],
	                touches: [],
	                target: target,
	                event: event
	            };
	
	            for (var i = 0, len = touches.length; i < len; i++) {
	                var touch = touches[i];
	                var pos = eventUtil.clientToLocal(root, touch);
	                trackItem.points.push([pos.zrX, pos.zrY]);
	                trackItem.touches.push(touch);
	            }
	
	            this._track.push(trackItem);
	        },
	
	        _recognize: function (event) {
	            for (var eventName in recognizers) {
	                if (recognizers.hasOwnProperty(eventName)) {
	                    var gestureInfo = recognizers[eventName](this._track, event);
	                    if (gestureInfo) {
	                        return gestureInfo;
	                    }
	                }
	            }
	        }
	    };
	
	    function dist(pointPair) {
	        var dx = pointPair[1][0] - pointPair[0][0];
	        var dy = pointPair[1][1] - pointPair[0][1];
	
	        return Math.sqrt(dx * dx + dy * dy);
	    }
	
	    function center(pointPair) {
	        return [
	            (pointPair[0][0] + pointPair[1][0]) / 2,
	            (pointPair[0][1] + pointPair[1][1]) / 2
	        ];
	    }
	
	    var recognizers = {
	
	        pinch: function (track, event) {
	            var trackLen = track.length;
	
	            if (!trackLen) {
	                return;
	            }
	
	            var pinchEnd = (track[trackLen - 1] || {}).points;
	            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;
	
	            if (pinchPre
	                && pinchPre.length > 1
	                && pinchEnd
	                && pinchEnd.length > 1
	            ) {
	                var pinchScale = dist(pinchEnd) / dist(pinchPre);
	                !isFinite(pinchScale) && (pinchScale = 1);
	
	                event.pinchScale = pinchScale;
	
	                var pinchCenter = center(pinchEnd);
	                event.pinchX = pinchCenter[0];
	                event.pinchY = pinchCenter[1];
	
	                return {
	                    type: 'pinch',
	                    target: track[0].target,
	                    event: event
	                };
	            }
	        }
	
	        // Only pinch currently.
	    };
	
	    return GestureMgr;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Default canvas painter
	 * @module zrender/Painter
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 *         pissang (https://www.github.com/pissang)
	 */
	 !(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	    'use strict';
	
	    var config = __webpack_require__(45);
	    var util = __webpack_require__(8);
	    var log = __webpack_require__(44);
	    var BoundingRect = __webpack_require__(13);
	    var timsort = __webpack_require__(89);
	
	    var Layer = __webpack_require__(96);
	
	    var requestAnimationFrame = __webpack_require__(92);
	
	    // PENDIGN
	    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.
	    //
	    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.
	    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;
	
	    function parseInt10(val) {
	        return parseInt(val, 10);
	    }
	
	    function isLayerValid(layer) {
	        if (!layer) {
	            return false;
	        }
	
	        if (layer.isBuildin) {
	            return true;
	        }
	
	        if (typeof(layer.resize) !== 'function'
	            || typeof(layer.refresh) !== 'function'
	        ) {
	            return false;
	        }
	
	        return true;
	    }
	
	    function preProcessLayer(layer) {
	        layer.__unusedCount++;
	    }
	
	    function postProcessLayer(layer) {
	        if (layer.__unusedCount == 1) {
	            layer.clear();
	        }
	    }
	
	    var tmpRect = new BoundingRect(0, 0, 0, 0);
	    var viewRect = new BoundingRect(0, 0, 0, 0);
	    function isDisplayableCulled(el, width, height) {
	        tmpRect.copy(el.getBoundingRect());
	        if (el.transform) {
	            tmpRect.applyTransform(el.transform);
	        }
	        viewRect.width = width;
	        viewRect.height = height;
	        return !tmpRect.intersect(viewRect);
	    }
	
	    function isClipPathChanged(clipPaths, prevClipPaths) {
	        if (clipPaths == prevClipPaths) { // Can both be null or undefined
	            return false;
	        }
	
	        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {
	            return true;
	        }
	        for (var i = 0; i < clipPaths.length; i++) {
	            if (clipPaths[i] !== prevClipPaths[i]) {
	                return true;
	            }
	        }
	    }
	
	    function doClip(clipPaths, ctx) {
	        for (var i = 0; i < clipPaths.length; i++) {
	            var clipPath = clipPaths[i];
	            var path = clipPath.path;
	
	            clipPath.setTransform(ctx);
	            path.beginPath(ctx);
	            clipPath.buildPath(path, clipPath.shape);
	            ctx.clip();
	            // Transform back
	            clipPath.restoreTransform(ctx);
	        }
	    }
	
	    function createRoot(width, height) {
	        var domRoot = document.createElement('div');
	        var domRootStyle = domRoot.style;
	
	        // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬
	        domRootStyle.position = 'relative';
	        domRootStyle.overflow = 'hidden';
	        domRootStyle.width = width + 'px';
	        domRootStyle.height = height + 'px';
	        return domRoot;
	    }
	
	    /**
	     * @alias module:zrender/Painter
	     * @constructor
	     * @param {HTMLElement} root 绘图容器
	     * @param {module:zrender/Storage} storage
	     * @param {Ojbect} opts
	     */
	    var Painter = function (root, storage, opts) {
	        // In node environment using node-canvas
	        var singleCanvas = !root.nodeName // In node ?
	            || root.nodeName.toUpperCase() === 'CANVAS';
	
	        opts = opts || {};
	
	        /**
	         * @type {number}
	         */
	        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;
	        /**
	         * @type {boolean}
	         * @private
	         */
	        this._singleCanvas = singleCanvas;
	        /**
	         * 绘图容器
	         * @type {HTMLElement}
	         */
	        this.root = root;
	
	        var rootStyle = root.style;
	
	        if (rootStyle) {
	            rootStyle['-webkit-tap-highlight-color'] = 'transparent';
	            rootStyle['-webkit-user-select'] =
	            rootStyle['user-select'] =
	            rootStyle['-webkit-touch-callout'] = 'none';
	
	            root.innerHTML = '';
	        }
	
	        /**
	         * @type {module:zrender/Storage}
	         */
	        this.storage = storage;
	
	        /**
	         * @type {Array.<number>}
	         * @private
	         */
	        var zlevelList = this._zlevelList = [];
	
	        /**
	         * @type {Object.<string, module:zrender/Layer>}
	         * @private
	         */
	        var layers = this._layers = {};
	
	        /**
	         * @type {Object.<string, Object>}
	         * @type {private}
	         */
	        this._layerConfig = {};
	
	        if (!singleCanvas) {
	            this._width = this._getWidth();
	            this._height = this._getHeight();
	
	            var domRoot = this._domRoot = createRoot(
	                this._width, this._height
	            );
	            root.appendChild(domRoot);
	        }
	        else {
	            // Use canvas width and height directly
	            var width = root.width;
	            var height = root.height;
	            this._width = width;
	            this._height = height;
	
	            // Create layer if only one given canvas
	            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height
	            var mainLayer = new Layer(root, this, 1);
	            mainLayer.initContext();
	            // FIXME Use canvas width and height
	            // mainLayer.resize(width, height);
	            layers[0] = mainLayer;
	            zlevelList.push(0);
	        }
	
	        this.pathToImage = this._createPathToImage();
	
	        // Layers for progressive rendering
	        this._progressiveLayers = [];
	
	        /**
	         * @type {module:zrender/Layer}
	         * @private
	         */
	        this._hoverlayer;
	
	        this._hoverElements = [];
	    };
	
	    Painter.prototype = {
	
	        constructor: Painter,
	
	        /**
	         * If painter use a single canvas
	         * @return {boolean}
	         */
	        isSingleCanvas: function () {
	            return this._singleCanvas;
	        },
	        /**
	         * @return {HTMLDivElement}
	         */
	        getViewportRoot: function () {
	            return this._singleCanvas ? this._layers[0].dom : this._domRoot;
	        },
	
	        /**
	         * 刷新
	         * @param {boolean} [paintAll=false] 强制绘制所有displayable
	         */
	        refresh: function (paintAll) {
	
	            var list = this.storage.getDisplayList(true);
	
	            var zlevelList = this._zlevelList;
	
	            this._paintList(list, paintAll);
	
	            // Paint custum layers
	            for (var i = 0; i < zlevelList.length; i++) {
	                var z = zlevelList[i];
	                var layer = this._layers[z];
	                if (!layer.isBuildin && layer.refresh) {
	                    layer.refresh();
	                }
	            }
	
	            this.refreshHover();
	
	            if (this._progressiveLayers.length) {
	                this._startProgessive();
	            }
	
	            return this;
	        },
	
	        addHover: function (el, hoverStyle) {
	            if (el.__hoverMir) {
	                return;
	            }
	            var elMirror = new el.constructor({
	                style: el.style,
	                shape: el.shape
	            });
	            elMirror.__from = el;
	            el.__hoverMir = elMirror;
	            elMirror.setStyle(hoverStyle);
	            this._hoverElements.push(elMirror);
	        },
	
	        removeHover: function (el) {
	            var elMirror = el.__hoverMir;
	            var hoverElements = this._hoverElements;
	            var idx = util.indexOf(hoverElements, elMirror);
	            if (idx >= 0) {
	                hoverElements.splice(idx, 1);
	            }
	            el.__hoverMir = null;
	        },
	
	        clearHover: function (el) {
	            var hoverElements = this._hoverElements;
	            for (var i = 0; i < hoverElements.length; i++) {
	                var from = hoverElements[i].__from;
	                if (from) {
	                    from.__hoverMir = null;
	                }
	            }
	            hoverElements.length = 0;
	        },
	
	        refreshHover: function () {
	            var hoverElements = this._hoverElements;
	            var len = hoverElements.length;
	            var hoverLayer = this._hoverlayer;
	            hoverLayer && hoverLayer.clear();
	
	            if (!len) {
	                return;
	            }
	            timsort(hoverElements, this.storage.displayableSortFunc);
	
	            // Use a extream large zlevel
	            // FIXME?
	            if (!hoverLayer) {
	                hoverLayer = this._hoverlayer = this.getLayer(1e5);
	            }
	
	            var scope = {};
	            hoverLayer.ctx.save();
	            for (var i = 0; i < len;) {
	                var el = hoverElements[i];
	                var originalEl = el.__from;
	                // Original el is removed
	                // PENDING
	                if (!(originalEl && originalEl.__zr)) {
	                    hoverElements.splice(i, 1);
	                    originalEl.__hoverMir = null;
	                    len--;
	                    continue;
	                }
	                i++;
	
	                // Use transform
	                // FIXME style and shape ?
	                if (!originalEl.invisible) {
	                    el.transform = originalEl.transform;
	                    el.invTransform = originalEl.invTransform;
	                    el.__clipPaths = originalEl.__clipPaths;
	                    // el.
	                    this._doPaintEl(el, hoverLayer, true, scope);
	                }
	            }
	            hoverLayer.ctx.restore();
	        },
	
	        _startProgessive: function () {
	            var self = this;
	
	            if (!self._furtherProgressive) {
	                return;
	            }
	
	            // Use a token to stop progress steps triggered by
	            // previous zr.refresh calling.
	            var token = self._progressiveToken = +new Date();
	
	            self._progress++;
	            requestAnimationFrame(step);
	
	            function step() {
	                // In case refreshed or disposed
	                if (token === self._progressiveToken && self.storage) {
	
	                    self._doPaintList(self.storage.getDisplayList());
	
	                    if (self._furtherProgressive) {
	                        self._progress++;
	                        requestAnimationFrame(step);
	                    }
	                    else {
	                        self._progressiveToken = -1;
	                    }
	                }
	            }
	        },
	
	        _clearProgressive: function () {
	            this._progressiveToken = -1;
	            this._progress = 0;
	            util.each(this._progressiveLayers, function (layer) {
	                layer.__dirty && layer.clear();
	            });
	        },
	
	        _paintList: function (list, paintAll) {
	
	            if (paintAll == null) {
	                paintAll = false;
	            }
	
	            this._updateLayerStatus(list);
	
	            this._clearProgressive();
	
	            this.eachBuildinLayer(preProcessLayer);
	
	            this._doPaintList(list, paintAll);
	
	            this.eachBuildinLayer(postProcessLayer);
	        },
	
	        _doPaintList: function (list, paintAll) {
	            var currentLayer;
	            var currentZLevel;
	            var ctx;
	
	            // var invTransform = [];
	            var scope;
	
	            var progressiveLayerIdx = 0;
	            var currentProgressiveLayer;
	
	            var width = this._width;
	            var height = this._height;
	            var layerProgress;
	            var frame = this._progress;
	            function flushProgressiveLayer(layer) {
	                var dpr = ctx.dpr || 1;
	                ctx.save();
	                ctx.globalAlpha = 1;
	                ctx.shadowBlur = 0;
	                // Avoid layer don't clear in next progressive frame
	                currentLayer.__dirty = true;
	                ctx.setTransform(1, 0, 0, 1, 0, 0);
	                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);
	                ctx.restore();
	            }
	
	            for (var i = 0, l = list.length; i < l; i++) {
	                var el = list[i];
	                var elZLevel = this._singleCanvas ? 0 : el.zlevel;
	
	                var elFrame = el.__frame;
	
	                // Flush at current context
	                // PENDING
	                if (elFrame < 0 && currentProgressiveLayer) {
	                    flushProgressiveLayer(currentProgressiveLayer);
	                    currentProgressiveLayer = null;
	                }
	
	                // Change draw layer
	                if (currentZLevel !== elZLevel) {
	                    if (ctx) {
	                        ctx.restore();
	                    }
	
	                    // Reset scope
	                    scope = {};
	
	                    // Only 0 zlevel if only has one canvas
	                    currentZLevel = elZLevel;
	                    currentLayer = this.getLayer(currentZLevel);
	
	                    if (!currentLayer.isBuildin) {
	                        log(
	                            'ZLevel ' + currentZLevel
	                            + ' has been used by unkown layer ' + currentLayer.id
	                        );
	                    }
	
	                    ctx = currentLayer.ctx;
	                    ctx.save();
	
	                    // Reset the count
	                    currentLayer.__unusedCount = 0;
	
	                    if (currentLayer.__dirty || paintAll) {
	                        currentLayer.clear();
	                    }
	                }
	
	                if (!(currentLayer.__dirty || paintAll)) {
	                    continue;
	                }
	
	                if (elFrame >= 0) {
	                    // Progressive layer changed
	                    if (!currentProgressiveLayer) {
	                        currentProgressiveLayer = this._progressiveLayers[
	                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)
	                        ];
	
	                        currentProgressiveLayer.ctx.save();
	                        currentProgressiveLayer.renderScope = {};
	
	                        if (currentProgressiveLayer
	                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)
	                        ) {
	                            // flushProgressiveLayer(currentProgressiveLayer);
	                            // Quick jump all progressive elements
	                            // All progressive element are not dirty, jump over and flush directly
	                            i = currentProgressiveLayer.__nextIdxNotProg - 1;
	                            // currentProgressiveLayer = null;
	                            continue;
	                        }
	
	                        layerProgress = currentProgressiveLayer.__progress;
	
	                        if (!currentProgressiveLayer.__dirty) {
	                            // Keep rendering
	                            frame = layerProgress;
	                        }
	
	                        currentProgressiveLayer.__progress = frame + 1;
	                    }
	
	                    if (elFrame === frame) {
	                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);
	                    }
	                }
	                else {
	                    this._doPaintEl(el, currentLayer, paintAll, scope);
	                }
	
	                el.__dirty = false;
	            }
	
	            if (currentProgressiveLayer) {
	                flushProgressiveLayer(currentProgressiveLayer);
	            }
	
	            // Restore the lastLayer ctx
	            ctx && ctx.restore();
	            // If still has clipping state
	            // if (scope.prevElClipPaths) {
	            //     ctx.restore();
	            // }
	
	            this._furtherProgressive = false;
	            util.each(this._progressiveLayers, function (layer) {
	                if (layer.__maxProgress >= layer.__progress) {
	                    this._furtherProgressive = true;
	                }
	            }, this);
	        },
	
	        _doPaintEl: function (el, currentLayer, forcePaint, scope) {
	            var ctx = currentLayer.ctx;
	            var m = el.transform;
	            if (
	                (currentLayer.__dirty || forcePaint)
	                // Ignore invisible element
	                && !el.invisible
	                // Ignore transparent element
	                && el.style.opacity !== 0
	                // Ignore scale 0 element, in some environment like node-canvas
	                // Draw a scale 0 element can cause all following draw wrong
	                // And setTransform with scale 0 will cause set back transform failed.
	                && !(m && !m[0] && !m[3])
	                // Ignore culled element
	                && !(el.culling && isDisplayableCulled(el, this._width, this._height))
	            ) {
	
	                var clipPaths = el.__clipPaths;
	
	                // Optimize when clipping on group with several elements
	                if (scope.prevClipLayer !== currentLayer
	                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)
	                ) {
	                    // If has previous clipping state, restore from it
	                    if (scope.prevElClipPaths) {
	                        scope.prevClipLayer.ctx.restore();
	                        scope.prevClipLayer = scope.prevElClipPaths = null;
	
	                        // Reset prevEl since context has been restored
	                        scope.prevEl = null;
	                    }
	                    // New clipping state
	                    if (clipPaths) {
	                        ctx.save();
	                        doClip(clipPaths, ctx);
	                        scope.prevClipLayer = currentLayer;
	                        scope.prevElClipPaths = clipPaths;
	                    }
	                }
	                el.beforeBrush && el.beforeBrush(ctx);
	
	                el.brush(ctx, scope.prevEl || null);
	                scope.prevEl = el;
	
	                el.afterBrush && el.afterBrush(ctx);
	            }
	        },
	
	        /**
	         * 获取 zlevel 所在层，如果不存在则会创建一个新的层
	         * @param {number} zlevel
	         * @return {module:zrender/Layer}
	         */
	        getLayer: function (zlevel) {
	            if (this._singleCanvas) {
	                return this._layers[0];
	            }
	
	            var layer = this._layers[zlevel];
	            if (!layer) {
	                // Create a new layer
	                layer = new Layer('zr_' + zlevel, this, this.dpr);
	                layer.isBuildin = true;
	
	                if (this._layerConfig[zlevel]) {
	                    util.merge(layer, this._layerConfig[zlevel], true);
	                }
	
	                this.insertLayer(zlevel, layer);
	
	                // Context is created after dom inserted to document
	                // Or excanvas will get 0px clientWidth and clientHeight
	                layer.initContext();
	            }
	
	            return layer;
	        },
	
	        insertLayer: function (zlevel, layer) {
	
	            var layersMap = this._layers;
	            var zlevelList = this._zlevelList;
	            var len = zlevelList.length;
	            var prevLayer = null;
	            var i = -1;
	            var domRoot = this._domRoot;
	
	            if (layersMap[zlevel]) {
	                log('ZLevel ' + zlevel + ' has been used already');
	                return;
	            }
	            // Check if is a valid layer
	            if (!isLayerValid(layer)) {
	                log('Layer of zlevel ' + zlevel + ' is not valid');
	                return;
	            }
	
	            if (len > 0 && zlevel > zlevelList[0]) {
	                for (i = 0; i < len - 1; i++) {
	                    if (
	                        zlevelList[i] < zlevel
	                        && zlevelList[i + 1] > zlevel
	                    ) {
	                        break;
	                    }
	                }
	                prevLayer = layersMap[zlevelList[i]];
	            }
	            zlevelList.splice(i + 1, 0, zlevel);
	
	            if (prevLayer) {
	                var prevDom = prevLayer.dom;
	                if (prevDom.nextSibling) {
	                    domRoot.insertBefore(
	                        layer.dom,
	                        prevDom.nextSibling
	                    );
	                }
	                else {
	                    domRoot.appendChild(layer.dom);
	                }
	            }
	            else {
	                if (domRoot.firstChild) {
	                    domRoot.insertBefore(layer.dom, domRoot.firstChild);
	                }
	                else {
	                    domRoot.appendChild(layer.dom);
	                }
	            }
	
	            layersMap[zlevel] = layer;
	        },
	
	        // Iterate each layer
	        eachLayer: function (cb, context) {
	            var zlevelList = this._zlevelList;
	            var z;
	            var i;
	            for (i = 0; i < zlevelList.length; i++) {
	                z = zlevelList[i];
	                cb.call(context, this._layers[z], z);
	            }
	        },
	
	        // Iterate each buildin layer
	        eachBuildinLayer: function (cb, context) {
	            var zlevelList = this._zlevelList;
	            var layer;
	            var z;
	            var i;
	            for (i = 0; i < zlevelList.length; i++) {
	                z = zlevelList[i];
	                layer = this._layers[z];
	                if (layer.isBuildin) {
	                    cb.call(context, layer, z);
	                }
	            }
	        },
	
	        // Iterate each other layer except buildin layer
	        eachOtherLayer: function (cb, context) {
	            var zlevelList = this._zlevelList;
	            var layer;
	            var z;
	            var i;
	            for (i = 0; i < zlevelList.length; i++) {
	                z = zlevelList[i];
	                layer = this._layers[z];
	                if (! layer.isBuildin) {
	                    cb.call(context, layer, z);
	                }
	            }
	        },
	
	        /**
	         * 获取所有已创建的层
	         * @param {Array.<module:zrender/Layer>} [prevLayer]
	         */
	        getLayers: function () {
	            return this._layers;
	        },
	
	        _updateLayerStatus: function (list) {
	
	            var layers = this._layers;
	            var progressiveLayers = this._progressiveLayers;
	
	            var elCountsLastFrame = {};
	            var progressiveElCountsLastFrame = {};
	
	            this.eachBuildinLayer(function (layer, z) {
	                elCountsLastFrame[z] = layer.elCount;
	                layer.elCount = 0;
	                layer.__dirty = false;
	            });
	
	            util.each(progressiveLayers, function (layer, idx) {
	                progressiveElCountsLastFrame[idx] = layer.elCount;
	                layer.elCount = 0;
	                layer.__dirty = false;
	            });
	
	            var progressiveLayerCount = 0;
	            var currentProgressiveLayer;
	            var lastProgressiveKey;
	            var frameCount = 0;
	            for (var i = 0, l = list.length; i < l; i++) {
	                var el = list[i];
	                var zlevel = this._singleCanvas ? 0 : el.zlevel;
	                var layer = layers[zlevel];
	                var elProgress = el.progressive;
	                if (layer) {
	                    layer.elCount++;
	                    layer.__dirty = layer.__dirty || el.__dirty;
	                }
	
	                /////// Update progressive
	                if (elProgress >= 0) {
	                    // Fix wrong progressive sequence problem.
	                    if (lastProgressiveKey !== elProgress) {
	                        lastProgressiveKey = elProgress;
	                        frameCount++;
	                    }
	                    var elFrame = el.__frame = frameCount - 1;
	                    if (!currentProgressiveLayer) {
	                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);
	                        currentProgressiveLayer = progressiveLayers[idx];
	                        if (!currentProgressiveLayer) {
	                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(
	                                'progressive', this, this.dpr
	                            );
	                            currentProgressiveLayer.initContext();
	                        }
	                        currentProgressiveLayer.__maxProgress = 0;
	                    }
	                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;
	                    currentProgressiveLayer.elCount++;
	
	                    currentProgressiveLayer.__maxProgress = Math.max(
	                        currentProgressiveLayer.__maxProgress, elFrame
	                    );
	
	                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {
	                        // Should keep rendering this  layer because progressive rendering is not finished yet
	                        layer.__dirty = true;
	                    }
	                }
	                else {
	                    el.__frame = -1;
	
	                    if (currentProgressiveLayer) {
	                        currentProgressiveLayer.__nextIdxNotProg = i;
	                        progressiveLayerCount++;
	                        currentProgressiveLayer = null;
	                    }
	                }
	            }
	
	            if (currentProgressiveLayer) {
	                progressiveLayerCount++;
	                currentProgressiveLayer.__nextIdxNotProg = i;
	            }
	
	            // 层中的元素数量有发生变化
	            this.eachBuildinLayer(function (layer, z) {
	                if (elCountsLastFrame[z] !== layer.elCount) {
	                    layer.__dirty = true;
	                }
	            });
	
	            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);
	            util.each(progressiveLayers, function (layer, idx) {
	                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {
	                    el.__dirty = true;
	                }
	                if (layer.__dirty) {
	                    layer.__progress = 0;
	                }
	            });
	        },
	
	        /**
	         * 清除hover层外所有内容
	         */
	        clear: function () {
	            this.eachBuildinLayer(this._clearLayer);
	            return this;
	        },
	
	        _clearLayer: function (layer) {
	            layer.clear();
	        },
	
	        /**
	         * 修改指定zlevel的绘制参数
	         *
	         * @param {string} zlevel
	         * @param {Object} config 配置对象
	         * @param {string} [config.clearColor=0] 每次清空画布的颜色
	         * @param {string} [config.motionBlur=false] 是否开启动态模糊
	         * @param {number} [config.lastFrameAlpha=0.7]
	         *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
	         */
	        configLayer: function (zlevel, config) {
	            if (config) {
	                var layerConfig = this._layerConfig;
	                if (!layerConfig[zlevel]) {
	                    layerConfig[zlevel] = config;
	                }
	                else {
	                    util.merge(layerConfig[zlevel], config, true);
	                }
	
	                var layer = this._layers[zlevel];
	
	                if (layer) {
	                    util.merge(layer, layerConfig[zlevel], true);
	                }
	            }
	        },
	
	        /**
	         * 删除指定层
	         * @param {number} zlevel 层所在的zlevel
	         */
	        delLayer: function (zlevel) {
	            var layers = this._layers;
	            var zlevelList = this._zlevelList;
	            var layer = layers[zlevel];
	            if (!layer) {
	                return;
	            }
	            layer.dom.parentNode.removeChild(layer.dom);
	            delete layers[zlevel];
	
	            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);
	        },
	
	        /**
	         * 区域大小变化后重绘
	         */
	        resize: function (width, height) {
	            var domRoot = this._domRoot;
	            // FIXME Why ?
	            domRoot.style.display = 'none';
	
	            width = width || this._getWidth();
	            height = height || this._getHeight();
	
	            domRoot.style.display = '';
	
	            // 优化没有实际改变的resize
	            if (this._width != width || height != this._height) {
	                domRoot.style.width = width + 'px';
	                domRoot.style.height = height + 'px';
	
	                for (var id in this._layers) {
	                    this._layers[id].resize(width, height);
	                }
	
	                this.refresh(true);
	            }
	
	            this._width = width;
	            this._height = height;
	
	            return this;
	        },
	
	        /**
	         * 清除单独的一个层
	         * @param {number} zlevel
	         */
	        clearLayer: function (zlevel) {
	            var layer = this._layers[zlevel];
	            if (layer) {
	                layer.clear();
	            }
	        },
	
	        /**
	         * 释放
	         */
	        dispose: function () {
	            this.root.innerHTML = '';
	
	            this.root =
	            this.storage =
	
	            this._domRoot =
	            this._layers = null;
	        },
	
	        /**
	         * Get canvas which has all thing rendered
	         * @param {Object} opts
	         * @param {string} [opts.backgroundColor]
	         */
	        getRenderedCanvas: function (opts) {
	            opts = opts || {};
	            if (this._singleCanvas) {
	                return this._layers[0].dom;
	            }
	
	            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);
	            imageLayer.initContext();
	
	            imageLayer.clearColor = opts.backgroundColor;
	            imageLayer.clear();
	
	            var displayList = this.storage.getDisplayList(true);
	
	            var scope = {};
	            for (var i = 0; i < displayList.length; i++) {
	                var el = displayList[i];
	                this._doPaintEl(el, imageLayer, true, scope);
	            }
	
	            return imageLayer.dom;
	        },
	        /**
	         * 获取绘图区域宽度
	         */
	        getWidth: function () {
	            return this._width;
	        },
	
	        /**
	         * 获取绘图区域高度
	         */
	        getHeight: function () {
	            return this._height;
	        },
	
	        _getWidth: function () {
	            var root = this.root;
	            var stl = document.defaultView.getComputedStyle(root);
	
	            // FIXME Better way to get the width and height when element has not been append to the document
	            return ((root.clientWidth || parseInt10(stl.width) || parseInt10(root.style.width))
	                    - (parseInt10(stl.paddingLeft) || 0)
	                    - (parseInt10(stl.paddingRight) || 0)) | 0;
	        },
	
	        _getHeight: function () {
	            var root = this.root;
	            var stl = document.defaultView.getComputedStyle(root);
	
	            return ((root.clientHeight || parseInt10(stl.height) || parseInt10(root.style.height))
	                    - (parseInt10(stl.paddingTop) || 0)
	                    - (parseInt10(stl.paddingBottom) || 0)) | 0;
	        },
	
	        _pathToImage: function (id, path, width, height, dpr) {
	            var canvas = document.createElement('canvas');
	            var ctx = canvas.getContext('2d');
	
	            canvas.width = width * dpr;
	            canvas.height = height * dpr;
	
	            ctx.clearRect(0, 0, width * dpr, height * dpr);
	
	            var pathTransform = {
	                position: path.position,
	                rotation: path.rotation,
	                scale: path.scale
	            };
	            path.position = [0, 0, 0];
	            path.rotation = 0;
	            path.scale = [1, 1];
	            if (path) {
	                path.brush(ctx);
	            }
	
	            var ImageShape = __webpack_require__(66);
	            var imgShape = new ImageShape({
	                id: id,
	                style: {
	                    x: 0,
	                    y: 0,
	                    image: canvas
	                }
	            });
	
	            if (pathTransform.position != null) {
	                imgShape.position = path.position = pathTransform.position;
	            }
	
	            if (pathTransform.rotation != null) {
	                imgShape.rotation = path.rotation = pathTransform.rotation;
	            }
	
	            if (pathTransform.scale != null) {
	                imgShape.scale = path.scale = pathTransform.scale;
	            }
	
	            return imgShape;
	        },
	
	        _createPathToImage: function () {
	            var me = this;
	
	            return function (id, e, width, height) {
	                return me._pathToImage(
	                    id, e, width, height, me.dpr
	                );
	            };
	        }
	    };
	
	    return Painter;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * @module zrender/Layer
	 * @author pissang(https://www.github.com/pissang)
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var util = __webpack_require__(8);
	    var config = __webpack_require__(45);
	    var Style = __webpack_require__(51);
	    var Pattern = __webpack_require__(63);
	
	    function returnFalse() {
	        return false;
	    }
	
	    /**
	     * 创建dom
	     *
	     * @inner
	     * @param {string} id dom id 待用
	     * @param {string} type dom type，such as canvas, div etc.
	     * @param {Painter} painter painter instance
	     * @param {number} number
	     */
	    function createDom(id, type, painter, dpr) {
	        var newDom = document.createElement(type);
	        var width = painter.getWidth();
	        var height = painter.getHeight();
	
	        var newDomStyle = newDom.style;
	        // 没append呢，请原谅我这样写，清晰~
	        newDomStyle.position = 'absolute';
	        newDomStyle.left = 0;
	        newDomStyle.top = 0;
	        newDomStyle.width = width + 'px';
	        newDomStyle.height = height + 'px';
	        newDom.width = width * dpr;
	        newDom.height = height * dpr;
	
	        // id不作为索引用，避免可能造成的重名，定义为私有属性
	        newDom.setAttribute('data-zr-dom-id', id);
	        return newDom;
	    }
	
	    /**
	     * @alias module:zrender/Layer
	     * @constructor
	     * @extends module:zrender/mixin/Transformable
	     * @param {string} id
	     * @param {module:zrender/Painter} painter
	     * @param {number} [dpr]
	     */
	    var Layer = function(id, painter, dpr) {
	        var dom;
	        dpr = dpr || config.devicePixelRatio;
	        if (typeof id === 'string') {
	            dom = createDom(id, 'canvas', painter, dpr);
	        }
	        // Not using isDom because in node it will return false
	        else if (util.isObject(id)) {
	            dom = id;
	            id = dom.id;
	        }
	        this.id = id;
	        this.dom = dom;
	
	        var domStyle = dom.style;
	        if (domStyle) { // Not in node
	            dom.onselectstart = returnFalse; // 避免页面选中的尴尬
	            domStyle['-webkit-user-select'] = 'none';
	            domStyle['user-select'] = 'none';
	            domStyle['-webkit-touch-callout'] = 'none';
	            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';
	        }
	
	        this.domBack = null;
	        this.ctxBack = null;
	
	        this.painter = painter;
	
	        this.config = null;
	
	        // Configs
	        /**
	         * 每次清空画布的颜色
	         * @type {string}
	         * @default 0
	         */
	        this.clearColor = 0;
	        /**
	         * 是否开启动态模糊
	         * @type {boolean}
	         * @default false
	         */
	        this.motionBlur = false;
	        /**
	         * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
	         * @type {number}
	         * @default 0.7
	         */
	        this.lastFrameAlpha = 0.7;
	
	        /**
	         * Layer dpr
	         * @type {number}
	         */
	        this.dpr = dpr;
	    };
	
	    Layer.prototype = {
	
	        constructor: Layer,
	
	        elCount: 0,
	
	        __dirty: true,
	
	        initContext: function () {
	            this.ctx = this.dom.getContext('2d');
	
	            this.ctx.dpr = this.dpr;
	        },
	
	        createBackBuffer: function () {
	            var dpr = this.dpr;
	
	            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);
	            this.ctxBack = this.domBack.getContext('2d');
	
	            if (dpr != 1) {
	                this.ctxBack.scale(dpr, dpr);
	            }
	        },
	
	        /**
	         * @param  {number} width
	         * @param  {number} height
	         */
	        resize: function (width, height) {
	            var dpr = this.dpr;
	
	            var dom = this.dom;
	            var domStyle = dom.style;
	            var domBack = this.domBack;
	
	            domStyle.width = width + 'px';
	            domStyle.height = height + 'px';
	
	            dom.width = width * dpr;
	            dom.height = height * dpr;
	
	            if (domBack) {
	                domBack.width = width * dpr;
	                domBack.height = height * dpr;
	
	                if (dpr != 1) {
	                    this.ctxBack.scale(dpr, dpr);
	                }
	            }
	        },
	
	        /**
	         * 清空该层画布
	         * @param {boolean} clearAll Clear all with out motion blur
	         */
	        clear: function (clearAll) {
	            var dom = this.dom;
	            var ctx = this.ctx;
	            var width = dom.width;
	            var height = dom.height;
	
	            var clearColor = this.clearColor;
	            var haveMotionBLur = this.motionBlur && !clearAll;
	            var lastFrameAlpha = this.lastFrameAlpha;
	
	            var dpr = this.dpr;
	
	            if (haveMotionBLur) {
	                if (!this.domBack) {
	                    this.createBackBuffer();
	                }
	
	                this.ctxBack.globalCompositeOperation = 'copy';
	                this.ctxBack.drawImage(
	                    dom, 0, 0,
	                    width / dpr,
	                    height / dpr
	                );
	            }
	
	            ctx.clearRect(0, 0, width, height);
	            if (clearColor) {
	                var clearColorGradientOrPattern;
	                // Gradient
	                if (clearColor.colorStops) {
	                    // Cache canvas gradient
	                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {
	                        x: 0,
	                        y: 0,
	                        width: width,
	                        height: height
	                    });
	
	                    clearColor.__canvasGradient = clearColorGradientOrPattern;
	                }
	                // Pattern
	                else if (clearColor.image) {
	                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);
	                }
	                ctx.save();
	                ctx.fillStyle = clearColorGradientOrPattern || clearColor;
	                ctx.fillRect(0, 0, width, height);
	                ctx.restore();
	            }
	
	            if (haveMotionBLur) {
	                var domBack = this.domBack;
	                ctx.save();
	                ctx.globalAlpha = lastFrameAlpha;
	                ctx.drawImage(domBack, 0, 0, width, height);
	                ctx.restore();
	            }
	        }
	    };
	
	    return Layer;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	    var Gradient = __webpack_require__(65);
	    return function (ecModel) {
	        function encodeColor(seriesModel) {
	            var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');
	            var data = seriesModel.getData();
	            var color = seriesModel.get(colorAccessPath) // Set in itemStyle
	                || seriesModel.getColorFromPalette(seriesModel.get('name'));  // Default color
	
	            // FIXME Set color function or use the platte color
	            data.setVisual('color', color);
	
	            // Only visible series has each data be visual encoded
	            if (!ecModel.isSeriesFiltered(seriesModel)) {
	                if (typeof color === 'function' && !(color instanceof Gradient)) {
	                    data.each(function (idx) {
	                        data.setItemVisual(
	                            idx, 'color', color(seriesModel.getDataParams(idx))
	                        );
	                    });
	                }
	
	                // itemStyle in each data item
	                data.each(function (idx) {
	                    var itemModel = data.getItemModel(idx);
	                    var color = itemModel.get(colorAccessPath, true);
	                    if (color != null) {
	                        data.setItemVisual(idx, 'color', color);
	                    }
	                });
	            }
	        }
	        ecModel.eachRawSeries(encodeColor);
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;// Compatitable with 2.0
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var zrUtil = __webpack_require__(8);
	    var compatStyle = __webpack_require__(99);
	
	    function get(opt, path) {
	        path = path.split(',');
	        var obj = opt;
	        for (var i = 0; i < path.length; i++) {
	            obj = obj && obj[path[i]];
	            if (obj == null) {
	                break;
	            }
	        }
	        return obj;
	    }
	
	    function set(opt, path, val, overwrite) {
	        path = path.split(',');
	        var obj = opt;
	        var key;
	        for (var i = 0; i < path.length - 1; i++) {
	            key = path[i];
	            if (obj[key] == null) {
	                obj[key] = {};
	            }
	            obj = obj[key];
	        }
	        if (overwrite || obj[path[i]] == null) {
	            obj[path[i]] = val;
	        }
	    }
	
	    function compatLayoutProperties(option) {
	        each(LAYOUT_PROPERTIES, function (prop) {
	            if (prop[0] in option && !(prop[1] in option)) {
	                option[prop[1]] = option[prop[0]];
	            }
	        });
	    }
	
	    var LAYOUT_PROPERTIES = [
	        ['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']
	    ];
	
	    var COMPATITABLE_COMPONENTS = [
	        'grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'
	    ];
	
	    var COMPATITABLE_SERIES = [
	        'bar', 'boxplot', 'candlestick', 'chord', 'effectScatter',
	        'funnel', 'gauge', 'lines', 'graph', 'heatmap', 'line', 'map', 'parallel',
	        'pie', 'radar', 'sankey', 'scatter', 'treemap'
	    ];
	
	    var each = zrUtil.each;
	
	    return function (option) {
	        each(option.series, function (seriesOpt) {
	            if (!zrUtil.isObject(seriesOpt)) {
	                return;
	            }
	
	            var seriesType = seriesOpt.type;
	
	            compatStyle(seriesOpt);
	
	            if (seriesType === 'pie' || seriesType === 'gauge') {
	                if (seriesOpt.clockWise != null) {
	                    seriesOpt.clockwise = seriesOpt.clockWise;
	                }
	            }
	            if (seriesType === 'gauge') {
	                var pointerColor = get(seriesOpt, 'pointer.color');
	                pointerColor != null
	                    && set(seriesOpt, 'itemStyle.normal.color', pointerColor);
	            }
	
	            for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {
	                if (COMPATITABLE_SERIES[i] === seriesOpt.type) {
	                    compatLayoutProperties(seriesOpt);
	                    break;
	                }
	            }
	        });
	
	        // dataRange has changed to visualMap
	        if (option.dataRange) {
	            option.visualMap = option.dataRange;
	        }
	
	        each(COMPATITABLE_COMPONENTS, function (componentName) {
	            var options = option[componentName];
	            if (options) {
	                if (!zrUtil.isArray(options)) {
	                    options = [options];
	                }
	                each(options, function (option) {
	                    compatLayoutProperties(option);
	                });
	            }
	        });
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var zrUtil = __webpack_require__(8);
	
	    var POSSIBLE_STYLES = [
	        'areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle',
	        'chordStyle', 'label', 'labelLine'
	    ];
	
	    function compatItemStyle(opt) {
	        var itemStyleOpt = opt && opt.itemStyle;
	        if (itemStyleOpt) {
	            zrUtil.each(POSSIBLE_STYLES, function (styleName) {
	                var normalItemStyleOpt = itemStyleOpt.normal;
	                var emphasisItemStyleOpt = itemStyleOpt.emphasis;
	                if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {
	                    opt[styleName] = opt[styleName] || {};
	                    if (!opt[styleName].normal) {
	                        opt[styleName].normal = normalItemStyleOpt[styleName];
	                    }
	                    else {
	                        zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);
	                    }
	                    normalItemStyleOpt[styleName] = null;
	                }
	                if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {
	                    opt[styleName] = opt[styleName] || {};
	                    if (!opt[styleName].emphasis) {
	                        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];
	                    }
	                    else {
	                        zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);
	                    }
	                    emphasisItemStyleOpt[styleName] = null;
	                }
	            });
	        }
	    }
	
	    return function (seriesOpt) {
	        if (!seriesOpt) {
	            return;
	        }
	        compatItemStyle(seriesOpt);
	        compatItemStyle(seriesOpt.markPoint);
	        compatItemStyle(seriesOpt.markLine);
	        var data = seriesOpt.data;
	        if (data) {
	            for (var i = 0; i < data.length; i++) {
	                compatItemStyle(data[i]);
	            }
	            // mark point data
	            var markPoint = seriesOpt.markPoint;
	            if (markPoint && markPoint.data) {
	                var mpData = markPoint.data;
	                for (var i = 0; i < mpData.length; i++) {
	                    compatItemStyle(mpData[i]);
	                }
	            }
	            // mark line data
	            var markLine = seriesOpt.markLine;
	            if (markLine && markLine.data) {
	                var mlData = markLine.data;
	                for (var i = 0; i < mlData.length; i++) {
	                    if (zrUtil.isArray(mlData[i])) {
	                        compatItemStyle(mlData[i][0]);
	                        compatItemStyle(mlData[i][1]);
	                    }
	                    else {
	                        compatItemStyle(mlData[i]);
	                    }
	                }
	            }
	        }
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var graphic = __webpack_require__(47);
	    var zrUtil = __webpack_require__(8);
	    var PI = Math.PI;
	    /**
	     * @param {module:echarts/ExtensionAPI} api
	     * @param {Object} [opts]
	     * @param {string} [opts.text]
	     * @param {string} [opts.color]
	     * @param {string} [opts.textColor]
	     * @return {module:zrender/Element}
	     */
	    return function (api, opts) {
	        opts = opts || {};
	        zrUtil.defaults(opts, {
	            text: 'loading',
	            color: '#c23531',
	            textColor: '#000',
	            maskColor: 'rgba(255, 255, 255, 0.8)',
	            zlevel: 0
	        });
	        var mask = new graphic.Rect({
	            style: {
	                fill: opts.maskColor
	            },
	            zlevel: opts.zlevel,
	            z: 10000
	        });
	        var arc = new graphic.Arc({
	            shape: {
	                startAngle: -PI / 2,
	                endAngle: -PI / 2 + 0.1,
	                r: 10
	            },
	            style: {
	                stroke: opts.color,
	                lineCap: 'round',
	                lineWidth: 5
	            },
	            zlevel: opts.zlevel,
	            z: 10001
	        });
	        var labelRect = new graphic.Rect({
	            style: {
	                fill: 'none',
	                text: opts.text,
	                textPosition: 'right',
	                textDistance: 10,
	                textFill: opts.textColor
	            },
	            zlevel: opts.zlevel,
	            z: 10001
	        });
	
	        arc.animateShape(true)
	            .when(1000, {
	                endAngle: PI * 3 / 2
	            })
	            .start('circularInOut');
	        arc.animateShape(true)
	            .when(1000, {
	                startAngle: PI * 3 / 2
	            })
	            .delay(300)
	            .start('circularInOut');
	
	        var group = new graphic.Group();
	        group.add(arc);
	        group.add(labelRect);
	        group.add(mask);
	        // Inject resize
	        group.resize = function () {
	            var cx = api.getWidth() / 2;
	            var cy = api.getHeight() / 2;
	            arc.setShape({
	                cx: cx,
	                cy: cy
	            });
	            var r = arc.shape.r;
	            labelRect.setShape({
	                x: cx - r,
	                y: cy - r,
	                width: r * 2,
	                height: r * 2
	            });
	
	            mask.setShape({
	                x: 0,
	                y: 0,
	                width: api.getWidth(),
	                height: api.getHeight()
	            });
	        };
	        group.resize();
	        return group;
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global) {/**
	 * List for data storage
	 * @module echarts/data/List
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var UNDEFINED = 'undefined';
	    var globalObj = typeof window === 'undefined' ? global : window;
	    var Float64Array = typeof globalObj.Float64Array === UNDEFINED
	        ? Array : globalObj.Float64Array;
	    var Int32Array = typeof globalObj.Int32Array === UNDEFINED
	        ? Array : globalObj.Int32Array;
	
	    var dataCtors = {
	        'float': Float64Array,
	        'int': Int32Array,
	        // Ordinal data type can be string or int
	        'ordinal': Array,
	        'number': Array,
	        'time': Array
	    };
	
	    var Model = __webpack_require__(16);
	    var DataDiffer = __webpack_require__(102);
	
	    var zrUtil = __webpack_require__(8);
	    var modelUtil = __webpack_require__(9);
	    var isObject = zrUtil.isObject;
	
	    var TRANSFERABLE_PROPERTIES = [
	        'stackedOn', 'hasItemOption', '_nameList', '_idList', '_rawData'
	    ];
	
	    var transferProperties = function (a, b) {
	        zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {
	            if (b.hasOwnProperty(propName)) {
	                a[propName] = b[propName];
	            }
	        });
	
	        a.__wrappedMethods = b.__wrappedMethods;
	    };
	
	    /**
	     * @constructor
	     * @alias module:echarts/data/List
	     *
	     * @param {Array.<string>} dimensions
	     *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius
	     * @param {module:echarts/model/Model} hostModel
	     */
	    var List = function (dimensions, hostModel) {
	
	        dimensions = dimensions || ['x', 'y'];
	
	        var dimensionInfos = {};
	        var dimensionNames = [];
	        for (var i = 0; i < dimensions.length; i++) {
	            var dimensionName;
	            var dimensionInfo = {};
	            if (typeof dimensions[i] === 'string') {
	                dimensionName = dimensions[i];
	                dimensionInfo = {
	                    name: dimensionName,
	                    stackable: false,
	                    // Type can be 'float', 'int', 'number'
	                    // Default is number, Precision of float may not enough
	                    type: 'number'
	                };
	            }
	            else {
	                dimensionInfo = dimensions[i];
	                dimensionName = dimensionInfo.name;
	                dimensionInfo.type = dimensionInfo.type || 'number';
	            }
	            dimensionNames.push(dimensionName);
	            dimensionInfos[dimensionName] = dimensionInfo;
	        }
	        /**
	         * @readOnly
	         * @type {Array.<string>}
	         */
	        this.dimensions = dimensionNames;
	
	        /**
	         * Infomation of each data dimension, like data type.
	         * @type {Object}
	         */
	        this._dimensionInfos = dimensionInfos;
	
	        /**
	         * @type {module:echarts/model/Model}
	         */
	        this.hostModel = hostModel;
	
	        /**
	         * @type {module:echarts/model/Model}
	         */
	        this.dataType;
	
	        /**
	         * Indices stores the indices of data subset after filtered.
	         * This data subset will be used in chart.
	         * @type {Array.<number>}
	         * @readOnly
	         */
	        this.indices = [];
	
	        /**
	         * Data storage
	         * @type {Object.<key, TypedArray|Array>}
	         * @private
	         */
	        this._storage = {};
	
	        /**
	         * @type {Array.<string>}
	         */
	        this._nameList = [];
	        /**
	         * @type {Array.<string>}
	         */
	        this._idList = [];
	        /**
	         * Models of data option is stored sparse for optimizing memory cost
	         * @type {Array.<module:echarts/model/Model>}
	         * @private
	         */
	        this._optionModels = [];
	
	        /**
	         * @param {module:echarts/data/List}
	         */
	        this.stackedOn = null;
	
	        /**
	         * Global visual properties after visual coding
	         * @type {Object}
	         * @private
	         */
	        this._visual = {};
	
	        /**
	         * Globel layout properties.
	         * @type {Object}
	         * @private
	         */
	        this._layout = {};
	
	        /**
	         * Item visual properties after visual coding
	         * @type {Array.<Object>}
	         * @private
	         */
	        this._itemVisuals = [];
	
	        /**
	         * Item layout properties after layout
	         * @type {Array.<Object>}
	         * @private
	         */
	        this._itemLayouts = [];
	
	        /**
	         * Graphic elemnents
	         * @type {Array.<module:zrender/Element>}
	         * @private
	         */
	        this._graphicEls = [];
	
	        /**
	         * @type {Array.<Array|Object>}
	         * @private
	         */
	        this._rawData;
	
	        /**
	         * @type {Object}
	         * @private
	         */
	        this._extent;
	    };
	
	    var listProto = List.prototype;
	
	    listProto.type = 'list';
	    /**
	     * If each data item has it's own option
	     * @type {boolean}
	     */
	    listProto.hasItemOption = true;
	
	    /**
	     * Get dimension name
	     * @param {string|number} dim
	     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius
	     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'
	     * @return {string} Concrete dim name.
	     */
	    listProto.getDimension = function (dim) {
	        if (!isNaN(dim)) {
	            dim = this.dimensions[dim] || dim;
	        }
	        return dim;
	    };
	    /**
	     * Get type and stackable info of particular dimension
	     * @param {string|number} dim
	     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius
	     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'
	     */
	    listProto.getDimensionInfo = function (dim) {
	        return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);
	    };
	
	    /**
	     * Initialize from data
	     * @param {Array.<Object|number|Array>} data
	     * @param {Array.<string>} [nameList]
	     * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number
	     */
	    listProto.initData = function (data, nameList, dimValueGetter) {
	        data = data || [];
	
	        if (__DEV__) {
	            if (!zrUtil.isArray(data)) {
	                throw new Error('Invalid data.');
	            }
	        }
	
	        this._rawData = data;
	
	        // Clear
	        var storage = this._storage = {};
	        var indices = this.indices = [];
	
	        var dimensions = this.dimensions;
	        var size = data.length;
	        var dimensionInfoMap = this._dimensionInfos;
	
	        var idList = [];
	        var nameRepeatCount = {};
	
	        nameList = nameList || [];
	
	        // Init storage
	        for (var i = 0; i < dimensions.length; i++) {
	            var dimInfo = dimensionInfoMap[dimensions[i]];
	            var DataCtor = dataCtors[dimInfo.type];
	            storage[dimensions[i]] = new DataCtor(size);
	        }
	
	        var self = this;
	        if (!dimValueGetter) {
	            self.hasItemOption = false;
	        }
	        // Default dim value getter
	        dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {
	            var value = modelUtil.getDataItemValue(dataItem);
	            // If any dataItem is like { value: 10 }
	            if (modelUtil.isDataItemOption(dataItem)) {
	                self.hasItemOption = true;
	            }
	            return modelUtil.converDataValue(
	                (value instanceof Array)
	                    ? value[dimIndex]
	                    // If value is a single number or something else not array.
	                    : value,
	                dimensionInfoMap[dimName]
	            );
	        };
	
	        for (var idx = 0; idx < data.length; idx++) {
	            var dataItem = data[idx];
	            // Each data item is value
	            // [1, 2]
	            // 2
	            // Bar chart, line chart which uses category axis
	            // only gives the 'y' value. 'x' value is the indices of cateogry
	            // Use a tempValue to normalize the value to be a (x, y) value
	
	            // Store the data by dimensions
	            for (var k = 0; k < dimensions.length; k++) {
	                var dim = dimensions[k];
	                var dimStorage = storage[dim];
	                // PENDING NULL is empty or zero
	                dimStorage[idx] = dimValueGetter(dataItem, dim, idx, k);
	            }
	
	            indices.push(idx);
	        }
	
	        // Use the name in option and create id
	        for (var i = 0; i < data.length; i++) {
	            if (!nameList[i]) {
	                if (data[i] && data[i].name != null) {
	                    nameList[i] = data[i].name;
	                }
	            }
	            var name = nameList[i] || '';
	            // Try using the id in option
	            var id = data[i] && data[i].id;
	
	            if (!id && name) {
	                // Use name as id and add counter to avoid same name
	                nameRepeatCount[name] = nameRepeatCount[name] || 0;
	                id = name;
	                if (nameRepeatCount[name] > 0) {
	                    id += '__ec__' + nameRepeatCount[name];
	                }
	                nameRepeatCount[name]++;
	            }
	            id && (idList[i] = id);
	        }
	
	        this._nameList = nameList;
	        this._idList = idList;
	    };
	
	    /**
	     * @return {number}
	     */
	    listProto.count = function () {
	        return this.indices.length;
	    };
	
	    /**
	     * Get value. Return NaN if idx is out of range.
	     * @param {string} dim Dim must be concrete name.
	     * @param {number} idx
	     * @param {boolean} stack
	     * @return {number}
	     */
	    listProto.get = function (dim, idx, stack) {
	        var storage = this._storage;
	        var dataIndex = this.indices[idx];
	
	        // If value not exists
	        if (dataIndex == null) {
	            return NaN;
	        }
	
	        var value = storage[dim] && storage[dim][dataIndex];
	        // FIXME ordinal data type is not stackable
	        if (stack) {
	            var dimensionInfo = this._dimensionInfos[dim];
	            if (dimensionInfo && dimensionInfo.stackable) {
	                var stackedOn = this.stackedOn;
	                while (stackedOn) {
	                    // Get no stacked data of stacked on
	                    var stackedValue = stackedOn.get(dim, idx);
	                    // Considering positive stack, negative stack and empty data
	                    if ((value >= 0 && stackedValue > 0)  // Positive stack
	                        || (value <= 0 && stackedValue < 0) // Negative stack
	                    ) {
	                        value += stackedValue;
	                    }
	                    stackedOn = stackedOn.stackedOn;
	                }
	            }
	        }
	        return value;
	    };
	
	    /**
	     * Get value for multi dimensions.
	     * @param {Array.<string>} [dimensions] If ignored, using all dimensions.
	     * @param {number} idx
	     * @param {boolean} stack
	     * @return {number}
	     */
	    listProto.getValues = function (dimensions, idx, stack) {
	        var values = [];
	
	        if (!zrUtil.isArray(dimensions)) {
	            stack = idx;
	            idx = dimensions;
	            dimensions = this.dimensions;
	        }
	
	        for (var i = 0, len = dimensions.length; i < len; i++) {
	            values.push(this.get(dimensions[i], idx, stack));
	        }
	
	        return values;
	    };
	
	    /**
	     * If value is NaN. Inlcuding '-'
	     * @param {string} dim
	     * @param {number} idx
	     * @return {number}
	     */
	    listProto.hasValue = function (idx) {
	        var dimensions = this.dimensions;
	        var dimensionInfos = this._dimensionInfos;
	        for (var i = 0, len = dimensions.length; i < len; i++) {
	            if (
	                // Ordinal type can be string or number
	                dimensionInfos[dimensions[i]].type !== 'ordinal'
	                && isNaN(this.get(dimensions[i], idx))
	            ) {
	                return false;
	            }
	        }
	        return true;
	    };
	
	    /**
	     * Get extent of data in one dimension
	     * @param {string} dim
	     * @param {boolean} stack
	     */
	    listProto.getDataExtent = function (dim, stack) {
	        dim = this.getDimension(dim);
	        var dimData = this._storage[dim];
	        var dimInfo = this.getDimensionInfo(dim);
	        stack = (dimInfo && dimInfo.stackable) && stack;
	        var dimExtent = (this._extent || (this._extent = {}))[dim + (!!stack)];
	        var value;
	        if (dimExtent) {
	            return dimExtent;
	        }
	        // var dimInfo = this._dimensionInfos[dim];
	        if (dimData) {
	            var min = Infinity;
	            var max = -Infinity;
	            // var isOrdinal = dimInfo.type === 'ordinal';
	            for (var i = 0, len = this.count(); i < len; i++) {
	                value = this.get(dim, i, stack);
	                // FIXME
	                // if (isOrdinal && typeof value === 'string') {
	                //     value = zrUtil.indexOf(dimData, value);
	                // }
	                value < min && (min = value);
	                value > max && (max = value);
	            }
	            return (this._extent[dim + !!stack] = [min, max]);
	        }
	        else {
	            return [Infinity, -Infinity];
	        }
	    };
	
	    /**
	     * Get sum of data in one dimension
	     * @param {string} dim
	     * @param {boolean} stack
	     */
	    listProto.getSum = function (dim, stack) {
	        var dimData = this._storage[dim];
	        var sum = 0;
	        if (dimData) {
	            for (var i = 0, len = this.count(); i < len; i++) {
	                var value = this.get(dim, i, stack);
	                if (!isNaN(value)) {
	                    sum += value;
	                }
	            }
	        }
	        return sum;
	    };
	
	    /**
	     * Retreive the index with given value
	     * @param {number} idx
	     * @param {number} value
	     * @return {number}
	     */
	    // FIXME Precision of float value
	    listProto.indexOf = function (dim, value) {
	        var storage = this._storage;
	        var dimData = storage[dim];
	        var indices = this.indices;
	
	        if (dimData) {
	            for (var i = 0, len = indices.length; i < len; i++) {
	                var rawIndex = indices[i];
	                if (dimData[rawIndex] === value) {
	                    return i;
	                }
	            }
	        }
	        return -1;
	    };
	
	    /**
	     * Retreive the index with given name
	     * @param {number} idx
	     * @param {number} name
	     * @return {number}
	     */
	    listProto.indexOfName = function (name) {
	        var indices = this.indices;
	        var nameList = this._nameList;
	
	        for (var i = 0, len = indices.length; i < len; i++) {
	            var rawIndex = indices[i];
	            if (nameList[rawIndex] === name) {
	                return i;
	            }
	        }
	
	        return -1;
	    };
	
	    /**
	     * Retreive the index with given raw data index
	     * @param {number} idx
	     * @param {number} name
	     * @return {number}
	     */
	    listProto.indexOfRawIndex = function (rawIndex) {
	        // Indices are ascending
	        var indices = this.indices;
	        var left = 0;
	        var right = indices.length - 1;
	        while (left <= right) {
	            var mid = (left + right) / 2 | 0;
	            if (indices[mid] < rawIndex) {
	                left = mid + 1;
	            }
	            else if (indices[mid] > rawIndex) {
	                right = mid - 1;
	            }
	            else {
	                return mid;
	            }
	        }
	        return -1;
	    };
	
	    /**
	     * Retreive the index of nearest value
	     * @param {string} dim
	     * @param {number} value
	     * @param {boolean} stack If given value is after stacked
	     * @param {number} [maxDistance=Infinity]
	     * @return {number}
	     */
	    listProto.indexOfNearest = function (dim, value, stack, maxDistance) {
	        var storage = this._storage;
	        var dimData = storage[dim];
	
	        if (maxDistance == null) {
	            maxDistance = Infinity;
	        }
	
	        var nearestIdx = -1;
	        if (dimData) {
	            var minDist = Number.MAX_VALUE;
	            for (var i = 0, len = this.count(); i < len; i++) {
	                var diff = value - this.get(dim, i, stack);
	                var dist = Math.abs(diff);
	                if (
	                    diff <= maxDistance
	                    && (dist < minDist
	                        // For the case of two data are same on xAxis, which has sequence data.
	                        // Show the nearest index
	                        // https://github.com/ecomfe/echarts/issues/2869
	                        || (dist === minDist && diff > 0)
	                    )
	                ) {
	                    minDist = dist;
	                    nearestIdx = i;
	                }
	            }
	        }
	        return nearestIdx;
	    };
	
	    /**
	     * Get raw data index
	     * @param {number} idx
	     * @return {number}
	     */
	    listProto.getRawIndex = function (idx) {
	        var rawIdx = this.indices[idx];
	        return rawIdx == null ? -1 : rawIdx;
	    };
	
	    /**
	     * Get raw data item
	     * @param {number} idx
	     * @return {number}
	     */
	    listProto.getRawDataItem = function (idx) {
	        return this._rawData[this.getRawIndex(idx)];
	    };
	
	    /**
	     * @param {number} idx
	     * @param {boolean} [notDefaultIdx=false]
	     * @return {string}
	     */
	    listProto.getName = function (idx) {
	        return this._nameList[this.indices[idx]] || '';
	    };
	
	    /**
	     * @param {number} idx
	     * @param {boolean} [notDefaultIdx=false]
	     * @return {string}
	     */
	    listProto.getId = function (idx) {
	        return this._idList[this.indices[idx]] || (this.getRawIndex(idx) + '');
	    };
	
	
	    function normalizeDimensions(dimensions) {
	        if (!zrUtil.isArray(dimensions)) {
	            dimensions = [dimensions];
	        }
	        return dimensions;
	    }
	
	    /**
	     * Data iteration
	     * @param {string|Array.<string>}
	     * @param {Function} cb
	     * @param {boolean} [stack=false]
	     * @param {*} [context=this]
	     *
	     * @example
	     *  list.each('x', function (x, idx) {});
	     *  list.each(['x', 'y'], function (x, y, idx) {});
	     *  list.each(function (idx) {})
	     */
	    listProto.each = function (dims, cb, stack, context) {
	        if (typeof dims === 'function') {
	            context = stack;
	            stack = cb;
	            cb = dims;
	            dims = [];
	        }
	
	        dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);
	
	        var value = [];
	        var dimSize = dims.length;
	        var indices = this.indices;
	
	        context = context || this;
	
	        for (var i = 0; i < indices.length; i++) {
	            // Simple optimization
	            switch (dimSize) {
	                case 0:
	                    cb.call(context, i);
	                    break;
	                case 1:
	                    cb.call(context, this.get(dims[0], i, stack), i);
	                    break;
	                case 2:
	                    cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);
	                    break;
	                default:
	                    for (var k = 0; k < dimSize; k++) {
	                        value[k] = this.get(dims[k], i, stack);
	                    }
	                    // Index
	                    value[k] = i;
	                    cb.apply(context, value);
	            }
	        }
	    };
	
	    /**
	     * Data filter
	     * @param {string|Array.<string>}
	     * @param {Function} cb
	     * @param {boolean} [stack=false]
	     * @param {*} [context=this]
	     */
	    listProto.filterSelf = function (dimensions, cb, stack, context) {
	        if (typeof dimensions === 'function') {
	            context = stack;
	            stack = cb;
	            cb = dimensions;
	            dimensions = [];
	        }
	
	        dimensions = zrUtil.map(
	            normalizeDimensions(dimensions), this.getDimension, this
	        );
	
	        var newIndices = [];
	        var value = [];
	        var dimSize = dimensions.length;
	        var indices = this.indices;
	
	        context = context || this;
	
	        for (var i = 0; i < indices.length; i++) {
	            var keep;
	            // Simple optimization
	            if (dimSize === 1) {
	                keep = cb.call(
	                    context, this.get(dimensions[0], i, stack), i
	                );
	            }
	            else {
	                for (var k = 0; k < dimSize; k++) {
	                    value[k] = this.get(dimensions[k], i, stack);
	                }
	                value[k] = i;
	                keep = cb.apply(context, value);
	            }
	            if (keep) {
	                newIndices.push(indices[i]);
	            }
	        }
	
	        this.indices = newIndices;
	
	        // Reset data extent
	        this._extent = {};
	
	        return this;
	    };
	
	    /**
	     * Data mapping to a plain array
	     * @param {string|Array.<string>} [dimensions]
	     * @param {Function} cb
	     * @param {boolean} [stack=false]
	     * @param {*} [context=this]
	     * @return {Array}
	     */
	    listProto.mapArray = function (dimensions, cb, stack, context) {
	        if (typeof dimensions === 'function') {
	            context = stack;
	            stack = cb;
	            cb = dimensions;
	            dimensions = [];
	        }
	
	        var result = [];
	        this.each(dimensions, function () {
	            result.push(cb && cb.apply(this, arguments));
	        }, stack, context);
	        return result;
	    };
	
	    function cloneListForMapAndSample(original, excludeDimensions) {
	        var allDimensions = original.dimensions;
	        var list = new List(
	            zrUtil.map(allDimensions, original.getDimensionInfo, original),
	            original.hostModel
	        );
	        // FIXME If needs stackedOn, value may already been stacked
	        transferProperties(list, original);
	
	        var storage = list._storage = {};
	        var originalStorage = original._storage;
	        // Init storage
	        for (var i = 0; i < allDimensions.length; i++) {
	            var dim = allDimensions[i];
	            var dimStore = originalStorage[dim];
	            if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {
	                storage[dim] = new dimStore.constructor(
	                    originalStorage[dim].length
	                );
	            }
	            else {
	                // Direct reference for other dimensions
	                storage[dim] = originalStorage[dim];
	            }
	        }
	        return list;
	    }
	
	    /**
	     * Data mapping to a new List with given dimensions
	     * @param {string|Array.<string>} dimensions
	     * @param {Function} cb
	     * @param {boolean} [stack=false]
	     * @param {*} [context=this]
	     * @return {Array}
	     */
	    listProto.map = function (dimensions, cb, stack, context) {
	        dimensions = zrUtil.map(
	            normalizeDimensions(dimensions), this.getDimension, this
	        );
	
	        var list = cloneListForMapAndSample(this, dimensions);
	        // Following properties are all immutable.
	        // So we can reference to the same value
	        var indices = list.indices = this.indices;
	
	        var storage = list._storage;
	
	        var tmpRetValue = [];
	        this.each(dimensions, function () {
	            var idx = arguments[arguments.length - 1];
	            var retValue = cb && cb.apply(this, arguments);
	            if (retValue != null) {
	                // a number
	                if (typeof retValue === 'number') {
	                    tmpRetValue[0] = retValue;
	                    retValue = tmpRetValue;
	                }
	                for (var i = 0; i < retValue.length; i++) {
	                    var dim = dimensions[i];
	                    var dimStore = storage[dim];
	                    var rawIdx = indices[idx];
	                    if (dimStore) {
	                        dimStore[rawIdx] = retValue[i];
	                    }
	                }
	            }
	        }, stack, context);
	
	        return list;
	    };
	
	    /**
	     * Large data down sampling on given dimension
	     * @param {string} dimension
	     * @param {number} rate
	     * @param {Function} sampleValue
	     * @param {Function} sampleIndex Sample index for name and id
	     */
	    listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {
	        var list = cloneListForMapAndSample(this, [dimension]);
	        var storage = this._storage;
	        var targetStorage = list._storage;
	
	        var originalIndices = this.indices;
	        var indices = list.indices = [];
	
	        var frameValues = [];
	        var frameIndices = [];
	        var frameSize = Math.floor(1 / rate);
	
	        var dimStore = targetStorage[dimension];
	        var len = this.count();
	        // Copy data from original data
	        for (var i = 0; i < storage[dimension].length; i++) {
	            targetStorage[dimension][i] = storage[dimension][i];
	        }
	        for (var i = 0; i < len; i += frameSize) {
	            // Last frame
	            if (frameSize > len - i) {
	                frameSize = len - i;
	                frameValues.length = frameSize;
	            }
	            for (var k = 0; k < frameSize; k++) {
	                var idx = originalIndices[i + k];
	                frameValues[k] = dimStore[idx];
	                frameIndices[k] = idx;
	            }
	            var value = sampleValue(frameValues);
	            var idx = frameIndices[sampleIndex(frameValues, value) || 0];
	            // Only write value on the filtered data
	            dimStore[idx] = value;
	            indices.push(idx);
	        }
	
	        return list;
	    };
	
	    /**
	     * Get model of one data item.
	     *
	     * @param {number} idx
	     */
	    // FIXME Model proxy ?
	    listProto.getItemModel = function (idx) {
	        var hostModel = this.hostModel;
	        idx = this.indices[idx];
	        return new Model(this._rawData[idx], hostModel, hostModel && hostModel.ecModel);
	    };
	
	    /**
	     * Create a data differ
	     * @param {module:echarts/data/List} otherList
	     * @return {module:echarts/data/DataDiffer}
	     */
	    listProto.diff = function (otherList) {
	        var idList = this._idList;
	        var otherIdList = otherList && otherList._idList;
	        return new DataDiffer(
	            otherList ? otherList.indices : [], this.indices, function (idx) {
	                return otherIdList[idx] || (idx + '');
	            }, function (idx) {
	                return idList[idx] || (idx + '');
	            }
	        );
	    };
	    /**
	     * Get visual property.
	     * @param {string} key
	     */
	    listProto.getVisual = function (key) {
	        var visual = this._visual;
	        return visual && visual[key];
	    };
	
	    /**
	     * Set visual property
	     * @param {string|Object} key
	     * @param {*} [value]
	     *
	     * @example
	     *  setVisual('color', color);
	     *  setVisual({
	     *      'color': color
	     *  });
	     */
	    listProto.setVisual = function (key, val) {
	        if (isObject(key)) {
	            for (var name in key) {
	                if (key.hasOwnProperty(name)) {
	                    this.setVisual(name, key[name]);
	                }
	            }
	            return;
	        }
	        this._visual = this._visual || {};
	        this._visual[key] = val;
	    };
	
	    /**
	     * Set layout property.
	     * @param {string} key
	     * @param {*} [val]
	     */
	    listProto.setLayout = function (key, val) {
	        if (isObject(key)) {
	            for (var name in key) {
	                if (key.hasOwnProperty(name)) {
	                    this.setLayout(name, key[name]);
	                }
	            }
	            return;
	        }
	        this._layout[key] = val;
	    };
	
	    /**
	     * Get layout property.
	     * @param  {string} key.
	     * @return {*}
	     */
	    listProto.getLayout = function (key) {
	        return this._layout[key];
	    };
	
	    /**
	     * Get layout of single data item
	     * @param {number} idx
	     */
	    listProto.getItemLayout = function (idx) {
	        return this._itemLayouts[idx];
	    };
	
	    /**
	     * Set layout of single data item
	     * @param {number} idx
	     * @param {Object} layout
	     * @param {boolean=} [merge=false]
	     */
	    listProto.setItemLayout = function (idx, layout, merge) {
	        this._itemLayouts[idx] = merge
	            ? zrUtil.extend(this._itemLayouts[idx] || {}, layout)
	            : layout;
	    };
	
	    /**
	     * Clear all layout of single data item
	     */
	    listProto.clearItemLayouts = function () {
	        this._itemLayouts.length = 0;
	    };
	
	    /**
	     * Get visual property of single data item
	     * @param {number} idx
	     * @param {string} key
	     * @param {boolean} ignoreParent
	     */
	    listProto.getItemVisual = function (idx, key, ignoreParent) {
	        var itemVisual = this._itemVisuals[idx];
	        var val = itemVisual && itemVisual[key];
	        if (val == null && !ignoreParent) {
	            // Use global visual property
	            return this.getVisual(key);
	        }
	        return val;
	    };
	
	    /**
	     * Set visual property of single data item
	     *
	     * @param {number} idx
	     * @param {string|Object} key
	     * @param {*} [value]
	     *
	     * @example
	     *  setItemVisual(0, 'color', color);
	     *  setItemVisual(0, {
	     *      'color': color
	     *  });
	     */
	    listProto.setItemVisual = function (idx, key, value) {
	        var itemVisual = this._itemVisuals[idx] || {};
	        this._itemVisuals[idx] = itemVisual;
	
	        if (isObject(key)) {
	            for (var name in key) {
	                if (key.hasOwnProperty(name)) {
	                    itemVisual[name] = key[name];
	                }
	            }
	            return;
	        }
	        itemVisual[key] = value;
	    };
	
	    /**
	     * Clear itemVisuals and list visual.
	     */
	    listProto.clearAllVisual = function () {
	        this._visual = {};
	        this._itemVisuals = [];
	    };
	
	    var setItemDataAndSeriesIndex = function (child) {
	        child.seriesIndex = this.seriesIndex;
	        child.dataIndex = this.dataIndex;
	        child.dataType = this.dataType;
	    };
	    /**
	     * Set graphic element relative to data. It can be set as null
	     * @param {number} idx
	     * @param {module:zrender/Element} [el]
	     */
	    listProto.setItemGraphicEl = function (idx, el) {
	        var hostModel = this.hostModel;
	
	        if (el) {
	            // Add data index and series index for indexing the data by element
	            // Useful in tooltip
	            el.dataIndex = idx;
	            el.dataType = this.dataType;
	            el.seriesIndex = hostModel && hostModel.seriesIndex;
	            if (el.type === 'group') {
	                el.traverse(setItemDataAndSeriesIndex, el);
	            }
	        }
	
	        this._graphicEls[idx] = el;
	    };
	
	    /**
	     * @param {number} idx
	     * @return {module:zrender/Element}
	     */
	    listProto.getItemGraphicEl = function (idx) {
	        return this._graphicEls[idx];
	    };
	
	    /**
	     * @param {Function} cb
	     * @param {*} context
	     */
	    listProto.eachItemGraphicEl = function (cb, context) {
	        zrUtil.each(this._graphicEls, function (el, idx) {
	            if (el) {
	                cb && cb.call(context, el, idx);
	            }
	        });
	    };
	
	    /**
	     * Shallow clone a new list except visual and layout properties, and graph elements.
	     * New list only change the indices.
	     */
	    listProto.cloneShallow = function () {
	        var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);
	        var list = new List(dimensionInfoList, this.hostModel);
	
	        // FIXME
	        list._storage = this._storage;
	
	        transferProperties(list, this);
	
	
	        // Clone will not change the data extent and indices
	        list.indices = this.indices.slice();
	
	        if (this._extent) {
	            list._extent = zrUtil.extend({}, this._extent);
	        }
	
	        return list;
	    };
	
	    /**
	     * Wrap some method to add more feature
	     * @param {string} methodName
	     * @param {Function} injectFunction
	     */
	    listProto.wrapMethod = function (methodName, injectFunction) {
	        var originalMethod = this[methodName];
	        if (typeof originalMethod !== 'function') {
	            return;
	        }
	        this.__wrappedMethods = this.__wrappedMethods || [];
	        this.__wrappedMethods.push(methodName);
	        this[methodName] = function () {
	            var res = originalMethod.apply(this, arguments);
	            return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));
	        };
	    };
	
	    // Methods that create a new list based on this list should be listed here.
	    // Notice that those method should `RETURN` the new list.
	    listProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map'];
	    // Methods that change indices of this list should be listed here.
	    listProto.CHANGABLE_METHODS = ['filterSelf'];
	
	    return List;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
	    'use strict';
	
	    function defaultKeyGetter(item) {
	        return item;
	    }
	
	    function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter) {
	        this._old = oldArr;
	        this._new = newArr;
	
	        this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;
	        this._newKeyGetter = newKeyGetter || defaultKeyGetter;
	    }
	
	    DataDiffer.prototype = {
	
	        constructor: DataDiffer,
	
	        /**
	         * Callback function when add a data
	         */
	        add: function (func) {
	            this._add = func;
	            return this;
	        },
	
	        /**
	         * Callback function when update a data
	         */
	        update: function (func) {
	            this._update = func;
	            return this;
	        },
	
	        /**
	         * Callback function when remove a data
	         */
	        remove: function (func) {
	            this._remove = func;
	            return this;
	        },
	
	        execute: function () {
	            var oldArr = this._old;
	            var newArr = this._new;
	            var oldKeyGetter = this._oldKeyGetter;
	            var newKeyGetter = this._newKeyGetter;
	
	            var oldDataIndexMap = {};
	            var newDataIndexMap = {};
	            var oldDataKeyArr = [];
	            var newDataKeyArr = [];
	            var i;
	
	            initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, oldKeyGetter);
	            initIndexMap(newArr, newDataIndexMap, newDataKeyArr, newKeyGetter);
	
	            // Travel by inverted order to make sure order consistency
	            // when duplicate keys exists (consider newDataIndex.pop() below).
	            // For performance consideration, these code below do not look neat.
	            for (i = 0; i < oldArr.length; i++) {
	                var key = oldDataKeyArr[i];
	                var idx = newDataIndexMap[key];
	
	                // idx can never be empty array here. see 'set null' logic below.
	                if (idx != null) {
	                    // Consider there is duplicate key (for example, use dataItem.name as key).
	                    // We should make sure every item in newArr and oldArr can be visited.
	                    var len = idx.length;
	                    if (len) {
	                        len === 1 && (newDataIndexMap[key] = null);
	                        idx = idx.unshift();
	                    }
	                    else {
	                        newDataIndexMap[key] = null;
	                    }
	                    this._update && this._update(idx, i);
	                }
	                else {
	                    this._remove && this._remove(i);
	                }
	            }
	
	            for (var i = 0; i < newDataKeyArr.length; i++) {
	                var key = newDataKeyArr[i];
	                if (newDataIndexMap.hasOwnProperty(key)) {
	                    var idx = newDataIndexMap[key];
	                    if (idx == null) {
	                        continue;
	                    }
	                    // idx can never be empty array here. see 'set null' logic above.
	                    if (!idx.length) {
	                        this._add && this._add(idx);
	                    }
	                    else {
	                        for (var j = 0, len = idx.length; j < len; j++) {
	                            this._add && this._add(idx[j]);
	                        }
	                    }
	                }
	            }
	        }
	    };
	
	    function initIndexMap(arr, map, keyArr, keyGetter) {
	        for (var i = 0; i < arr.length; i++) {
	            var key = keyGetter(arr[i], i);
	            var existence = map[key];
	            if (existence == null) {
	                keyArr.push(key);
	                map[key] = i;
	            }
	            else {
	                if (!existence.length) {
	                    map[key] = existence = [existence];
	                }
	                existence.push(i);
	            }
	        }
	    }
	
	    return DataDiffer;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var zrUtil = __webpack_require__(8);
	
	    __webpack_require__(104);
	
	    __webpack_require__(121);
	    __webpack_require__(124);
	
	    var barLayoutGrid = __webpack_require__(126);
	    var echarts = __webpack_require__(5);
	
	    echarts.registerLayout(zrUtil.curry(barLayoutGrid, 'bar'));
	    // Visual coding for legend
	    echarts.registerVisual(function (ecModel) {
	        ecModel.eachSeriesByType('bar', function (seriesModel) {
	            var data = seriesModel.getData();
	            data.setVisual('legendSymbol', 'roundRect');
	        });
	    });
	
	    // In case developer forget to include grid component
	    __webpack_require__(127);
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Grid is a region which contains at most 4 cartesian systems
	 *
	 * TODO Default cartesian
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, factory) {
	
	    var layout = __webpack_require__(25);
	    var axisHelper = __webpack_require__(105);
	
	    var zrUtil = __webpack_require__(8);
	    var Cartesian2D = __webpack_require__(111);
	    var Axis2D = __webpack_require__(113);
	
	    var each = zrUtil.each;
	
	    var ifAxisCrossZero = axisHelper.ifAxisCrossZero;
	    var niceScaleExtent = axisHelper.niceScaleExtent;
	
	    // 依赖 GridModel, AxisModel 做预处理
	    __webpack_require__(116);
	
	    /**
	     * Check if the axis is used in the specified grid
	     * @inner
	     */
	    function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {
	        return axisModel.findGridModel() === gridModel;
	    }
	
	    function getLabelUnionRect(axis) {
	        var axisModel = axis.model;
	        var labels = axisModel.getFormattedLabels();
	        var rect;
	        var step = 1;
	        var labelCount = labels.length;
	        if (labelCount > 40) {
	            // Simple optimization for large amount of labels
	            step = Math.ceil(labelCount / 40);
	        }
	        for (var i = 0; i < labelCount; i += step) {
	            if (!axis.isLabelIgnored(i)) {
	                var singleRect = axisModel.getTextRect(labels[i]);
	                // FIXME consider label rotate
	                rect ? rect.union(singleRect) : (rect = singleRect);
	            }
	        }
	        return rect;
	    }
	
	    function Grid(gridModel, ecModel, api) {
	        /**
	         * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}
	         * @private
	         */
	        this._coordsMap = {};
	
	        /**
	         * @type {Array.<module:echarts/coord/cartesian/Cartesian>}
	         * @private
	         */
	        this._coordsList = [];
	
	        /**
	         * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}
	         * @private
	         */
	        this._axesMap = {};
	
	        /**
	         * @type {Array.<module:echarts/coord/cartesian/Axis2D>}
	         * @private
	         */
	        this._axesList = [];
	
	        this._initCartesian(gridModel, ecModel, api);
	
	        this._model = gridModel;
	    }
	
	    var gridProto = Grid.prototype;
	
	    gridProto.type = 'grid';
	
	    gridProto.getRect = function () {
	        return this._rect;
	    };
	
	    gridProto.update = function (ecModel, api) {
	
	        var axesMap = this._axesMap;
	
	        this._updateScale(ecModel, this._model);
	
	        function ifAxisCanNotOnZero(otherAxisDim) {
	            var axes = axesMap[otherAxisDim];
	            for (var idx in axes) {
	                var axis = axes[idx];
	                if (axis && (axis.type === 'category' || !ifAxisCrossZero(axis))) {
	                    return true;
	                }
	            }
	            return false;
	        }
	
	        each(axesMap.x, function (xAxis) {
	            niceScaleExtent(xAxis, xAxis.model);
	        });
	        each(axesMap.y, function (yAxis) {
	            niceScaleExtent(yAxis, yAxis.model);
	        });
	        // Fix configuration
	        each(axesMap.x, function (xAxis) {
	            // onZero can not be enabled in these two situations
	            // 1. When any other axis is a category axis
	            // 2. When any other axis not across 0 point
	            if (ifAxisCanNotOnZero('y')) {
	                xAxis.onZero = false;
	            }
	        });
	        each(axesMap.y, function (yAxis) {
	            if (ifAxisCanNotOnZero('x')) {
	                yAxis.onZero = false;
	            }
	        });
	
	        // Resize again if containLabel is enabled
	        // FIXME It may cause getting wrong grid size in data processing stage
	        this.resize(this._model, api);
	    };
	
	    /**
	     * Resize the grid
	     * @param {module:echarts/coord/cartesian/GridModel} gridModel
	     * @param {module:echarts/ExtensionAPI} api
	     */
	    gridProto.resize = function (gridModel, api) {
	
	        var gridRect = layout.getLayoutRect(
	            gridModel.getBoxLayoutParams(), {
	                width: api.getWidth(),
	                height: api.getHeight()
	            });
	
	        this._rect = gridRect;
	
	        var axesList = this._axesList;
	
	        adjustAxes();
	
	        // Minus label size
	        if (gridModel.get('containLabel')) {
	            each(axesList, function (axis) {
	                if (!axis.model.get('axisLabel.inside')) {
	                    var labelUnionRect = getLabelUnionRect(axis);
	                    if (labelUnionRect) {
	                        var dim = axis.isHorizontal() ? 'height' : 'width';
	                        var margin = axis.model.get('axisLabel.margin');
	                        gridRect[dim] -= labelUnionRect[dim] + margin;
	                        if (axis.position === 'top') {
	                            gridRect.y += labelUnionRect.height + margin;
	                        }
	                        else if (axis.position === 'left')  {
	                            gridRect.x += labelUnionRect.width + margin;
	                        }
	                    }
	                }
	            });
	
	            adjustAxes();
	        }
	
	        function adjustAxes() {
	            each(axesList, function (axis) {
	                var isHorizontal = axis.isHorizontal();
	                var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];
	                var idx = axis.inverse ? 1 : 0;
	                axis.setExtent(extent[idx], extent[1 - idx]);
	                updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);
	            });
	        }
	    };
	
	    /**
	     * @param {string} axisType
	     * @param {ndumber} [axisIndex]
	     */
	    gridProto.getAxis = function (axisType, axisIndex) {
	        var axesMapOnDim = this._axesMap[axisType];
	        if (axesMapOnDim != null) {
	            if (axisIndex == null) {
	                // Find first axis
	                for (var name in axesMapOnDim) {
	                    return axesMapOnDim[name];
	                }
	            }
	            return axesMapOnDim[axisIndex];
	        }
	    };
	
	    gridProto.getCartesian = function (xAxisIndex, yAxisIndex) {
	        if (xAxisIndex != null && yAxisIndex != null) {
	            var key = 'x' + xAxisIndex + 'y' + yAxisIndex;
	            return this._coordsMap[key];
	        }
	        else {
	            // When only xAxisIndex or yAxisIndex given, find its first cartesian.
	            for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {
	                if (coordList[i].getAxis('x').index === xAxisIndex
	                    || coordList[i].getAxis('y').index === yAxisIndex
	                ) {
	                    return coordList[i];
	                }
	            }
	        }
	    };
	
	    /**
	     * Initialize cartesian coordinate systems
	     * @private
	     */
	    gridProto._initCartesian = function (gridModel, ecModel, api) {
	        var axisPositionUsed = {
	            left: false,
	            right: false,
	            top: false,
	            bottom: false
	        };
	
	        var axesMap = {
	            x: {},
	            y: {}
	        };
	        var axesCount = {
	            x: 0,
	            y: 0
	        };
	
	        /// Create axis
	        ecModel.eachComponent('xAxis', createAxisCreator('x'), this);
	        ecModel.eachComponent('yAxis', createAxisCreator('y'), this);
	
	        if (!axesCount.x || !axesCount.y) {
	            // Roll back when there no either x or y axis
	            this._axesMap = {};
	            this._axesList = [];
	            return;
	        }
	
	        this._axesMap = axesMap;
	
	        /// Create cartesian2d
	        each(axesMap.x, function (xAxis, xAxisIndex) {
	            each(axesMap.y, function (yAxis, yAxisIndex) {
	                var key = 'x' + xAxisIndex + 'y' + yAxisIndex;
	                var cartesian = new Cartesian2D(key);
	
	                cartesian.grid = this;
	
	                this._coordsMap[key] = cartesian;
	                this._coordsList.push(cartesian);
	
	                cartesian.addAxis(xAxis);
	                cartesian.addAxis(yAxis);
	            }, this);
	        }, this);
	
	        function createAxisCreator(axisType) {
	            return function (axisModel, idx) {
	                if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {
	                    return;
	                }
	
	                var axisPosition = axisModel.get('position');
	                if (axisType === 'x') {
	                    // Fix position
	                    if (axisPosition !== 'top' && axisPosition !== 'bottom') {
	                        // Default bottom of X
	                        axisPosition = 'bottom';
	                        if (axisPositionUsed[axisPosition]) {
	                            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';
	                        }
	                    }
	                }
	                else {
	                    // Fix position
	                    if (axisPosition !== 'left' && axisPosition !== 'right') {
	                        // Default left of Y
	                        axisPosition = 'left';
	                        if (axisPositionUsed[axisPosition]) {
	                            axisPosition = axisPosition === 'left' ? 'right' : 'left';
	                        }
	                    }
	                }
	                axisPositionUsed[axisPosition] = true;
	
	                var axis = new Axis2D(
	                    axisType, axisHelper.createScaleByModel(axisModel),
	                    [0, 0],
	                    axisModel.get('type'),
	                    axisPosition
	                );
	
	                var isCategory = axis.type === 'category';
	                axis.onBand = isCategory && axisModel.get('boundaryGap');
	                axis.inverse = axisModel.get('inverse');
	
	                axis.onZero = axisModel.get('axisLine.onZero');
	
	                // Inject axis into axisModel
	                axisModel.axis = axis;
	
	                // Inject axisModel into axis
	                axis.model = axisModel;
	
	                // Inject grid info axis
	                axis.grid = this;
	
	                // Index of axis, can be used as key
	                axis.index = idx;
	
	                this._axesList.push(axis);
	
	                axesMap[axisType][idx] = axis;
	                axesCount[axisType]++;
	            };
	        }
	    };
	
	    /**
	     * Update cartesian properties from series
	     * @param  {module:echarts/model/Option} option
	     * @private
	     */
	    gridProto._updateScale = function (ecModel, gridModel) {
	        // Reset scale
	        zrUtil.each(this._axesList, function (axis) {
	            axis.scale.setExtent(Infinity, -Infinity);
	        });
	        ecModel.eachSeries(function (seriesModel) {
	            if (isCartesian2D(seriesModel)) {
	                var axesModels = findAxesModels(seriesModel, ecModel);
	                var xAxisModel = axesModels[0];
	                var yAxisModel = axesModels[1];
	
	                if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel)
	                    || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)
	                 ) {
	                    return;
	                }
	
	                var cartesian = this.getCartesian(
	                    xAxisModel.componentIndex, yAxisModel.componentIndex
	                );
	                var data = seriesModel.getData();
	                var xAxis = cartesian.getAxis('x');
	                var yAxis = cartesian.getAxis('y');
	
	                if (data.type === 'list') {
	                    unionExtent(data, xAxis, seriesModel);
	                    unionExtent(data, yAxis, seriesModel);
	                }
	            }
	        }, this);
	
	        function unionExtent(data, axis, seriesModel) {
	            each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {
	                axis.scale.unionExtent(data.getDataExtent(
	                    dim, axis.scale.type !== 'ordinal'
	                ));
	            });
	        }
	    };
	
	    /**
	     * @inner
	     */
	    function updateAxisTransfrom(axis, coordBase) {
	        var axisExtent = axis.getExtent();
	        var axisExtentSum = axisExtent[0] + axisExtent[1];
	
	        // Fast transform
	        axis.toGlobalCoord = axis.dim === 'x'
	            ? function (coord) {
	                return coord + coordBase;
	            }
	            : function (coord) {
	                return axisExtentSum - coord + coordBase;
	            };
	        axis.toLocalCoord = axis.dim === 'x'
	            ? function (coord) {
	                return coord - coordBase;
	            }
	            : function (coord) {
	                return axisExtentSum - coord + coordBase;
	            };
	    }
	
	    var axesTypes = ['xAxis', 'yAxis'];
	    /**
	     * @inner
	     */
	    function findAxesModels(seriesModel, ecModel) {
	        return zrUtil.map(axesTypes, function (axisType) {
	            var axisModel = ecModel.queryComponents({
	                mainType: axisType,
	                index: seriesModel.get(axisType + 'Index'),
	                id: seriesModel.get(axisType + 'Id')
	            })[0];
	
	            if (__DEV__) {
	                if (!axisModel) {
	                    throw new Error(axisType + ' "' + zrUtil.retrieve(
	                        seriesModel.get(axisType + 'Index'),
	                        seriesModel.get(axisType + 'Id'),
	                        0
	                    ) + '" not found');
	                }
	            }
	            return axisModel;
	        });
	    }
	
	    /**
	     * @inner
	     */
	    function isCartesian2D(seriesModel) {
	        return seriesModel.get('coordinateSystem') === 'cartesian2d';
	    }
	
	    Grid.create = function (ecModel, api) {
	        var grids = [];
	        ecModel.eachComponent('grid', function (gridModel, idx) {
	            var grid = new Grid(gridModel, ecModel, api);
	            grid.name = 'grid_' + idx;
	            grid.resize(gridModel, api);
	
	            gridModel.coordinateSystem = grid;
	
	            grids.push(grid);
	        });
	
	        // Inject the coordinateSystems into seriesModel
	        ecModel.eachSeries(function (seriesModel) {
	            if (!isCartesian2D(seriesModel)) {
	                return;
	            }
	
	            var axesModels = findAxesModels(seriesModel, ecModel);
	            var xAxisModel = axesModels[0];
	            var yAxisModel = axesModels[1];
	
	            var gridModel = xAxisModel.findGridModel();
	
	            if (__DEV__) {
	                if (!gridModel) {
	                    throw new Error(
	                        'Grid "' + zrUtil.retrieve(
	                            xAxisModel.get('gridIndex'),
	                            xAxisModel.get('gridId'),
	                            0
	                        ) + '" not found'
	                    );
	                }
	                if (xAxisModel.findGridModel() !== yAxisModel.findGridModel()) {
	                    throw new Error('xAxis and yAxis must use the same grid');
	                }
	            }
	
	            var grid = gridModel.coordinateSystem;
	
	            seriesModel.coordinateSystem = grid.getCartesian(
	                xAxisModel.componentIndex, yAxisModel.componentIndex
	            );
	        });
	
	        return grids;
	    };
	
	    // For deciding which dimensions to use when creating list data
	    Grid.dimensions = Cartesian2D.prototype.dimensions;
	
	    __webpack_require__(30).register('cartesian2d', Grid);
	
	    return Grid;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var OrdinalScale = __webpack_require__(106);
	    var IntervalScale = __webpack_require__(108);
	    __webpack_require__(109);
	    __webpack_require__(110);
	    var Scale = __webpack_require__(107);
	
	    var numberUtil = __webpack_require__(11);
	    var zrUtil = __webpack_require__(8);
	    var textContain = __webpack_require__(12);
	    var axisHelper = {};
	
	    /**
	     * Get axis scale extent before niced.
	     */
	    axisHelper.getScaleExtent = function (axis, model) {
	        var scale = axis.scale;
	        var originalExtent = scale.getExtent();
	        var span = originalExtent[1] - originalExtent[0];
	        if (scale.type === 'ordinal') {
	            // If series has no data, scale extent may be wrong
	            if (!isFinite(span)) {
	                return [0, 0];
	            }
	            else {
	                return originalExtent;
	            }
	        }
	        var min = model.getMin ? model.getMin() : model.get('min');
	        var max = model.getMax ? model.getMax() : model.get('max');
	        var crossZero = model.getNeedCrossZero
	            ? model.getNeedCrossZero() : !model.get('scale');
	        var boundaryGap = model.get('boundaryGap');
	        if (!zrUtil.isArray(boundaryGap)) {
	            boundaryGap = [boundaryGap || 0, boundaryGap || 0];
	        }
	        boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);
	        boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);
	        var fixMin = true;
	        var fixMax = true;
	        // Add boundary gap
	        if (min == null) {
	            min = originalExtent[0] - boundaryGap[0] * span;
	            fixMin = false;
	        }
	        if (max == null) {
	            max = originalExtent[1] + boundaryGap[1] * span;
	            fixMax = false;
	        }
	        if (min === 'dataMin') {
	            min = originalExtent[0];
	        }
	        if (max === 'dataMax') {
	            max = originalExtent[1];
	        }
	        // Evaluate if axis needs cross zero
	        if (crossZero) {
	            // Axis is over zero and min is not set
	            if (min > 0 && max > 0 && !fixMin) {
	                min = 0;
	            }
	            // Axis is under zero and max is not set
	            if (min < 0 && max < 0 && !fixMax) {
	                max = 0;
	            }
	        }
	        return [min, max];
	    };
	
	    axisHelper.niceScaleExtent = function (axis, model) {
	        var scale = axis.scale;
	        var extent = axisHelper.getScaleExtent(axis, model);
	        var fixMin = (model.getMin ? model.getMin() : model.get('min')) != null;
	        var fixMax = (model.getMax ? model.getMax() : model.get('max')) != null;
	        var splitNumber = model.get('splitNumber');
	
	        if (scale.type === 'log') {
	            scale.base = model.get('logBase');
	        }
	
	        scale.setExtent(extent[0], extent[1]);
	        scale.niceExtent(splitNumber, fixMin, fixMax);
	
	        // Use minInterval to constraint the calculated interval.
	        // If calculated interval is less than minInterval. increase the interval quantity until
	        // it is larger than minInterval.
	        // For example:
	        //  minInterval is 1, calculated interval is 0.2, so increase it to be 1. In this way we can get
	        //  an integer axis.
	        var minInterval = model.get('minInterval');
	        if (isFinite(minInterval) && !fixMin && !fixMax && scale.type === 'interval') {
	            var interval = scale.getInterval();
	            var intervalScale = Math.max(Math.abs(interval), minInterval) / interval;
	            // while (interval < minInterval) {
	            //     var quantity = numberUtil.quantity(interval);
	            //     interval = quantity * 10;
	            //     scaleQuantity *= 10;
	            // }
	            extent = scale.getExtent();
	            scale.setExtent(intervalScale * extent[0], extent[1] * intervalScale);
	            scale.niceExtent(splitNumber);
	        }
	
	        // If some one specified the min, max. And the default calculated interval
	        // is not good enough. He can specify the interval. It is often appeared
	        // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard
	        // to be 60.
	        // FIXME
	        var interval = model.get('interval');
	        if (interval != null) {
	            scale.setInterval && scale.setInterval(interval);
	        }
	    };
	
	    /**
	     * @param {module:echarts/model/Model} model
	     * @param {string} [axisType] Default retrieve from model.type
	     * @return {module:echarts/scale/*}
	     */
	    axisHelper.createScaleByModel = function(model, axisType) {
	        axisType = axisType || model.get('type');
	        if (axisType) {
	            switch (axisType) {
	                // Buildin scale
	                case 'category':
	                    return new OrdinalScale(
	                        model.getCategories(), [Infinity, -Infinity]
	                    );
	                case 'value':
	                    return new IntervalScale();
	                // Extended scale, like time and log
	                default:
	                    return (Scale.getClass(axisType) || IntervalScale).create(model);
	            }
	        }
	    };
	
	    /**
	     * Check if the axis corss 0
	     */
	    axisHelper.ifAxisCrossZero = function (axis) {
	        var dataExtent = axis.scale.getExtent();
	        var min = dataExtent[0];
	        var max = dataExtent[1];
	        return !((min > 0 && max > 0) || (min < 0 && max < 0));
	    };
	
	    /**
	     * @param {Array.<number>} tickCoords In axis self coordinate.
	     * @param {Array.<string>} labels
	     * @param {string} font
	     * @param {boolean} isAxisHorizontal
	     * @return {number}
	     */
	    axisHelper.getAxisLabelInterval = function (tickCoords, labels, font, isAxisHorizontal) {
	        // FIXME
	        // 不同角的axis和label，不只是horizontal和vertical.
	
	        var textSpaceTakenRect;
	        var autoLabelInterval = 0;
	        var accumulatedLabelInterval = 0;
	
	        var step = 1;
	        if (labels.length > 40) {
	            // Simple optimization for large amount of labels
	            step = Math.floor(labels.length / 40);
	        }
	
	        for (var i = 0; i < tickCoords.length; i += step) {
	            var tickCoord = tickCoords[i];
	            var rect = textContain.getBoundingRect(
	                labels[i], font, 'center', 'top'
	            );
	            rect[isAxisHorizontal ? 'x' : 'y'] += tickCoord;
	            // FIXME Magic number 1.5
	            rect[isAxisHorizontal ? 'width' : 'height'] *= 1.3;
	            if (!textSpaceTakenRect) {
	                textSpaceTakenRect = rect.clone();
	            }
	            // There is no space for current label;
	            else if (textSpaceTakenRect.intersect(rect)) {
	                accumulatedLabelInterval++;
	                autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);
	            }
	            else {
	                textSpaceTakenRect.union(rect);
	                // Reset
	                accumulatedLabelInterval = 0;
	            }
	        }
	        if (autoLabelInterval === 0 && step > 1) {
	            return step;
	        }
	        return (autoLabelInterval + 1) * step - 1;
	    };
	
	    /**
	     * @param {Object} axis
	     * @param {Function} labelFormatter
	     * @return {Array.<string>}
	     */
	    axisHelper.getFormattedLabels = function (axis, labelFormatter) {
	        var scale = axis.scale;
	        var labels = scale.getTicksLabels();
	        var ticks = scale.getTicks();
	        if (typeof labelFormatter === 'string') {
	            labelFormatter = (function (tpl) {
	                return function (val) {
	                    return tpl.replace('{value}', val);
	                };
	            })(labelFormatter);
	            return zrUtil.map(labels, labelFormatter);
	        }
	        else if (typeof labelFormatter === 'function') {
	            return zrUtil.map(ticks, function (tick, idx) {
	                return labelFormatter(
	                    axis.type === 'category' ? scale.getLabel(tick) : tick,
	                    idx
	                );
	            }, this);
	        }
	        else {
	            return labels;
	        }
	    };
	
	    return axisHelper;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Linear continuous scale
	 * @module echarts/coord/scale/Ordinal
	 *
	 * http://en.wikipedia.org/wiki/Level_of_measurement
	 */
	
	// FIXME only one data
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var zrUtil = __webpack_require__(8);
	    var Scale = __webpack_require__(107);
	
	    var scaleProto = Scale.prototype;
	
	    var OrdinalScale = Scale.extend({
	
	        type: 'ordinal',
	
	        init: function (data, extent) {
	            this._data = data;
	            this._extent = extent || [0, data.length - 1];
	        },
	
	        parse: function (val) {
	            return typeof val === 'string'
	                ? zrUtil.indexOf(this._data, val)
	                // val might be float.
	                : Math.round(val);
	        },
	
	        contain: function (rank) {
	            rank = this.parse(rank);
	            return scaleProto.contain.call(this, rank)
	                && this._data[rank] != null;
	        },
	
	        /**
	         * Normalize given rank or name to linear [0, 1]
	         * @param {number|string} [val]
	         * @return {number}
	         */
	        normalize: function (val) {
	            return scaleProto.normalize.call(this, this.parse(val));
	        },
	
	        scale: function (val) {
	            return Math.round(scaleProto.scale.call(this, val));
	        },
	
	        /**
	         * @return {Array}
	         */
	        getTicks: function () {
	            var ticks = [];
	            var extent = this._extent;
	            var rank = extent[0];
	
	            while (rank <= extent[1]) {
	                ticks.push(rank);
	                rank++;
	            }
	
	            return ticks;
	        },
	
	        /**
	         * Get item on rank n
	         * @param {number} n
	         * @return {string}
	         */
	        getLabel: function (n) {
	            return this._data[n];
	        },
	
	        /**
	         * @return {number}
	         */
	        count: function () {
	            return this._extent[1] - this._extent[0] + 1;
	        },
	
	        niceTicks: zrUtil.noop,
	        niceExtent: zrUtil.noop
	    });
	
	    /**
	     * @return {module:echarts/scale/Time}
	     */
	    OrdinalScale.create = function () {
	        return new OrdinalScale();
	    };
	
	    return OrdinalScale;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * // Scale class management
	 * @module echarts/scale/Scale
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var clazzUtil = __webpack_require__(17);
	
	    function Scale() {
	        /**
	         * Extent
	         * @type {Array.<number>}
	         * @protected
	         */
	        this._extent = [Infinity, -Infinity];
	
	        /**
	         * Step is calculated in adjustExtent
	         * @type {Array.<number>}
	         * @protected
	         */
	        this._interval = 0;
	
	        this.init && this.init.apply(this, arguments);
	    }
	
	    var scaleProto = Scale.prototype;
	
	    /**
	     * Parse input val to valid inner number.
	     * @param {*} val
	     * @return {number}
	     */
	    scaleProto.parse = function (val) {
	        // Notice: This would be a trap here, If the implementation
	        // of this method depends on extent, and this method is used
	        // before extent set (like in dataZoom), it would be wrong.
	        // Nevertheless, parse does not depend on extent generally.
	        return val;
	    };
	
	    scaleProto.contain = function (val) {
	        var extent = this._extent;
	        return val >= extent[0] && val <= extent[1];
	    };
	
	    /**
	     * Normalize value to linear [0, 1], return 0.5 if extent span is 0
	     * @param {number} val
	     * @return {number}
	     */
	    scaleProto.normalize = function (val) {
	        var extent = this._extent;
	        if (extent[1] === extent[0]) {
	            return 0.5;
	        }
	        return (val - extent[0]) / (extent[1] - extent[0]);
	    };
	
	    /**
	     * Scale normalized value
	     * @param {number} val
	     * @return {number}
	     */
	    scaleProto.scale = function (val) {
	        var extent = this._extent;
	        return val * (extent[1] - extent[0]) + extent[0];
	    };
	
	    /**
	     * Set extent from data
	     * @param {Array.<number>} other
	     */
	    scaleProto.unionExtent = function (other) {
	        var extent = this._extent;
	        other[0] < extent[0] && (extent[0] = other[0]);
	        other[1] > extent[1] && (extent[1] = other[1]);
	        // not setExtent because in log axis it may transformed to power
	        // this.setExtent(extent[0], extent[1]);
	    };
	
	    /**
	     * Get extent
	     * @return {Array.<number>}
	     */
	    scaleProto.getExtent = function () {
	        return this._extent.slice();
	    };
	
	    /**
	     * Set extent
	     * @param {number} start
	     * @param {number} end
	     */
	    scaleProto.setExtent = function (start, end) {
	        var thisExtent = this._extent;
	        if (!isNaN(start)) {
	            thisExtent[0] = start;
	        }
	        if (!isNaN(end)) {
	            thisExtent[1] = end;
	        }
	    };
	
	    /**
	     * @return {Array.<string>}
	     */
	    scaleProto.getTicksLabels = function () {
	        var labels = [];
	        var ticks = this.getTicks();
	        for (var i = 0; i < ticks.length; i++) {
	            labels.push(this.getLabel(ticks[i]));
	        }
	        return labels;
	    };
	
	    clazzUtil.enableClassExtend(Scale);
	    clazzUtil.enableClassManagement(Scale, {
	        registerWhenExtend: true
	    });
	
	    return Scale;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Interval scale
	 * @module echarts/scale/Interval
	 */
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var numberUtil = __webpack_require__(11);
	    var formatUtil = __webpack_require__(10);
	    var Scale = __webpack_require__(107);
	
	    var mathFloor = Math.floor;
	    var mathCeil = Math.ceil;
	
	    var getPrecisionSafe = numberUtil.getPrecisionSafe;
	    var roundingErrorFix = numberUtil.round;
	    /**
	     * @alias module:echarts/coord/scale/Interval
	     * @constructor
	     */
	    var IntervalScale = Scale.extend({
	
	        type: 'interval',
	
	        _interval: 0,
	
	        setExtent: function (start, end) {
	            var thisExtent = this._extent;
	            //start,end may be a Number like '25',so...
	            if (!isNaN(start)) {
	                thisExtent[0] = parseFloat(start);
	            }
	            if (!isNaN(end)) {
	                thisExtent[1] = parseFloat(end);
	            }
	        },
	
	        unionExtent: function (other) {
	            var extent = this._extent;
	            other[0] < extent[0] && (extent[0] = other[0]);
	            other[1] > extent[1] && (extent[1] = other[1]);
	
	            // unionExtent may called by it's sub classes
	            IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);
	        },
	        /**
	         * Get interval
	         */
	        getInterval: function () {
	            if (!this._interval) {
	                this.niceTicks();
	            }
	            return this._interval;
	        },
	
	        /**
	         * Set interval
	         */
	        setInterval: function (interval) {
	            this._interval = interval;
	            // Dropped auto calculated niceExtent and use user setted extent
	            // We assume user wan't to set both interval, min, max to get a better result
	            this._niceExtent = this._extent.slice();
	        },
	
	        /**
	         * @return {Array.<number>}
	         */
	        getTicks: function () {
	            if (!this._interval) {
	                this.niceTicks();
	            }
	            var interval = this._interval;
	            var extent = this._extent;
	            var ticks = [];
	
	            // Consider this case: using dataZoom toolbox, zoom and zoom.
	            var safeLimit = 10000;
	
	            if (interval) {
	                var niceExtent = this._niceExtent;
	                var precision = getPrecisionSafe(interval) + 2;
	
	                if (extent[0] < niceExtent[0]) {
	                    ticks.push(extent[0]);
	                }
	                var tick = niceExtent[0];
	                while (tick <= niceExtent[1]) {
	                    ticks.push(tick);
	                    // Avoid rounding error
	                    tick = roundingErrorFix(tick + interval, precision);
	                    if (ticks.length > safeLimit) {
	                        return [];
	                    }
	                }
	                if (extent[1] > niceExtent[1]) {
	                    ticks.push(extent[1]);
	                }
	            }
	
	            return ticks;
	        },
	
	        /**
	         * @return {Array.<string>}
	         */
	        getTicksLabels: function () {
	            var labels = [];
	            var ticks = this.getTicks();
	            for (var i = 0; i < ticks.length; i++) {
	                labels.push(this.getLabel(ticks[i]));
	            }
	            return labels;
	        },
	
	        /**
	         * @param {number} n
	         * @return {number}
	         */
	        getLabel: function (data) {
	            return formatUtil.addCommas(data);
	        },
	
	        /**
	         * Update interval and extent of intervals for nice ticks
	         *
	         * @param {number} [splitNumber = 5] Desired number of ticks
	         */
	        niceTicks: function (splitNumber) {
	            splitNumber = splitNumber || 5;
	            var extent = this._extent;
	            var span = extent[1] - extent[0];
	            if (!isFinite(span)) {
	                return;
	            }
	            // User may set axis min 0 and data are all negative
	            // FIXME If it needs to reverse ?
	            if (span < 0) {
	                span = -span;
	                extent.reverse();
	            }
	
	            // From "Nice Numbers for Graph Labels" of Graphic Gems
	            // var niceSpan = numberUtil.nice(span, false);
	            var step = roundingErrorFix(
	                numberUtil.nice(span / splitNumber, true),
	                Math.max(
	                    getPrecisionSafe(extent[0]),
	                    getPrecisionSafe(extent[1])
	                // extent may be [0, 1], and step should have 1 more digits.
	                // To make it safe we add 2 more digits
	                ) + 2
	            );
	
	            var precision = getPrecisionSafe(step) + 2;
	            // Niced extent inside original extent
	            var niceExtent = [
	                roundingErrorFix(mathCeil(extent[0] / step) * step, precision),
	                roundingErrorFix(mathFloor(extent[1] / step) * step, precision)
	            ];
	
	            this._interval = step;
	            this._niceExtent = niceExtent;
	        },
	
	        /**
	         * Nice extent.
	         * @param {number} [splitNumber = 5] Given approx tick number
	         * @param {boolean} [fixMin=false]
	         * @param {boolean} [fixMax=false]
	         */
	        niceExtent: function (splitNumber, fixMin, fixMax) {
	            var extent = this._extent;
	            // If extent start and end are same, expand them
	            if (extent[0] === extent[1]) {
	                if (extent[0] !== 0) {
	                    // Expand extent
	                    var expandSize = extent[0];
	                    // In the fowllowing case
	                    //      Axis has been fixed max 100
	                    //      Plus data are all 100 and axis extent are [100, 100].
	                    // Extend to the both side will cause expanded max is larger than fixed max.
	                    // So only expand to the smaller side.
	                    if (!fixMax) {
	                        extent[1] += expandSize / 2;
	                        extent[0] -= expandSize / 2;
	                    }
	                    else {
	                        extent[0] -= expandSize / 2;
	                    }
	                }
	                else {
	                    extent[1] = 1;
	                }
	            }
	            var span = extent[1] - extent[0];
	            // If there are no data and extent are [Infinity, -Infinity]
	            if (!isFinite(span)) {
	                extent[0] = 0;
	                extent[1] = 1;
	            }
	
	            this.niceTicks(splitNumber);
	
	            // var extent = this._extent;
	            var interval = this._interval;
	
	            if (!fixMin) {
	                extent[0] = roundingErrorFix(mathFloor(extent[0] / interval) * interval);
	            }
	            if (!fixMax) {
	                extent[1] = roundingErrorFix(mathCeil(extent[1] / interval) * interval);
	            }
	        }
	    });
	
	    /**
	     * @return {module:echarts/scale/Time}
	     */
	    IntervalScale.create = function () {
	        return new IntervalScale();
	    };
	
	    return IntervalScale;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Interval scale
	 * @module echarts/coord/scale/Time
	 */
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var zrUtil = __webpack_require__(8);
	    var numberUtil = __webpack_require__(11);
	    var formatUtil = __webpack_require__(10);
	
	    var IntervalScale = __webpack_require__(108);
	
	    var intervalScaleProto = IntervalScale.prototype;
	
	    var mathCeil = Math.ceil;
	    var mathFloor = Math.floor;
	    var ONE_SECOND = 1000;
	    var ONE_MINUTE = ONE_SECOND * 60;
	    var ONE_HOUR = ONE_MINUTE * 60;
	    var ONE_DAY = ONE_HOUR * 24;
	
	    // FIXME 公用？
	    var bisect = function (a, x, lo, hi) {
	        while (lo < hi) {
	            var mid = lo + hi >>> 1;
	            if (a[mid][2] < x) {
	                lo = mid + 1;
	            }
	            else {
	                hi  = mid;
	            }
	        }
	        return lo;
	    };
	
	    /**
	     * @alias module:echarts/coord/scale/Time
	     * @constructor
	     */
	    var TimeScale = IntervalScale.extend({
	        type: 'time',
	
	        // Overwrite
	        getLabel: function (val) {
	            var stepLvl = this._stepLvl;
	
	            var date = new Date(val);
	
	            return formatUtil.formatTime(stepLvl[0], date);
	        },
	
	        // Overwrite
	        niceExtent: function (approxTickNum, fixMin, fixMax) {
	            var extent = this._extent;
	            // If extent start and end are same, expand them
	            if (extent[0] === extent[1]) {
	                // Expand extent
	                extent[0] -= ONE_DAY;
	                extent[1] += ONE_DAY;
	            }
	            // If there are no data and extent are [Infinity, -Infinity]
	            if (extent[1] === -Infinity && extent[0] === Infinity) {
	                var d = new Date();
	                extent[1] = new Date(d.getFullYear(), d.getMonth(), d.getDate());
	                extent[0] = extent[1] - ONE_DAY;
	            }
	
	            this.niceTicks(approxTickNum);
	
	            // var extent = this._extent;
	            var interval = this._interval;
	
	            if (!fixMin) {
	                extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);
	            }
	            if (!fixMax) {
	                extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);
	            }
	        },
	
	        // Overwrite
	        niceTicks: function (approxTickNum) {
	            approxTickNum = approxTickNum || 10;
	
	            var extent = this._extent;
	            var span = extent[1] - extent[0];
	            var approxInterval = span / approxTickNum;
	            var scaleLevelsLen = scaleLevels.length;
	            var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);
	
	            var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];
	            var interval = level[2];
	            // Same with interval scale if span is much larger than 1 year
	            if (level[0] === 'year') {
	                var yearSpan = span / interval;
	
	                // From "Nice Numbers for Graph Labels" of Graphic Gems
	                // var niceYearSpan = numberUtil.nice(yearSpan, false);
	                var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);
	
	                interval *= yearStep;
	            }
	
	            var niceExtent = [
	                mathCeil(extent[0] / interval) * interval,
	                mathFloor(extent[1] / interval) * interval
	            ];
	
	            this._stepLvl = level;
	            // Interval will be used in getTicks
	            this._interval = interval;
	            this._niceExtent = niceExtent;
	        },
	
	        parse: function (val) {
	            // val might be float.
	            return +numberUtil.parseDate(val);
	        }
	    });
	
	    zrUtil.each(['contain', 'normalize'], function (methodName) {
	        TimeScale.prototype[methodName] = function (val) {
	            return intervalScaleProto[methodName].call(this, this.parse(val));
	        };
	    });
	
	    // Steps from d3
	    var scaleLevels = [
	        // Format       step    interval
	        ['hh:mm:ss',    1,      ONE_SECOND],           // 1s
	        ['hh:mm:ss',    5,      ONE_SECOND * 5],       // 5s
	        ['hh:mm:ss',    10,     ONE_SECOND * 10],      // 10s
	        ['hh:mm:ss',    15,     ONE_SECOND * 15],      // 15s
	        ['hh:mm:ss',    30,     ONE_SECOND * 30],      // 30s
	        ['hh:mm\nMM-dd',1,      ONE_MINUTE],          // 1m
	        ['hh:mm\nMM-dd',5,      ONE_MINUTE * 5],      // 5m
	        ['hh:mm\nMM-dd',10,     ONE_MINUTE * 10],     // 10m
	        ['hh:mm\nMM-dd',15,     ONE_MINUTE * 15],     // 15m
	        ['hh:mm\nMM-dd',30,     ONE_MINUTE * 30],     // 30m
	        ['hh:mm\nMM-dd',1,      ONE_HOUR],        // 1h
	        ['hh:mm\nMM-dd',2,      ONE_HOUR * 2],    // 2h
	        ['hh:mm\nMM-dd',6,      ONE_HOUR * 6],    // 6h
	        ['hh:mm\nMM-dd',12,     ONE_HOUR * 12],   // 12h
	        ['MM-dd\nyyyy', 1,      ONE_DAY],   // 1d
	        ['week',        7,      ONE_DAY * 7],        // 7d
	        ['month',       1,      ONE_DAY * 31],       // 1M
	        ['quarter',     3,      ONE_DAY * 380 / 4],  // 3M
	        ['half-year',   6,      ONE_DAY * 380 / 2],  // 6M
	        ['year',        1,      ONE_DAY * 380]       // 1Y
	    ];
	
	    /**
	     * @return {module:echarts/scale/Time}
	     */
	    TimeScale.create = function () {
	        return new TimeScale();
	    };
	
	    return TimeScale;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Log scale
	 * @module echarts/scale/Log
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var zrUtil = __webpack_require__(8);
	    var Scale = __webpack_require__(107);
	    var numberUtil = __webpack_require__(11);
	
	    // Use some method of IntervalScale
	    var IntervalScale = __webpack_require__(108);
	
	    var scaleProto = Scale.prototype;
	    var intervalScaleProto = IntervalScale.prototype;
	
	    var mathFloor = Math.floor;
	    var mathCeil = Math.ceil;
	    var mathPow = Math.pow;
	
	    var mathLog = Math.log;
	
	    var LogScale = Scale.extend({
	
	        type: 'log',
	
	        base: 10,
	
	        /**
	         * @return {Array.<number>}
	         */
	        getTicks: function () {
	            return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {
	                return numberUtil.round(mathPow(this.base, val));
	            }, this);
	        },
	
	        /**
	         * @param {number} val
	         * @return {string}
	         */
	        getLabel: intervalScaleProto.getLabel,
	
	        /**
	         * @param  {number} val
	         * @return {number}
	         */
	        scale: function (val) {
	            val = scaleProto.scale.call(this, val);
	            return mathPow(this.base, val);
	        },
	
	        /**
	         * @param {number} start
	         * @param {number} end
	         */
	        setExtent: function (start, end) {
	            var base = this.base;
	            start = mathLog(start) / mathLog(base);
	            end = mathLog(end) / mathLog(base);
	            intervalScaleProto.setExtent.call(this, start, end);
	        },
	
	        /**
	         * @return {number} end
	         */
	        getExtent: function () {
	            var base = this.base;
	            var extent = scaleProto.getExtent.call(this);
	            extent[0] = mathPow(base, extent[0]);
	            extent[1] = mathPow(base, extent[1]);
	            return extent;
	        },
	
	        /**
	         * @param  {Array.<number>} extent
	         */
	        unionExtent: function (extent) {
	            var base = this.base;
	            extent[0] = mathLog(extent[0]) / mathLog(base);
	            extent[1] = mathLog(extent[1]) / mathLog(base);
	            scaleProto.unionExtent.call(this, extent);
	        },
	
	        /**
	         * Update interval and extent of intervals for nice ticks
	         * @param  {number} [approxTickNum = 10] Given approx tick number
	         */
	        niceTicks: function (approxTickNum) {
	            approxTickNum = approxTickNum || 10;
	            var extent = this._extent;
	            var span = extent[1] - extent[0];
	            if (span === Infinity || span <= 0) {
	                return;
	            }
	
	            var interval = numberUtil.quantity(span);
	            var err = approxTickNum / span * interval;
	
	            // Filter ticks to get closer to the desired count.
	            if (err <= 0.5) {
	                interval *= 10;
	            }
	
	            // Interval should be integer
	            while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {
	                interval *= 10;
	            }
	
	            var niceExtent = [
	                numberUtil.round(mathCeil(extent[0] / interval) * interval),
	                numberUtil.round(mathFloor(extent[1] / interval) * interval)
	            ];
	
	            this._interval = interval;
	            this._niceExtent = niceExtent;
	        },
	
	        /**
	         * Nice extent.
	         * @param {number} [approxTickNum = 10] Given approx tick number
	         * @param {boolean} [fixMin=false]
	         * @param {boolean} [fixMax=false]
	         */
	        niceExtent: intervalScaleProto.niceExtent
	    });
	
	    zrUtil.each(['contain', 'normalize'], function (methodName) {
	        LogScale.prototype[methodName] = function (val) {
	            val = mathLog(val) / mathLog(this.base);
	            return scaleProto[methodName].call(this, val);
	        };
	    });
	
	    LogScale.create = function () {
	        return new LogScale();
	    };
	
	    return LogScale;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
	
	    'use strict';
	
	    var zrUtil = __webpack_require__(8);
	    var Cartesian = __webpack_require__(112);
	
	    function Cartesian2D(name) {
	
	        Cartesian.call(this, name);
	    }
	
	    Cartesian2D.prototype = {
	
	        constructor: Cartesian2D,
	
	        type: 'cartesian2d',
	
	        /**
	         * @type {Array.<string>}
	         * @readOnly
	         */
	        dimensions: ['x', 'y'],
	
	        /**
	         * Base axis will be used on stacking.
	         *
	         * @return {module:echarts/coord/cartesian/Axis2D}
	         */
	        getBaseAxis: function () {
	            return this.getAxesByScale('ordinal')[0]
	                || this.getAxesByScale('time')[0]
	                || this.getAxis('x');
	        },
	
	        /**
	         * If contain point
	         * @param {Array.<number>} point
	         * @return {boolean}
	         */
	        containPoint: function (point) {
	            var axisX = this.getAxis('x');
	            var axisY = this.getAxis('y');
	            return axisX.contain(axisX.toLocalCoord(point[0]))
	                && axisY.contain(axisY.toLocalCoord(point[1]));
	        },
	
	        /**
	         * If contain data
	         * @param {Array.<number>} data
	         * @return {boolean}
	         */
	        containData: function (data) {
	            return this.getAxis('x').containData(data[0])
	                && this.getAxis('y').containData(data[1]);
	        },
	
	        /**
	         * Convert series data to an array of points
	         * @param {module:echarts/data/List} data
	         * @param {boolean} stack
	         * @return {Array}
	         *  Return array of points. For example:
	         *  `[[10, 10], [20, 20], [30, 30]]`
	         */
	        dataToPoints: function (data, stack) {
	            return data.mapArray(['x', 'y'], function (x, y) {
	                return this.dataToPoint([x, y]);
	            }, stack, this);
	        },
	
	        /**
	         * @param {Array.<number>} data
	         * @param {boolean} [clamp=false]
	         * @return {Array.<number>}
	         */
	        dataToPoint: function (data, clamp) {
	            var xAxis = this.getAxis('x');
	            var yAxis = this.getAxis('y');
	            return [
	                xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)),
	                yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))
	            ];
	        },
	
	        /**
	         * @param {Array.<number>} point
	         * @param {boolean} [clamp=false]
	         * @return {Array.<number>}
	         */
	        pointToData: function (point, clamp) {
	            var xAxis = this.getAxis('x');
	            var yAxis = this.getAxis('y');
	            return [
	                xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp),
	                yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)
	            ];
	        },
	
	        /**
	         * Get other axis
	         * @param {module:echarts/coord/cartesian/Axis2D} axis
	         */
	        getOtherAxis: function (axis) {
	            return this.getAxis(axis.dim === 'x' ? 'y' : 'x');
	        }
	    };
	
	    zrUtil.inherits(Cartesian2D, Cartesian);
	
	    return Cartesian2D;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Cartesian coordinate system
	 * @module  echarts/coord/Cartesian
	 *
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    'use strict';
	
	    var zrUtil = __webpack_require__(8);
	
	    function dimAxisMapper(dim) {
	        return this._axes[dim];
	    }
	
	    /**
	     * @alias module:echarts/coord/Cartesian
	     * @constructor
	     */
	    var Cartesian = function (name) {
	        this._axes = {};
	
	        this._dimList = [];
	
	        /**
	         * @type {string}
	         */
	        this.name = name || '';
	    };
	
	    Cartesian.prototype = {
	
	        constructor: Cartesian,
	
	        type: 'cartesian',
	
	        /**
	         * Get axis
	         * @param  {number|string} dim
	         * @return {module:echarts/coord/Cartesian~Axis}
	         */
	        getAxis: function (dim) {
	            return this._axes[dim];
	        },
	
	        /**
	         * Get axes list
	         * @return {Array.<module:echarts/coord/Cartesian~Axis>}
	         */
	        getAxes: function () {
	            return zrUtil.map(this._dimList, dimAxisMapper, this);
	        },
	
	        /**
	         * Get axes list by given scale type
	         */
	        getAxesByScale: function (scaleType) {
	            scaleType = scaleType.toLowerCase();
	            return zrUtil.filter(
	                this.getAxes(),
	                function (axis) {
	                    return axis.scale.type === scaleType;
	                }
	            );
	        },
	
	        /**
	         * Add axis
	         * @param {module:echarts/coord/Cartesian.Axis}
	         */
	        addAxis: function (axis) {
	            var dim = axis.dim;
	
	            this._axes[dim] = axis;
	
	            this._dimList.push(dim);
	        },
	
	        /**
	         * Convert data to coord in nd space
	         * @param {Array.<number>|Object.<string, number>} val
	         * @return {Array.<number>|Object.<string, number>}
	         */
	        dataToCoord: function (val) {
	            return this._dataCoordConvert(val, 'dataToCoord');
	        },
	
	        /**
	         * Convert coord in nd space to data
	         * @param  {Array.<number>|Object.<string, number>} val
	         * @return {Array.<number>|Object.<string, number>}
	         */
	        coordToData: function (val) {
	            return this._dataCoordConvert(val, 'coordToData');
	        },
	
	        _dataCoordConvert: function (input, method) {
	            var dimList = this._dimList;
	
	            var output = input instanceof Array ? [] : {};
	
	            for (var i = 0; i < dimList.length; i++) {
	                var dim = dimList[i];
	                var axis = this._axes[dim];
	
	                output[dim] = axis[method](input[dim]);
	            }
	
	            return output;
	        }
	    };
	
	    return Cartesian;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var zrUtil = __webpack_require__(8);
	    var Axis = __webpack_require__(114);
	    var axisLabelInterval = __webpack_require__(115);
	
	    /**
	     * Extend axis 2d
	     * @constructor module:echarts/coord/cartesian/Axis2D
	     * @extends {module:echarts/coord/cartesian/Axis}
	     * @param {string} dim
	     * @param {*} scale
	     * @param {Array.<number>} coordExtent
	     * @param {string} axisType
	     * @param {string} position
	     */
	    var Axis2D = function (dim, scale, coordExtent, axisType, position) {
	        Axis.call(this, dim, scale, coordExtent);
	        /**
	         * Axis type
	         *  - 'category'
	         *  - 'value'
	         *  - 'time'
	         *  - 'log'
	         * @type {string}
	         */
	        this.type = axisType || 'value';
	
	        /**
	         * Axis position
	         *  - 'top'
	         *  - 'bottom'
	         *  - 'left'
	         *  - 'right'
	         */
	        this.position = position || 'bottom';
	    };
	
	    Axis2D.prototype = {
	
	        constructor: Axis2D,
	
	        /**
	         * Index of axis, can be used as key
	         */
	        index: 0,
	        /**
	         * If axis is on the zero position of the other axis
	         * @type {boolean}
	         */
	        onZero: false,
	
	        /**
	         * Axis model
	         * @param {module:echarts/coord/cartesian/AxisModel}
	         */
	        model: null,
	
	        isHorizontal: function () {
	            var position = this.position;
	            return position === 'top' || position === 'bottom';
	        },
	
	        getGlobalExtent: function () {
	            var ret = this.getExtent();
	            ret[0] = this.toGlobalCoord(ret[0]);
	            ret[1] = this.toGlobalCoord(ret[1]);
	            return ret;
	        },
	
	        /**
	         * @return {number}
	         */
	        getLabelInterval: function () {
	            var labelInterval = this._labelInterval;
	            if (!labelInterval) {
	                labelInterval = this._labelInterval = axisLabelInterval(this);
	            }
	            return labelInterval;
	        },
	
	        /**
	         * If label is ignored.
	         * Automatically used when axis is category and label can not be all shown
	         * @param  {number}  idx
	         * @return {boolean}
	         */
	        isLabelIgnored: function (idx) {
	            if (this.type === 'category') {
	                var labelInterval = this.getLabelInterval();
	                return ((typeof labelInterval === 'function')
	                    && !labelInterval(idx, this.scale.getLabel(idx)))
	                    || idx % (labelInterval + 1);
	            }
	        },
	
	        /**
	         * Transform global coord to local coord,
	         * i.e. var localCoord = axis.toLocalCoord(80);
	         * designate by module:echarts/coord/cartesian/Grid.
	         * @type {Function}
	         */
	        toLocalCoord: null,
	
	        /**
	         * Transform global coord to local coord,
	         * i.e. var globalCoord = axis.toLocalCoord(40);
	         * designate by module:echarts/coord/cartesian/Grid.
	         * @type {Function}
	         */
	        toGlobalCoord: null
	
	    };
	    zrUtil.inherits(Axis2D, Axis);
	
	    return Axis2D;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var numberUtil = __webpack_require__(11);
	    var linearMap = numberUtil.linearMap;
	    var zrUtil = __webpack_require__(8);
	
	    function fixExtentWithBands(extent, nTick) {
	        var size = extent[1] - extent[0];
	        var len = nTick;
	        var margin = size / len / 2;
	        extent[0] += margin;
	        extent[1] -= margin;
	    }
	
	    var normalizedExtent = [0, 1];
	    /**
	     * @name module:echarts/coord/CartesianAxis
	     * @constructor
	     */
	    var Axis = function (dim, scale, extent) {
	
	        /**
	         * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'
	         * @type {string}
	         */
	        this.dim = dim;
	
	        /**
	         * Axis scale
	         * @type {module:echarts/coord/scale/*}
	         */
	        this.scale = scale;
	
	        /**
	         * @type {Array.<number>}
	         * @private
	         */
	        this._extent = extent || [0, 0];
	
	        /**
	         * @type {boolean}
	         */
	        this.inverse = false;
	
	        /**
	         * Usually true when axis has a ordinal scale
	         * @type {boolean}
	         */
	        this.onBand = false;
	    };
	
	    Axis.prototype = {
	
	        constructor: Axis,
	
	        /**
	         * If axis extent contain given coord
	         * @param {number} coord
	         * @return {boolean}
	         */
	        contain: function (coord) {
	            var extent = this._extent;
	            var min = Math.min(extent[0], extent[1]);
	            var max = Math.max(extent[0], extent[1]);
	            return coord >= min && coord <= max;
	        },
	
	        /**
	         * If axis extent contain given data
	         * @param {number} data
	         * @return {boolean}
	         */
	        containData: function (data) {
	            return this.contain(this.dataToCoord(data));
	        },
	
	        /**
	         * Get coord extent.
	         * @return {Array.<number>}
	         */
	        getExtent: function () {
	            var ret = this._extent.slice();
	            return ret;
	        },
	
	        /**
	         * Get precision used for formatting
	         * @param {Array.<number>} [dataExtent]
	         * @return {number}
	         */
	        getPixelPrecision: function (dataExtent) {
	            return numberUtil.getPixelPrecision(
	                dataExtent || this.scale.getExtent(),
	                this._extent
	            );
	        },
	
	        /**
	         * Set coord extent
	         * @param {number} start
	         * @param {number} end
	         */
	        setExtent: function (start, end) {
	            var extent = this._extent;
	            extent[0] = start;
	            extent[1] = end;
	        },
	
	        /**
	         * Convert data to coord. Data is the rank if it has a ordinal scale
	         * @param {number} data
	         * @param  {boolean} clamp
	         * @return {number}
	         */
	        dataToCoord: function (data, clamp) {
	            var extent = this._extent;
	            var scale = this.scale;
	            data = scale.normalize(data);
	
	            if (this.onBand && scale.type === 'ordinal') {
	                extent = extent.slice();
	                fixExtentWithBands(extent, scale.count());
	            }
	
	            return linearMap(data, normalizedExtent, extent, clamp);
	        },
	
	        /**
	         * Convert coord to data. Data is the rank if it has a ordinal scale
	         * @param {number} coord
	         * @param  {boolean} clamp
	         * @return {number}
	         */
	        coordToData: function (coord, clamp) {
	            var extent = this._extent;
	            var scale = this.scale;
	
	            if (this.onBand && scale.type === 'ordinal') {
	                extent = extent.slice();
	                fixExtentWithBands(extent, scale.count());
	            }
	
	            var t = linearMap(coord, extent, normalizedExtent, clamp);
	
	            return this.scale.scale(t);
	        },
	        /**
	         * @return {Array.<number>}
	         */
	        getTicksCoords: function (alignWithLabel) {
	            if (this.onBand && !alignWithLabel) {
	                var bands = this.getBands();
	                var coords = [];
	                for (var i = 0; i < bands.length; i++) {
	                    coords.push(bands[i][0]);
	                }
	                if (bands[i - 1]) {
	                    coords.push(bands[i - 1][1]);
	                }
	                return coords;
	            }
	            else {
	                return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);
	            }
	        },
	
	        /**
	         * Coords of labels are on the ticks or on the middle of bands
	         * @return {Array.<number>}
	         */
	        getLabelsCoords: function () {
	            return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);
	        },
	
	        /**
	         * Get bands.
	         *
	         * If axis has labels [1, 2, 3, 4]. Bands on the axis are
	         * |---1---|---2---|---3---|---4---|.
	         *
	         * @return {Array}
	         */
	         // FIXME Situation when labels is on ticks
	        getBands: function () {
	            var extent = this.getExtent();
	            var bands = [];
	            var len = this.scale.count();
	            var start = extent[0];
	            var end = extent[1];
	            var span = end - start;
	
	            for (var i = 0; i < len; i++) {
	                bands.push([
	                    span * i / len + start,
	                    span * (i + 1) / len + start
	                ]);
	            }
	            return bands;
	        },
	
	        /**
	         * Get width of band
	         * @return {number}
	         */
	        getBandWidth: function () {
	            var axisExtent = this._extent;
	            var dataExtent = this.scale.getExtent();
	
	            var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);
	            // Fix #2728, avoid NaN when only one data.
	            len === 0 && (len = 1);
	
	            var size = Math.abs(axisExtent[1] - axisExtent[0]);
	
	            return Math.abs(size) / len;
	        }
	    };
	
	    return Axis;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Helper function for axisLabelInterval calculation
	 */
	
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
	    'use strict';
	
	    var zrUtil = __webpack_require__(8);
	    var axisHelper = __webpack_require__(105);
	
	    return function (axis) {
	        var axisModel = axis.model;
	        var labelModel = axisModel.getModel('axisLabel');
	        var labelInterval = labelModel.get('interval');
	        if (!(axis.type === 'category' && labelInterval === 'auto')) {
	            return labelInterval === 'auto' ? 0 : labelInterval;
	        }
	
	        return axisHelper.getAxisLabelInterval(
	            zrUtil.map(axis.scale.getTicks(), axis.dataToCoord, axis),
	            axisModel.getFormattedLabels(),
	            labelModel.getModel('textStyle').getFont(),
	            axis.isHorizontal()
	        );
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;// Grid 是在有直角坐标系的时候必须要存在的
	// 所以这里也要被 Cartesian2D 依赖
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
	
	    'use strict';
	
	    __webpack_require__(117);
	    var ComponentModel = __webpack_require__(23);
	
	    return ComponentModel.extend({
	
	        type: 'grid',
	
	        dependencies: ['xAxis', 'yAxis'],
	
	        layoutMode: 'box',
	
	        /**
	         * @type {module:echarts/coord/cartesian/Grid}
	         */
	        coordinateSystem: null,
	
	        defaultOption: {
	            show: false,
	            zlevel: 0,
	            z: 0,
	            left: '10%',
	            top: 60,
	            right: '10%',
	            bottom: 60,
	            // If grid size contain label
	            containLabel: false,
	            // width: {totalWidth} - left - right,
	            // height: {totalHeight} - top - bottom,
	            backgroundColor: 'rgba(0,0,0,0)',
	            borderWidth: 1,
	            borderColor: '#ccc'
	        }
	    });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
	
	    'use strict';
	
	    var ComponentModel = __webpack_require__(23);
	    var zrUtil = __webpack_require__(8);
	    var axisModelCreator = __webpack_require__(118);
	
	    var AxisModel = ComponentModel.extend({
	
	        type: 'cartesian2dAxis',
	
	        /**
	         * @type {module:echarts/coord/cartesian/Axis2D}
	         */
	        axis: null,
	
	        /**
	         * @override
	         */
	        init: function () {
	            AxisModel.superApply(this, 'init', arguments);
	            this._resetRange();
	        },
	
	        /**
	         * @override
	         */
	        mergeOption: function () {
	            AxisModel.superApply(this, 'mergeOption', arguments);
	            this._resetRange();
	        },
	
	        /**
	         * @override
	         */
	        restoreData: function () {
	            AxisModel.superApply(this, 'restoreData', arguments);
	            this._resetRange();
	        },
	
	        /**
	         * @public
	         * @param {number} rangeStart
	         * @param {number} rangeEnd
	         */
	        setRange: function (rangeStart, rangeEnd) {
	            this.option.rangeStart = rangeStart;
	            this.option.rangeEnd = rangeEnd;
	        },
	
	        /**
	         * @public
	         * @return {Array.<number|string|Date>}
	         */
	        getMin: function () {
	            var option = this.option;
	            return option.rangeStart != null ? option.rangeStart : option.min;
	        },
	
	        /**
	         * @public
	         * @return {Array.<number|string|Date>}
	         */
	        getMax: function () {
	            var option = this.option;
	            return option.rangeEnd != null ? option.rangeEnd : option.max;
	        },
	
	        /**
	         * @public
	         * @return {boolean}
	         */
	        getNeedCrossZero: function () {
	            var option = this.option;
	            return (option.rangeStart != null || option.rangeEnd != null)
	                ? false : !option.scale;
	        },
	
	        /**
	         * @return {module:echarts/model/Model}
	         */
	        findGridModel: function () {
	            return this.ecModel.queryComponents({
	                mainType: 'grid',
	                index: this.get('gridIndex'),
	                id: this.get('gridId')
	            })[0];
	        },
	
	        /**
	         * @private
	         */
	        _resetRange: function () {
	            // rangeStart and rangeEnd is readonly.
	            this.option.rangeStart = this.option.rangeEnd = null;
	        }
	
	    });
	
	    function getAxisType(axisDim, option) {
	        // Default axis with data is category axis
	        return option.type || (option.data ? 'category' : 'value');
	    }
	
	    zrUtil.merge(AxisModel.prototype, __webpack_require__(120));
	
	    var extraOption = {
	        // gridIndex: 0,
	        // gridId: '',
	
	        // Offset is for multiple axis on the same position
	        offset: 0
	    };
	
	    axisModelCreator('x', AxisModel, getAxisType, extraOption);
	    axisModelCreator('y', AxisModel, getAxisType, extraOption);
	
	    return AxisModel;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var axisDefault = __webpack_require__(119);
	    var zrUtil = __webpack_require__(8);
	    var ComponentModel = __webpack_require__(23);
	    var layout = __webpack_require__(25);
	
	    // FIXME axisType is fixed ?
	    var AXIS_TYPES = ['value', 'category', 'time', 'log'];
	
	    /**
	     * Generate sub axis model class
	     * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'
	     * @param {module:echarts/model/Component} BaseAxisModelClass
	     * @param {Function} axisTypeDefaulter
	     * @param {Object} [extraDefaultOption]
	     */
	    return function (axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {
	
	        zrUtil.each(AXIS_TYPES, function (axisType) {
	
	            BaseAxisModelClass.extend({
	
	                type: axisName + 'Axis.' + axisType,
	
	                mergeDefaultAndTheme: function (option, ecModel) {
	                    var layoutMode = this.layoutMode;
	                    var inputPositionParams = layoutMode
	                        ? layout.getLayoutParams(option) : {};
	
	                    var themeModel = ecModel.getTheme();
	                    zrUtil.merge(option, themeModel.get(axisType + 'Axis'));
	                    zrUtil.merge(option, this.getDefaultOption());
	
	                    option.type = axisTypeDefaulter(axisName, option);
	
	                    if (layoutMode) {
	                        layout.mergeLayoutParam(option, inputPositionParams, layoutMode);
	                    }
	                },
	
	                defaultOption: zrUtil.mergeAll(
	                    [
	                        {},
	                        axisDefault[axisType + 'Axis'],
	                        extraDefaultOption
	                    ],
	                    true
	                )
	            });
	        });
	
	        ComponentModel.registerSubTypeDefaulter(
	            axisName + 'Axis',
	            zrUtil.curry(axisTypeDefaulter, axisName)
	        );
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var zrUtil = __webpack_require__(8);
	
	    var defaultOption = {
	        show: true,
	        zlevel: 0,                  // 一级层叠
	        z: 0,                       // 二级层叠
	        // 反向坐标轴
	        inverse: false,
	
	        // 坐标轴名字，默认为空
	        name: '',
	        // 坐标轴名字位置，支持'start' | 'middle' | 'end'
	        nameLocation: 'end',
	        // 坐标轴名字旋转，degree。
	        nameRotate: null, // Adapt to axis rotate, when nameLocation is 'middle'.
	        nameTruncate: {
	            maxWidth: null,
	            ellipsis: '...',
	            placeholder: '.'
	        },
	        // 坐标轴文字样式，默认取全局样式
	        nameTextStyle: {},
	        // 文字与轴线距离
	        nameGap: 15,
	
	        silent: false, // Default false to support tooltip.
	        triggerEvent: false, // Default false to avoid legacy user event listener fail.
	
	        tooltip: {
	            show: false
	        },
	
	        // 坐标轴线
	        axisLine: {
	            // 默认显示，属性show控制显示与否
	            show: true,
	            onZero: true,
	            // 属性lineStyle控制线条样式
	            lineStyle: {
	                color: '#333',
	                width: 1,
	                type: 'solid'
	            }
	        },
	        // 坐标轴小标记
	        axisTick: {
	            // 属性show控制显示与否，默认显示
	            show: true,
	            // 控制小标记是否在grid里
	            inside: false,
	            // 属性length控制线长
	            length: 5,
	            // 属性lineStyle控制线条样式
	            lineStyle: {
	                width: 1
	            }
	        },
	        // 坐标轴文本标签，详见axis.axisLabel
	        axisLabel: {
	            show: true,
	            // 控制文本标签是否在grid里
	            inside: false,
	            rotate: 0,
	            margin: 8,
	            // formatter: null,
	            // 其余属性默认使用全局文本样式，详见TEXTSTYLE
	            textStyle: {
	                fontSize: 12
	            }
	        },
	        // 分隔线
	        splitLine: {
	            // 默认显示，属性show控制显示与否
	            show: true,
	            // 属性lineStyle（详见lineStyle）控制线条样式
	            lineStyle: {
	                color: ['#ccc'],
	                width: 1,
	                type: 'solid'
	            }
	        },
	        // 分隔区域
	        splitArea: {
	            // 默认不显示，属性show控制显示与否
	            show: false,
	            // 属性areaStyle（详见areaStyle）控制区域样式
	            areaStyle: {
	                color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']
	            }
	        }
	    };
	
	    var categoryAxis = zrUtil.merge({
	        // 类目起始和结束两端空白策略
	        boundaryGap: true,
	        // splitArea: {
	            // show: false
	        // },
	        splitLine: {
	            show: false
	        },
	        // 坐标轴小标记
	        axisTick: {
	            // If tick is align with label when boundaryGap is true
	            // Default with axisTick
	            alignWithLabel: false,
	            interval: 'auto'
	        },
	        // 坐标轴文本标签，详见axis.axisLabel
	        axisLabel: {
	            interval: 'auto'
	        }
	    }, defaultOption);
	
	    var valueAxis = zrUtil.merge({
	        // 数值起始和结束两端空白策略
	        boundaryGap: [0, 0],
	        // 最小值, 设置成 'dataMin' 则从数据中计算最小值
	        // min: null,
	        // 最大值，设置成 'dataMax' 则从数据中计算最大值
	        // max: null,
	        // Readonly prop, specifies start value of the range when using data zoom.
	        // rangeStart: null
	        // Readonly prop, specifies end value of the range when using data zoom.
	        // rangeEnd: null
	        // 脱离0值比例，放大聚焦到最终_min，_max区间
	        // scale: false,
	        // 分割段数，默认为5
	        splitNumber: 5
	        // Minimum interval
	        // minInterval: null
	    }, defaultOption);
	
	    // FIXME
	    var timeAxis = zrUtil.defaults({
	        scale: true,
	        min: 'dataMin',
	        max: 'dataMax'
	    }, valueAxis);
	    var logAxis = zrUtil.defaults({
	        logBase: 10
	    }, valueAxis);
	    logAxis.scale = true;
	
	    return {
	        categoryAxis: categoryAxis,
	        valueAxis: valueAxis,
	        timeAxis: timeAxis,
	        logAxis: logAxis
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var zrUtil = __webpack_require__(8);
	    var axisHelper = __webpack_require__(105);
	
	    function getName(obj) {
	        if (zrUtil.isObject(obj) && obj.value != null) {
	            return obj.value;
	        }
	        else {
	            return obj;
	        }
	    }
	    /**
	     * Get categories
	     */
	    function getCategories() {
	        return this.get('type') === 'category'
	            && zrUtil.map(this.get('data'), getName);
	    }
	
	    /**
	     * Format labels
	     * @return {Array.<string>}
	     */
	    function getFormattedLabels() {
	        return axisHelper.getFormattedLabels(
	            this.axis,
	            this.get('axisLabel.formatter')
	        );
	    }
	
	    return {
	
	        getFormattedLabels: getFormattedLabels,
	
	        getCategories: getCategories
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
	
	    'use strict';
	
	    var SeriesModel = __webpack_require__(32);
	    var createListFromArray = __webpack_require__(122);
	
	    return SeriesModel.extend({
	
	        type: 'series.bar',
	
	        dependencies: ['grid', 'polar'],
	
	        getInitialData: function (option, ecModel) {
	            if (__DEV__) {
	                var coordSys = option.coordinateSystem;
	                if (coordSys !== 'cartesian2d') {
	                    throw new Error('Bar only support cartesian2d coordinateSystem');
	                }
	            }
	            return createListFromArray(option.data, this, ecModel);
	        },
	
	        getMarkerPosition: function (value) {
	            var coordSys = this.coordinateSystem;
	            if (coordSys) {
	                // PENDING if clamp ?
	                var pt = coordSys.dataToPoint(value, true);
	                var data = this.getData();
	                var offset = data.getLayout('offset');
	                var size = data.getLayout('size');
	                var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;
	                pt[offsetIndex] += offset + size / 2;
	                return pt;
	            }
	            return [NaN, NaN];
	        },
	
	        brushSelector: 'rect',
	
	        defaultOption: {
	            zlevel: 0,                  // 一级层叠
	            z: 2,                       // 二级层叠
	            coordinateSystem: 'cartesian2d',
	            legendHoverLink: true,
	            // stack: null
	
	            // Cartesian coordinate system
	            // xAxisIndex: 0,
	            // yAxisIndex: 0,
	
	            // 最小高度改为0
	            barMinHeight: 0,
	
	            // barMaxWidth: null,
	            // 默认自适应
	            // barWidth: null,
	            // 柱间距离，默认为柱形宽度的30%，可设固定值
	            // barGap: '30%',
	            // 类目间柱形距离，默认为类目间距的20%，可设固定值
	            // barCategoryGap: '20%',
	            // label: {
	            //     normal: {
	            //         show: false
	            //     }
	            // },
	            itemStyle: {
	                normal: {
	                    // color: '各异'
	                },
	                emphasis: {}
	            }
	        }
	    });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
	    'use strict';
	
	    var List = __webpack_require__(101);
	    var completeDimensions = __webpack_require__(123);
	    var zrUtil = __webpack_require__(8);
	    var modelUtil = __webpack_require__(9);
	    var CoordinateSystem = __webpack_require__(30);
	    var getDataItemValue = modelUtil.getDataItemValue;
	    var converDataValue = modelUtil.converDataValue;
	
	    function firstDataNotNull(data) {
	        var i = 0;
	        while (i < data.length && data[i] == null) {
	            i++;
	        }
	        return data[i];
	    }
	    function ifNeedCompleteOrdinalData(data) {
	        var sampleItem = firstDataNotNull(data);
	        return sampleItem != null
	            && !zrUtil.isArray(getDataItemValue(sampleItem));
	    }
	
	    /**
	     * Helper function to create a list from option data
	     */
	    function createListFromArray(data, seriesModel, ecModel) {
	        // If data is undefined
	        data = data || [];
	
	        if (__DEV__) {
	            if (!zrUtil.isArray(data)) {
	                throw new Error('Invalid data.');
	            }
	        }
	
	        var coordSysName = seriesModel.get('coordinateSystem');
	        var creator = creators[coordSysName];
	        var registeredCoordSys = CoordinateSystem.get(coordSysName);
	        // FIXME
	        var axesInfo = creator && creator(data, seriesModel, ecModel);
	        var dimensions = axesInfo && axesInfo.dimensions;
	        if (!dimensions) {
	            // Get dimensions from registered coordinate system
	            dimensions = (registeredCoordSys && registeredCoordSys.dimensions) || ['x', 'y'];
	            dimensions = completeDimensions(dimensions, data, dimensions.concat(['value']));
	        }
	        var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;
	
	        var list = new List(dimensions, seriesModel);
	
	        var nameList = createNameList(axesInfo, data);
	
	        var categories = {};
	        var dimValueGetter = (categoryIndex >= 0 && ifNeedCompleteOrdinalData(data))
	            ? function (itemOpt, dimName, dataIndex, dimIndex) {
	                // If any dataItem is like { value: 10 }
	                if (modelUtil.isDataItemOption(itemOpt)) {
	                    list.hasItemOption = true;
	                }
	
	                // Use dataIndex as ordinal value in categoryAxis
	                return dimIndex === categoryIndex
	                    ? dataIndex
	                    : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);
	            }
	            : function (itemOpt, dimName, dataIndex, dimIndex) {
	                var value = getDataItemValue(itemOpt);
	                var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]);
	                // If any dataItem is like { value: 10 }
	                if (modelUtil.isDataItemOption(itemOpt)) {
	                    list.hasItemOption = true;
	                }
	
	                var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;
	                if (categoryAxesModels && categoryAxesModels[dimName]) {
	                    // If given value is a category string
	                    if (typeof val === 'string') {
	                        // Lazy get categories
	                        categories[dimName] = categories[dimName]
	                            || categoryAxesModels[dimName].getCategories();
	                        val = zrUtil.indexOf(categories[dimName], val);
	                        if (val < 0 && !isNaN(val)) {
	                            // In case some one write '1', '2' istead of 1, 2
	                            val = +val;
	                        }
	                    }
	                }
	                return val;
	            };
	
	        list.hasItemOption = false;
	        list.initData(data, nameList, dimValueGetter);
	
	        return list;
	    }
	
	    function isStackable(axisType) {
	        return axisType !== 'category' && axisType !== 'time';
	    }
	
	    function getDimTypeByAxis(axisType) {
	        return axisType === 'category'
	            ? 'ordinal'
	            : axisType === 'time'
	            ? 'time'
	            : 'float';
	    }
	
	    /**
	     * Creaters for each coord system.
	     */
	    var creators = {
	
	        cartesian2d: function (data, seriesModel, ecModel) {
	
	            var axesModels = zrUtil.map(['xAxis', 'yAxis'], function (name) {
	                return ecModel.queryComponents({
	                    mainType: name,
	                    index: seriesModel.get(name + 'Index'),
	                    id: seriesModel.get(name + 'Id')
	                })[0];
	            });
	            var xAxisModel = axesModels[0];
	            var yAxisModel = axesModels[1];
	
	            if (__DEV__) {
	                if (!xAxisModel) {
	                    throw new Error('xAxis "' + zrUtil.retrieve(
	                        seriesModel.get('xAxisIndex'),
	                        seriesModel.get('xAxisId'),
	                        0
	                    ) + '" not found');
	                }
	                if (!yAxisModel) {
	                    throw new Error('yAxis "' + zrUtil.retrieve(
	                        seriesModel.get('xAxisIndex'),
	                        seriesModel.get('yAxisId'),
	                        0
	                    ) + '" not found');
	                }
	            }
	
	            var xAxisType = xAxisModel.get('type');
	            var yAxisType = yAxisModel.get('type');
	
	            var dimensions = [
	                {
	                    name: 'x',
	                    type: getDimTypeByAxis(xAxisType),
	                    stackable: isStackable(xAxisType)
	                },
	                {
	                    name: 'y',
	                    // If two category axes
	                    type: getDimTypeByAxis(yAxisType),
	                    stackable: isStackable(yAxisType)
	                }
	            ];
	
	            var isXAxisCateogry = xAxisType === 'category';
	            var isYAxisCategory = yAxisType === 'category';
	
	            completeDimensions(dimensions, data, ['x', 'y', 'z']);
	
	            var categoryAxesModels = {};
	            if (isXAxisCateogry) {
	                categoryAxesModels.x = xAxisModel;
	            }
	            if (isYAxisCategory) {
	                categoryAxesModels.y = yAxisModel;
	            }
	            return {
	                dimensions: dimensions,
	                categoryIndex: isXAxisCateogry ? 0 : (isYAxisCategory ? 1 : -1),
	                categoryAxesModels: categoryAxesModels
	            };
	        },
	
	        polar: function (data, seriesModel, ecModel) {
	            var polarModel = ecModel.queryComponents({
	                mainType: 'polar',
	                index: seriesModel.get('polarIndex'),
	                id: seriesModel.get('polarId')
	            })[0];
	
	            var angleAxisModel = polarModel.findAxisModel('angleAxis');
	            var radiusAxisModel = polarModel.findAxisModel('radiusAxis');
	
	            if (__DEV__) {
	                if (!angleAxisModel) {
	                    throw new Error('angleAxis option not found');
	                }
	                if (!radiusAxisModel) {
	                    throw new Error('radiusAxis option not found');
	                }
	            }
	
	            var radiusAxisType = radiusAxisModel.get('type');
	            var angleAxisType = angleAxisModel.get('type');
	
	            var dimensions = [
	                {
	                    name: 'radius',
	                    type: getDimTypeByAxis(radiusAxisType),
	                    stackable: isStackable(radiusAxisType)
	                },
	                {
	                    name: 'angle',
	                    type: getDimTypeByAxis(angleAxisType),
	                    stackable: isStackable(angleAxisType)
	                }
	            ];
	            var isAngleAxisCateogry = angleAxisType === 'category';
	            var isRadiusAxisCateogry = radiusAxisType === 'category';
	
	            completeDimensions(dimensions, data, ['radius', 'angle', 'value']);
	
	            var categoryAxesModels = {};
	            if (isRadiusAxisCateogry) {
	                categoryAxesModels.radius = radiusAxisModel;
	            }
	            if (isAngleAxisCateogry) {
	                categoryAxesModels.angle = angleAxisModel;
	            }
	            return {
	                dimensions: dimensions,
	                categoryIndex: isAngleAxisCateogry ? 1 : (isRadiusAxisCateogry ? 0 : -1),
	                categoryAxesModels: categoryAxesModels
	            };
	        },
	
	        geo: function (data, seriesModel, ecModel) {
	            // TODO Region
	            // 多个散点图系列在同一个地区的时候
	            return {
	                dimensions: completeDimensions([
	                    {name: 'lng'},
	                    {name: 'lat'}
	                ], data, ['lng', 'lat', 'value'])
	            };
	        }
	    };
	
	    function createNameList(result, data) {
	        var nameList = [];
	
	        var categoryDim = result && result.dimensions[result.categoryIndex];
	        var categoryAxisModel;
	        if (categoryDim) {
	            categoryAxisModel = result.categoryAxesModels[categoryDim.name];
	        }
	
	        if (categoryAxisModel) {
	            // FIXME Two category axis
	            var categories = categoryAxisModel.getCategories();
	            if (categories) {
	                var dataLen = data.length;
	                // Ordered data is given explicitly like
	                // [[3, 0.2], [1, 0.3], [2, 0.15]]
	                // or given scatter data,
	                // pick the category
	                if (zrUtil.isArray(data[0]) && data[0].length > 1) {
	                    nameList = [];
	                    for (var i = 0; i < dataLen; i++) {
	                        nameList[i] = categories[data[i][result.categoryIndex || 0]];
	                    }
	                }
	                else {
	                    nameList = categories.slice(0);
	                }
	            }
	        }
	
	        return nameList;
	    }
	
	    return createListFromArray;
	
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Complete dimensions by data (guess dimension).
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var zrUtil = __webpack_require__(8);
	
	    /**
	     * Complete the dimensions array guessed from the data structure.
	     * @param  {Array.<string>} dimensions      Necessary dimensions, like ['x', 'y']
	     * @param  {Array} data                     Data list. [[1, 2, 3], [2, 3, 4]]
	     * @param  {Array.<string>} defaultNames    Default names to fill not necessary dimensions, like ['value']
	     * @param  {string} extraPrefix             Prefix of name when filling the left dimensions.
	     * @return {Array.<string>}
	     */
	    function completeDimensions(dimensions, data, defaultNames, extraPrefix) {
	        if (!data) {
	            return dimensions;
	        }
	
	        var value0 = retrieveValue(data[0]);
	        var dimSize = zrUtil.isArray(value0) && value0.length || 1;
	
	        defaultNames = defaultNames || [];
	        extraPrefix = extraPrefix || 'extra';
	        for (var i = 0; i < dimSize; i++) {
	            if (!dimensions[i]) {
	                var name = defaultNames[i] || (extraPrefix + (i - defaultNames.length));
	                dimensions[i] = guessOrdinal(data, i)
	                    ? {type: 'ordinal', name: name}
	                    : name;
	            }
	        }
	
	        return dimensions;
	    }
	
	    // The rule should not be complex, otherwise user might not
	    // be able to known where the data is wrong.
	    var guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {
	        for (var i = 0, len = data.length; i < len; i++) {
	            var value = retrieveValue(data[i]);
	
	            if (!zrUtil.isArray(value)) {
	                return false;
	            }
	
	            var value = value[dimIndex];
	            if (value != null && isFinite(value)) {
	                return false;
	            }
	            else if (zrUtil.isString(value) && value !== '-') {
	                return true;
	            }
	        }
	        return false;
	    };
	
	    function retrieveValue(o) {
	        return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value: o;
	    }
	
	    return completeDimensions;
	
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    'use strict';
	
	    var zrUtil = __webpack_require__(8);
	    var graphic = __webpack_require__(47);
	
	    zrUtil.extend(__webpack_require__(16).prototype, __webpack_require__(125));
	
	    function fixLayoutWithLineWidth(layout, lineWidth) {
	        var signX = layout.width > 0 ? 1 : -1;
	        var signY = layout.height > 0 ? 1 : -1;
	        // In case width or height are too small.
	        lineWidth = Math.min(lineWidth, Math.abs(layout.width), Math.abs(layout.height));
	        layout.x += signX * lineWidth / 2;
	        layout.y += signY * lineWidth / 2;
	        layout.width -= signX * lineWidth;
	        layout.height -= signY * lineWidth;
	    }
	
	    return __webpack_require__(5).extendChartView({
	
	        type: 'bar',
	
	        render: function (seriesModel, ecModel, api) {
	            var coordinateSystemType = seriesModel.get('coordinateSystem');
	
	            if (coordinateSystemType === 'cartesian2d') {
	                this._renderOnCartesian(seriesModel, ecModel, api);
	            }
	
	            return this.group;
	        },
	
	        _renderOnCartesian: function (seriesModel, ecModel, api) {
	            var group = this.group;
	            var data = seriesModel.getData();
	            var oldData = this._data;
	
	            var cartesian = seriesModel.coordinateSystem;
	            var baseAxis = cartesian.getBaseAxis();
	            var isHorizontal = baseAxis.isHorizontal();
	
	            var enableAnimation = seriesModel.get('animation');
	
	            var barBorderWidthQuery = ['itemStyle', 'normal', 'barBorderWidth'];
	
	            function createRect(dataIndex, isUpdate) {
	                var layout = data.getItemLayout(dataIndex);
	                var lineWidth = data.getItemModel(dataIndex).get(barBorderWidthQuery) || 0;
	                fixLayoutWithLineWidth(layout, lineWidth);
	
	                var rect = new graphic.Rect({
	                    shape: zrUtil.extend({}, layout)
	                });
	                // Animation
	                if (enableAnimation) {
	                    var rectShape = rect.shape;
	                    var animateProperty = isHorizontal ? 'height' : 'width';
	                    var animateTarget = {};
	                    rectShape[animateProperty] = 0;
	                    animateTarget[animateProperty] = layout[animateProperty];
	                    graphic[isUpdate? 'updateProps' : 'initProps'](rect, {
	                        shape: animateTarget
	                    }, seriesModel, dataIndex);
	                }
	                return rect;
	            }
	            data.diff(oldData)
	                .add(function (dataIndex) {
	                    // 空数据
	                    if (!data.hasValue(dataIndex)) {
	                        return;
	                    }
	
	                    var rect = createRect(dataIndex);
	
	                    data.setItemGraphicEl(dataIndex, rect);
	
	                    group.add(rect);
	
	                })
	                .update(function (newIndex, oldIndex) {
	                    var rect = oldData.getItemGraphicEl(oldIndex);
	                    // 空数据
	                    if (!data.hasValue(newIndex)) {
	                        group.remove(rect);
	                        return;
	                    }
	                    if (!rect) {
	                        rect = createRect(newIndex, true);
	                    }
	
	                    var layout = data.getItemLayout(newIndex);
	                    var lineWidth = data.getItemModel(newIndex).get(barBorderWidthQuery) || 0;
	                    fixLayoutWithLineWidth(layout, lineWidth);
	
	                    graphic.updateProps(rect, {
	                        shape: layout
	                    }, seriesModel, newIndex);
	
	                    data.setItemGraphicEl(newIndex, rect);
	
	                    // Add back
	                    group.add(rect);
	                })
	                .remove(function (idx) {
	                    var rect = oldData.getItemGraphicEl(idx);
	                    if (rect) {
	                        // Not show text when animating
	                        rect.style.text = '';
	                        graphic.updateProps(rect, {
	                            shape: {
	                                width: 0
	                            }
	                        }, seriesModel, idx, function () {
	                            group.remove(rect);
	                        });
	                    }
	                })
	                .execute();
	
	            this._updateStyle(seriesModel, data, isHorizontal);
	
	            this._data = data;
	        },
	
	        _updateStyle: function (seriesModel, data, isHorizontal) {
	            function setLabel(style, model, color, labelText, labelPositionOutside) {
	                graphic.setText(style, model, color);
	                style.text = labelText;
	                if (style.textPosition === 'outside') {
	                    style.textPosition = labelPositionOutside;
	                }
	            }
	
	            data.eachItemGraphicEl(function (rect, idx) {
	                var itemModel = data.getItemModel(idx);
	                var color = data.getItemVisual(idx, 'color');
	                var opacity = data.getItemVisual(idx, 'opacity');
	                var layout = data.getItemLayout(idx);
	                var itemStyleModel = itemModel.getModel('itemStyle.normal');
	
	                var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();
	
	                rect.setShape('r', itemStyleModel.get('barBorderRadius') || 0);
	
	                rect.useStyle(zrUtil.defaults(
	                    {
	                        fill: color,
	                        opacity: opacity
	                    },
	                    itemStyleModel.getBarItemStyle()
	                ));
	
	                var labelPositionOutside = isHorizontal
	                    ? (layout.height > 0 ? 'bottom' : 'top')
	                    : (layout.width > 0 ? 'left' : 'right');
	
	                var labelModel = itemModel.getModel('label.normal');
	                var hoverLabelModel = itemModel.getModel('label.emphasis');
	                var rectStyle = rect.style;
	                if (labelModel.get('show')) {
	                    setLabel(
	                        rectStyle, labelModel, color,
	                        zrUtil.retrieve(
	                            seriesModel.getFormattedLabel(idx, 'normal'),
	                            seriesModel.getRawValue(idx)
	                        ),
	                        labelPositionOutside
	                    );
	                }
	                else {
	                    rectStyle.text = '';
	                }
	                if (hoverLabelModel.get('show')) {
	                    setLabel(
	                        hoverStyle, hoverLabelModel, color,
	                        zrUtil.retrieve(
	                            seriesModel.getFormattedLabel(idx, 'emphasis'),
	                            seriesModel.getRawValue(idx)
	                        ),
	                        labelPositionOutside
	                    );
	                }
	                else {
	                    hoverStyle.text = '';
	                }
	                graphic.setHoverStyle(rect, hoverStyle);
	            });
	        },
	
	        remove: function (ecModel, api) {
	            var group = this.group;
	            if (ecModel.get('animation')) {
	                if (this._data) {
	                    this._data.eachItemGraphicEl(function (el) {
	                        // Not show text when animating
	                        el.style.text = '';
	                        graphic.updateProps(el, {
	                            shape: {
	                                width: 0
	                            }
	                        }, ecModel, el.dataIndex, function () {
	                            group.remove(el);
	                        });
	                    });
	                }
	            }
	            else {
	                group.removeAll();
	            }
	        }
	    });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	
	    var getBarItemStyle = __webpack_require__(19)(
	        [
	            ['fill', 'color'],
	            ['stroke', 'borderColor'],
	            ['lineWidth', 'borderWidth'],
	            // Compatitable with 2
	            ['stroke', 'barBorderColor'],
	            ['lineWidth', 'barBorderWidth'],
	            ['opacity'],
	            ['shadowBlur'],
	            ['shadowOffsetX'],
	            ['shadowOffsetY'],
	            ['shadowColor']
	        ]
	    );
	    return {
	        getBarItemStyle: function (excludes) {
	            var style = getBarItemStyle.call(this, excludes);
	            if (this.getBorderLineDash) {
	                var lineDash = this.getBorderLineDash();
	                lineDash && (style.lineDash = lineDash);
	            }
	            return style;
	        }
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
	
	    'use strict';
	
	    var zrUtil = __webpack_require__(8);
	    var numberUtil = __webpack_require__(11);
	    var parsePercent = numberUtil.parsePercent;
	
	    function getSeriesStackId(seriesModel) {
	        return seriesModel.get('stack') || '__ec_stack_' + seriesModel.seriesIndex;
	    }
	
	    function getAxisKey(axis) {
	        return axis.dim + axis.index;
	    }
	
	    function calBarWidthAndOffset(barSeries, api) {
	        // Columns info on each category axis. Key is cartesian name
	        var columnsMap = {};
	
	        zrUtil.each(barSeries, function (seriesModel, idx) {
	            var data = seriesModel.getData();
	            var cartesian = seriesModel.coordinateSystem;
	
	            var baseAxis = cartesian.getBaseAxis();
	            var axisExtent = baseAxis.getExtent();
	            var bandWidth = baseAxis.type === 'category'
	                ? baseAxis.getBandWidth()
	                : (Math.abs(axisExtent[1] - axisExtent[0]) / data.count());
	
	            var columnsOnAxis = columnsMap[getAxisKey(baseAxis)] || {
	                bandWidth: bandWidth,
	                remainedWidth: bandWidth,
	                autoWidthCount: 0,
	                categoryGap: '20%',
	                gap: '30%',
	                stacks: {}
	            };
	            var stacks = columnsOnAxis.stacks;
	            columnsMap[getAxisKey(baseAxis)] = columnsOnAxis;
	
	            var stackId = getSeriesStackId(seriesModel);
	
	            if (!stacks[stackId]) {
	                columnsOnAxis.autoWidthCount++;
	            }
	            stacks[stackId] = stacks[stackId] || {
	                width: 0,
	                maxWidth: 0
	            };
	
	            var barWidth = parsePercent(
	                seriesModel.get('barWidth'), bandWidth
	            );
	            var barMaxWidth = parsePercent(
	                seriesModel.get('barMaxWidth'), bandWidth
	            );
	            var barGap = seriesModel.get('barGap');
	            var barCategoryGap = seriesModel.get('barCategoryGap');
	            // TODO
	            if (barWidth && !stacks[stackId].width) {
	                barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
	                stacks[stackId].width = barWidth;
	                columnsOnAxis.remainedWidth -= barWidth;
	            }
	
	            barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
	            (barGap != null) && (columnsOnAxis.gap = barGap);
	            (barCategoryGap != null) && (columnsOnAxis.categoryGap = barCategoryGap);
	        });
	
	        var result = {};
	
	        zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {
	
	            result[coordSysName] = {};
	
	            var stacks = columnsOnAxis.stacks;
	            var bandWidth = columnsOnAxis.bandWidth;
	            var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);
	            var barGapPercent = parsePercent(columnsOnAxis.gap, 1);
	
	            var remainedWidth = columnsOnAxis.remainedWidth;
	            var autoWidthCount = columnsOnAxis.autoWidthCount;
	            var autoWidth = (remainedWidth - categoryGap)
	                / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
	            autoWidth = Math.max(autoWidth, 0);
	
	            // Find if any auto calculated bar exceeded maxBarWidth
	            zrUtil.each(stacks, function (column, stack) {
	                var maxWidth = column.maxWidth;
	                if (!column.width && maxWidth && maxWidth < autoWidth) {
	                    maxWidth = Math.min(maxWidth, remainedWidth);
	                    remainedWidth -= maxWidth;
	                    column.width = maxWidth;
	                    autoWidthCount--;
	                }
	            });
	
	            // Recalculate width again
	            autoWidth = (remainedWidth - categoryGap)
	                / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
	            autoWidth = Math.max(autoWidth, 0);
	
	            var widthSum = 0;
	            var lastColumn;
	            zrUtil.each(stacks, function (column, idx) {
	                if (!column.width) {
	                    column.width = autoWidth;
	                }
	                lastColumn = column;
	                widthSum += column.width * (1 + barGapPercent);
	            });
	            if (lastColumn) {
	                widthSum -= lastColumn.width * barGapPercent;
	            }
	
	            var offset = -widthSum / 2;
	            zrUtil.each(stacks, function (column, stackId) {
	                result[coordSysName][stackId] = result[coordSysName][stackId] || {
	                    offset: offset,
	                    width: column.width
	                };
	
	                offset += column.width * (1 + barGapPercent);
	            });
	        });
	
	        return result;
	    }
	
	    /**
	     * @param {string} seriesType
	     * @param {module:echarts/model/Global} ecModel
	     * @param {module:echarts/ExtensionAPI} api
	     */
	    function barLayoutGrid(seriesType, ecModel, api) {
	
	        var barWidthAndOffset = calBarWidthAndOffset(
	            zrUtil.filter(
	                ecModel.getSeriesByType(seriesType),
	                function (seriesModel) {
	                    return !ecModel.isSeriesFiltered(seriesModel)
	                        && seriesModel.coordinateSystem
	                        && seriesModel.coordinateSystem.type === 'cartesian2d';
	                }
	            )
	        );
	
	        var lastStackCoords = {};
	
	        ecModel.eachSeriesByType(seriesType, function (seriesModel) {
	
	            var data = seriesModel.getData();
	            var cartesian = seriesModel.coordinateSystem;
	            var baseAxis = cartesian.getBaseAxis();
	
	            var stackId = getSeriesStackId(seriesModel);
	            var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];
	            var columnOffset = columnLayoutInfo.offset;
	            var columnWidth = columnLayoutInfo.width;
	            var valueAxis = cartesian.getOtherAxis(baseAxis);
	
	            var barMinHeight = seriesModel.get('barMinHeight') || 0;
	
	            var valueAxisStart = baseAxis.onZero
	                ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0))
	                : valueAxis.getGlobalExtent()[0];
	
	            var coords = cartesian.dataToPoints(data, true);
	            lastStackCoords[stackId] = lastStackCoords[stackId] || [];
	
	            data.setLayout({
	                offset: columnOffset,
	                size: columnWidth
	            });
	            data.each(valueAxis.dim, function (value, idx) {
	                // 空数据
	                if (isNaN(value)) {
	                    return;
	                }
	                if (!lastStackCoords[stackId][idx]) {
	                    lastStackCoords[stackId][idx] = {
	                        // Positive stack
	                        p: valueAxisStart,
	                        // Negative stack
	                        n: valueAxisStart
	                    };
	                }
	                var sign = value >= 0 ? 'p' : 'n';
	                var coord = coords[idx];
	                var lastCoord = lastStackCoords[stackId][idx][sign];
	                var x, y, width, height;
	                if (valueAxis.isHorizontal()) {
	                    x = lastCoord;
	                    y = coord[1] + columnOffset;
	                    width = coord[0] - lastCoord;
	                    height = columnWidth;
	
	                    if (Math.abs(width) < barMinHeight) {
	                        width = (width < 0 ? -1 : 1) * barMinHeight;
	                    }
	                    lastStackCoords[stackId][idx][sign] += width;
	                }
	                else {
	                    x = coord[0] + columnOffset;
	                    y = lastCoord;
	                    width = columnWidth;
	                    height = coord[1] - lastCoord;
	                    if (Math.abs(height) < barMinHeight) {
	                        // Include zero to has a positive bar
	                        height = (height <= 0 ? -1 : 1) * barMinHeight;
	                    }
	                    lastStackCoords[stackId][idx][sign] += height;
	                }
	
	                data.setItemLayout(idx, {
	                    x: x,
	                    y: y,
	                    width: width,
	                    height: height
	                });
	            }, true);
	
	        }, this);
	    }
	
	    return barLayoutGrid;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
	    'use strict';
	
	    var graphic = __webpack_require__(47);
	    var zrUtil = __webpack_require__(8);
	    var echarts = __webpack_require__(5);
	
	    __webpack_require__(104);
	
	    __webpack_require__(128);
	
	    // Grid view
	    echarts.extendComponentView({
	
	        type: 'grid',
	
	        render: function (gridModel, ecModel) {
	            this.group.removeAll();
	            if (gridModel.get('show')) {
	                this.group.add(new graphic.Rect({
	                    shape:gridModel.coordinateSystem.getRect(),
	                    style: zrUtil.defaults({
	                        fill: gridModel.get('backgroundColor')
	                    }, gridModel.getItemStyle()),
	                    silent: true
	                }));
	            }
	        }
	    });
	
	    echarts.registerPreprocessor(function (option) {
	        // Only create grid when need
	        if (option.xAxis && option.yAxis && !option.grid) {
	            option.grid = {};
	        }
	    });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;// TODO boundaryGap
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
	    'use strict';
	
	    __webpack_require__(117);
	
	    __webpack_require__(129);
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var zrUtil = __webpack_require__(8);
	    var graphic = __webpack_require__(47);
	    var AxisBuilder = __webpack_require__(130);
	    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;
	    var getInterval = AxisBuilder.getInterval;
	
	    var axisBuilderAttrs = [
	        'axisLine', 'axisLabel', 'axisTick', 'axisName'
	    ];
	    var selfBuilderAttrs = [
	        'splitArea', 'splitLine'
	    ];
	
	    // function getAlignWithLabel(model, axisModel) {
	    //     var alignWithLabel = model.get('alignWithLabel');
	    //     if (alignWithLabel === 'auto') {
	    //         alignWithLabel = axisModel.get('axisTick.alignWithLabel');
	    //     }
	    //     return alignWithLabel;
	    // }
	
	    var AxisView = __webpack_require__(5).extendComponentView({
	
	        type: 'axis',
	
	        render: function (axisModel, ecModel) {
	
	            this.group.removeAll();
	
	            var oldAxisGroup = this._axisGroup;
	            this._axisGroup = new graphic.Group();
	
	            this.group.add(this._axisGroup);
	
	            if (!axisModel.get('show')) {
	                return;
	            }
	
	            var gridModel = axisModel.findGridModel();
	
	            var layout = layoutAxis(gridModel, axisModel);
	
	            var axisBuilder = new AxisBuilder(axisModel, layout);
	
	            zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);
	
	            this._axisGroup.add(axisBuilder.getGroup());
	
	            zrUtil.each(selfBuilderAttrs, function (name) {
	                if (axisModel.get(name + '.show')) {
	                    this['_' + name](axisModel, gridModel, layout.labelInterval);
	                }
	            }, this);
	
	            graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);
	        },
	
	        /**
	         * @param {module:echarts/coord/cartesian/AxisModel} axisModel
	         * @param {module:echarts/coord/cartesian/GridModel} gridModel
	         * @param {number|Function} labelInterval
	         * @private
	         */
	        _splitLine: function (axisModel, gridModel, labelInterval) {
	            var axis = axisModel.axis;
	
	            var splitLineModel = axisModel.getModel('splitLine');
	            var lineStyleModel = splitLineModel.getModel('lineStyle');
	            var lineColors = lineStyleModel.get('color');
	
	            var lineInterval = getInterval(splitLineModel, labelInterval);
	
	            lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];
	
	            var gridRect = gridModel.coordinateSystem.getRect();
	            var isHorizontal = axis.isHorizontal();
	
	            var lineCount = 0;
	
	            var ticksCoords = axis.getTicksCoords(
	                // splitLineModel.get('alignWithLabel')
	            );
	            var ticks = axis.scale.getTicks();
	
	            var p1 = [];
	            var p2 = [];
	            // Simple optimization
	            // Batching the lines if color are the same
	            var lineStyle = lineStyleModel.getLineStyle();
	            for (var i = 0; i < ticksCoords.length; i++) {
	                if (ifIgnoreOnTick(axis, i, lineInterval)) {
	                    continue;
	                }
	
	                var tickCoord = axis.toGlobalCoord(ticksCoords[i]);
	
	                if (isHorizontal) {
	                    p1[0] = tickCoord;
	                    p1[1] = gridRect.y;
	                    p2[0] = tickCoord;
	                    p2[1] = gridRect.y + gridRect.height;
	                }
	                else {
	                    p1[0] = gridRect.x;
	                    p1[1] = tickCoord;
	                    p2[0] = gridRect.x + gridRect.width;
	                    p2[1] = tickCoord;
	                }
	
	                var colorIndex = (lineCount++) % lineColors.length;
	                this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({
	                    anid: 'line_' + ticks[i],
	
	                    shape: {
	                        x1: p1[0],
	                        y1: p1[1],
	                        x2: p2[0],
	                        y2: p2[1]
	                    },
	                    style: zrUtil.defaults({
	                        stroke: lineColors[colorIndex]
	                    }, lineStyle),
	                    silent: true
	                })));
	            }
	        },
	
	        /**
	         * @param {module:echarts/coord/cartesian/AxisModel} axisModel
	         * @param {module:echarts/coord/cartesian/GridModel} gridModel
	         * @param {number|Function} labelInterval
	         * @private
	         */
	        _splitArea: function (axisModel, gridModel, labelInterval) {
	            var axis = axisModel.axis;
	
	            var splitAreaModel = axisModel.getModel('splitArea');
	            var areaStyleModel = splitAreaModel.getModel('areaStyle');
	            var areaColors = areaStyleModel.get('color');
	
	            var gridRect = gridModel.coordinateSystem.getRect();
	
	            var ticksCoords = axis.getTicksCoords(
	                // splitAreaModel.get('alignWithLabel')
	            );
	            var ticks = axis.scale.getTicks();
	
	            var prevX = axis.toGlobalCoord(ticksCoords[0]);
	            var prevY = axis.toGlobalCoord(ticksCoords[0]);
	
	            var count = 0;
	
	            var areaInterval = getInterval(splitAreaModel, labelInterval);
	
	            var areaStyle = areaStyleModel.getAreaStyle();
	            areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];
	
	            for (var i = 1; i < ticksCoords.length; i++) {
	                if (ifIgnoreOnTick(axis, i, areaInterval)) {
	                    continue;
	                }
	
	                var tickCoord = axis.toGlobalCoord(ticksCoords[i]);
	
	                var x;
	                var y;
	                var width;
	                var height;
	                if (axis.isHorizontal()) {
	                    x = prevX;
	                    y = gridRect.y;
	                    width = tickCoord - x;
	                    height = gridRect.height;
	                }
	                else {
	                    x = gridRect.x;
	                    y = prevY;
	                    width = gridRect.width;
	                    height = tickCoord - y;
	                }
	
	                var colorIndex = (count++) % areaColors.length;
	                this._axisGroup.add(new graphic.Rect({
	                    anid: 'area_' + ticks[i],
	
	                    shape: {
	                        x: x,
	                        y: y,
	                        width: width,
	                        height: height
	                    },
	                    style: zrUtil.defaults({
	                        fill: areaColors[colorIndex]
	                    }, areaStyle),
	                    silent: true
	                }));
	
	                prevX = x + width;
	                prevY = y + height;
	            }
	        }
	    });
	
	    AxisView.extend({
	        type: 'xAxis'
	    });
	    AxisView.extend({
	        type: 'yAxis'
	    });
	
	    /**
	     * @inner
	     */
	    function layoutAxis(gridModel, axisModel) {
	        var grid = gridModel.coordinateSystem;
	        var axis = axisModel.axis;
	        var layout = {};
	
	        var rawAxisPosition = axis.position;
	        var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;
	        var axisDim = axis.dim;
	
	        // [left, right, top, bottom]
	        var rect = grid.getRect();
	        var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];
	
	        var axisOffset = axisModel.get('offset') || 0;
	
	        var posMap = {
	            x: { top: rectBound[2] - axisOffset, bottom: rectBound[3] + axisOffset },
	            y: { left: rectBound[0] - axisOffset, right: rectBound[1] + axisOffset }
	        };
	
	        posMap.x.onZero = Math.max(Math.min(getZero('y'), posMap.x.bottom), posMap.x.top);
	        posMap.y.onZero = Math.max(Math.min(getZero('x'), posMap.y.right), posMap.y.left);
	
	        function getZero(dim, val) {
	            var theAxis = grid.getAxis(dim);
	            return theAxis.toGlobalCoord(theAxis.dataToCoord(0));
	        }
	
	        // Axis position
	        layout.position = [
	            axisDim === 'y' ? posMap.y[axisPosition] : rectBound[0],
	            axisDim === 'x' ? posMap.x[axisPosition] : rectBound[3]
	        ];
	
	        // Axis rotation
	        layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1);
	
	        // Tick and label direction, x y is axisDim
	        var dirMap = {top: -1, bottom: 1, left: -1, right: 1};
	
	        layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];
	        if (axis.onZero) {
	            layout.labelOffset = posMap[axisDim][rawAxisPosition] - posMap[axisDim].onZero;
	        }
	
	        if (axisModel.getModel('axisTick').get('inside')) {
	            layout.tickDirection = -layout.tickDirection;
	        }
	        if (axisModel.getModel('axisLabel').get('inside')) {
	            layout.labelDirection = -layout.labelDirection;
	        }
	
	        // Special label rotation
	        var labelRotation = axisModel.getModel('axisLabel').get('rotate');
	        layout.labelRotation = axisPosition === 'top' ? -labelRotation : labelRotation;
	
	        // label interval when auto mode.
	        layout.labelInterval = axis.getLabelInterval();
	
	        // Over splitLine and splitArea
	        layout.z2 = 1;
	
	        return layout;
	    }
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var zrUtil = __webpack_require__(8);
	    var formatUtil = __webpack_require__(10);
	    var graphic = __webpack_require__(47);
	    var Model = __webpack_require__(16);
	    var numberUtil = __webpack_require__(11);
	    var remRadian = numberUtil.remRadian;
	    var isRadianAroundZero = numberUtil.isRadianAroundZero;
	    var vec2 = __webpack_require__(14);
	    var v2ApplyTransform = vec2.applyTransform;
	    var retrieve = zrUtil.retrieve;
	
	    var PI = Math.PI;
	
	    function makeAxisEventDataBase(axisModel) {
	        var eventData = {
	            componentType: axisModel.mainType
	        };
	        eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;
	        return eventData;
	    }
	
	    /**
	     * A final axis is translated and rotated from a "standard axis".
	     * So opt.position and opt.rotation is required.
	     *
	     * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],
	     * for example: (0, 0) ------------> (0, 50)
	     *
	     * nameDirection or tickDirection or labelDirection is 1 means tick
	     * or label is below the standard axis, whereas is -1 means above
	     * the standard axis. labelOffset means offset between label and axis,
	     * which is useful when 'onZero', where axisLabel is in the grid and
	     * label in outside grid.
	     *
	     * Tips: like always,
	     * positive rotation represents anticlockwise, and negative rotation
	     * represents clockwise.
	     * The direction of position coordinate is the same as the direction
	     * of screen coordinate.
	     *
	     * Do not need to consider axis 'inverse', which is auto processed by
	     * axis extent.
	     *
	     * @param {module:zrender/container/Group} group
	     * @param {Object} axisModel
	     * @param {Object} opt Standard axis parameters.
	     * @param {Array.<number>} opt.position [x, y]
	     * @param {number} opt.rotation by radian
	     * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle'.
	     * @param {number} [opt.tickDirection=1] 1 or -1
	     * @param {number} [opt.labelDirection=1] 1 or -1
	     * @param {number} [opt.labelOffset=0] Usefull when onZero.
	     * @param {string} [opt.axisLabelShow] default get from axisModel.
	     * @param {string} [opt.axisName] default get from axisModel.
	     * @param {number} [opt.axisNameAvailableWidth]
	     * @param {number} [opt.labelRotation] by degree, default get from axisModel.
	     * @param {number} [opt.labelInterval] Default label interval when label
	     *                                     interval from model is null or 'auto'.
	     * @param {number} [opt.strokeContainThreshold] Default label interval when label
	     */
	    var AxisBuilder = function (axisModel, opt) {
	
	        /**
	         * @readOnly
	         */
	        this.opt = opt;
	
	        /**
	         * @readOnly
	         */
	        this.axisModel = axisModel;
	
	        // Default value
	        zrUtil.defaults(
	            opt,
	            {
	                labelOffset: 0,
	                nameDirection: 1,
	                tickDirection: 1,
	                labelDirection: 1,
	                silent: true
	            }
	        );
	
	        /**
	         * @readOnly
	         */
	        this.group = new graphic.Group();
	
	        // FIXME Not use a seperate text group?
	        var dumbGroup = new graphic.Group({
	            position: opt.position.slice(),
	            rotation: opt.rotation
	        });
	
	        // this.group.add(dumbGroup);
	        // this._dumbGroup = dumbGroup;
	
	        dumbGroup.updateTransform();
	        this._transform = dumbGroup.transform;
	
	        this._dumbGroup = dumbGroup;
	    };
	
	    AxisBuilder.prototype = {
	
	        constructor: AxisBuilder,
	
	        hasBuilder: function (name) {
	            return !!builders[name];
	        },
	
	        add: function (name) {
	            builders[name].call(this);
	        },
	
	        getGroup: function () {
	            return this.group;
	        }
	
	    };
	
	    var builders = {
	
	        /**
	         * @private
	         */
	        axisLine: function () {
	            var opt = this.opt;
	            var axisModel = this.axisModel;
	
	            if (!axisModel.get('axisLine.show')) {
	                return;
	            }
	
	            var extent = this.axisModel.axis.getExtent();
	
	            var matrix = this._transform;
	            var pt1 = [extent[0], 0];
	            var pt2 = [extent[1], 0];
	            if (matrix) {
	                v2ApplyTransform(pt1, pt1, matrix);
	                v2ApplyTransform(pt2, pt2, matrix);
	            }
	
	            this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({
	
	                // Id for animation
	                anid: 'line',
	
	                shape: {
	                    x1: pt1[0],
	                    y1: pt1[1],
	                    x2: pt2[0],
	                    y2: pt2[1]
	                },
	                style: zrUtil.extend(
	                    {lineCap: 'round'},
	                    axisModel.getModel('axisLine.lineStyle').getLineStyle()
	                ),
	                strokeContainThreshold: opt.strokeContainThreshold || 5,
	                silent: true,
	                z2: 1
	            })));
	        },
	
	        /**
	         * @private
	         */
	        axisTick: function () {
	            var axisModel = this.axisModel;
	
	            if (!axisModel.get('axisTick.show')) {
	                return;
	            }
	
	            var axis = axisModel.axis;
	            var tickModel = axisModel.getModel('axisTick');
	            var opt = this.opt;
	
	            var lineStyleModel = tickModel.getModel('lineStyle');
	            var tickLen = tickModel.get('length');
	
	            var tickInterval = getInterval(tickModel, opt.labelInterval);
	            var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel'));
	            var ticks = axis.scale.getTicks();
	
	            var pt1 = [];
	            var pt2 = [];
	            var matrix = this._transform;
	
	            for (var i = 0; i < ticksCoords.length; i++) {
	                // Only ordinal scale support tick interval
	                if (ifIgnoreOnTick(axis, i, tickInterval)) {
	                     continue;
	                }
	
	                var tickCoord = ticksCoords[i];
	
	                pt1[0] = tickCoord;
	                pt1[1] = 0;
	                pt2[0] = tickCoord;
	                pt2[1] = opt.tickDirection * tickLen;
	
	                if (matrix) {
	                    v2ApplyTransform(pt1, pt1, matrix);
	                    v2ApplyTransform(pt2, pt2, matrix);
	                }
	                // Tick line, Not use group transform to have better line draw
	                this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({
	
	                    // Id for animation
	                    anid: 'tick_' + ticks[i],
	
	                    shape: {
	                        x1: pt1[0],
	                        y1: pt1[1],
	                        x2: pt2[0],
	                        y2: pt2[1]
	                    },
	                    style: zrUtil.defaults(
	                        lineStyleModel.getLineStyle(),
	                        {
	                            stroke: axisModel.get('axisLine.lineStyle.color')
	                        }
	                    ),
	                    z2: 2,
	                    silent: true
	                })));
	            }
	        },
	
	        /**
	         * @param {module:echarts/coord/cartesian/AxisModel} axisModel
	         * @param {module:echarts/coord/cartesian/GridModel} gridModel
	         * @private
	         */
	        axisLabel: function () {
	            var opt = this.opt;
	            var axisModel = this.axisModel;
	            var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));
	
	            if (!show) {
	                return;
	            }
	
	            var axis = axisModel.axis;
	            var labelModel = axisModel.getModel('axisLabel');
	            var textStyleModel = labelModel.getModel('textStyle');
	            var labelMargin = labelModel.get('margin');
	            var ticks = axis.scale.getTicks();
	            var labels = axisModel.getFormattedLabels();
	
	            // Special label rotate.
	            var labelRotation = retrieve(opt.labelRotation, labelModel.get('rotate')) || 0;
	            // To radian.
	            labelRotation = labelRotation * PI / 180;
	
	            var labelLayout = innerTextLayout(opt, labelRotation, opt.labelDirection);
	            var categoryData = axisModel.get('data');
	
	            var textEls = [];
	            var silent = isSilent(axisModel);
	            var triggerEvent = axisModel.get('triggerEvent');
	
	            for (var i = 0; i < ticks.length; i++) {
	                if (ifIgnoreOnTick(axis, i, opt.labelInterval)) {
	                     continue;
	                }
	
	                var itemTextStyleModel = textStyleModel;
	                if (categoryData && categoryData[i] && categoryData[i].textStyle) {
	                    itemTextStyleModel = new Model(
	                        categoryData[i].textStyle, textStyleModel, axisModel.ecModel
	                    );
	                }
	                var textColor = itemTextStyleModel.getTextColor()
	                    || axisModel.get('axisLine.lineStyle.color');
	
	                var tickCoord = axis.dataToCoord(ticks[i]);
	                var pos = [
	                    tickCoord,
	                    opt.labelOffset + opt.labelDirection * labelMargin
	                ];
	                var labelBeforeFormat = axis.scale.getLabel(ticks[i]);
	
	                var textEl = new graphic.Text({
	
	                    // Id for animation
	                    anid: 'label_' + ticks[i],
	
	                    style: {
	                        text: labels[i],
	                        textAlign: itemTextStyleModel.get('align', true) || labelLayout.textAlign,
	                        textVerticalAlign: itemTextStyleModel.get('baseline', true) || labelLayout.verticalAlign,
	                        textFont: itemTextStyleModel.getFont(),
	                        fill: typeof textColor === 'function' ? textColor(labelBeforeFormat) : textColor
	                    },
	                    position: pos,
	                    rotation: labelLayout.rotation,
	                    silent: silent,
	                    z2: 10
	                });
	
	                // Pack data for mouse event
	                if (triggerEvent) {
	                    textEl.eventData = makeAxisEventDataBase(axisModel);
	                    textEl.eventData.targetType = 'axisLabel';
	                    textEl.eventData.value = labelBeforeFormat;
	                }
	
	
	                // FIXME
	                this._dumbGroup.add(textEl);
	                textEl.updateTransform();
	
	                textEls.push(textEl);
	                this.group.add(textEl);
	
	                textEl.decomposeTransform();
	            }
	
	            function isTwoLabelOverlapped(current, next) {
	                var firstRect = current && current.getBoundingRect().clone();
	                var nextRect = next && next.getBoundingRect().clone();
	                if (firstRect && nextRect) {
	                    firstRect.applyTransform(current.getLocalTransform());
	                    nextRect.applyTransform(next.getLocalTransform());
	                    return firstRect.intersect(nextRect);
	                }
	            }
	            if (axis.type !== 'category') {
	                // If min or max are user set, we need to check
	                // If the tick on min(max) are overlap on their neighbour tick
	                // If they are overlapped, we need to hide the min(max) tick label
	                if (axisModel.getMin ? axisModel.getMin() : axisModel.get('min')) {
	                    var firstLabel = textEls[0];
	                    var nextLabel = textEls[1];
	                    if (isTwoLabelOverlapped(firstLabel, nextLabel)) {
	                        firstLabel.ignore = true;
	                    }
	                }
	                if (axisModel.getMax ? axisModel.getMax() : axisModel.get('max')) {
	                    var lastLabel = textEls[textEls.length - 1];
	                    var prevLabel = textEls[textEls.length - 2];
	                    if (isTwoLabelOverlapped(prevLabel, lastLabel)) {
	                        lastLabel.ignore = true;
	                    }
	                }
	            }
	        },
	
	        /**
	         * @private
	         */
	        axisName: function () {
	            var opt = this.opt;
	            var axisModel = this.axisModel;
	            var name = retrieve(opt.axisName, axisModel.get('name'));
	
	            if (!name) {
	                return;
	            }
	
	            var nameLocation = axisModel.get('nameLocation');
	            var nameDirection = opt.nameDirection;
	            var textStyleModel = axisModel.getModel('nameTextStyle');
	            var gap = axisModel.get('nameGap') || 0;
	
	            var extent = this.axisModel.axis.getExtent();
	            var gapSignal = extent[0] > extent[1] ? -1 : 1;
	            var pos = [
	                nameLocation === 'start'
	                    ? extent[0] - gapSignal * gap
	                    : nameLocation === 'end'
	                    ? extent[1] + gapSignal * gap
	                    : (extent[0] + extent[1]) / 2, // 'middle'
	                // Reuse labelOffset.
	                nameLocation === 'middle' ? opt.labelOffset + nameDirection * gap : 0
	            ];
	
	            var labelLayout;
	
	            var nameRotation = axisModel.get('nameRotate');
	            if (nameRotation != null) {
	                nameRotation = nameRotation * PI / 180; // To radian.
	            }
	
	            var axisNameAvailableWidth;
	
	            if (nameLocation === 'middle') {
	                labelLayout = innerTextLayout(
	                    opt,
	                    nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.
	                    nameDirection
	                );
	            }
	            else {
	                labelLayout = endTextLayout(
	                    opt, nameLocation, nameRotation || 0, extent
	                );
	
	                axisNameAvailableWidth = opt.axisNameAvailableWidth;
	                if (axisNameAvailableWidth != null) {
	                    axisNameAvailableWidth = Math.abs(
	                        axisNameAvailableWidth / Math.sin(labelLayout.rotation)
	                    );
	                    !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);
	                }
	            }
	
	            var textFont = textStyleModel.getFont();
	
	            var truncateOpt = axisModel.get('nameTruncate', true) || {};
	            var ellipsis = truncateOpt.ellipsis;
	            var maxWidth = retrieve(truncateOpt.maxWidth, axisNameAvailableWidth);
	            var truncatedText = (ellipsis != null && maxWidth != null)
	                ? formatUtil.truncateText(
	                    name, maxWidth, textFont, ellipsis,
	                    {minChar: 2, placeholder: truncateOpt.placeholder}
	                )
	                : name;
	
	            var tooltipOpt = axisModel.get('tooltip', true);
	
	            var mainType = axisModel.mainType;
	            var formatterParams = {
	                componentType: mainType,
	                name: name,
	                $vars: ['name']
	            };
	            formatterParams[mainType + 'Index'] = axisModel.componentIndex;
	
	            var textEl = new graphic.Text({
	
	                // Id for animation
	                anid: 'name',
	
	                __fullText: name,
	                __truncatedText: truncatedText,
	
	                style: {
	                    text: truncatedText,
	                    textFont: textFont,
	                    fill: textStyleModel.getTextColor()
	                        || axisModel.get('axisLine.lineStyle.color'),
	                    textAlign: labelLayout.textAlign,
	                    textVerticalAlign: labelLayout.verticalAlign
	                },
	                position: pos,
	                rotation: labelLayout.rotation,
	                silent: isSilent(axisModel),
	                z2: 1,
	                tooltip: (tooltipOpt && tooltipOpt.show)
	                    ? zrUtil.extend({
	                        content: name,
	                        formatter: function () {
	                            return name;
	                        },
	                        formatterParams: formatterParams
	                    }, tooltipOpt)
	                    : null
	            });
	
	            if (axisModel.get('triggerEvent')) {
	                textEl.eventData = makeAxisEventDataBase(axisModel);
	                textEl.eventData.targetType = 'axisName';
	                textEl.eventData.name = name;
	            }
	
	            // FIXME
	            this._dumbGroup.add(textEl);
	            textEl.updateTransform();
	
	            this.group.add(textEl);
	
	            textEl.decomposeTransform();
	        }
	
	    };
	
	    /**
	     * @inner
	     */
	    function innerTextLayout(opt, textRotation, direction) {
	        var rotationDiff = remRadian(textRotation - opt.rotation);
	        var textAlign;
	        var verticalAlign;
	
	        if (isRadianAroundZero(rotationDiff)) { // Label is parallel with axis line.
	            verticalAlign = direction > 0 ? 'top' : 'bottom';
	            textAlign = 'center';
	        }
	        else if (isRadianAroundZero(rotationDiff - PI)) { // Label is inverse parallel with axis line.
	            verticalAlign = direction > 0 ? 'bottom' : 'top';
	            textAlign = 'center';
	        }
	        else {
	            verticalAlign = 'middle';
	
	            if (rotationDiff > 0 && rotationDiff < PI) {
	                textAlign = direction > 0 ? 'right' : 'left';
	            }
	            else {
	                textAlign = direction > 0 ? 'left' : 'right';
	            }
	        }
	
	        return {
	            rotation: rotationDiff,
	            textAlign: textAlign,
	            verticalAlign: verticalAlign
	        };
	    }
	
	    /**
	     * @inner
	     */
	    function endTextLayout(opt, textPosition, textRotate, extent) {
	        var rotationDiff = remRadian(textRotate - opt.rotation);
	        var textAlign;
	        var verticalAlign;
	        var inverse = extent[0] > extent[1];
	        var onLeft = (textPosition === 'start' && !inverse)
	            || (textPosition !== 'start' && inverse);
	
	        if (isRadianAroundZero(rotationDiff - PI / 2)) {
	            verticalAlign = onLeft ? 'bottom' : 'top';
	            textAlign = 'center';
	        }
	        else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {
	            verticalAlign = onLeft ? 'top' : 'bottom';
	            textAlign = 'center';
	        }
	        else {
	            verticalAlign = 'middle';
	            if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {
	                textAlign = onLeft ? 'left' : 'right';
	            }
	            else {
	                textAlign = onLeft ? 'right' : 'left';
	            }
	        }
	
	        return {
	            rotation: rotationDiff,
	            textAlign: textAlign,
	            verticalAlign: verticalAlign
	        };
	    }
	
	    /**
	     * @inner
	     */
	    function isSilent(axisModel) {
	        var tooltipOpt = axisModel.get('tooltip');
	        return axisModel.get('silent')
	            // Consider mouse cursor, add these restrictions.
	            || !(
	                axisModel.get('triggerEvent') || (tooltipOpt && tooltipOpt.show)
	            );
	    }
	
	    /**
	     * @static
	     */
	    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (axis, i, interval) {
	        var rawTick;
	        var scale = axis.scale;
	        return scale.type === 'ordinal'
	            && (
	                typeof interval === 'function'
	                    ? (
	                        rawTick = scale.getTicks()[i],
	                        !interval(rawTick, scale.getLabel(rawTick))
	                    )
	                    : i % (interval + 1)
	            );
	    };
	
	    /**
	     * @static
	     */
	    var getInterval = AxisBuilder.getInterval = function (model, labelInterval) {
	        var interval = model.get('interval');
	        if (interval == null || interval == 'auto') {
	            interval = labelInterval;
	        }
	        return interval;
	    };
	
	    return AxisBuilder;
	
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;// FIXME Better way to pack data in graphic element
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    __webpack_require__(132);
	
	    __webpack_require__(133);
	
	    // Show tip action
	    /**
	     * @action
	     * @property {string} type
	     * @property {number} seriesIndex
	     * @property {number} dataIndex
	     * @property {number} [x]
	     * @property {number} [y]
	     */
	    __webpack_require__(5).registerAction(
	        {
	            type: 'showTip',
	            event: 'showTip',
	            update: 'none'
	        },
	        // noop
	        function () {}
	    );
	    // Hide tip action
	    __webpack_require__(5).registerAction(
	        {
	            type: 'hideTip',
	            event: 'hideTip',
	            update: 'none'
	        },
	        // noop
	        function () {}
	    );
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    __webpack_require__(5).extendComponentModel({
	
	        type: 'tooltip',
	
	        defaultOption: {
	            zlevel: 0,
	
	            z: 8,
	
	            show: true,
	
	            // tooltip主体内容
	            showContent: true,
	
	            // 触发类型，默认数据触发，见下图，可选为：'item' ¦ 'axis'
	            trigger: 'item',
	
	            // 触发条件，支持 'click' | 'mousemove'
	            triggerOn: 'mousemove',
	
	            // 是否永远显示 content
	            alwaysShowContent: false,
	
	            // 位置 {Array} | {Function}
	            // position: null
	
	            // 内容格式器：{string}（Template） ¦ {Function}
	            // formatter: null
	
	            showDelay: 0,
	
	            // 隐藏延迟，单位ms
	            hideDelay: 100,
	
	            // 动画变换时间，单位s
	            transitionDuration: 0.4,
	
	            enterable: false,
	
	            // 提示背景颜色，默认为透明度为0.7的黑色
	            backgroundColor: 'rgba(50,50,50,0.7)',
	
	            // 提示边框颜色
	            borderColor: '#333',
	
	            // 提示边框圆角，单位px，默认为4
	            borderRadius: 4,
	
	            // 提示边框线宽，单位px，默认为0（无边框）
	            borderWidth: 0,
	
	            // 提示内边距，单位px，默认各方向内边距为5，
	            // 接受数组分别设定上右下左边距，同css
	            padding: 5,
	
	            // Extra css text
	            extraCssText: '',
	
	            // 坐标轴指示器，坐标轴触发有效
	            axisPointer: {
	                // 默认为直线
	                // 可选为：'line' | 'shadow' | 'cross'
	                type: 'line',
	
	                // type 为 line 的时候有效，指定 tooltip line 所在的轴，可选
	                // 可选 'x' | 'y' | 'angle' | 'radius' | 'auto'
	                // 默认 'auto'，会选择类型为 cateogry 的轴，对于双数值轴，笛卡尔坐标系会默认选择 x 轴
	                // 极坐标系会默认选择 angle 轴
	                axis: 'auto',
	
	                animation: true,
	                animationDurationUpdate: 200,
	                animationEasingUpdate: 'exponentialOut',
	
	                // 直线指示器样式设置
	                lineStyle: {
	                    color: '#555',
	                    width: 1,
	                    type: 'solid'
	                },
	
	                crossStyle: {
	                    color: '#555',
	                    width: 1,
	                    type: 'dashed',
	
	                    // TODO formatter
	                    textStyle: {}
	                },
	
	                // 阴影指示器样式设置
	                shadowStyle: {
	                    color: 'rgba(150,150,150,0.3)'
	                }
	            },
	            textStyle: {
	                color: '#fff',
	                fontSize: 14
	            }
	        }
	    });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var TooltipContent = __webpack_require__(134);
	    var graphic = __webpack_require__(47);
	    var zrUtil = __webpack_require__(8);
	    var formatUtil = __webpack_require__(10);
	    var numberUtil = __webpack_require__(11);
	    var parsePercent = numberUtil.parsePercent;
	    var env = __webpack_require__(6);
	    var Model = __webpack_require__(16);
	
	    function dataEqual(a, b) {
	        if (!a || !b) {
	            return false;
	        }
	        var round = numberUtil.round;
	        return round(a[0]) === round(b[0])
	            && round(a[1]) === round(b[1]);
	    }
	    /**
	     * @inner
	     */
	    function makeLineShape(x1, y1, x2, y2) {
	        return {
	            x1: x1,
	            y1: y1,
	            x2: x2,
	            y2: y2
	        };
	    }
	
	    /**
	     * @inner
	     */
	    function makeRectShape(x, y, width, height) {
	        return {
	            x: x,
	            y: y,
	            width: width,
	            height: height
	        };
	    }
	
	    /**
	     * @inner
	     */
	    function makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {
	        return {
	            cx: cx,
	            cy: cy,
	            r0: r0,
	            r: r,
	            startAngle: startAngle,
	            endAngle: endAngle,
	            clockwise: true
	        };
	    }
	
	    function refixTooltipPosition(x, y, el, viewWidth, viewHeight) {
	        var width = el.clientWidth;
	        var height = el.clientHeight;
	        var gap = 20;
	
	        if (x + width + gap > viewWidth) {
	            x -= width + gap;
	        }
	        else {
	            x += gap;
	        }
	        if (y + height + gap > viewHeight) {
	            y -= height + gap;
	        }
	        else {
	            y += gap;
	        }
	        return [x, y];
	    }
	
	    function calcTooltipPosition(position, rect, dom) {
	        var domWidth = dom.clientWidth;
	        var domHeight = dom.clientHeight;
	        var gap = 5;
	        var x = 0;
	        var y = 0;
	        var rectWidth = rect.width;
	        var rectHeight = rect.height;
	        switch (position) {
	            case 'inside':
	                x = rect.x + rectWidth / 2 - domWidth / 2;
	                y = rect.y + rectHeight / 2 - domHeight / 2;
	                break;
	            case 'top':
	                x = rect.x + rectWidth / 2 - domWidth / 2;
	                y = rect.y - domHeight - gap;
	                break;
	            case 'bottom':
	                x = rect.x + rectWidth / 2 - domWidth / 2;
	                y = rect.y + rectHeight + gap;
	                break;
	            case 'left':
	                x = rect.x - domWidth - gap;
	                y = rect.y + rectHeight / 2 - domHeight / 2;
	                break;
	            case 'right':
	                x = rect.x + rectWidth + gap;
	                y = rect.y + rectHeight / 2 - domHeight / 2;
	        }
	        return [x, y];
	    }
	
	    /**
	     * @param  {string|Function|Array.<number>} positionExpr
	     * @param  {number} x Mouse x
	     * @param  {number} y Mouse y
	     * @param  {module:echarts/component/tooltip/TooltipContent} content
	     * @param  {Object|<Array.<Object>} params
	     * @param  {module:zrender/Element} el target element
	     * @param  {module:echarts/ExtensionAPI} api
	     * @return {Array.<number>}
	     */
	    function updatePosition(positionExpr, x, y, content, params, el, api) {
	        var viewWidth = api.getWidth();
	        var viewHeight = api.getHeight();
	
	        var rect = el && el.getBoundingRect().clone();
	        el && rect.applyTransform(el.transform);
	        if (typeof positionExpr === 'function') {
	            // Callback of position can be an array or a string specify the position
	            positionExpr = positionExpr([x, y], params, content.el, rect);
	        }
	
	        if (zrUtil.isArray(positionExpr)) {
	            x = parsePercent(positionExpr[0], viewWidth);
	            y = parsePercent(positionExpr[1], viewHeight);
	        }
	        // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element
	        else if (typeof positionExpr === 'string' && el) {
	            var pos = calcTooltipPosition(
	                positionExpr, rect, content.el
	            );
	            x = pos[0];
	            y = pos[1];
	        }
	        else {
	            var pos = refixTooltipPosition(
	                x, y, content.el, viewWidth, viewHeight
	            );
	            x = pos[0];
	            y = pos[1];
	        }
	
	        content.moveTo(x, y);
	    }
	
	    function ifSeriesSupportAxisTrigger(seriesModel) {
	        var coordSys = seriesModel.coordinateSystem;
	        var trigger = seriesModel.get('tooltip.trigger', true);
	        // Ignore series use item tooltip trigger and series coordinate system is not cartesian or
	        return !(!coordSys
	            || (coordSys.type !== 'cartesian2d' && coordSys.type !== 'polar' && coordSys.type !== 'singleAxis')
	            || trigger === 'item');
	    }
	
	    __webpack_require__(5).extendComponentView({
	
	        type: 'tooltip',
	
	        _axisPointers: {},
	
	        init: function (ecModel, api) {
	            if (env.node) {
	                return;
	            }
	            var tooltipContent = new TooltipContent(api.getDom(), api);
	            this._tooltipContent = tooltipContent;
	
	            api.on('showTip', this._manuallyShowTip, this);
	            api.on('hideTip', this._manuallyHideTip, this);
	        },
	
	        render: function (tooltipModel, ecModel, api) {
	            if (env.node) {
	                return;
	            }
	
	            // Reset
	            this.group.removeAll();
	
	            /**
	             * @type {Object}
	             * @private
	             */
	            this._axisPointers = {};
	
	            /**
	             * @private
	             * @type {module:echarts/component/tooltip/TooltipModel}
	             */
	            this._tooltipModel = tooltipModel;
	
	            /**
	             * @private
	             * @type {module:echarts/model/Global}
	             */
	            this._ecModel = ecModel;
	
	            /**
	             * @private
	             * @type {module:echarts/ExtensionAPI}
	             */
	            this._api = api;
	
	            /**
	             * @type {Object}
	             * @private
	             */
	            this._lastHover = {
	                // data
	                // payloadBatch
	            };
	
	            var tooltipContent = this._tooltipContent;
	            tooltipContent.update();
	            tooltipContent.enterable = tooltipModel.get('enterable');
	            this._alwaysShowContent = tooltipModel.get('alwaysShowContent');
	
	            /**
	             * @type {Object.<string, Array>}
	             */
	            this._seriesGroupByAxis = this._prepareAxisTriggerData(
	                tooltipModel, ecModel
	            );
	
	            var crossText = this._crossText;
	            if (crossText) {
	                this.group.add(crossText);
	            }
	
	            // Try to keep the tooltip show when refreshing
	            if (this._lastX != null && this._lastY != null) {
	                var self = this;
	                clearTimeout(this._refreshUpdateTimeout);
	                this._refreshUpdateTimeout = setTimeout(function () {
	                    // Show tip next tick after other charts are rendered
	                    // In case highlight action has wrong result
	                    // FIXME
	                    self._manuallyShowTip({
	                        x: self._lastX,
	                        y: self._lastY
	                    });
	                });
	            }
	
	            var zr = this._api.getZr();
	            zr.off('click', this._tryShow);
	            zr.off('mousemove', this._mousemove);
	            zr.off('mouseout', this._hide);
	            zr.off('globalout', this._hide);
	            if (tooltipModel.get('triggerOn') === 'click') {
	                zr.on('click', this._tryShow, this);
	            }
	            else {
	                zr.on('mousemove', this._mousemove, this);
	                zr.on('mouseout', this._hide, this);
	                zr.on('globalout', this._hide, this);
	            }
	        },
	
	        _mousemove: function (e) {
	            var showDelay = this._tooltipModel.get('showDelay');
	            var self = this;
	            clearTimeout(this._showTimeout);
	            if (showDelay > 0) {
	                this._showTimeout = setTimeout(function () {
	                    self._tryShow(e);
	                }, showDelay);
	            }
	            else {
	                this._tryShow(e);
	            }
	        },
	
	        /**
	         * Show tip manually by
	         *  dispatchAction({
	         *      type: 'showTip',
	         *      x: 10,
	         *      y: 10
	         *  });
	         * Or
	         *  dispatchAction({
	         *      type: 'showTip',
	         *      seriesIndex: 0,
	         *      dataIndex: 1
	         *  });
	         *
	         *  TODO Batch
	         */
	        _manuallyShowTip: function (event) {
	            // From self
	            if (event.from === this.uid) {
	                return;
	            }
	
	            var ecModel = this._ecModel;
	            var seriesIndex = event.seriesIndex;
	            var dataIndex = event.dataIndex;
	            var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
	            var api = this._api;
	
	            if (event.x == null || event.y == null) {
	                if (!seriesModel) {
	                    // Find the first series can use axis trigger
	                    ecModel.eachSeries(function (_series) {
	                        if (ifSeriesSupportAxisTrigger(_series) && !seriesModel) {
	                            seriesModel = _series;
	                        }
	                    });
	                }
	                if (seriesModel) {
	                    var data = seriesModel.getData();
	                    if (dataIndex == null) {
	                        dataIndex = data.indexOfName(event.name);
	                    }
	                    var el = data.getItemGraphicEl(dataIndex);
	                    var cx, cy;
	                    // Try to get the point in coordinate system
	                    var coordSys = seriesModel.coordinateSystem;
	                    if (coordSys && coordSys.dataToPoint) {
	                        var point = coordSys.dataToPoint(
	                            data.getValues(
	                                zrUtil.map(coordSys.dimensions, function (dim) {
	                                    return seriesModel.coordDimToDataDim(dim)[0];
	                                }), dataIndex, true
	                            )
	                        );
	                        cx = point && point[0];
	                        cy = point && point[1];
	                    }
	                    else if (el) {
	                        // Use graphic bounding rect
	                        var rect = el.getBoundingRect().clone();
	                        rect.applyTransform(el.transform);
	                        cx = rect.x + rect.width / 2;
	                        cy = rect.y + rect.height / 2;
	                    }
	                    if (cx != null && cy != null) {
	                        this._tryShow({
	                            offsetX: cx,
	                            offsetY: cy,
	                            target: el,
	                            event: {}
	                        });
	                    }
	                }
	            }
	            else {
	                var el = api.getZr().handler.findHover(event.x, event.y);
	                this._tryShow({
	                    offsetX: event.x,
	                    offsetY: event.y,
	                    target: el,
	                    event: {}
	                });
	            }
	        },
	
	        _manuallyHideTip: function (e) {
	            if (e.from === this.uid) {
	                return;
	            }
	
	            this._hide();
	        },
	
	        _prepareAxisTriggerData: function (tooltipModel, ecModel) {
	            // Prepare data for axis trigger
	            var seriesGroupByAxis = {};
	            ecModel.eachSeries(function (seriesModel) {
	                if (ifSeriesSupportAxisTrigger(seriesModel)) {
	                    var coordSys = seriesModel.coordinateSystem;
	                    var baseAxis;
	                    var key;
	
	                    // Only cartesian2d, polar and single support axis trigger
	                    if (coordSys.type === 'cartesian2d') {
	                        // FIXME `axisPointer.axis` is not baseAxis
	                        baseAxis = coordSys.getBaseAxis();
	                        key = baseAxis.dim + baseAxis.index;
	                    }
	                    else if (coordSys.type === 'singleAxis') {
	                        baseAxis = coordSys.getAxis();
	                        key = baseAxis.dim + baseAxis.type;
	                    }
	                    else {
	                        baseAxis = coordSys.getBaseAxis();
	                        key = baseAxis.dim + coordSys.name;
	                    }
	
	                    seriesGroupByAxis[key] = seriesGroupByAxis[key] || {
	                        coordSys: [],
	                        series: []
	                    };
	                    seriesGroupByAxis[key].coordSys.push(coordSys);
	                    seriesGroupByAxis[key].series.push(seriesModel);
	                }
	            }, this);
	
	            return seriesGroupByAxis;
	        },
	
	        /**
	         * mousemove handler
	         * @param {Object} e
	         * @private
	         */
	        _tryShow: function (e) {
	            var el = e.target;
	            var tooltipModel = this._tooltipModel;
	            var globalTrigger = tooltipModel.get('trigger');
	            var ecModel = this._ecModel;
	            var api = this._api;
	
	            if (!tooltipModel) {
	                return;
	            }
	
	            // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed
	            this._lastX = e.offsetX;
	            this._lastY = e.offsetY;
	
	            // Always show item tooltip if mouse is on the element with dataIndex
	            if (el && el.dataIndex != null) {
	                // Use dataModel in element if possible
	                // Used when mouseover on a element like markPoint or edge
	                // In which case, the data is not main data in series.
	                var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);
	                var dataIndex = el.dataIndex;
	                var itemModel = dataModel.getData().getItemModel(dataIndex);
	                // Series or single data may use item trigger when global is axis trigger
	                if ((itemModel.get('tooltip.trigger') || globalTrigger) === 'axis') {
	                    this._showAxisTooltip(tooltipModel, ecModel, e);
	                }
	                else {
	                    // Reset ticket
	                    this._ticket = '';
	                    // If either single data or series use item trigger
	                    this._hideAxisPointer();
	                    // Reset last hover and dispatch downplay action
	                    this._resetLastHover();
	
	                    this._showItemTooltipContent(dataModel, dataIndex, el.dataType, e);
	                }
	
	                api.dispatchAction({
	                    type: 'showTip',
	                    from: this.uid,
	                    dataIndex: el.dataIndex,
	                    seriesIndex: el.seriesIndex
	                });
	            }
	            // Tooltip provided directly. Like legend
	            else if (el && el.tooltip) {
	                var tooltipOpt = el.tooltip;
	                if (typeof tooltipOpt === 'string') {
	                    var content = tooltipOpt;
	                    tooltipOpt = {
	                        content: content,
	                        // Fixed formatter
	                        formatter: content
	                    };
	                }
	                var subTooltipModel = new Model(tooltipOpt, tooltipModel);
	                var defaultHtml = subTooltipModel.get('content');
	                var asyncTicket = Math.random();
	                this._showTooltipContent(
	                    // TODO params
	                    subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {},
	                    asyncTicket, e.offsetX, e.offsetY, el, api
	                );
	            }
	            else {
	                if (globalTrigger === 'item') {
	                    this._hide();
	                }
	                else {
	                    // Try show axis tooltip
	                    this._showAxisTooltip(tooltipModel, ecModel, e);
	                }
	
	                // Action of cross pointer
	                // other pointer types will trigger action in _dispatchAndShowSeriesTooltipContent method
	                if (tooltipModel.get('axisPointer.type') === 'cross') {
	                    api.dispatchAction({
	                        type: 'showTip',
	                        from: this.uid,
	                        x: e.offsetX,
	                        y: e.offsetY
	                    });
	                }
	            }
	        },
	
	        /**
	         * Show tooltip on axis
	         * @param {module:echarts/component/tooltip/TooltipModel} tooltipModel
	         * @param {module:echarts/model/Global} ecModel
	         * @param {Object} e
	         * @private
	         */
	        _showAxisTooltip: function (tooltipModel, ecModel, e) {
	            var axisPointerModel = tooltipModel.getModel('axisPointer');
	            var axisPointerType = axisPointerModel.get('type');
	
	            if (axisPointerType === 'cross') {
	                var el = e.target;
	                if (el && el.dataIndex != null) {
	                    var seriesModel = ecModel.getSeriesByIndex(el.seriesIndex);
	                    var dataIndex = el.dataIndex;
	                    this._showItemTooltipContent(seriesModel, dataIndex, el.dataType, e);
	                }
	            }
	
	            this._showAxisPointer();
	            var allNotShow = true;
	            zrUtil.each(this._seriesGroupByAxis, function (seriesCoordSysSameAxis) {
	                // Try show the axis pointer
	                var allCoordSys = seriesCoordSysSameAxis.coordSys;
	                var coordSys = allCoordSys[0];
	
	                // If mouse position is not in the grid or polar
	                var point = [e.offsetX, e.offsetY];
	
	                if (!coordSys.containPoint(point)) {
	                    // Hide axis pointer
	                    this._hideAxisPointer(coordSys.name);
	                    return;
	                }
	
	                allNotShow = false;
	                // Make sure point is discrete on cateogry axis
	                var dimensions = coordSys.dimensions;
	                var value = coordSys.pointToData(point, true);
	                point = coordSys.dataToPoint(value);
	                var baseAxis = coordSys.getBaseAxis();
	                var axisType = axisPointerModel.get('axis');
	                if (axisType === 'auto') {
	                    axisType = baseAxis.dim;
	                }
	
	                var contentNotChange = false;
	                var lastHover = this._lastHover;
	                if (axisPointerType === 'cross') {
	                    // If hover data not changed
	                    // Possible when two axes are all category
	                    if (dataEqual(lastHover.data, value)) {
	                        contentNotChange = true;
	                    }
	                    lastHover.data = value;
	                }
	                else {
	                    var valIndex = zrUtil.indexOf(dimensions, axisType);
	
	                    // If hover data not changed on the axis dimension
	                    if (lastHover.data === value[valIndex]) {
	                        contentNotChange = true;
	                    }
	                    lastHover.data = value[valIndex];
	                }
	
	                if (coordSys.type === 'cartesian2d' && !contentNotChange) {
	                    this._showCartesianPointer(
	                        axisPointerModel, coordSys, axisType, point
	                    );
	                }
	                else if (coordSys.type === 'polar' && !contentNotChange) {
	                    this._showPolarPointer(
	                        axisPointerModel, coordSys, axisType, point
	                    );
	                }
	                else if (coordSys.type === 'singleAxis' && !contentNotChange) {
	                    this._showSinglePointer(
	                        axisPointerModel, coordSys, axisType, point
	                    );
	                }
	
	                if (axisPointerType !== 'cross') {
	                    this._dispatchAndShowSeriesTooltipContent(
	                        coordSys, seriesCoordSysSameAxis.series, point, value, contentNotChange
	                    );
	                }
	            }, this);
	
	            if (!this._tooltipModel.get('show')) {
	                this._hideAxisPointer();
	            }
	
	            if (allNotShow) {
	                this._hide();
	            }
	        },
	
	        /**
	         * Show tooltip on axis of cartesian coordinate
	         * @param {module:echarts/model/Model} axisPointerModel
	         * @param {module:echarts/coord/cartesian/Cartesian2D} cartesians
	         * @param {string} axisType
	         * @param {Array.<number>} point
	         * @private
	         */
	        _showCartesianPointer: function (axisPointerModel, cartesian, axisType, point) {
	            var self = this;
	
	            var axisPointerType = axisPointerModel.get('type');
	            var baseAxis = cartesian.getBaseAxis();
	            var moveAnimation = axisPointerType !== 'cross'
	                && baseAxis.type === 'category'
	                && baseAxis.getBandWidth() > 20;
	
	            if (axisPointerType === 'cross') {
	                moveGridLine('x', point, cartesian.getAxis('y').getGlobalExtent());
	                moveGridLine('y', point, cartesian.getAxis('x').getGlobalExtent());
	
	                this._updateCrossText(cartesian, point, axisPointerModel);
	            }
	            else {
	                var otherAxis = cartesian.getAxis(axisType === 'x' ? 'y' : 'x');
	                var otherExtent = otherAxis.getGlobalExtent();
	
	                if (cartesian.type === 'cartesian2d') {
	                    (axisPointerType === 'line' ? moveGridLine : moveGridShadow)(
	                        axisType, point, otherExtent
	                    );
	                }
	            }
	
	            /**
	             * @inner
	             */
	            function moveGridLine(axisType, point, otherExtent) {
	                var targetShape = axisType === 'x'
	                    ? makeLineShape(point[0], otherExtent[0], point[0], otherExtent[1])
	                    : makeLineShape(otherExtent[0], point[1], otherExtent[1], point[1]);
	
	                var pointerEl = self._getPointerElement(
	                    cartesian, axisPointerModel, axisType, targetShape
	                );
	                graphic.subPixelOptimizeLine({
	                    shape: targetShape,
	                    style: pointerEl.style
	                });
	
	                moveAnimation
	                    ? graphic.updateProps(pointerEl, {
	                        shape: targetShape
	                    }, axisPointerModel)
	                    :  pointerEl.attr({
	                        shape: targetShape
	                    });
	            }
	
	            /**
	             * @inner
	             */
	            function moveGridShadow(axisType, point, otherExtent) {
	                var axis = cartesian.getAxis(axisType);
	                var bandWidth = axis.getBandWidth();
	                var span = otherExtent[1] - otherExtent[0];
	                var targetShape = axisType === 'x'
	                    ? makeRectShape(point[0] - bandWidth / 2, otherExtent[0], bandWidth, span)
	                    : makeRectShape(otherExtent[0], point[1] - bandWidth / 2, span, bandWidth);
	
	                var pointerEl = self._getPointerElement(
	                    cartesian, axisPointerModel, axisType, targetShape
	                );
	                moveAnimation
	                    ? graphic.updateProps(pointerEl, {
	                        shape: targetShape
	                    }, axisPointerModel)
	                    :  pointerEl.attr({
	                        shape: targetShape
	                    });
	            }
	        },
	
	        _showSinglePointer: function (axisPointerModel, single, axisType, point) {
	            var self = this;
	            var axisPointerType = axisPointerModel.get('type');
	            var moveAnimation = axisPointerType !== 'cross' && single.getBaseAxis().type === 'category';
	            var rect = single.getRect();
	            var otherExtent = [rect.y, rect.y + rect.height];
	
	            moveSingleLine(axisType, point, otherExtent);
	
	            /**
	             * @inner
	             */
	            function moveSingleLine(axisType, point, otherExtent) {
	                var axis = single.getAxis();
	                var orient = axis.orient;
	
	                var targetShape = orient === 'horizontal'
	                    ? makeLineShape(point[0], otherExtent[0], point[0], otherExtent[1])
	                    : makeLineShape(otherExtent[0], point[1], otherExtent[1], point[1]);
	
	                var pointerEl = self._getPointerElement(
	                    single, axisPointerModel, axisType, targetShape
	                );
	                moveAnimation
	                    ? graphic.updateProps(pointerEl, {
	                        shape: targetShape
	                    }, axisPointerModel)
	                    :  pointerEl.attr({
	                        shape: targetShape
	                    });
	            }
	
	        },
	
	        /**
	         * Show tooltip on axis of polar coordinate
	         * @param {module:echarts/model/Model} axisPointerModel
	         * @param {Array.<module:echarts/coord/polar/Polar>} polar
	         * @param {string} axisType
	         * @param {Array.<number>} point
	         */
	        _showPolarPointer: function (axisPointerModel, polar, axisType, point) {
	            var self = this;
	
	            var axisPointerType = axisPointerModel.get('type');
	
	            var angleAxis = polar.getAngleAxis();
	            var radiusAxis = polar.getRadiusAxis();
	
	            var moveAnimation = axisPointerType !== 'cross'
	                && polar.getBaseAxis().type === 'category';
	
	            if (axisPointerType === 'cross') {
	                movePolarLine('angle', point, radiusAxis.getExtent());
	                movePolarLine('radius', point, angleAxis.getExtent());
	
	                this._updateCrossText(polar, point, axisPointerModel);
	            }
	            else {
	                var otherAxis = polar.getAxis(axisType === 'radius' ? 'angle' : 'radius');
	                var otherExtent = otherAxis.getExtent();
	
	                (axisPointerType === 'line' ? movePolarLine : movePolarShadow)(
	                    axisType, point, otherExtent
	                );
	            }
	            /**
	             * @inner
	             */
	            function movePolarLine(axisType, point, otherExtent) {
	                var mouseCoord = polar.pointToCoord(point);
	
	                var targetShape;
	
	                if (axisType === 'angle') {
	                    var p1 = polar.coordToPoint([otherExtent[0], mouseCoord[1]]);
	                    var p2 = polar.coordToPoint([otherExtent[1], mouseCoord[1]]);
	                    targetShape = makeLineShape(p1[0], p1[1], p2[0], p2[1]);
	                }
	                else {
	                    targetShape = {
	                        cx: polar.cx,
	                        cy: polar.cy,
	                        r: mouseCoord[0]
	                    };
	                }
	
	                var pointerEl = self._getPointerElement(
	                    polar, axisPointerModel, axisType, targetShape
	                );
	
	                moveAnimation
	                    ? graphic.updateProps(pointerEl, {
	                        shape: targetShape
	                    }, axisPointerModel)
	                    :  pointerEl.attr({
	                        shape: targetShape
	                    });
	            }
	
	            /**
	             * @inner
	             */
	            function movePolarShadow(axisType, point, otherExtent) {
	                var axis = polar.getAxis(axisType);
	                var bandWidth = axis.getBandWidth();
	
	                var mouseCoord = polar.pointToCoord(point);
	
	                var targetShape;
	
	                var radian = Math.PI / 180;
	
	                if (axisType === 'angle') {
	                    targetShape = makeSectorShape(
	                        polar.cx, polar.cy,
	                        otherExtent[0], otherExtent[1],
	                        // In ECharts y is negative if angle is positive
	                        (-mouseCoord[1] - bandWidth / 2) * radian,
	                        (-mouseCoord[1] + bandWidth / 2) * radian
	                    );
	                }
	                else {
	                    targetShape = makeSectorShape(
	                        polar.cx, polar.cy,
	                        mouseCoord[0] - bandWidth / 2,
	                        mouseCoord[0] + bandWidth / 2,
	                        0, Math.PI * 2
	                    );
	                }
	
	                var pointerEl = self._getPointerElement(
	                    polar, axisPointerModel, axisType, targetShape
	                );
	                moveAnimation
	                    ? graphic.updateProps(pointerEl, {
	                        shape: targetShape
	                    }, axisPointerModel)
	                    :  pointerEl.attr({
	                        shape: targetShape
	                    });
	            }
	        },
	
	        _updateCrossText: function (coordSys, point, axisPointerModel) {
	            var crossStyleModel = axisPointerModel.getModel('crossStyle');
	            var textStyleModel = crossStyleModel.getModel('textStyle');
	
	            var tooltipModel = this._tooltipModel;
	
	            var text = this._crossText;
	            if (!text) {
	                text = this._crossText = new graphic.Text({
	                    style: {
	                        textAlign: 'left',
	                        textVerticalAlign: 'bottom'
	                    }
	                });
	                this.group.add(text);
	            }
	
	            var value = coordSys.pointToData(point);
	
	            var dims = coordSys.dimensions;
	            value = zrUtil.map(value, function (val, idx) {
	                var axis = coordSys.getAxis(dims[idx]);
	                if (axis.type === 'category' || axis.type === 'time') {
	                    val = axis.scale.getLabel(val);
	                }
	                else {
	                    val = formatUtil.addCommas(
	                        val.toFixed(axis.getPixelPrecision())
	                    );
	                }
	                return val;
	            });
	
	            text.setStyle({
	                fill: textStyleModel.getTextColor() || crossStyleModel.get('color'),
	                textFont: textStyleModel.getFont(),
	                text: value.join(', '),
	                x: point[0] + 5,
	                y: point[1] - 5
	            });
	            text.z = tooltipModel.get('z');
	            text.zlevel = tooltipModel.get('zlevel');
	        },
	
	        _getPointerElement: function (coordSys, pointerModel, axisType, initShape) {
	            var tooltipModel = this._tooltipModel;
	            var z = tooltipModel.get('z');
	            var zlevel = tooltipModel.get('zlevel');
	            var axisPointers = this._axisPointers;
	            var coordSysName = coordSys.name;
	            axisPointers[coordSysName] = axisPointers[coordSysName] || {};
	            if (axisPointers[coordSysName][axisType]) {
	                return axisPointers[coordSysName][axisType];
	            }
	
	            // Create if not exists
	            var pointerType = pointerModel.get('type');
	            var styleModel = pointerModel.getModel(pointerType + 'Style');
	            var isShadow = pointerType === 'shadow';
	            var style = styleModel[isShadow ? 'getAreaStyle' : 'getLineStyle']();
	
	            var elementType = coordSys.type === 'polar'
	                ? (isShadow ? 'Sector' : (axisType === 'radius' ? 'Circle' : 'Line'))
	                : (isShadow ? 'Rect' : 'Line');
	
	            isShadow ? (style.stroke = null) : (style.fill = null);
	
	            var el = axisPointers[coordSysName][axisType] = new graphic[elementType]({
	                style: style,
	                z: z,
	                zlevel: zlevel,
	                silent: true,
	                shape: initShape
	            });
	
	            this.group.add(el);
	            return el;
	        },
	
	        /**
	         * Dispatch actions and show tooltip on series
	         * @param {Array.<module:echarts/model/Series>} seriesList
	         * @param {Array.<number>} point
	         * @param {Array.<number>} value
	         * @param {boolean} contentNotChange
	         * @param {Object} e
	         */
	        _dispatchAndShowSeriesTooltipContent: function (
	            coordSys, seriesList, point, value, contentNotChange
	        ) {
	
	            var rootTooltipModel = this._tooltipModel;
	
	            var baseAxis = coordSys.getBaseAxis();
	            var baseDimIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;
	
	            var payloadBatch = zrUtil.map(seriesList, function (series) {
	                return {
	                    seriesIndex: series.seriesIndex,
	                    dataIndex: series.getAxisTooltipDataIndex
	                        ? series.getAxisTooltipDataIndex(series.coordDimToDataDim(baseAxis.dim), value, baseAxis)
	                        : series.getData().indexOfNearest(
	                            series.coordDimToDataDim(baseAxis.dim)[0],
	                            value[baseDimIndex],
	                            // Add a threshold to avoid find the wrong dataIndex when data length is not same
	                            false, baseAxis.type === 'category' ? 0.5 : null
	                        )
	                };
	            });
	
	            var lastHover = this._lastHover;
	            var api = this._api;
	            // Dispatch downplay action
	            if (lastHover.payloadBatch && !contentNotChange) {
	                api.dispatchAction({
	                    type: 'downplay',
	                    batch: lastHover.payloadBatch
	                });
	            }
	            // Dispatch highlight action
	            if (!contentNotChange) {
	                api.dispatchAction({
	                    type: 'highlight',
	                    batch: payloadBatch
	                });
	                lastHover.payloadBatch = payloadBatch;
	            }
	            // Dispatch showTip action
	            api.dispatchAction({
	                type: 'showTip',
	                dataIndex: payloadBatch[0].dataIndex,
	                seriesIndex: payloadBatch[0].seriesIndex,
	                from: this.uid
	            });
	
	            if (baseAxis && rootTooltipModel.get('showContent') && rootTooltipModel.get('show')) {
	                var paramsList = zrUtil.map(seriesList, function (series, index) {
	                    return series.getDataParams(payloadBatch[index].dataIndex);
	                });
	
	                if (!contentNotChange) {
	                    // Update html content
	                    var firstDataIndex = payloadBatch[0].dataIndex;
	
	                    // Default tooltip content
	                    // FIXME
	                    // (1) shold be the first data which has name?
	                    // (2) themeRiver, firstDataIndex is array, and first line is unnecessary.
	                    var firstLine = baseAxis.type === 'time'
	                        ? baseAxis.scale.getLabel(value[baseDimIndex])
	                        : seriesList[0].getData().getName(firstDataIndex);
	                    var defaultHtml = (firstLine ? firstLine + '<br />' : '')
	                        + zrUtil.map(seriesList, function (series, index) {
	                            return series.formatTooltip(payloadBatch[index].dataIndex, true);
	                        }).join('<br />');
	
	                    var asyncTicket = 'axis_' + coordSys.name + '_' + firstDataIndex;
	
	                    this._showTooltipContent(
	                        rootTooltipModel, defaultHtml, paramsList, asyncTicket,
	                        point[0], point[1], null, api
	                    );
	                }
	                else {
	                    updatePosition(
	                        rootTooltipModel.get('position'), point[0], point[1],
	                        this._tooltipContent, paramsList, null, api
	                    );
	                }
	            }
	        },
	
	        /**
	         * Show tooltip on item
	         * @param {module:echarts/model/Series} seriesModel
	         * @param {number} dataIndex
	         * @param {string} dataType
	         * @param {Object} e
	         */
	        _showItemTooltipContent: function (seriesModel, dataIndex, dataType, e) {
	            // FIXME Graph data
	            var api = this._api;
	            var data = seriesModel.getData(dataType);
	            var itemModel = data.getItemModel(dataIndex);
	
	            var tooltipOpt = itemModel.get('tooltip', true);
	            if (typeof tooltipOpt === 'string') {
	                // In each data item tooltip can be simply write:
	                // {
	                //  value: 10,
	                //  tooltip: 'Something you need to know'
	                // }
	                var tooltipContent = tooltipOpt;
	                tooltipOpt = {
	                    formatter: tooltipContent
	                };
	            }
	            var rootTooltipModel = this._tooltipModel;
	            var seriesTooltipModel = seriesModel.getModel(
	                'tooltip', rootTooltipModel
	            );
	            var tooltipModel = new Model(tooltipOpt, seriesTooltipModel, seriesTooltipModel.ecModel);
	
	            var params = seriesModel.getDataParams(dataIndex, dataType);
	            var defaultHtml = seriesModel.formatTooltip(dataIndex, false, dataType);
	
	            var asyncTicket = 'item_' + seriesModel.name + '_' + dataIndex;
	
	            this._showTooltipContent(
	                tooltipModel, defaultHtml, params, asyncTicket,
	                e.offsetX, e.offsetY, e.target, api
	            );
	        },
	
	        _showTooltipContent: function (
	            tooltipModel, defaultHtml, params, asyncTicket, x, y, target, api
	        ) {
	            // Reset ticket
	            this._ticket = '';
	
	            if (tooltipModel.get('showContent') && tooltipModel.get('show')) {
	                var tooltipContent = this._tooltipContent;
	
	                var formatter = tooltipModel.get('formatter');
	                var positionExpr = tooltipModel.get('position');
	                var html = defaultHtml;
	
	                if (formatter) {
	                    if (typeof formatter === 'string') {
	                        html = formatUtil.formatTpl(formatter, params);
	                    }
	                    else if (typeof formatter === 'function') {
	                        var self = this;
	                        var ticket = asyncTicket;
	                        var callback = function (cbTicket, html) {
	                            if (cbTicket === self._ticket) {
	                                tooltipContent.setContent(html);
	
	                                updatePosition(
	                                    positionExpr, x, y,
	                                    tooltipContent, params, target, api
	                                );
	                            }
	                        };
	                        self._ticket = ticket;
	                        html = formatter(params, ticket, callback);
	                    }
	                }
	
	                tooltipContent.show(tooltipModel);
	                tooltipContent.setContent(html);
	
	                updatePosition(
	                    positionExpr, x, y,
	                    tooltipContent, params, target, api
	                );
	            }
	        },
	
	        /**
	         * Show axis pointer
	         * @param {string} [coordSysName]
	         */
	        _showAxisPointer: function (coordSysName) {
	            if (coordSysName) {
	                var axisPointers = this._axisPointers[coordSysName];
	                axisPointers && zrUtil.each(axisPointers, function (el) {
	                    el.show();
	                });
	            }
	            else {
	                this.group.eachChild(function (child) {
	                    child.show();
	                });
	                this.group.show();
	            }
	        },
	
	        _resetLastHover: function () {
	            var lastHover = this._lastHover;
	            if (lastHover.payloadBatch) {
	                this._api.dispatchAction({
	                    type: 'downplay',
	                    batch: lastHover.payloadBatch
	                });
	            }
	            // Reset lastHover
	            this._lastHover = {};
	        },
	        /**
	         * Hide axis pointer
	         * @param {string} [coordSysName]
	         */
	        _hideAxisPointer: function (coordSysName) {
	            if (coordSysName) {
	                var axisPointers = this._axisPointers[coordSysName];
	                axisPointers && zrUtil.each(axisPointers, function (el) {
	                    el.hide();
	                });
	            }
	            else {
	                if (this.group.children().length) {
	                    this.group.hide();
	                }
	            }
	        },
	
	        _hide: function () {
	            clearTimeout(this._showTimeout);
	
	            this._hideAxisPointer();
	            this._resetLastHover();
	            if (!this._alwaysShowContent) {
	                this._tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));
	            }
	
	            this._api.dispatchAction({
	                type: 'hideTip',
	                from: this.uid
	            });
	
	            this._lastX = this._lastY = null;
	        },
	
	        dispose: function (ecModel, api) {
	            if (env.node) {
	                return;
	            }
	            var zr = api.getZr();
	            this._tooltipContent.hide();
	
	            zr.off('click', this._tryShow);
	            zr.off('mousemove', this._mousemove);
	            zr.off('mouseout', this._hide);
	            zr.off('globalout', this._hide);
	
	            api.off('showTip', this._manuallyShowTip);
	            api.off('hideTip', this._manuallyHideTip);
	        }
	    });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * @module echarts/component/tooltip/TooltipContent
	 */
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
	
	    var zrUtil = __webpack_require__(8);
	    var zrColor = __webpack_require__(43);
	    var eventUtil = __webpack_require__(91);
	    var formatUtil = __webpack_require__(10);
	    var each = zrUtil.each;
	    var toCamelCase = formatUtil.toCamelCase;
	    var env = __webpack_require__(6);
	
	    var vendors = ['', '-webkit-', '-moz-', '-o-'];
	
	    var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';
	
	    /**
	     * @param {number} duration
	     * @return {string}
	     * @inner
	     */
	    function assembleTransition(duration) {
	        var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';
	        var transitionText = 'left ' + duration + 's ' + transitionCurve + ','
	                            + 'top ' + duration + 's ' + transitionCurve;
	        return zrUtil.map(vendors, function (vendorPrefix) {
	            return vendorPrefix + 'transition:' + transitionText;
	        }).join(';');
	    }
	
	    /**
	     * @param {Object} textStyle
	     * @return {string}
	     * @inner
	     */
	    function assembleFont(textStyleModel) {
	        var cssText = [];
	
	        var fontSize = textStyleModel.get('fontSize');
	        var color = textStyleModel.getTextColor();
	
	        color && cssText.push('color:' + color);
	
	        cssText.push('font:' + textStyleModel.getFont());
	
	        fontSize &&
	            cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');
	
	        each(['decoration', 'align'], function (name) {
	            var val = textStyleModel.get(name);
	            val && cssText.push('text-' + name + ':' + val);
	        });
	
	        return cssText.join(';');
	    }
	
	    /**
	     * @param {Object} tooltipModel
	     * @return {string}
	     * @inner
	     */
	    function assembleCssText(tooltipModel) {
	
	        tooltipModel = tooltipModel;
	
	        var cssText = [];
	
	        var transitionDuration = tooltipModel.get('transitionDuration');
	        var backgroundColor = tooltipModel.get('backgroundColor');
	        var textStyleModel = tooltipModel.getModel('textStyle');
	        var padding = tooltipModel.get('padding');
	
	        // Animation transition
	        transitionDuration &&
	            cssText.push(assembleTransition(transitionDuration));
	
	        if (backgroundColor) {
	            if (env.canvasSupported) {
	                cssText.push('background-Color:' + backgroundColor);
	            }
	            else {
	                // for ie
	                cssText.push(
	                    'background-Color:#' + zrColor.toHex(backgroundColor)
	                );
	                cssText.push('filter:alpha(opacity=70)');
	            }
	        }
	
	        // Border style
	        each(['width', 'color', 'radius'], function (name) {
	            var borderName = 'border-' + name;
	            var camelCase = toCamelCase(borderName);
	            var val = tooltipModel.get(camelCase);
	            val != null &&
	                cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));
	        });
	
	        // Text style
	        cssText.push(assembleFont(textStyleModel));
	
	        // Padding
	        if (padding != null) {
	            cssText.push('padding:' + formatUtil.normalizeCssArray(padding).join('px ') + 'px');
	        }
	
	        return cssText.join(';') + ';';
	    }
	
	    /**
	     * @alias module:echarts/component/tooltip/TooltipContent
	     * @constructor
	     */
	    function TooltipContent(container, api) {
	        var el = document.createElement('div');
	        var zr = api.getZr();
	
	        this.el = el;
	
	        this._x = api.getWidth() / 2;
	        this._y = api.getHeight() / 2;
	
	        container.appendChild(el);
	
	        this._container = container;
	
	        this._show = false;
	
	        /**
	         * @private
	         */
	        this._hideTimeout;
	
	        var self = this;
	        el.onmouseenter = function () {
	            // clear the timeout in hideLater and keep showing tooltip
	            if (self.enterable) {
	                clearTimeout(self._hideTimeout);
	                self._show = true;
	            }
	            self._inContent = true;
	        };
	        el.onmousemove = function (e) {
	            if (!self.enterable) {
	                // Try trigger zrender event to avoid mouse
	                // in and out shape too frequently
	                var handler = zr.handler;
	                eventUtil.normalizeEvent(container, e);
	                handler.dispatch('mousemove', e);
	            }
	        };
	        el.onmouseleave = function () {
	            if (self.enterable) {
	                if (self._show) {
	                    self.hideLater(self._hideDelay);
	                }
	            }
	            self._inContent = false;
	        };
	
	        compromiseMobile(el, container);
	    }
	
	    function compromiseMobile(tooltipContentEl, container) {
	        // Prevent default behavior on mobile. For example,
	        // default pinch gesture will cause browser zoom.
	        // We do not preventing event on tooltip contnet el,
	        // because user may need customization in tooltip el.
	        eventUtil.addEventListener(container, 'touchstart', preventDefault);
	        eventUtil.addEventListener(container, 'touchmove', preventDefault);
	        eventUtil.addEventListener(container, 'touchend', preventDefault);
	
	        function preventDefault(e) {
	            if (contains(e.target)) {
	                e.preventDefault();
	            }
	        }
	
	        function contains(targetEl) {
	            while (targetEl && targetEl !== container) {
	                if (targetEl === tooltipContentEl) {
	                    return true;
	                }
	                targetEl = targetEl.parentNode;
	            }
	        }
	    }
	
	    TooltipContent.prototype = {
	
	        constructor: TooltipContent,
	
	        enterable: true,
	
	        /**
	         * Update when tooltip is rendered
	         */
	        update: function () {
	            var container = this._container;
	            var stl = container.currentStyle
	                || document.defaultView.getComputedStyle(container);
	            var domStyle = container.style;
	            if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {
	                domStyle.position = 'relative';
	            }
	            // Hide the tooltip
	            // PENDING
	            // this.hide();
	        },
	
	        show: function (tooltipModel) {
	            clearTimeout(this._hideTimeout);
	            var el = this.el;
	
	            el.style.cssText = gCssText + assembleCssText(tooltipModel)
	                // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore
	                + ';left:' + this._x + 'px;top:' + this._y + 'px;'
	                + (tooltipModel.get('extraCssText') || '');
	
	            el.style.display = el.innerHTML ?  'block' : 'none';
	
	            this._show = true;
	        },
	
	        setContent: function (content) {
	            var el = this.el;
	            el.innerHTML = content;
	            el.style.display = content ? 'block' : 'none';
	        },
	
	        moveTo: function (x, y) {
	            var style = this.el.style;
	            style.left = x + 'px';
	            style.top = y + 'px';
	
	            this._x = x;
	            this._y = y;
	        },
	
	        hide: function () {
	            this.el.style.display = 'none';
	            this._show = false;
	        },
	
	        // showLater: function ()
	
	        hideLater: function (time) {
	            if (this._show && !(this._inContent && this.enterable)) {
	                if (time) {
	                    this._hideDelay = time;
	                    // Set show false to avoid invoke hideLater mutiple times
	                    this._show = false;
	                    this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);
	                }
	                else {
	                    this.hide();
	                }
	            }
	        },
	
	        isShow: function () {
	            return this._show;
	        }
	    };
	
	    return TooltipContent;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {
	
	    'use strict';
	
	    var echarts = __webpack_require__(5);
	    var graphic = __webpack_require__(47);
	    var layout = __webpack_require__(25);
	
	    // Model
	    echarts.extendComponentModel({
	
	        type: 'title',
	
	        layoutMode: {type: 'box', ignoreSize: true},
	
	        defaultOption: {
	            // 一级层叠
	            zlevel: 0,
	            // 二级层叠
	            z: 6,
	            show: true,
	
	            text: '',
	            // 超链接跳转
	            // link: null,
	            // 仅支持self | blank
	            target: 'blank',
	            subtext: '',
	
	            // 超链接跳转
	            // sublink: null,
	            // 仅支持self | blank
	            subtarget: 'blank',
	
	            // 'center' ¦ 'left' ¦ 'right'
	            // ¦ {number}（x坐标，单位px）
	            left: 0,
	            // 'top' ¦ 'bottom' ¦ 'center'
	            // ¦ {number}（y坐标，单位px）
	            top: 0,
	
	            // 水平对齐
	            // 'auto' | 'left' | 'right' | 'center'
	            // 默认根据 left 的位置判断是左对齐还是右对齐
	            // textAlign: null
	            //
	            // 垂直对齐
	            // 'auto' | 'top' | 'bottom' | 'middle'
	            // 默认根据 top 位置判断是上对齐还是下对齐
	            // textBaseline: null
	
	            backgroundColor: 'rgba(0,0,0,0)',
	
	            // 标题边框颜色
	            borderColor: '#ccc',
	
	            // 标题边框线宽，单位px，默认为0（无边框）
	            borderWidth: 0,
	
	            // 标题内边距，单位px，默认各方向内边距为5，
	            // 接受数组分别设定上右下左边距，同css
	            padding: 5,
	
	            // 主副标题纵向间隔，单位px，默认为10，
	            itemGap: 10,
	            textStyle: {
	                fontSize: 18,
	                fontWeight: 'bolder',
	                color: '#333'
	            },
	            subtextStyle: {
	                color: '#aaa'
	            }
	        }
	    });
	
	    // View
	    echarts.extendComponentView({
	
	        type: 'title',
	
	        render: function (titleModel, ecModel, api) {
	            this.group.removeAll();
	
	            if (!titleModel.get('show')) {
	                return;
	            }
	
	            var group = this.group;
	
	            var textStyleModel = titleModel.getModel('textStyle');
	            var subtextStyleModel = titleModel.getModel('subtextStyle');
	
	            var textAlign = titleModel.get('textAlign');
	            var textBaseline = titleModel.get('textBaseline');
	
	            var textEl = new graphic.Text({
	                style: {
	                    text: titleModel.get('text'),
	                    textFont: textStyleModel.getFont(),
	                    fill: textStyleModel.getTextColor()
	                },
	                z2: 10
	            });
	
	            var textRect = textEl.getBoundingRect();
	
	            var subText = titleModel.get('subtext');
	            var subTextEl = new graphic.Text({
	                style: {
	                    text: subText,
	                    textFont: subtextStyleModel.getFont(),
	                    fill: subtextStyleModel.getTextColor(),
	                    y: textRect.height + titleModel.get('itemGap'),
	                    textBaseline: 'top'
	                },
	                z2: 10
	            });
	
	            var link = titleModel.get('link');
	            var sublink = titleModel.get('sublink');
	
	            textEl.silent = !link;
	            subTextEl.silent = !sublink;
	
	            if (link) {
	                textEl.on('click', function () {
	                    window.open(link, '_' + titleModel.get('target'));
	                });
	            }
	            if (sublink) {
	                subTextEl.on('click', function () {
	                    window.open(sublink, '_' + titleModel.get('subtarget'));
	                });
	            }
	
	            group.add(textEl);
	            subText && group.add(subTextEl);
	            // If no subText, but add subTextEl, there will be an empty line.
	
	            var groupRect = group.getBoundingRect();
	            var layoutOption = titleModel.getBoxLayoutParams();
	            layoutOption.width = groupRect.width;
	            layoutOption.height = groupRect.height;
	            var layoutRect = layout.getLayoutRect(
	                layoutOption, {
	                    width: api.getWidth(),
	                    height: api.getHeight()
	                }, titleModel.get('padding')
	            );
	            // Adjust text align based on position
	            if (!textAlign) {
	                // Align left if title is on the left. center and right is same
	                textAlign = titleModel.get('left') || titleModel.get('right');
	                if (textAlign === 'middle') {
	                    textAlign = 'center';
	                }
	                // Adjust layout by text align
	                if (textAlign === 'right') {
	                    layoutRect.x += layoutRect.width;
	                }
	                else if (textAlign === 'center') {
	                    layoutRect.x += layoutRect.width / 2;
	                }
	            }
	            if (!textBaseline) {
	                textBaseline = titleModel.get('top') || titleModel.get('bottom');
	                if (textBaseline === 'center') {
	                    textBaseline = 'middle';
	                }
	                if (textBaseline === 'bottom') {
	                    layoutRect.y += layoutRect.height;
	                }
	                else if (textBaseline === 'middle') {
	                    layoutRect.y += layoutRect.height / 2;
	                }
	
	                textBaseline = textBaseline || 'top';
	            }
	
	            group.attr('position', [layoutRect.x, layoutRect.y]);
	            var alignStyle = {
	                textAlign: textAlign,
	                textVerticalAlign: textBaseline
	            };
	            textEl.setStyle(alignStyle);
	            subTextEl.setStyle(alignStyle);
	
	            // Render background
	            // Get groupRect again because textAlign has been changed
	            groupRect = group.getBoundingRect();
	            var padding = layoutRect.margin;
	            var style = titleModel.getItemStyle(['color', 'opacity']);
	            style.fill = titleModel.get('backgroundColor');
	            var rect = new graphic.Rect({
	                shape: {
	                    x: groupRect.x - padding[3],
	                    y: groupRect.y - padding[0],
	                    width: groupRect.width + padding[1] + padding[3],
	                    height: groupRect.height + padding[0] + padding[2]
	                },
	                style: style,
	                silent: true
	            });
	            graphic.subPixelOptimizeRect(rect);
	
	            group.add(rect);
	        }
	    });
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }
]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy90ZXN0LWVjaGFydHMuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL2VjaGFydHMvZWNoYXJ0cy5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvenJlbmRlci9jb3JlL2Vudi5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvZWNoYXJ0cy9tb2RlbC9HbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL3pyZW5kZXIvY29yZS91dGlsLmpzIiwid2VicGFjazovLy8uL2RlcC9lY2hhcnRzL3V0aWwvbW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL2VjaGFydHMvdXRpbC9mb3JtYXQuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL2VjaGFydHMvdXRpbC9udW1iZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL3pyZW5kZXIvY29udGFpbi90ZXh0LmpzIiwid2VicGFjazovLy8uL2RlcC96cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0LmpzIiwid2VicGFjazovLy8uL2RlcC96cmVuZGVyL2NvcmUvdmVjdG9yLmpzIiwid2VicGFjazovLy8uL2RlcC96cmVuZGVyL2NvcmUvbWF0cml4LmpzIiwid2VicGFjazovLy8uL2RlcC9lY2hhcnRzL21vZGVsL01vZGVsLmpzIiwid2VicGFjazovLy8uL2RlcC9lY2hhcnRzL3V0aWwvY2xhenouanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL2VjaGFydHMvbW9kZWwvbWl4aW4vbGluZVN0eWxlLmpzIiwid2VicGFjazovLy8uL2RlcC9lY2hhcnRzL21vZGVsL21peGluL21ha2VTdHlsZU1hcHBlci5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvZWNoYXJ0cy9tb2RlbC9taXhpbi9hcmVhU3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL2VjaGFydHMvbW9kZWwvbWl4aW4vdGV4dFN0eWxlLmpzIiwid2VicGFjazovLy8uL2RlcC9lY2hhcnRzL21vZGVsL21peGluL2l0ZW1TdHlsZS5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvZWNoYXJ0cy9tb2RlbC9Db21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL2VjaGFydHMvdXRpbC9jb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL2VjaGFydHMvdXRpbC9sYXlvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL2VjaGFydHMvbW9kZWwvbWl4aW4vYm94TGF5b3V0LmpzIiwid2VicGFjazovLy8uL2RlcC9lY2hhcnRzL21vZGVsL2dsb2JhbERlZmF1bHQuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL2VjaGFydHMvbW9kZWwvbWl4aW4vY29sb3JQYWxldHRlLmpzIiwid2VicGFjazovLy8uL2RlcC9lY2hhcnRzL0V4dGVuc2lvbkFQSS5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvZWNoYXJ0cy9Db29yZGluYXRlU3lzdGVtLmpzIiwid2VicGFjazovLy8uL2RlcC9lY2hhcnRzL21vZGVsL09wdGlvbk1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL2VjaGFydHMvbW9kZWwvU2VyaWVzLmpzIiwid2VicGFjazovLy8uL2RlcC9lY2hhcnRzL3ZpZXcvQ29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL2RlcC96cmVuZGVyL2NvbnRhaW5lci9Hcm91cC5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvenJlbmRlci9FbGVtZW50LmpzIiwid2VicGFjazovLy8uL2RlcC96cmVuZGVyL2NvcmUvZ3VpZC5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvenJlbmRlci9taXhpbi9FdmVudGZ1bC5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvenJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlLmpzIiwid2VicGFjazovLy8uL2RlcC96cmVuZGVyL21peGluL0FuaW1hdGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL3pyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yLmpzIiwid2VicGFjazovLy8uL2RlcC96cmVuZGVyL2FuaW1hdGlvbi9DbGlwLmpzIiwid2VicGFjazovLy8uL2RlcC96cmVuZGVyL2FuaW1hdGlvbi9lYXNpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL3pyZW5kZXIvdG9vbC9jb2xvci5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvenJlbmRlci9jb3JlL2xvZy5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvenJlbmRlci9jb25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL2VjaGFydHMvdmlldy9DaGFydC5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvZWNoYXJ0cy91dGlsL2dyYXBoaWMuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL3pyZW5kZXIvdG9vbC9wYXRoLmpzIiwid2VicGFjazovLy8uL2RlcC96cmVuZGVyL2dyYXBoaWMvUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlLmpzIiwid2VicGFjazovLy8uL2RlcC96cmVuZGVyL2dyYXBoaWMvU3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL3pyZW5kZXIvZ3JhcGhpYy9taXhpbi9SZWN0VGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvenJlbmRlci9jb3JlL1BhdGhQcm94eS5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvenJlbmRlci9jb3JlL2N1cnZlLmpzIiwid2VicGFjazovLy8uL2RlcC96cmVuZGVyL2NvcmUvYmJveC5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvenJlbmRlci9jb250YWluL3BhdGguanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL3pyZW5kZXIvY29udGFpbi9saW5lLmpzIiwid2VicGFjazovLy8uL2RlcC96cmVuZGVyL2NvbnRhaW4vY3ViaWMuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL3pyZW5kZXIvY29udGFpbi9xdWFkcmF0aWMuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL3pyZW5kZXIvY29udGFpbi9hcmMuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL3pyZW5kZXIvY29udGFpbi91dGlsLmpzIiwid2VicGFjazovLy8uL2RlcC96cmVuZGVyL2NvbnRhaW4vd2luZGluZ0xpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL3pyZW5kZXIvZ3JhcGhpYy9QYXR0ZXJuLmpzIiwid2VicGFjazovLy8uL2RlcC96cmVuZGVyL3Rvb2wvdHJhbnNmb3JtUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvenJlbmRlci9ncmFwaGljL0dyYWRpZW50LmpzIiwid2VicGFjazovLy8uL2RlcC96cmVuZGVyL2dyYXBoaWMvSW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL3pyZW5kZXIvY29yZS9MUlUuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL3pyZW5kZXIvZ3JhcGhpYy9UZXh0LmpzIiwid2VicGFjazovLy8uL2RlcC96cmVuZGVyL2dyYXBoaWMvc2hhcGUvQ2lyY2xlLmpzIiwid2VicGFjazovLy8uL2RlcC96cmVuZGVyL2dyYXBoaWMvc2hhcGUvU2VjdG9yLmpzIiwid2VicGFjazovLy8uL2RlcC96cmVuZGVyL2dyYXBoaWMvc2hhcGUvUmluZy5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvenJlbmRlci9ncmFwaGljL3NoYXBlL1BvbHlnb24uanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL3pyZW5kZXIvZ3JhcGhpYy9oZWxwZXIvcG9seS5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvenJlbmRlci9ncmFwaGljL2hlbHBlci9zbW9vdGhTcGxpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL3pyZW5kZXIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoQmV6aWVyLmpzIiwid2VicGFjazovLy8uL2RlcC96cmVuZGVyL2dyYXBoaWMvc2hhcGUvUG9seWxpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL3pyZW5kZXIvZ3JhcGhpYy9zaGFwZS9SZWN0LmpzIiwid2VicGFjazovLy8uL2RlcC96cmVuZGVyL2dyYXBoaWMvaGVscGVyL3JvdW5kUmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvenJlbmRlci9ncmFwaGljL3NoYXBlL0xpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL3pyZW5kZXIvZ3JhcGhpYy9zaGFwZS9CZXppZXJDdXJ2ZS5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvenJlbmRlci9ncmFwaGljL3NoYXBlL0FyYy5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvenJlbmRlci9ncmFwaGljL0NvbXBvdW5kUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvenJlbmRlci9ncmFwaGljL0xpbmVhckdyYWRpZW50LmpzIiwid2VicGFjazovLy8uL2RlcC96cmVuZGVyL2dyYXBoaWMvUmFkaWFsR3JhZGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL3pyZW5kZXIvenJlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvenJlbmRlci9IYW5kbGVyLmpzIiwid2VicGFjazovLy8uL2RlcC96cmVuZGVyL21peGluL0RyYWdnYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvenJlbmRlci9TdG9yYWdlLmpzIiwid2VicGFjazovLy8uL2RlcC96cmVuZGVyL2NvcmUvdGltc29ydC5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvenJlbmRlci9hbmltYXRpb24vQW5pbWF0aW9uLmpzIiwid2VicGFjazovLy8uL2RlcC96cmVuZGVyL2NvcmUvZXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL3pyZW5kZXIvYW5pbWF0aW9uL3JlcXVlc3RBbmltYXRpb25GcmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvenJlbmRlci9kb20vSGFuZGxlclByb3h5LmpzIiwid2VicGFjazovLy8uL2RlcC96cmVuZGVyL2NvcmUvR2VzdHVyZU1nci5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvenJlbmRlci9QYWludGVyLmpzIiwid2VicGFjazovLy8uL2RlcC96cmVuZGVyL0xheWVyLmpzIiwid2VicGFjazovLy8uL2RlcC9lY2hhcnRzL3Zpc3VhbC9zZXJpZXNDb2xvci5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvZWNoYXJ0cy9wcmVwcm9jZXNzb3IvYmFja3dhcmRDb21wYXQuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL2VjaGFydHMvcHJlcHJvY2Vzc29yL2hlbHBlci9jb21wYXRTdHlsZS5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvZWNoYXJ0cy9sb2FkaW5nL2RlZmF1bHQuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL2VjaGFydHMvZGF0YS9MaXN0LmpzIiwid2VicGFjazovLy8uL2RlcC9lY2hhcnRzL2RhdGEvRGF0YURpZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvZWNoYXJ0cy9jaGFydC9iYXIuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL2VjaGFydHMvY29vcmQvY2FydGVzaWFuL0dyaWQuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL2VjaGFydHMvY29vcmQvYXhpc0hlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvZWNoYXJ0cy9zY2FsZS9PcmRpbmFsLmpzIiwid2VicGFjazovLy8uL2RlcC9lY2hhcnRzL3NjYWxlL1NjYWxlLmpzIiwid2VicGFjazovLy8uL2RlcC9lY2hhcnRzL3NjYWxlL0ludGVydmFsLmpzIiwid2VicGFjazovLy8uL2RlcC9lY2hhcnRzL3NjYWxlL1RpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL2VjaGFydHMvc2NhbGUvTG9nLmpzIiwid2VicGFjazovLy8uL2RlcC9lY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9DYXJ0ZXNpYW4yRC5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vQ2FydGVzaWFuLmpzIiwid2VicGFjazovLy8uL2RlcC9lY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzMkQuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL2VjaGFydHMvY29vcmQvQXhpcy5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vYXhpc0xhYmVsSW50ZXJ2YWwuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL2VjaGFydHMvY29vcmQvY2FydGVzaWFuL0dyaWRNb2RlbC5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vQXhpc01vZGVsLmpzIiwid2VicGFjazovLy8uL2RlcC9lY2hhcnRzL2Nvb3JkL2F4aXNNb2RlbENyZWF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL2VjaGFydHMvY29vcmQvYXhpc0RlZmF1bHQuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL2VjaGFydHMvY29vcmQvYXhpc01vZGVsQ29tbW9uTWl4aW4uanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL2VjaGFydHMvY2hhcnQvYmFyL0JhclNlcmllcy5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvZWNoYXJ0cy9jaGFydC9oZWxwZXIvY3JlYXRlTGlzdEZyb21BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvZWNoYXJ0cy9kYXRhL2hlbHBlci9jb21wbGV0ZURpbWVuc2lvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL2VjaGFydHMvY2hhcnQvYmFyL0JhclZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL2VjaGFydHMvY2hhcnQvYmFyL2Jhckl0ZW1TdHlsZS5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvZWNoYXJ0cy9sYXlvdXQvYmFyR3JpZC5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvZWNoYXJ0cy9jb21wb25lbnQvZ3JpZC5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvZWNoYXJ0cy9jb21wb25lbnQvYXhpcy5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvZWNoYXJ0cy9jb21wb25lbnQvYXhpcy9BeGlzVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvZWNoYXJ0cy9jb21wb25lbnQvYXhpcy9BeGlzQnVpbGRlci5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvZWNoYXJ0cy9jb21wb25lbnQvdG9vbHRpcC5qcyIsIndlYnBhY2s6Ly8vLi9kZXAvZWNoYXJ0cy9jb21wb25lbnQvdG9vbHRpcC9Ub29sdGlwTW9kZWwuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL2VjaGFydHMvY29tcG9uZW50L3Rvb2x0aXAvVG9vbHRpcFZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL2VjaGFydHMvY29tcG9uZW50L3Rvb2x0aXAvVG9vbHRpcENvbnRlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vZGVwL2VjaGFydHMvY29tcG9uZW50L3RpdGxlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsRUFhQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxnQkFBZTtBQUNmO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTCxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsZ0JBQWU7QUFDZjtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLEVBQUMsRUFBRTs7Ozs7OzttQ0M1REg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxn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QkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0IsNEJBQTRCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQsd0JBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsNEJBQTRCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLDRCQUE0QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLDRCQUE0QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QUNyQyxtQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFDLHVKOzs7Ozs7bUNDM1BEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9B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Q0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsT0FBTztBQUMxQixvQkFBbUIsT0FBTztBQUMxQixxQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLHFCQUFvQixRQUFRO0FBQzVCLHFCQUFvQixRQUFRO0FBQzVCLHFCQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLHFCQUFvQixRQUFRO0FBQzVCLHFCQUFvQixRQUFRO0FBQzVCLHFCQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBQzs7Ozs7OzttQ0N2UkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW1CLDRCQUE0QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFtQiw0QkFBNEI7QUFDL0Msb0JBQW1CLDRCQUE0QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFtQiw0QkFBNEI7QUFDL0Msb0JBQW1CLDRCQUE0QjtBQUMvQyxvQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW1CLDRCQUE0QjtBQUMvQyxvQkFBbUIsNEJBQTRCO0FBQy9DLG9CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxvQkFBbUIsNEJBQTRCO0FBQy9DLG9CQUFtQiw0QkFBNEI7QUFDL0Msb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFtQiw0QkFBNEI7QUFDL0Msb0JBQW1CLDRCQUE0QjtBQUMvQyxvQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7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QUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLHVCQUF1QjtBQUMxQyxvQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EscUJBQW9CLFNBQVM7QUFDN0Isc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxxQkFBb0IsU0FBUztBQUM3QixzQkFBcUI7QUFDckI7QUFDQTtBQUNBLDRCQUEyQiwyQkFBMkI7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLDRCQUEyQiwyQkFBMkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLDRCQUEyQiwyQkFBMkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSxx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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxFQUFDOzs7Ozs7O0FDeFNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUFDQSx3QkFBdUIsY0FBYztBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQyxZQUFZO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBdUMsa0JBQWtCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxV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Q25CO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxVQUFT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QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsU0FBUztBQUN4QixpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSx1QkFBdUI7QUFDdEMsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSwyQkFBMkI7QUFDMUMsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSx1QkFBdUI7QUFDdEMsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSwyQkFBMkI7QUFDMUMsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGFBQVksdUNBQXVDLGdDQUFnQyxFQUFFO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLGFBQVksNEJBQTRCLGdDQUFnQyxFQUFFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSx1QkFBdUI7QUFDdEMsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSwyQkFBMkI7QUFDMUMsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsbUNBQW1DO0FBQ2xELGdCQUFlLG1DQUFtQztBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsZUFBZTtBQUM5QixnQkFBZSxlQUFlO0FBQzlCLGdCQUFlLFNBQVM7QUFDeEIsaUJBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLGVBQWU7QUFDOUIsZ0JBQWUsU0FBUztBQUN4QixpQkFBZ0IsT0FBTztBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBLEVBQUMsdUo7Ozs7OzttQ0N6aUJEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBbUIsZUFBZTtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQyx1Sjs7Ozs7O0FDbFpEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLHlEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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QkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBMkIsK0JBQStCO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSxxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0EscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSxxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsUUFBUTtBQUM1QixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIseUJBQXlCO0FBQzVDLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSxvQkFBbUIseUJBQXlCO0FBQzVDLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0NBQStCLHFCQUFxQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTJCLFNBQVM7QUFDcEM7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixvRUFBb0U7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkIsU0FBUztBQUNwQztBQUNBLGdDQUErQiwyQkFBMkI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0IsZUFBZTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQixhQUFhO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUEyQixpQkFBaUI7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixTQUFTO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLHVKOzs7Ozs7bUNDalpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyx1Sjs7Ozs7O21DQzFDRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLHVKOzs7Ozs7bUNDekNEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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bUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBQyx1Sjs7Ozs7O0FDektEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0NBQStCLHNCQUFzQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBQyx1Sjs7Ozs7O0FDN0hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOzs7QUFHVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxFQUFDOzs7Ozs7O0FDOUJEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMLEVBQUM7Ozs7Ozs7QUMzREQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsRUFBQzs7Ozs7OztBQzNCRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxFQUFDLHVKOzs7Ozs7bUNDeEJEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBbUMsaUNBQWlDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVEQUFzRCxPQUFPO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsdUo7Ozs7OztBQ3pDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckIsZ0JBQWUsUUFBUTtBQUN2QixpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBdUIsU0FBUztBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBdUIsVUFBVTtBQUNqQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7Ozs7Ozs7QUNyRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsTUFBTTtBQUNyQixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0EsZ0JBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE0QyxTQUFTO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7Ozs7Ozs7QUNwR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLEVBQUMsdUo7Ozs7OztBQzdCRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLEVBQUM7Ozs7Ozs7bUNDekNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsdUo7Ozs7OztBQ3pGRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsRUFBQzs7Ozs7OztBQzFERDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxxQkFBb0IsT0FBTztBQUMzQixxQkFBb0I7QUFDcEI7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O0FBQ0Esb0JBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCLHdCQUF3QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0EsRUFBQzs7Ozs7OztBQzVRRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBYyxZQUFZO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7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RUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixRQUFRO0FBQzVCLHFCQUFvQixTQUFTO0FBQzdCO0FBQ0EscUJBQW9CLFNBQVM7QUFDN0I7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBQzs7Ozs7OztBQzNQRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHlFQUF3RTtBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7Ozs7O21DQ3BHRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7Ozs7OzttQ0NWRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixNQUFNO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLE1BQU07QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLE1BQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixNQUFNO0FBQ3pCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixNQUFNO0FBQ3pC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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsNkJBQTZCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRCQUEyQix3QkFBd0I7QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FB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QUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQXlELFNBQVM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFDLHVKOzs7Ozs7bUNDM0hEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsRUFBQyx1Sjs7Ozs7O0FDdkJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSx5Q0FBeUM7QUFDeEQsZ0JBQWUsNEJBQTRCO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUF5RCxzQkFBc0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCLDRCQUE0QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBQyx1Sjs7Ozs7O21DQ3JlRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWUsMkJBQTJCO0FBQzFDLGdCQUFlLE9BQU87QUFDdEIsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZSxlQUFlO0FBQzlCLGdCQUFlLGVBQWU7QUFDOUIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxRQUFRO0FBQ3ZCLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLFNBQVM7QUFDeEIsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBeUMsTUFBTTtBQUMvQztBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFDLHVKOzs7Ozs7QUNwT0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLGNBQWM7QUFDakMscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFDLHVKOzs7Ozs7QUM5RkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLEVBQUU7QUFDakIsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQSxFQUFDLHVKOzs7Ozs7QUMxSEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUIscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFDOzs7Ozs7O0FDaE9EO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLHVKOzs7Ozs7bUNDeEpEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUMsdUo7Ozs7OzttQ0N0Q0Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxFQUFDLHVKOzs7Ozs7bUNDMUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEM7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEM7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQixjQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUIsWUFBWTtBQUNqQyxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUMsYUFBYTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBQyx1Sjs7Ozs7O0FDeFJEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0IsZUFBZTtBQUMvQixpQkFBZ0IsTUFBTTtBQUN0QixpQkFBZ0IsZUFBZTtBQUMvQixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQSx3QkFBdUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTBDLFNBQVM7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFDLHVKOzs7Ozs7bUNDaEVEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUEyQztBQUMzQyxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBcUI7O0FBRXJCOztBQUVBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0Esa0JBQWlCO0FBQ2pCOztBQUVBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFh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QUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXVEO0FBQ3ZEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUE4QixPQUFPO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBb0IsdUJBQXVCLHNCQUFzQjtBQUNqRTs7QUFFQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUMsdUo7Ozs7OzttQ0MzUUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXFCLDhCQUE4Qjs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQSxtQkFBa0IsT0FBTztBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQSxjQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQSxjQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTCxFQUFDLHVKIiwiZmlsZSI6InRlc3QtZWNoYXJ0cy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IGh1bW9ySGFuIG9uIDIwMTYvOC8yNC5cclxuICovXHJcbnJlcXVpcmUuY29uZmlnKHtcclxuICAgIHBhY2thZ2VzOiBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnZWNoYXJ0cycsXHJcbiAgICAgICAgICAgIGxvY2F0aW9uOiAnLi4vZGVwL2VjaGFydHMvJyxcclxuICAgICAgICAgICAgbWFpbjogJ2VjaGFydHMnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICd6cmVuZGVyJyxcclxuICAgICAgICAgICAgbG9jYXRpb246ICcuLi9kZXAvenJlbmRlci9zcmMnLCAvLyB6cmVuZGVy5LiOZWNoYXJ0c+WcqOWQjOS4gOe6p+ebruW9lVxyXG4gICAgICAgICAgICBtYWluOiAnenJlbmRlcidcclxuICAgICAgICB9XHJcbiAgICBdXHJcbn0pO1xyXG52YXIgZWNoYXJ0cyA9IHJlcXVpcmUoXCIuLi9kZXAvZWNoYXJ0cy9lY2hhcnRzLmpzXCIpO1xyXG5yZXF1aXJlKCdlY2hhcnRzL2NoYXJ0L2JhcicpO1xyXG4vLyDlvJXlhaXmj5DnpLrmoYblkozmoIfpopjnu4Tku7ZcclxucmVxdWlyZSgnZWNoYXJ0cy9jb21wb25lbnQvdG9vbHRpcCcpO1xyXG5yZXF1aXJlKCdlY2hhcnRzL2NvbXBvbmVudC90aXRsZScpO1xyXG52YXIgbXlDaGFydCA9IGVjaGFydHMuaW5pdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGVzdCcpKTtcclxubXlDaGFydC5zZXRPcHRpb24oe1xyXG4gICAgdGl0bGU6IHtcclxuICAgICAgICB0ZXh0OiAnRUNoYXJ0cyDlhaXpl6jnpLrkvosnXHJcbiAgICB9LFxyXG4gICAgdG9vbHRpcDoge30sXHJcbiAgICBsZWdlbmQ6IHtcclxuICAgICAgICBkYXRhOlsn6ZSA6YePJ11cclxuICAgIH0sXHJcbiAgICB4QXhpczoge1xyXG4gICAgICAgIGRhdGE6IFtcIuihrOihq1wiLFwi576K5q+b6KGrXCIsXCLpm6rnurrooatcIixcIuijpOWtkFwiLFwi6auY6Lef6Z6LXCIsXCLoopzlrZBcIl1cclxuICAgIH0sXHJcbiAgICB5QXhpczoge30sXHJcbiAgICBzZXJpZXM6IFt7XHJcbiAgICAgICAgbmFtZTogJ+mUgOmHjycsXHJcbiAgICAgICAgdHlwZTogJ2JhcicsXHJcbiAgICAgICAgZGF0YTogWzUsIDIwLCAzNiwgMTAsIDEwLCAyMF1cclxuICAgIH1dXHJcbn0pO1xyXG4vKnZhciBlY2hhcnRzID0gcmVxdWlyZSgnLi4vZGVwL2VjaGFydHMubWluLmpzJyk7XHJcbnZhciBteUNoYXJ0ID0gZWNoYXJ0cy5pbml0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0ZXN0JykpO1xyXG5teUNoYXJ0LnNldE9wdGlvbih7XHJcbiAgICB0aXRsZToge1xyXG4gICAgICAgIHRleHQ6ICdFQ2hhcnRzIOWFpemXqOekuuS+iydcclxuICAgIH0sXHJcbiAgICB0b29sdGlwOiB7fSxcclxuICAgIGxlZ2VuZDoge1xyXG4gICAgICAgIGRhdGE6WyfplIDph48nXVxyXG4gICAgfSxcclxuICAgIHhBeGlzOiB7XHJcbiAgICAgICAgZGF0YTogW1wi6KGs6KGrXCIsXCLnvormr5vooatcIixcIumbque6uuihq1wiLFwi6KOk5a2QXCIsXCLpq5jot5/pnotcIixcIuiinOWtkFwiXVxyXG4gICAgfSxcclxuICAgIHlBeGlzOiB7fSxcclxuICAgIHNlcmllczogW3tcclxuICAgICAgICBuYW1lOiAn6ZSA6YePJyxcclxuICAgICAgICB0eXBlOiAnYmFyJyxcclxuICAgICAgICBkYXRhOiBbNSwgMjAsIDM2LCAxMCwgMTAsIDIwXVxyXG4gICAgfV1cclxufSk7Ki9cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2pzL3Rlc3QtZWNoYXJ0cy5qc1xuICoqIG1vZHVsZSBpZCA9IDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsIi8vIEVuYWJsZSBERVYgbW9kZSB3aGVuIHVzaW5nIHNvdXJjZSBjb2RlIHdpdGhvdXQgYnVpbGQuIHdoaWNoIGhhcyBubyBfX0RFVl9fIHZhcmlhYmxlXG4vLyBJbiBidWlsZCBwcm9jZXNzICd0eXBlb2YgX19ERVZfXycgd2lsbCBiZSByZXBsYWNlIHdpdGggJ2Jvb2xlYW4nXG4vLyBTbyB0aGlzIGNvZGUgd2lsbCBiZSByZW1vdmVkIG9yIGRpc2FibGVkIGFueXdheSBhZnRlciBidWlsdC5cbmlmICh0eXBlb2YgX19ERVZfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBJbiBicm93c2VyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHdpbmRvdy5fX0RFVl9fID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gSW4gbm9kZVxuICAgIGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGdsb2JhbC5fX0RFVl9fID0gdHJ1ZTtcbiAgICB9XG59XG5cbi8qIVxuICogRUNoYXJ0cywgYSBqYXZhc2NyaXB0IGludGVyYWN0aXZlIGNoYXJ0IGxpYnJhcnkuXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LCBCYWlkdSBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExJQ0VOU0VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9lY29tZmUvZWNoYXJ0cy9ibG9iL21hc3Rlci9MSUNFTlNFLnR4dFxuICovXG5cbi8qKlxuICogQG1vZHVsZSBlY2hhcnRzXG4gKi9cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG4gICAgdmFyIGVudiA9IHJlcXVpcmUoJ3pyZW5kZXIvY29yZS9lbnYnKTtcblxuICAgIHZhciBHbG9iYWxNb2RlbCA9IHJlcXVpcmUoJy4vbW9kZWwvR2xvYmFsJyk7XG4gICAgdmFyIEV4dGVuc2lvbkFQSSA9IHJlcXVpcmUoJy4vRXh0ZW5zaW9uQVBJJyk7XG4gICAgdmFyIENvb3JkaW5hdGVTeXN0ZW1NYW5hZ2VyID0gcmVxdWlyZSgnLi9Db29yZGluYXRlU3lzdGVtJyk7XG4gICAgdmFyIE9wdGlvbk1hbmFnZXIgPSByZXF1aXJlKCcuL21vZGVsL09wdGlvbk1hbmFnZXInKTtcblxuICAgIHZhciBDb21wb25lbnRNb2RlbCA9IHJlcXVpcmUoJy4vbW9kZWwvQ29tcG9uZW50Jyk7XG4gICAgdmFyIFNlcmllc01vZGVsID0gcmVxdWlyZSgnLi9tb2RlbC9TZXJpZXMnKTtcblxuICAgIHZhciBDb21wb25lbnRWaWV3ID0gcmVxdWlyZSgnLi92aWV3L0NvbXBvbmVudCcpO1xuICAgIHZhciBDaGFydFZpZXcgPSByZXF1aXJlKCcuL3ZpZXcvQ2hhcnQnKTtcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4vdXRpbC9ncmFwaGljJyk7XG5cbiAgICB2YXIgenJlbmRlciA9IHJlcXVpcmUoJ3pyZW5kZXIvenJlbmRlcicpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2NvcmUvdXRpbCcpO1xuICAgIHZhciBjb2xvclRvb2wgPSByZXF1aXJlKCd6cmVuZGVyL3Rvb2wvY29sb3InKTtcbiAgICB2YXIgRXZlbnRmdWwgPSByZXF1aXJlKCd6cmVuZGVyL21peGluL0V2ZW50ZnVsJyk7XG4gICAgdmFyIHRpbXNvcnQgPSByZXF1aXJlKCd6cmVuZGVyL2NvcmUvdGltc29ydCcpO1xuXG4gICAgdmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcblxuICAgIHZhciBQUklPUklUWV9QUk9DRVNTT1JfRklMVEVSID0gMTAwMDtcbiAgICB2YXIgUFJJT1JJVFlfUFJPQ0VTU09SX1NUQVRJU1RJQyA9IDUwMDA7XG5cblxuICAgIHZhciBQUklPUklUWV9WSVNVQUxfTEFZT1VUID0gMTAwMDtcbiAgICB2YXIgUFJJT1JJVFlfVklTVUFMX0dMT0JBTCA9IDIwMDA7XG4gICAgdmFyIFBSSU9SSVRZX1ZJU1VBTF9DSEFSVCA9IDMwMDA7XG4gICAgdmFyIFBSSU9SSVRZX1ZJU1VBTF9DT01QT05FTlQgPSA0MDAwO1xuICAgIHZhciBQUklPUklUWV9WSVNVQUxfQlJVU0ggPSA1MDAwO1xuXG4gICAgLy8gTWFpbiBwcm9jZXNzIGhhdmUgdGhyZWUgZW50cmllczogYHNldE9wdGlvbmAsIGBkaXNwYXRjaEFjdGlvbmAgYW5kIGByZXNpemVgLFxuICAgIC8vIHdoZXJlIHRoZXkgbXVzdCBub3QgYmUgaW52b2tlZCBuZXN0ZWRseSwgZXhjZXB0IHRoZSBvbmx5IGNhc2U6IGludm9rZVxuICAgIC8vIGRpc3BhdGNoQWN0aW9uIHdpdGggdXBkYXRlTWV0aG9kIFwibm9uZVwiIGluIG1haW4gcHJvY2Vzcy5cbiAgICAvLyBUaGlzIGZsYWcgaXMgdXNlZCB0byBjYXJyeSBvdXQgdGhpcyBydWxlLlxuICAgIC8vIEFsbCBldmVudHMgd2lsbCBiZSB0cmlnZ2VyZWQgb3V0IHNpZGUgbWFpbiBwcm9jZXNzIChpLmUuIHdoZW4gIXRoaXNbSU5fTUFJTl9QUk9DRVNTXSkuXG4gICAgdmFyIElOX01BSU5fUFJPQ0VTUyA9ICdfX2ZsYWdfaW5fbWFpbl9wcm9jZXNzJztcbiAgICB2YXIgSEFTX0dSQURJRU5UX09SX1BBVFRFUk5fQkcgPSAnX2hhc0dyYWRpZW50T3JQYXR0ZXJuQmcnO1xuXG5cbiAgICB2YXIgT1BUSU9OX1VQREFURUQgPSAnX29wdGlvblVwZGF0ZWQnO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlUmVnaXN0ZXJFdmVudFdpdGhMb3dlcmNhc2VOYW1lKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlciwgY29udGV4dCkge1xuICAgICAgICAgICAgLy8gRXZlbnQgbmFtZSBpcyBhbGwgbG93ZXJjYXNlXG4gICAgICAgICAgICBldmVudE5hbWUgPSBldmVudE5hbWUgJiYgZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBFdmVudGZ1bC5wcm90b3R5cGVbbWV0aG9kXS5jYWxsKHRoaXMsIGV2ZW50TmFtZSwgaGFuZGxlciwgY29udGV4dCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBtb2R1bGUgZWNoYXJ0c35NZXNzYWdlQ2VudGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWVzc2FnZUNlbnRlcigpIHtcbiAgICAgICAgRXZlbnRmdWwuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgTWVzc2FnZUNlbnRlci5wcm90b3R5cGUub24gPSBjcmVhdGVSZWdpc3RlckV2ZW50V2l0aExvd2VyY2FzZU5hbWUoJ29uJyk7XG4gICAgTWVzc2FnZUNlbnRlci5wcm90b3R5cGUub2ZmID0gY3JlYXRlUmVnaXN0ZXJFdmVudFdpdGhMb3dlcmNhc2VOYW1lKCdvZmYnKTtcbiAgICBNZXNzYWdlQ2VudGVyLnByb3RvdHlwZS5vbmUgPSBjcmVhdGVSZWdpc3RlckV2ZW50V2l0aExvd2VyY2FzZU5hbWUoJ29uZScpO1xuICAgIHpyVXRpbC5taXhpbihNZXNzYWdlQ2VudGVyLCBFdmVudGZ1bCk7XG4gICAgLyoqXG4gICAgICogQG1vZHVsZSBlY2hhcnRzfkVDaGFydHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFQ2hhcnRzIChkb20sIHRoZW1lLCBvcHRzKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgICAgIC8vIEdldCB0aGVtZSBieSBuYW1lXG4gICAgICAgIGlmICh0eXBlb2YgdGhlbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGVtZSA9IHRoZW1lU3RvcmFnZVt0aGVtZV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHcm91cCBpZFxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ncm91cDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRG9tRWxlbWVudH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2RvbSA9IGRvbTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fenIgPSB6cmVuZGVyLmluaXQoZG9tLCB7XG4gICAgICAgICAgICByZW5kZXJlcjogb3B0cy5yZW5kZXJlciB8fCAnY2FudmFzJyxcbiAgICAgICAgICAgIGRldmljZVBpeGVsUmF0aW86IG9wdHMuZGV2aWNlUGl4ZWxSYXRpb1xuICAgICAgICB9KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3RoZW1lID0genJVdGlsLmNsb25lKHRoZW1lKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6ZWNoYXJ0cy92aWV3L0NoYXJ0Pn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2NoYXJ0c1ZpZXdzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOmVjaGFydHMvdmlldy9DaGFydD59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jaGFydHNNYXAgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6ZWNoYXJ0cy92aWV3L0NvbXBvbmVudD59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jb21wb25lbnRzVmlld3MgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBtb2R1bGU6ZWNoYXJ0cy92aWV3L0NvbXBvbmVudD59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jb21wb25lbnRzTWFwID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9hcGkgPSBuZXcgRXh0ZW5zaW9uQVBJKHRoaXMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvQ29vcmRpbmF0ZVN5c3RlbX1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2Nvb3JkU3lzTWdyID0gbmV3IENvb3JkaW5hdGVTeXN0ZW1NYW5hZ2VyKCk7XG5cbiAgICAgICAgRXZlbnRmdWwuY2FsbCh0aGlzKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzfk1lc3NhZ2VDZW50ZXJ9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9tZXNzYWdlQ2VudGVyID0gbmV3IE1lc3NhZ2VDZW50ZXIoKTtcblxuICAgICAgICAvLyBJbml0IG1vdXNlIGV2ZW50c1xuICAgICAgICB0aGlzLl9pbml0RXZlbnRzKCk7XG5cbiAgICAgICAgLy8gSW4gY2FzZSBzb21lIHBlb3BsZSB3cml0ZSBgd2luZG93Lm9ucmVzaXplID0gY2hhcnQucmVzaXplYFxuICAgICAgICB0aGlzLnJlc2l6ZSA9IHpyVXRpbC5iaW5kKHRoaXMucmVzaXplLCB0aGlzKTtcblxuICAgICAgICAvLyBDYW4ndCBkaXNwYXRjaCBhY3Rpb24gZHVyaW5nIHJlbmRlcmluZyBwcm9jZWR1cmVcbiAgICAgICAgdGhpcy5fcGVuZGluZ0FjdGlvbnMgPSBbXTtcbiAgICAgICAgLy8gU29ydCBvbiBkZW1hbmRcbiAgICAgICAgZnVuY3Rpb24gcHJpb3JpdHlTb3J0RnVuYyhhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5wcmlvIC0gYi5wcmlvO1xuICAgICAgICB9XG4gICAgICAgIHRpbXNvcnQodmlzdWFsRnVuY3MsIHByaW9yaXR5U29ydEZ1bmMpO1xuICAgICAgICB0aW1zb3J0KGRhdGFQcm9jZXNzb3JGdW5jcywgcHJpb3JpdHlTb3J0RnVuYyk7XG5cbiAgICAgICAgdGhpcy5fenIuYW5pbWF0aW9uLm9uKCdmcmFtZScsIHRoaXMuX29uZnJhbWUsIHRoaXMpO1xuICAgIH1cblxuICAgIHZhciBlY2hhcnRzUHJvdG8gPSBFQ2hhcnRzLnByb3RvdHlwZTtcblxuICAgIGVjaGFydHNQcm90by5fb25mcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gTGF6eSB1cGRhdGVcbiAgICAgICAgaWYgKHRoaXNbT1BUSU9OX1VQREFURURdKSB7XG5cbiAgICAgICAgICAgIHRoaXNbSU5fTUFJTl9QUk9DRVNTXSA9IHRydWU7XG5cbiAgICAgICAgICAgIHVwZGF0ZU1ldGhvZHMucHJlcGFyZUFuZFVwZGF0ZS5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICB0aGlzW0lOX01BSU5fUFJPQ0VTU10gPSBmYWxzZTtcblxuICAgICAgICAgICAgdGhpc1tPUFRJT05fVVBEQVRFRF0gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7SFRNTERvbUVsZW1lbnR9XG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmdldERvbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvbTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXJ+WlJlbmRlcn1cbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8uZ2V0WnIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl96cjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbm90TWVyZ2VcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtsYXp5VXBkYXRlPWZhbHNlXSBVc2VmdWwgd2hlbiBzZXRPcHRpb24gZnJlcXVlbnRseS5cbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8uc2V0T3B0aW9uID0gZnVuY3Rpb24gKG9wdGlvbiwgbm90TWVyZ2UsIGxhenlVcGRhdGUpIHtcbiAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgIHpyVXRpbC5hc3NlcnQoIXRoaXNbSU5fTUFJTl9QUk9DRVNTXSwgJ2BzZXRPcHRpb25gIHNob3VsZCBub3QgYmUgY2FsbGVkIGR1cmluZyBtYWluIHByb2Nlc3MuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzW0lOX01BSU5fUFJPQ0VTU10gPSB0cnVlO1xuXG4gICAgICAgIGlmICghdGhpcy5fbW9kZWwgfHwgbm90TWVyZ2UpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25NYW5hZ2VyID0gbmV3IE9wdGlvbk1hbmFnZXIodGhpcy5fYXBpKTtcbiAgICAgICAgICAgIHZhciB0aGVtZSA9IHRoaXMuX3RoZW1lO1xuICAgICAgICAgICAgdmFyIGVjTW9kZWwgPSB0aGlzLl9tb2RlbCA9IG5ldyBHbG9iYWxNb2RlbChudWxsLCBudWxsLCB0aGVtZSwgb3B0aW9uTWFuYWdlcik7XG4gICAgICAgICAgICBlY01vZGVsLmluaXQobnVsbCwgbnVsbCwgdGhlbWUsIG9wdGlvbk1hbmFnZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbW9kZWwuc2V0T3B0aW9uKG9wdGlvbiwgb3B0aW9uUHJlcHJvY2Vzc29yRnVuY3MpO1xuXG4gICAgICAgIGlmIChsYXp5VXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzW09QVElPTl9VUERBVEVEXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1cGRhdGVNZXRob2RzLnByZXBhcmVBbmRVcGRhdGUuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3pyLnJlZnJlc2hJbW1lZGlhdGVseSgpO1xuICAgICAgICAgICAgdGhpc1tPUFRJT05fVVBEQVRFRF0gPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXNbSU5fTUFJTl9QUk9DRVNTXSA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX2ZsdXNoUGVuZGluZ0FjdGlvbnMoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQERFUFJFQ0FURURcbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8uc2V0VGhlbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdFQ2hhcnRzI3NldFRoZW1lKCkgaXMgREVQUkVDQVRFRCBpbiBFQ2hhcnRzIDMuMCcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9XG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmdldE1vZGVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW9kZWw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8uZ2V0T3B0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW9kZWwgJiYgdGhpcy5fbW9kZWwuZ2V0T3B0aW9uKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8uZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl96ci5nZXRXaWR0aCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3pyLmdldEhlaWdodCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2FudmFzIHdoaWNoIGhhcyBhbGwgdGhpbmcgcmVuZGVyZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5iYWNrZ3JvdW5kQ29sb3JdXG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmdldFJlbmRlcmVkQ2FudmFzID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgaWYgKCFlbnYuY2FudmFzU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIG9wdHMucGl4ZWxSYXRpbyA9IG9wdHMucGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgICBvcHRzLmJhY2tncm91bmRDb2xvciA9IG9wdHMuYmFja2dyb3VuZENvbG9yXG4gICAgICAgICAgICB8fCB0aGlzLl9tb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpO1xuICAgICAgICB2YXIgenIgPSB0aGlzLl96cjtcbiAgICAgICAgdmFyIGxpc3QgPSB6ci5zdG9yYWdlLmdldERpc3BsYXlMaXN0KCk7XG4gICAgICAgIC8vIFN0b3AgYW5pbWF0aW9uc1xuICAgICAgICB6clV0aWwuZWFjaChsaXN0LCBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGVsLnN0b3BBbmltYXRpb24odHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4genIucGFpbnRlci5nZXRSZW5kZXJlZENhbnZhcyhvcHRzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy50eXBlPSdwbmcnXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5waXhlbFJhdGlvPTFdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmJhY2tncm91bmRDb2xvcl1cbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8uZ2V0RGF0YVVSTCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICB2YXIgZXhjbHVkZUNvbXBvbmVudHMgPSBvcHRzLmV4Y2x1ZGVDb21wb25lbnRzO1xuICAgICAgICB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsO1xuICAgICAgICB2YXIgZXhjbHVkZXNDb21wb25lbnRWaWV3cyA9IFtdO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgZWFjaChleGNsdWRlQ29tcG9uZW50cywgZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudCh7XG4gICAgICAgICAgICAgICAgbWFpblR5cGU6IGNvbXBvbmVudFR5cGVcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmlldyA9IHNlbGYuX2NvbXBvbmVudHNNYXBbY29tcG9uZW50Ll9fdmlld0lkXTtcbiAgICAgICAgICAgICAgICBpZiAoIXZpZXcuZ3JvdXAuaWdub3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVzQ29tcG9uZW50Vmlld3MucHVzaCh2aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5ncm91cC5pZ25vcmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgdXJsID0gdGhpcy5nZXRSZW5kZXJlZENhbnZhcyhvcHRzKS50b0RhdGFVUkwoXG4gICAgICAgICAgICAnaW1hZ2UvJyArIChvcHRzICYmIG9wdHMudHlwZSB8fCAncG5nJylcbiAgICAgICAgKTtcblxuICAgICAgICBlYWNoKGV4Y2x1ZGVzQ29tcG9uZW50Vmlld3MsIGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgICAgICAgICB2aWV3Lmdyb3VwLmlnbm9yZSA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMudHlwZT0ncG5nJ11cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucGl4ZWxSYXRpbz0xXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5iYWNrZ3JvdW5kQ29sb3JdXG4gICAgICovXG4gICAgZWNoYXJ0c1Byb3RvLmdldENvbm5lY3RlZERhdGFVUkwgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICBpZiAoIWVudi5jYW52YXNTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ3JvdXBJZCA9IHRoaXMuZ3JvdXA7XG4gICAgICAgIHZhciBtYXRoTWluID0gTWF0aC5taW47XG4gICAgICAgIHZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG4gICAgICAgIHZhciBNQVhfTlVNQkVSID0gSW5maW5pdHk7XG4gICAgICAgIGlmIChjb25uZWN0ZWRHcm91cHNbZ3JvdXBJZF0pIHtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gTUFYX05VTUJFUjtcbiAgICAgICAgICAgIHZhciB0b3AgPSBNQVhfTlVNQkVSO1xuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gLU1BWF9OVU1CRVI7XG4gICAgICAgICAgICB2YXIgYm90dG9tID0gLU1BWF9OVU1CRVI7XG4gICAgICAgICAgICB2YXIgY2FudmFzTGlzdCA9IFtdO1xuICAgICAgICAgICAgdmFyIGRwciA9IChvcHRzICYmIG9wdHMucGl4ZWxSYXRpbykgfHwgMTtcbiAgICAgICAgICAgIGZvciAodmFyIGlkIGluIGluc3RhbmNlcykge1xuICAgICAgICAgICAgICAgIHZhciBjaGFydCA9IGluc3RhbmNlc1tpZF07XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJ0Lmdyb3VwID09PSBncm91cElkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYW52YXMgPSBjaGFydC5nZXRSZW5kZXJlZENhbnZhcyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHpyVXRpbC5jbG9uZShvcHRzKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYm91bmRpbmdSZWN0ID0gY2hhcnQuZ2V0RG9tKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBtYXRoTWluKGJvdW5kaW5nUmVjdC5sZWZ0LCBsZWZ0KTtcbiAgICAgICAgICAgICAgICAgICAgdG9wID0gbWF0aE1pbihib3VuZGluZ1JlY3QudG9wLCB0b3ApO1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9IG1hdGhNYXgoYm91bmRpbmdSZWN0LnJpZ2h0LCByaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbSA9IG1hdGhNYXgoYm91bmRpbmdSZWN0LmJvdHRvbSwgYm90dG9tKTtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbTogY2FudmFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogYm91bmRpbmdSZWN0LmxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IGJvdW5kaW5nUmVjdC50b3BcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZWZ0ICo9IGRwcjtcbiAgICAgICAgICAgIHRvcCAqPSBkcHI7XG4gICAgICAgICAgICByaWdodCAqPSBkcHI7XG4gICAgICAgICAgICBib3R0b20gKj0gZHByO1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgICAgICAgICAgIHZhciB0YXJnZXRDYW52YXMgPSB6clV0aWwuY3JlYXRlQ2FudmFzKCk7XG4gICAgICAgICAgICB0YXJnZXRDYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIHRhcmdldENhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB2YXIgenIgPSB6cmVuZGVyLmluaXQodGFyZ2V0Q2FudmFzKTtcblxuICAgICAgICAgICAgZWFjaChjYW52YXNMaXN0LCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciBpbWcgPSBuZXcgZ3JhcGhpYy5JbWFnZSh7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBpdGVtLmxlZnQgKiBkcHIgLSBsZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogaXRlbS50b3AgKiBkcHIgLSB0b3AsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogaXRlbS5kb21cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHpyLmFkZChpbWcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB6ci5yZWZyZXNoSW1tZWRpYXRlbHkoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldENhbnZhcy50b0RhdGFVUkwoJ2ltYWdlLycgKyAob3B0cyAmJiBvcHRzLnR5cGUgfHwgJ3BuZycpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldERhdGFVUkwob3B0cyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHVwZGF0ZU1ldGhvZHMgPSB7XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUudGltZSAmJiBjb25zb2xlLnRpbWUoJ3VwZGF0ZScpO1xuXG4gICAgICAgICAgICB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsO1xuICAgICAgICAgICAgdmFyIGFwaSA9IHRoaXMuX2FwaTtcbiAgICAgICAgICAgIHZhciBjb29yZFN5c01nciA9IHRoaXMuX2Nvb3JkU3lzTWdyO1xuICAgICAgICAgICAgdmFyIHpyID0gdGhpcy5fenI7XG4gICAgICAgICAgICAvLyB1cGRhdGUgYmVmb3JlIHNldE9wdGlvblxuICAgICAgICAgICAgaWYgKCFlY01vZGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaXhtZSBGaXJzdCB0aW1lIHVwZGF0ZSA/XG4gICAgICAgICAgICBlY01vZGVsLnJlc3RvcmVEYXRhKCk7XG5cbiAgICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgICAgIC8vIFNhdmUgdG90YWwgZWNNb2RlbCBoZXJlIGZvciB1bmRvL3JlZG8gKGFmdGVyIHJlc3RvcmluZyBkYXRhIGFuZCBiZWZvcmUgcHJvY2Vzc2luZyBkYXRhKS5cbiAgICAgICAgICAgIC8vIFVuZG8gKHJlc3RvcmF0aW9uIG9mIHRvdGFsIGVjTW9kZWwpIGNhbiBiZSBjYXJyaWVkIG91dCBpbiAnYWN0aW9uJyBvciBvdXRzaWRlIEFQSSBjYWxsLlxuXG4gICAgICAgICAgICAvLyBDcmVhdGUgbmV3IGNvb3JkaW5hdGUgc3lzdGVtIGVhY2ggdXBkYXRlXG4gICAgICAgICAgICAvLyBJbiBMaW5lVmlldyBtYXkgc2F2ZSB0aGUgb2xkIGNvb3JkaW5hdGUgc3lzdGVtIGFuZCB1c2UgaXQgdG8gZ2V0IHRoZSBvcmlnbmFsIHBvaW50XG4gICAgICAgICAgICBjb29yZFN5c01nci5jcmVhdGUodGhpcy5fbW9kZWwsIHRoaXMuX2FwaSk7XG5cbiAgICAgICAgICAgIHByb2Nlc3NEYXRhLmNhbGwodGhpcywgZWNNb2RlbCwgYXBpKTtcblxuICAgICAgICAgICAgc3RhY2tTZXJpZXNEYXRhLmNhbGwodGhpcywgZWNNb2RlbCk7XG5cbiAgICAgICAgICAgIGNvb3JkU3lzTWdyLnVwZGF0ZShlY01vZGVsLCBhcGkpO1xuXG4gICAgICAgICAgICBkb1Zpc3VhbEVuY29kaW5nLmNhbGwodGhpcywgZWNNb2RlbCwgcGF5bG9hZCk7XG5cbiAgICAgICAgICAgIGRvUmVuZGVyLmNhbGwodGhpcywgZWNNb2RlbCwgcGF5bG9hZCk7XG5cbiAgICAgICAgICAgIC8vIFNldCBiYWNrZ3JvdW5kXG4gICAgICAgICAgICB2YXIgYmFja2dyb3VuZENvbG9yID0gZWNNb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpIHx8ICd0cmFuc3BhcmVudCc7XG5cbiAgICAgICAgICAgIHZhciBwYWludGVyID0genIucGFpbnRlcjtcbiAgICAgICAgICAgIC8vIFRPRE8gYWxsIHVzZSBjbGVhckNvbG9yID9cbiAgICAgICAgICAgIGlmIChwYWludGVyLmlzU2luZ2xlQ2FudmFzICYmIHBhaW50ZXIuaXNTaW5nbGVDYW52YXMoKSkge1xuICAgICAgICAgICAgICAgIHpyLmNvbmZpZ0xheWVyKDAsIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJDb2xvcjogYmFja2dyb3VuZENvbG9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBJRThcbiAgICAgICAgICAgICAgICBpZiAoIWVudi5jYW52YXNTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yQXJyID0gY29sb3JUb29sLnBhcnNlKGJhY2tncm91bmRDb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvciA9IGNvbG9yVG9vbC5zdHJpbmdpZnkoY29sb3JBcnIsICdyZ2InKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG9yQXJyWzNdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3IgPSAndHJhbnNwYXJlbnQnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IuY29sb3JTdG9wcyB8fCBiYWNrZ3JvdW5kQ29sb3IuaW1hZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gR3JhZGllbnQgYmFja2dyb3VuZFxuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBGaXhlZCBsYXllcu+8n1xuICAgICAgICAgICAgICAgICAgICB6ci5jb25maWdMYXllcigwLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhckNvbG9yOiBiYWNrZ3JvdW5kQ29sb3JcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbSEFTX0dSQURJRU5UX09SX1BBVFRFUk5fQkddID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb20uc3R5bGUuYmFja2dyb3VuZCA9ICd0cmFuc3BhcmVudCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpc1tIQVNfR1JBRElFTlRfT1JfUEFUVEVSTl9CR10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHpyLmNvbmZpZ0xheWVyKDAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhckNvbG9yOiBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzW0hBU19HUkFESUVOVF9PUl9QQVRURVJOX0JHXSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvbS5zdHlsZS5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY29uc29sZS50aW1lICYmIGNvbnNvbGUudGltZUVuZCgndXBkYXRlJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gUEVORElOR1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZVZpZXc6IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgICAgICB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgYmVmb3JlIHNldE9wdGlvblxuICAgICAgICAgICAgaWYgKCFlY01vZGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLmNsZWFyQWxsVmlzdWFsKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZG9WaXN1YWxFbmNvZGluZy5jYWxsKHRoaXMsIGVjTW9kZWwsIHBheWxvYWQpO1xuXG4gICAgICAgICAgICBpbnZva2VVcGRhdGVNZXRob2QuY2FsbCh0aGlzLCAndXBkYXRlVmlldycsIGVjTW9kZWwsIHBheWxvYWQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlVmlzdWFsOiBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICAgICAgdmFyIGVjTW9kZWwgPSB0aGlzLl9tb2RlbDtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIGJlZm9yZSBzZXRPcHRpb25cbiAgICAgICAgICAgIGlmICghZWNNb2RlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgICAgIHNlcmllc01vZGVsLmdldERhdGEoKS5jbGVhckFsbFZpc3VhbCgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRvVmlzdWFsRW5jb2RpbmcuY2FsbCh0aGlzLCBlY01vZGVsLCBwYXlsb2FkKTtcblxuICAgICAgICAgICAgaW52b2tlVXBkYXRlTWV0aG9kLmNhbGwodGhpcywgJ3VwZGF0ZVZpc3VhbCcsIGVjTW9kZWwsIHBheWxvYWQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlTGF5b3V0OiBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICAgICAgdmFyIGVjTW9kZWwgPSB0aGlzLl9tb2RlbDtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIGJlZm9yZSBzZXRPcHRpb25cbiAgICAgICAgICAgIGlmICghZWNNb2RlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZG9MYXlvdXQuY2FsbCh0aGlzLCBlY01vZGVsLCBwYXlsb2FkKTtcblxuICAgICAgICAgICAgaW52b2tlVXBkYXRlTWV0aG9kLmNhbGwodGhpcywgJ3VwZGF0ZUxheW91dCcsIGVjTW9kZWwsIHBheWxvYWQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgaGlnaGxpZ2h0OiBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICAgICAgdG9nZ2xlSGlnaGxpZ2h0LmNhbGwodGhpcywgJ2hpZ2hsaWdodCcsIHBheWxvYWQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgZG93bnBsYXk6IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgICAgICB0b2dnbGVIaWdobGlnaHQuY2FsbCh0aGlzLCAnZG93bnBsYXknLCBwYXlsb2FkKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHByZXBhcmVBbmRVcGRhdGU6IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgICAgICB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsO1xuXG4gICAgICAgICAgICBwcmVwYXJlVmlldy5jYWxsKHRoaXMsICdjb21wb25lbnQnLCBlY01vZGVsKTtcblxuICAgICAgICAgICAgcHJlcGFyZVZpZXcuY2FsbCh0aGlzLCAnY2hhcnQnLCBlY01vZGVsKTtcblxuICAgICAgICAgICAgdXBkYXRlTWV0aG9kcy51cGRhdGUuY2FsbCh0aGlzLCBwYXlsb2FkKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9nZ2xlSGlnaGxpZ2h0KG1ldGhvZCwgcGF5bG9hZCkge1xuICAgICAgICB2YXIgZWNNb2RlbCA9IHRoaXMuX21vZGVsO1xuXG4gICAgICAgIC8vIGRpc3BhdGNoQWN0aW9uIGJlZm9yZSBzZXRPcHRpb25cbiAgICAgICAgaWYgKCFlY01vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoXG4gICAgICAgICAgICB7bWFpblR5cGU6ICdzZXJpZXMnLCBxdWVyeTogcGF5bG9hZH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYXJ0VmlldyA9IHRoaXMuX2NoYXJ0c01hcFtzZXJpZXNNb2RlbC5fX3ZpZXdJZF07XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJ0VmlldyAmJiBjaGFydFZpZXcuX19hbGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFydFZpZXdbbWV0aG9kXShcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc01vZGVsLCBlY01vZGVsLCB0aGlzLl9hcGksIHBheWxvYWRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZSB0aGUgY2hhcnRcbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8ucmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgenJVdGlsLmFzc2VydCghdGhpc1tJTl9NQUlOX1BST0NFU1NdLCAnYHJlc2l6ZWAgc2hvdWxkIG5vdCBiZSBjYWxsZWQgZHVyaW5nIG1haW4gcHJvY2Vzcy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXNbSU5fTUFJTl9QUk9DRVNTXSA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5fenIucmVzaXplKCk7XG5cbiAgICAgICAgdmFyIG9wdGlvbkNoYW5nZWQgPSB0aGlzLl9tb2RlbCAmJiB0aGlzLl9tb2RlbC5yZXNldE9wdGlvbignbWVkaWEnKTtcbiAgICAgICAgdXBkYXRlTWV0aG9kc1tvcHRpb25DaGFuZ2VkID8gJ3ByZXBhcmVBbmRVcGRhdGUnIDogJ3VwZGF0ZSddLmNhbGwodGhpcyk7XG5cbiAgICAgICAgLy8gUmVzaXplIGxvYWRpbmcgZWZmZWN0XG4gICAgICAgIHRoaXMuX2xvYWRpbmdGWCAmJiB0aGlzLl9sb2FkaW5nRlgucmVzaXplKCk7XG5cbiAgICAgICAgdGhpc1tJTl9NQUlOX1BST0NFU1NdID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fZmx1c2hQZW5kaW5nQWN0aW9ucygpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTaG93IGxvYWRpbmcgZWZmZWN0XG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBbbmFtZT0nZGVmYXVsdCddXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBbY2ZnXVxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5zaG93TG9hZGluZyA9IGZ1bmN0aW9uIChuYW1lLCBjZmcpIHtcbiAgICAgICAgaWYgKHpyVXRpbC5pc09iamVjdChuYW1lKSkge1xuICAgICAgICAgICAgY2ZnID0gbmFtZTtcbiAgICAgICAgICAgIG5hbWUgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBuYW1lID0gbmFtZSB8fCAnZGVmYXVsdCc7XG5cbiAgICAgICAgdGhpcy5oaWRlTG9hZGluZygpO1xuICAgICAgICBpZiAoIWxvYWRpbmdFZmZlY3RzW25hbWVdKSB7XG4gICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTG9hZGluZyBlZmZlY3RzICcgKyBuYW1lICsgJyBub3QgZXhpc3RzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbCA9IGxvYWRpbmdFZmZlY3RzW25hbWVdKHRoaXMuX2FwaSwgY2ZnKTtcbiAgICAgICAgdmFyIHpyID0gdGhpcy5fenI7XG4gICAgICAgIHRoaXMuX2xvYWRpbmdGWCA9IGVsO1xuXG4gICAgICAgIHpyLmFkZChlbCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhpZGUgbG9hZGluZyBlZmZlY3RcbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8uaGlkZUxvYWRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2xvYWRpbmdGWCAmJiB0aGlzLl96ci5yZW1vdmUodGhpcy5fbG9hZGluZ0ZYKTtcbiAgICAgICAgdGhpcy5fbG9hZGluZ0ZYID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50T2JqXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5tYWtlQWN0aW9uRnJvbUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50T2JqKSB7XG4gICAgICAgIHZhciBwYXlsb2FkID0genJVdGlsLmV4dGVuZCh7fSwgZXZlbnRPYmopO1xuICAgICAgICBwYXlsb2FkLnR5cGUgPSBldmVudEFjdGlvbk1hcFtldmVudE9iai50eXBlXTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwdWJpbGNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGF5bG9hZC50eXBlXSBBY3Rpb24gdHlwZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NpbGVudD1mYWxzZV0gV2hldGhlciB0cmlnZ2VyIGV2ZW50LlxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5kaXNwYXRjaEFjdGlvbiA9IGZ1bmN0aW9uIChwYXlsb2FkLCBzaWxlbnQpIHtcbiAgICAgICAgdmFyIGFjdGlvbldyYXAgPSBhY3Rpb25zW3BheWxvYWQudHlwZV07XG4gICAgICAgIGlmICghYWN0aW9uV3JhcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFjdGlvbkluZm8gPSBhY3Rpb25XcmFwLmFjdGlvbkluZm87XG4gICAgICAgIHZhciB1cGRhdGVNZXRob2QgPSBhY3Rpb25JbmZvLnVwZGF0ZSB8fCAndXBkYXRlJztcblxuICAgICAgICAvLyBpZiAoX19ERVZfXykge1xuICAgICAgICAvLyAgICAgenJVdGlsLmFzc2VydChcbiAgICAgICAgLy8gICAgICAgICAhdGhpc1tJTl9NQUlOX1BST0NFU1NdLFxuICAgICAgICAvLyAgICAgICAgICdgZGlzcGF0Y2hBY3Rpb25gIHNob3VsZCBub3QgYmUgY2FsbGVkIGR1cmluZyBtYWluIHByb2Nlc3MuJ1xuICAgICAgICAvLyAgICAgICAgICsgJ3VubGVzcyB1cGRhdGVNYXRob2QgaXMgXCJub25lXCIuJ1xuICAgICAgICAvLyAgICAgKTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIE1heSBkaXNwYXRjaEFjdGlvbiBpbiByZW5kZXJpbmcgcHJvY2VkdXJlXG4gICAgICAgIGlmICh0aGlzW0lOX01BSU5fUFJPQ0VTU10pIHtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdBY3Rpb25zLnB1c2gocGF5bG9hZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzW0lOX01BSU5fUFJPQ0VTU10gPSB0cnVlO1xuXG4gICAgICAgIHZhciBwYXlsb2FkcyA9IFtwYXlsb2FkXTtcbiAgICAgICAgdmFyIGJhdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gQmF0Y2ggYWN0aW9uXG4gICAgICAgIGlmIChwYXlsb2FkLmJhdGNoKSB7XG4gICAgICAgICAgICBiYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHBheWxvYWRzID0genJVdGlsLm1hcChwYXlsb2FkLmJhdGNoLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSB6clV0aWwuZGVmYXVsdHMoenJVdGlsLmV4dGVuZCh7fSwgaXRlbSksIHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIGl0ZW0uYmF0Y2ggPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXZlbnRPYmpCYXRjaCA9IFtdO1xuICAgICAgICB2YXIgZXZlbnRPYmo7XG4gICAgICAgIHZhciBpc0hpZ2hsaWdodE9yRG93bnBsYXkgPSBwYXlsb2FkLnR5cGUgPT09ICdoaWdobGlnaHQnIHx8IHBheWxvYWQudHlwZSA9PT0gJ2Rvd25wbGF5JztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXlsb2Fkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJhdGNoSXRlbSA9IHBheWxvYWRzW2ldO1xuICAgICAgICAgICAgLy8gQWN0aW9uIGNhbiBzcGVjaWZ5IHRoZSBldmVudCBieSByZXR1cm4gaXQuXG4gICAgICAgICAgICBldmVudE9iaiA9IGFjdGlvbldyYXAuYWN0aW9uKGJhdGNoSXRlbSwgdGhpcy5fbW9kZWwpO1xuICAgICAgICAgICAgLy8gRW1pdCBldmVudCBvdXRzaWRlXG4gICAgICAgICAgICBldmVudE9iaiA9IGV2ZW50T2JqIHx8IHpyVXRpbC5leHRlbmQoe30sIGJhdGNoSXRlbSk7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHR5cGUgdG8gZXZlbnRUeXBlXG4gICAgICAgICAgICBldmVudE9iai50eXBlID0gYWN0aW9uSW5mby5ldmVudCB8fCBldmVudE9iai50eXBlO1xuICAgICAgICAgICAgZXZlbnRPYmpCYXRjaC5wdXNoKGV2ZW50T2JqKTtcblxuICAgICAgICAgICAgLy8gSGlnaGxpZ2h0IGFuZCBkb3ducGxheSBhcmUgc3BlY2lhbC5cbiAgICAgICAgICAgIGlzSGlnaGxpZ2h0T3JEb3ducGxheSAmJiB1cGRhdGVNZXRob2RzW3VwZGF0ZU1ldGhvZF0uY2FsbCh0aGlzLCBiYXRjaEl0ZW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVwZGF0ZU1ldGhvZCAhPT0gJ25vbmUnICYmICFpc0hpZ2hsaWdodE9yRG93bnBsYXkpIHtcbiAgICAgICAgICAgIC8vIFN0aWxsIGRpcnR5XG4gICAgICAgICAgICBpZiAodGhpc1tPUFRJT05fVVBEQVRFRF0pIHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBQYXNzIHBheWxvYWQgP1xuICAgICAgICAgICAgICAgIHVwZGF0ZU1ldGhvZHMucHJlcGFyZUFuZFVwZGF0ZS5jYWxsKHRoaXMsIHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIHRoaXNbT1BUSU9OX1VQREFURURdID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVNZXRob2RzW3VwZGF0ZU1ldGhvZF0uY2FsbCh0aGlzLCBwYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZvbGxvdyB0aGUgcnVsZSBvZiBhY3Rpb24gYmF0Y2hcbiAgICAgICAgaWYgKGJhdGNoZWQpIHtcbiAgICAgICAgICAgIGV2ZW50T2JqID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IGFjdGlvbkluZm8uZXZlbnQgfHwgcGF5bG9hZC50eXBlLFxuICAgICAgICAgICAgICAgIGJhdGNoOiBldmVudE9iakJhdGNoXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXZlbnRPYmogPSBldmVudE9iakJhdGNoWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpc1tJTl9NQUlOX1BST0NFU1NdID0gZmFsc2U7XG5cbiAgICAgICAgIXNpbGVudCAmJiB0aGlzLl9tZXNzYWdlQ2VudGVyLnRyaWdnZXIoZXZlbnRPYmoudHlwZSwgZXZlbnRPYmopO1xuXG4gICAgICAgIHRoaXMuX2ZsdXNoUGVuZGluZ0FjdGlvbnMoKTtcblxuICAgIH07XG5cbiAgICBlY2hhcnRzUHJvdG8uX2ZsdXNoUGVuZGluZ0FjdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwZW5kaW5nQWN0aW9ucyA9IHRoaXMuX3BlbmRpbmdBY3Rpb25zO1xuICAgICAgICB3aGlsZSAocGVuZGluZ0FjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgcGF5bG9hZCA9IHBlbmRpbmdBY3Rpb25zLnNoaWZ0KCk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoQWN0aW9uKHBheWxvYWQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGV2ZW50XG4gICAgICogQG1ldGhvZFxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5vbiA9IGNyZWF0ZVJlZ2lzdGVyRXZlbnRXaXRoTG93ZXJjYXNlTmFtZSgnb24nKTtcbiAgICBlY2hhcnRzUHJvdG8ub2ZmID0gY3JlYXRlUmVnaXN0ZXJFdmVudFdpdGhMb3dlcmNhc2VOYW1lKCdvZmYnKTtcbiAgICBlY2hhcnRzUHJvdG8ub25lID0gY3JlYXRlUmVnaXN0ZXJFdmVudFdpdGhMb3dlcmNhc2VOYW1lKCdvbmUnKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnZva2VVcGRhdGVNZXRob2QobWV0aG9kTmFtZSwgZWNNb2RlbCwgcGF5bG9hZCkge1xuICAgICAgICB2YXIgYXBpID0gdGhpcy5fYXBpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBhbGwgY29tcG9uZW50c1xuICAgICAgICBlYWNoKHRoaXMuX2NvbXBvbmVudHNWaWV3cywgZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudE1vZGVsID0gY29tcG9uZW50Ll9fbW9kZWw7XG4gICAgICAgICAgICBjb21wb25lbnRbbWV0aG9kTmFtZV0oY29tcG9uZW50TW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG5cbiAgICAgICAgICAgIHVwZGF0ZVooY29tcG9uZW50TW9kZWwsIGNvbXBvbmVudCk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIC8vIFVwYXRlIGFsbCBjaGFydHNcbiAgICAgICAgZWNNb2RlbC5lYWNoU2VyaWVzKGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgaWR4KSB7XG4gICAgICAgICAgICB2YXIgY2hhcnQgPSB0aGlzLl9jaGFydHNNYXBbc2VyaWVzTW9kZWwuX192aWV3SWRdO1xuICAgICAgICAgICAgY2hhcnRbbWV0aG9kTmFtZV0oc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCk7XG5cbiAgICAgICAgICAgIHVwZGF0ZVooc2VyaWVzTW9kZWwsIGNoYXJ0KTtcblxuICAgICAgICAgICAgdXBkYXRlUHJvZ3Jlc3NpdmVBbmRCbGVuZChzZXJpZXNNb2RlbCwgY2hhcnQpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAvLyBJZiB1c2UgaG92ZXIgbGF5ZXJcbiAgICAgICAgdXBkYXRlSG92ZXJMYXllclN0YXR1cyh0aGlzLl96ciwgZWNNb2RlbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZSB2aWV3IGluc3RhbmNlcyBvZiBjaGFydHMgYW5kIGNvbXBvbmVudHNcbiAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByZXBhcmVWaWV3KHR5cGUsIGVjTW9kZWwpIHtcbiAgICAgICAgdmFyIGlzQ29tcG9uZW50ID0gdHlwZSA9PT0gJ2NvbXBvbmVudCc7XG4gICAgICAgIHZhciB2aWV3TGlzdCA9IGlzQ29tcG9uZW50ID8gdGhpcy5fY29tcG9uZW50c1ZpZXdzIDogdGhpcy5fY2hhcnRzVmlld3M7XG4gICAgICAgIHZhciB2aWV3TWFwID0gaXNDb21wb25lbnQgPyB0aGlzLl9jb21wb25lbnRzTWFwIDogdGhpcy5fY2hhcnRzTWFwO1xuICAgICAgICB2YXIgenIgPSB0aGlzLl96cjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXdMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2aWV3TGlzdFtpXS5fX2FsaXZlID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBlY01vZGVsW2lzQ29tcG9uZW50ID8gJ2VhY2hDb21wb25lbnQnIDogJ2VhY2hTZXJpZXMnXShmdW5jdGlvbiAoY29tcG9uZW50VHlwZSwgbW9kZWwpIHtcbiAgICAgICAgICAgIGlmIChpc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnRUeXBlID09PSAnc2VyaWVzJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBjb21wb25lbnRUeXBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb25zaWRlcjogaWQgc2FtZSBhbmQgdHlwZSBjaGFuZ2VkLlxuICAgICAgICAgICAgdmFyIHZpZXdJZCA9IG1vZGVsLmlkICsgJ18nICsgbW9kZWwudHlwZTtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gdmlld01hcFt2aWV3SWRdO1xuICAgICAgICAgICAgaWYgKCF2aWV3KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzVHlwZSA9IENvbXBvbmVudE1vZGVsLnBhcnNlQ2xhc3NUeXBlKG1vZGVsLnR5cGUpO1xuICAgICAgICAgICAgICAgIHZhciBDbGF6eiA9IGlzQ29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgID8gQ29tcG9uZW50Vmlldy5nZXRDbGFzcyhjbGFzc1R5cGUubWFpbiwgY2xhc3NUeXBlLnN1YilcbiAgICAgICAgICAgICAgICAgICAgOiBDaGFydFZpZXcuZ2V0Q2xhc3MoY2xhc3NUeXBlLnN1Yik7XG4gICAgICAgICAgICAgICAgaWYgKENsYXp6KSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcgPSBuZXcgQ2xhenooKTtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5pbml0KGVjTW9kZWwsIHRoaXMuX2FwaSk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdNYXBbdmlld0lkXSA9IHZpZXc7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdMaXN0LnB1c2godmlldyk7XG4gICAgICAgICAgICAgICAgICAgIHpyLmFkZCh2aWV3Lmdyb3VwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVycm9yXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1vZGVsLl9fdmlld0lkID0gdmlld0lkO1xuICAgICAgICAgICAgdmlldy5fX2FsaXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIHZpZXcuX19pZCA9IHZpZXdJZDtcbiAgICAgICAgICAgIHZpZXcuX19tb2RlbCA9IG1vZGVsO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXdMaXN0Lmxlbmd0aDspIHtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gdmlld0xpc3RbaV07XG4gICAgICAgICAgICBpZiAoIXZpZXcuX19hbGl2ZSkge1xuICAgICAgICAgICAgICAgIHpyLnJlbW92ZSh2aWV3Lmdyb3VwKTtcbiAgICAgICAgICAgICAgICB2aWV3LmRpc3Bvc2UoZWNNb2RlbCwgdGhpcy5fYXBpKTtcbiAgICAgICAgICAgICAgICB2aWV3TGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHZpZXdNYXBbdmlldy5fX2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3NvciBkYXRhIGluIGVhY2ggc2VyaWVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0RhdGEoZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgIGVhY2goZGF0YVByb2Nlc3NvckZ1bmNzLCBmdW5jdGlvbiAocHJvY2Vzcykge1xuICAgICAgICAgICAgcHJvY2Vzcy5mdW5jKGVjTW9kZWwsIGFwaSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tTZXJpZXNEYXRhKGVjTW9kZWwpIHtcbiAgICAgICAgdmFyIHN0YWNrZWREYXRhTWFwID0ge307XG4gICAgICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzKSB7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBzZXJpZXMuZ2V0KCdzdGFjaycpO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXMuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgaWYgKHN0YWNrICYmIGRhdGEudHlwZSA9PT0gJ2xpc3QnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzU3RhY2sgPSBzdGFja2VkRGF0YU1hcFtzdGFja107XG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzU3RhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zdGFja2VkT24gPSBwcmV2aW91c1N0YWNrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGFja2VkRGF0YU1hcFtzdGFja10gPSBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMYXlvdXQgYmVmb3JlIGVhY2ggY2hhcnQgcmVuZGVyIHRoZXJlIHNlcmllcywgc3BlY2lhbCB2aXN1YWwgZW5jb2Rpbmcgc3RhZ2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb0xheW91dChlY01vZGVsLCBwYXlsb2FkKSB7XG4gICAgICAgIHZhciBhcGkgPSB0aGlzLl9hcGk7XG4gICAgICAgIGVhY2godmlzdWFsRnVuY3MsIGZ1bmN0aW9uICh2aXN1YWwpIHtcbiAgICAgICAgICAgIGlmICh2aXN1YWwuaXNMYXlvdXQpIHtcbiAgICAgICAgICAgICAgICB2aXN1YWwuZnVuYyhlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGUgdmlzdWFsIGluZm9tYXRpb24gZnJvbSBkYXRhIGFmdGVyIGRhdGEgcHJvY2Vzc2luZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRvVmlzdWFsRW5jb2RpbmcoZWNNb2RlbCwgcGF5bG9hZCkge1xuICAgICAgICB2YXIgYXBpID0gdGhpcy5fYXBpO1xuICAgICAgICBlY01vZGVsLmNsZWFyQ29sb3JQYWxldHRlKCk7XG4gICAgICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAgIHNlcmllc01vZGVsLmNsZWFyQ29sb3JQYWxldHRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoKHZpc3VhbEZ1bmNzLCBmdW5jdGlvbiAodmlzdWFsKSB7XG4gICAgICAgICAgICB2aXN1YWwuZnVuYyhlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgZWFjaCBjaGFydCBhbmQgY29tcG9uZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb1JlbmRlcihlY01vZGVsLCBwYXlsb2FkKSB7XG4gICAgICAgIHZhciBhcGkgPSB0aGlzLl9hcGk7XG4gICAgICAgIC8vIFJlbmRlciBhbGwgY29tcG9uZW50c1xuICAgICAgICBlYWNoKHRoaXMuX2NvbXBvbmVudHNWaWV3cywgZnVuY3Rpb24gKGNvbXBvbmVudFZpZXcpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRNb2RlbCA9IGNvbXBvbmVudFZpZXcuX19tb2RlbDtcbiAgICAgICAgICAgIGNvbXBvbmVudFZpZXcucmVuZGVyKGNvbXBvbmVudE1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuXG4gICAgICAgICAgICB1cGRhdGVaKGNvbXBvbmVudE1vZGVsLCBjb21wb25lbnRWaWV3KTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgZWFjaCh0aGlzLl9jaGFydHNWaWV3cywgZnVuY3Rpb24gKGNoYXJ0KSB7XG4gICAgICAgICAgICBjaGFydC5fX2FsaXZlID0gZmFsc2U7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIC8vIFJlbmRlciBhbGwgY2hhcnRzXG4gICAgICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGlkeCkge1xuICAgICAgICAgICAgdmFyIGNoYXJ0VmlldyA9IHRoaXMuX2NoYXJ0c01hcFtzZXJpZXNNb2RlbC5fX3ZpZXdJZF07XG4gICAgICAgICAgICBjaGFydFZpZXcuX19hbGl2ZSA9IHRydWU7XG4gICAgICAgICAgICBjaGFydFZpZXcucmVuZGVyKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuXG4gICAgICAgICAgICBjaGFydFZpZXcuZ3JvdXAuc2lsZW50ID0gISFzZXJpZXNNb2RlbC5nZXQoJ3NpbGVudCcpO1xuXG4gICAgICAgICAgICB1cGRhdGVaKHNlcmllc01vZGVsLCBjaGFydFZpZXcpO1xuXG4gICAgICAgICAgICB1cGRhdGVQcm9ncmVzc2l2ZUFuZEJsZW5kKHNlcmllc01vZGVsLCBjaGFydFZpZXcpO1xuXG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIC8vIElmIHVzZSBob3ZlciBsYXllclxuICAgICAgICB1cGRhdGVIb3ZlckxheWVyU3RhdHVzKHRoaXMuX3pyLCBlY01vZGVsKTtcblxuICAgICAgICAvLyBSZW1vdmUgZ3JvdXBzIG9mIHVucmVuZGVyZWQgY2hhcnRzXG4gICAgICAgIGVhY2godGhpcy5fY2hhcnRzVmlld3MsIGZ1bmN0aW9uIChjaGFydCkge1xuICAgICAgICAgICAgaWYgKCFjaGFydC5fX2FsaXZlKSB7XG4gICAgICAgICAgICAgICAgY2hhcnQucmVtb3ZlKGVjTW9kZWwsIGFwaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cblxuICAgIHZhciBNT1VTRV9FVkVOVF9OQU1FUyA9IFtcbiAgICAgICAgJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCcsICdtb3VzZW1vdmUnLCAnbW91c2Vkb3duJywgJ21vdXNldXAnLCAnZ2xvYmFsb3V0J1xuICAgIF07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8uX2luaXRFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVhY2goTU9VU0VfRVZFTlRfTkFNRVMsIGZ1bmN0aW9uIChldmVOYW1lKSB7XG4gICAgICAgICAgICB0aGlzLl96ci5vbihldmVOYW1lLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5nZXRNb2RlbCgpO1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgICAgIGlmIChlbCAmJiBlbC5kYXRhSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YU1vZGVsID0gZWwuZGF0YU1vZGVsIHx8IGVjTW9kZWwuZ2V0U2VyaWVzQnlJbmRleChlbC5zZXJpZXNJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSBkYXRhTW9kZWwgJiYgZGF0YU1vZGVsLmdldERhdGFQYXJhbXMoZWwuZGF0YUluZGV4LCBlbC5kYXRhVHlwZSkgfHwge307XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5ldmVudCA9IGU7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy50eXBlID0gZXZlTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKGV2ZU5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIGVsZW1lbnQgaGFzIGN1c3RvbSBldmVudERhdGEgb2YgY29tcG9uZW50c1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVsICYmIGVsLmV2ZW50RGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoZXZlTmFtZSwgZWwuZXZlbnREYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgZWFjaChldmVudEFjdGlvbk1hcCwgZnVuY3Rpb24gKGFjdGlvblR5cGUsIGV2ZW50VHlwZSkge1xuICAgICAgICAgICAgdGhpcy5fbWVzc2FnZUNlbnRlci5vbihldmVudFR5cGUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcihldmVudFR5cGUsIGV2ZW50KTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBlY2hhcnRzUHJvdG8uaXNEaXNwb3NlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3Bvc2VkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhclxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb24oeyBzZXJpZXM6IFtdIH0sIHRydWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGlzcG9zZSBpbnN0YW5jZVxuICAgICAqL1xuICAgIGVjaGFydHNQcm90by5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlzcG9zZWQpIHtcbiAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdJbnN0YW5jZSAnICsgdGhpcy5pZCArICcgaGFzIGJlZW4gZGlzcG9zZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kaXNwb3NlZCA9IHRydWU7XG5cbiAgICAgICAgdmFyIGFwaSA9IHRoaXMuX2FwaTtcbiAgICAgICAgdmFyIGVjTW9kZWwgPSB0aGlzLl9tb2RlbDtcblxuICAgICAgICBlYWNoKHRoaXMuX2NvbXBvbmVudHNWaWV3cywgZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgY29tcG9uZW50LmRpc3Bvc2UoZWNNb2RlbCwgYXBpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVhY2godGhpcy5fY2hhcnRzVmlld3MsIGZ1bmN0aW9uIChjaGFydCkge1xuICAgICAgICAgICAgY2hhcnQuZGlzcG9zZShlY01vZGVsLCBhcGkpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBEaXNwb3NlIGFmdGVyIGFsbCB2aWV3cyBkaXNwb3NlZFxuICAgICAgICB0aGlzLl96ci5kaXNwb3NlKCk7XG5cbiAgICAgICAgZGVsZXRlIGluc3RhbmNlc1t0aGlzLmlkXTtcbiAgICB9O1xuXG4gICAgenJVdGlsLm1peGluKEVDaGFydHMsIEV2ZW50ZnVsKTtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUhvdmVyTGF5ZXJTdGF0dXMoenIsIGVjTW9kZWwpIHtcbiAgICAgICAgdmFyIHN0b3JhZ2UgPSB6ci5zdG9yYWdlO1xuICAgICAgICB2YXIgZWxDb3VudCA9IDA7XG4gICAgICAgIHN0b3JhZ2UudHJhdmVyc2UoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBpZiAoIWVsLmlzR3JvdXApIHtcbiAgICAgICAgICAgICAgICBlbENvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZWxDb3VudCA+IGVjTW9kZWwuZ2V0KCdob3ZlckxheWVyVGhyZXNob2xkJykgJiYgIWVudi5ub2RlKSB7XG4gICAgICAgICAgICBzdG9yYWdlLnRyYXZlcnNlKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIGlmICghZWwuaXNHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICBlbC51c2VIb3ZlckxheWVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgY2hhcnQgcHJvZ3Jlc3NpdmUgYW5kIGJsZW5kLlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzfG1vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudH0gbW9kZWxcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL3ZpZXcvQ29tcG9uZW50fG1vZHVsZTplY2hhcnRzL3ZpZXcvQ2hhcnR9IHZpZXdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVQcm9ncmVzc2l2ZUFuZEJsZW5kKHNlcmllc01vZGVsLCBjaGFydFZpZXcpIHtcbiAgICAgICAgLy8gUHJvZ3Jlc3NpdmUgY29uZmlndXJhdGlvblxuICAgICAgICB2YXIgZWxDb3VudCA9IDA7XG4gICAgICAgIGNoYXJ0Vmlldy5ncm91cC50cmF2ZXJzZShmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGlmIChlbC50eXBlICE9PSAnZ3JvdXAnICYmICFlbC5pZ25vcmUpIHtcbiAgICAgICAgICAgICAgICBlbENvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZnJhbWVEcmF3TnVtID0gK3Nlcmllc01vZGVsLmdldCgncHJvZ3Jlc3NpdmUnKTtcbiAgICAgICAgdmFyIG5lZWRQcm9ncmVzc2l2ZSA9IGVsQ291bnQgPiBzZXJpZXNNb2RlbC5nZXQoJ3Byb2dyZXNzaXZlVGhyZXNob2xkJykgJiYgZnJhbWVEcmF3TnVtICYmICFlbnYubm9kZTtcbiAgICAgICAgaWYgKG5lZWRQcm9ncmVzc2l2ZSkge1xuICAgICAgICAgICAgY2hhcnRWaWV3Lmdyb3VwLnRyYXZlcnNlKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FIG1hcmtlciBhbmQgb3RoZXIgY29tcG9uZW50c1xuICAgICAgICAgICAgICAgIGlmICghZWwuaXNHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICBlbC5wcm9ncmVzc2l2ZSA9IG5lZWRQcm9ncmVzc2l2ZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmZsb29yKGVsQ291bnQrKyAvIGZyYW1lRHJhd051bSkgOiAtMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5lZWRQcm9ncmVzc2l2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuc3RvcEFuaW1hdGlvbih0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmxlbmQgY29uZmlncmF0aW9uXG4gICAgICAgIHZhciBibGVuZE1vZGUgPSBzZXJpZXNNb2RlbC5nZXQoJ2JsZW5kTW9kZScpIHx8IG51bGw7XG4gICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICBpZiAoIWVudi5jYW52YXNTdXBwb3J0ZWQgJiYgYmxlbmRNb2RlICYmIGJsZW5kTW9kZSAhPT0gJ3NvdXJjZS1vdmVyJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignT25seSBjYW52YXMgc3VwcG9ydCBibGVuZE1vZGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGFydFZpZXcuZ3JvdXAudHJhdmVyc2UoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAvLyBGSVhNRSBtYXJrZXIgYW5kIG90aGVyIGNvbXBvbmVudHNcbiAgICAgICAgICAgIGlmICghZWwuaXNHcm91cCkge1xuICAgICAgICAgICAgICAgIGVsLnNldFN0eWxlKCdibGVuZCcsIGJsZW5kTW9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc3xtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Db21wb25lbnR9IG1vZGVsXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy92aWV3L0NvbXBvbmVudHxtb2R1bGU6ZWNoYXJ0cy92aWV3L0NoYXJ0fSB2aWV3XG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlWihtb2RlbCwgdmlldykge1xuICAgICAgICB2YXIgeiA9IG1vZGVsLmdldCgneicpO1xuICAgICAgICB2YXIgemxldmVsID0gbW9kZWwuZ2V0KCd6bGV2ZWwnKTtcbiAgICAgICAgLy8gU2V0IHogYW5kIHpsZXZlbFxuICAgICAgICB2aWV3Lmdyb3VwLnRyYXZlcnNlKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKGVsLnR5cGUgIT09ICdncm91cCcpIHtcbiAgICAgICAgICAgICAgICB6ICE9IG51bGwgJiYgKGVsLnogPSB6KTtcbiAgICAgICAgICAgICAgICB6bGV2ZWwgIT0gbnVsbCAmJiAoZWwuemxldmVsID0gemxldmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheS48RnVuY3Rpb24+fVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIHZhciBhY3Rpb25zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBNYXAgZXZlbnRUeXBlIHRvIGFjdGlvblR5cGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHZhciBldmVudEFjdGlvbk1hcCA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogRGF0YSBwcm9jZXNzb3IgZnVuY3Rpb25zIG9mIGVhY2ggc3RhZ2VcbiAgICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdC48c3RyaW5nLCBGdW5jdGlvbj4+fVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIHZhciBkYXRhUHJvY2Vzc29yRnVuY3MgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheS48RnVuY3Rpb24+fVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIHZhciBvcHRpb25QcmVwcm9jZXNzb3JGdW5jcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVmlzdWFsIGVuY29kaW5nIGZ1bmN0aW9ucyBvZiBlYWNoIHN0YWdlXG4gICAgICogQHR5cGUge0FycmF5LjxPYmplY3QuPHN0cmluZywgRnVuY3Rpb24+Pn1cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICB2YXIgdmlzdWFsRnVuY3MgPSBbXTtcbiAgICAvKipcbiAgICAgKiBUaGVtZSBzdG9yYWdlXG4gICAgICogQHR5cGUge09iamVjdC48a2V5LCBPYmplY3Q+fVxuICAgICAqL1xuICAgIHZhciB0aGVtZVN0b3JhZ2UgPSB7fTtcbiAgICAvKipcbiAgICAgKiBMb2FkaW5nIGVmZmVjdHNcbiAgICAgKi9cbiAgICB2YXIgbG9hZGluZ0VmZmVjdHMgPSB7fTtcblxuXG4gICAgdmFyIGluc3RhbmNlcyA9IHt9O1xuICAgIHZhciBjb25uZWN0ZWRHcm91cHMgPSB7fTtcblxuICAgIHZhciBpZEJhc2UgPSBuZXcgRGF0ZSgpIC0gMDtcbiAgICB2YXIgZ3JvdXBJZEJhc2UgPSBuZXcgRGF0ZSgpIC0gMDtcbiAgICB2YXIgRE9NX0FUVFJJQlVURV9LRVkgPSAnX2VjaGFydHNfaW5zdGFuY2VfJztcbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOmVjaGFydHNcbiAgICAgKi9cbiAgICB2YXIgZWNoYXJ0cyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB2ZXJzaW9uOiAnMy4yLjMnLFxuICAgICAgICBkZXBlbmRlbmNpZXM6IHtcbiAgICAgICAgICAgIHpyZW5kZXI6ICczLjEuMydcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBlbmFibGVDb25uZWN0KGNoYXJ0KSB7XG5cbiAgICAgICAgdmFyIFNUQVRVU19QRU5ESU5HID0gMDtcbiAgICAgICAgdmFyIFNUQVRVU19VUERBVElORyA9IDE7XG4gICAgICAgIHZhciBTVEFUVVNfVVBEQVRFRCA9IDI7XG4gICAgICAgIHZhciBTVEFUVVNfS0VZID0gJ19fY29ubmVjdFVwZGF0ZVN0YXR1cyc7XG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUNvbm5lY3RlZENoYXJ0c1N0YXR1cyhjaGFydHMsIHN0YXR1cykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXJDaGFydCA9IGNoYXJ0c1tpXTtcbiAgICAgICAgICAgICAgICBvdGhlckNoYXJ0W1NUQVRVU19LRVldID0gc3RhdHVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHpyVXRpbC5lYWNoKGV2ZW50QWN0aW9uTWFwLCBmdW5jdGlvbiAoYWN0aW9uVHlwZSwgZXZlbnRUeXBlKSB7XG4gICAgICAgICAgICBjaGFydC5fbWVzc2FnZUNlbnRlci5vbihldmVudFR5cGUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0ZWRHcm91cHNbY2hhcnQuZ3JvdXBdICYmIGNoYXJ0W1NUQVRVU19LRVldICE9PSBTVEFUVVNfUEVORElORykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWN0aW9uID0gY2hhcnQubWFrZUFjdGlvbkZyb21FdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdGhlckNoYXJ0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpZCBpbiBpbnN0YW5jZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdGhlckNoYXJ0ID0gaW5zdGFuY2VzW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdGhlckNoYXJ0ICE9PSBjaGFydCAmJiBvdGhlckNoYXJ0Lmdyb3VwID09PSBjaGFydC5ncm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyQ2hhcnRzLnB1c2gob3RoZXJDaGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ29ubmVjdGVkQ2hhcnRzU3RhdHVzKG90aGVyQ2hhcnRzLCBTVEFUVVNfUEVORElORyk7XG4gICAgICAgICAgICAgICAgICAgIGVhY2gob3RoZXJDaGFydHMsIGZ1bmN0aW9uIChvdGhlckNoYXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXJDaGFydFtTVEFUVVNfS0VZXSAhPT0gU1RBVFVTX1VQREFUSU5HKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJDaGFydC5kaXNwYXRjaEFjdGlvbihhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ29ubmVjdGVkQ2hhcnRzU3RhdHVzKG90aGVyQ2hhcnRzLCBTVEFUVVNfVVBEQVRFRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SFRNTERvbUVsZW1lbnR9IGRvbVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbdGhlbWVdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKi9cbiAgICBlY2hhcnRzLmluaXQgPSBmdW5jdGlvbiAoZG9tLCB0aGVtZSwgb3B0cykge1xuICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgLy8gQ2hlY2sgdmVyc2lvblxuICAgICAgICAgICAgaWYgKCh6cmVuZGVyLnZlcnNpb24ucmVwbGFjZSgnLicsICcnKSAtIDApIDwgKGVjaGFydHMuZGVwZW5kZW5jaWVzLnpyZW5kZXIucmVwbGFjZSgnLicsICcnKSAtIDApKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnWlJlbmRlciAnICsgenJlbmRlci52ZXJzaW9uXG4gICAgICAgICAgICAgICAgICAgICsgJyBpcyB0b28gb2xkIGZvciBFQ2hhcnRzICcgKyBlY2hhcnRzLnZlcnNpb25cbiAgICAgICAgICAgICAgICAgICAgKyAnLiBDdXJyZW50IHZlcnNpb24gbmVlZCBaUmVuZGVyICdcbiAgICAgICAgICAgICAgICAgICAgKyBlY2hhcnRzLmRlcGVuZGVuY2llcy56cmVuZGVyICsgJysnXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZG9tKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbml0aWFsaXplIGZhaWxlZDogaW52YWxpZCBkb20uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoenJVdGlsLmlzRG9tKGRvbSkgJiYgZG9tLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgIT09ICdDQU5WQVMnICYmICghZG9tLmNsaWVudFdpZHRoIHx8ICFkb20uY2xpZW50SGVpZ2h0KSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQ2FuXFwndCBnZXQgZG9tIHdpZHRoIG9yIGhlaWdodCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoYXJ0ID0gbmV3IEVDaGFydHMoZG9tLCB0aGVtZSwgb3B0cyk7XG4gICAgICAgIGNoYXJ0LmlkID0gJ2VjXycgKyBpZEJhc2UrKztcbiAgICAgICAgaW5zdGFuY2VzW2NoYXJ0LmlkXSA9IGNoYXJ0O1xuXG4gICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUgJiZcbiAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoRE9NX0FUVFJJQlVURV9LRVksIGNoYXJ0LmlkKTtcblxuICAgICAgICBlbmFibGVDb25uZWN0KGNoYXJ0KTtcblxuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ3xBcnJheS48bW9kdWxlOmVjaGFydHN+RUNoYXJ0cz59IGdyb3VwSWRcbiAgICAgKi9cbiAgICBlY2hhcnRzLmNvbm5lY3QgPSBmdW5jdGlvbiAoZ3JvdXBJZCkge1xuICAgICAgICAvLyBJcyBhcnJheSBvZiBjaGFydHNcbiAgICAgICAgaWYgKHpyVXRpbC5pc0FycmF5KGdyb3VwSWQpKSB7XG4gICAgICAgICAgICB2YXIgY2hhcnRzID0gZ3JvdXBJZDtcbiAgICAgICAgICAgIGdyb3VwSWQgPSBudWxsO1xuICAgICAgICAgICAgLy8gSWYgYW55IGNoYXJ0IGhhcyBncm91cFxuICAgICAgICAgICAgenJVdGlsLmVhY2goY2hhcnRzLCBmdW5jdGlvbiAoY2hhcnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQuZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBncm91cElkID0gY2hhcnQuZ3JvdXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBncm91cElkID0gZ3JvdXBJZCB8fCAoJ2dfJyArIGdyb3VwSWRCYXNlKyspO1xuICAgICAgICAgICAgenJVdGlsLmVhY2goY2hhcnRzLCBmdW5jdGlvbiAoY2hhcnQpIHtcbiAgICAgICAgICAgICAgICBjaGFydC5ncm91cCA9IGdyb3VwSWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0ZWRHcm91cHNbZ3JvdXBJZF0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gZ3JvdXBJZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBncm91cElkXG4gICAgICovXG4gICAgZWNoYXJ0cy5kaXNDb25uZWN0ID0gZnVuY3Rpb24gKGdyb3VwSWQpIHtcbiAgICAgICAgY29ubmVjdGVkR3JvdXBzW2dyb3VwSWRdID0gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERpc3Bvc2UgYSBjaGFydCBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzfkVDaGFydHN8SFRNTERvbUVsZW1lbnR8c3RyaW5nfSBjaGFydFxuICAgICAqL1xuICAgIGVjaGFydHMuZGlzcG9zZSA9IGZ1bmN0aW9uIChjaGFydCkge1xuICAgICAgICBpZiAoenJVdGlsLmlzRG9tKGNoYXJ0KSkge1xuICAgICAgICAgICAgY2hhcnQgPSBlY2hhcnRzLmdldEluc3RhbmNlQnlEb20oY2hhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjaGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNoYXJ0ID0gaW5zdGFuY2VzW2NoYXJ0XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGNoYXJ0IGluc3RhbmNlb2YgRUNoYXJ0cykgJiYgIWNoYXJ0LmlzRGlzcG9zZWQoKSkge1xuICAgICAgICAgICAgY2hhcnQuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSAge0hUTUxEb21FbGVtZW50fSBkb21cbiAgICAgKiBAcmV0dXJuIHtlY2hhcnRzfkVDaGFydHN9XG4gICAgICovXG4gICAgZWNoYXJ0cy5nZXRJbnN0YW5jZUJ5RG9tID0gZnVuY3Rpb24gKGRvbSkge1xuICAgICAgICB2YXIga2V5ID0gZG9tLmdldEF0dHJpYnV0ZShET01fQVRUUklCVVRFX0tFWSk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZXNba2V5XTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcmV0dXJuIHtlY2hhcnRzfkVDaGFydHN9XG4gICAgICovXG4gICAgZWNoYXJ0cy5nZXRJbnN0YW5jZUJ5SWQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZXNba2V5XTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgdGhlbWVcbiAgICAgKi9cbiAgICBlY2hhcnRzLnJlZ2lzdGVyVGhlbWUgPSBmdW5jdGlvbiAobmFtZSwgdGhlbWUpIHtcbiAgICAgICAgdGhlbWVTdG9yYWdlW25hbWVdID0gdGhlbWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIG9wdGlvbiBwcmVwcm9jZXNzb3JcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVwcm9jZXNzb3JGdW5jXG4gICAgICovXG4gICAgZWNoYXJ0cy5yZWdpc3RlclByZXByb2Nlc3NvciA9IGZ1bmN0aW9uIChwcmVwcm9jZXNzb3JGdW5jKSB7XG4gICAgICAgIG9wdGlvblByZXByb2Nlc3NvckZ1bmNzLnB1c2gocHJlcHJvY2Vzc29yRnVuYyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJpb3JpdHk9MTAwMF1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcm9jZXNzb3JGdW5jXG4gICAgICovXG4gICAgZWNoYXJ0cy5yZWdpc3RlclByb2Nlc3NvciA9IGZ1bmN0aW9uIChwcmlvcml0eSwgcHJvY2Vzc29yRnVuYykge1xuICAgICAgICBpZiAodHlwZW9mIHByaW9yaXR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBwcm9jZXNzb3JGdW5jID0gcHJpb3JpdHk7XG4gICAgICAgICAgICBwcmlvcml0eSA9IFBSSU9SSVRZX1BST0NFU1NPUl9GSUxURVI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgIGlmIChpc05hTihwcmlvcml0eSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua293biBwcm9jZXNzb3IgcHJpb3JpdHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkYXRhUHJvY2Vzc29yRnVuY3MucHVzaCh7XG4gICAgICAgICAgICBwcmlvOiBwcmlvcml0eSxcbiAgICAgICAgICAgIGZ1bmM6IHByb2Nlc3NvckZ1bmNcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVzYWdlOlxuICAgICAqIHJlZ2lzdGVyQWN0aW9uKCdzb21lQWN0aW9uJywgJ3NvbWVFdmVudCcsIGZ1bmN0aW9uICgpIHsgLi4uIH0pO1xuICAgICAqIHJlZ2lzdGVyQWN0aW9uKCdzb21lQWN0aW9uJywgZnVuY3Rpb24gKCkgeyAuLi4gfSk7XG4gICAgICogcmVnaXN0ZXJBY3Rpb24oXG4gICAgICogICAgIHt0eXBlOiAnc29tZUFjdGlvbicsIGV2ZW50OiAnc29tZUV2ZW50JywgdXBkYXRlOiAndXBkYXRlVmlldyd9LFxuICAgICAqICAgICBmdW5jdGlvbiAoKSB7IC4uLiB9XG4gICAgICogKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3xPYmplY3QpfSBhY3Rpb25JbmZvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjdGlvbkluZm8udHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYWN0aW9uSW5mby5ldmVudF1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2FjdGlvbkluZm8udXBkYXRlXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZXZlbnROYW1lXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjdGlvblxuICAgICAqL1xuICAgIGVjaGFydHMucmVnaXN0ZXJBY3Rpb24gPSBmdW5jdGlvbiAoYWN0aW9uSW5mbywgZXZlbnROYW1lLCBhY3Rpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBldmVudE5hbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IGV2ZW50TmFtZTtcbiAgICAgICAgICAgIGV2ZW50TmFtZSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhY3Rpb25UeXBlID0genJVdGlsLmlzT2JqZWN0KGFjdGlvbkluZm8pXG4gICAgICAgICAgICA/IGFjdGlvbkluZm8udHlwZVxuICAgICAgICAgICAgOiAoW2FjdGlvbkluZm8sIGFjdGlvbkluZm8gPSB7XG4gICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50TmFtZVxuICAgICAgICAgICAgfV1bMF0pO1xuXG4gICAgICAgIC8vIEV2ZW50IG5hbWUgaXMgYWxsIGxvd2VyY2FzZVxuICAgICAgICBhY3Rpb25JbmZvLmV2ZW50ID0gKGFjdGlvbkluZm8uZXZlbnQgfHwgYWN0aW9uVHlwZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgZXZlbnROYW1lID0gYWN0aW9uSW5mby5ldmVudDtcblxuICAgICAgICBpZiAoIWFjdGlvbnNbYWN0aW9uVHlwZV0pIHtcbiAgICAgICAgICAgIGFjdGlvbnNbYWN0aW9uVHlwZV0gPSB7YWN0aW9uOiBhY3Rpb24sIGFjdGlvbkluZm86IGFjdGlvbkluZm99O1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50QWN0aW9uTWFwW2V2ZW50TmFtZV0gPSBhY3Rpb25UeXBlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSB7Kn0gQ29vcmRpbmF0ZVN5c3RlbVxuICAgICAqL1xuICAgIGVjaGFydHMucmVnaXN0ZXJDb29yZGluYXRlU3lzdGVtID0gZnVuY3Rpb24gKHR5cGUsIENvb3JkaW5hdGVTeXN0ZW0pIHtcbiAgICAgICAgQ29vcmRpbmF0ZVN5c3RlbU1hbmFnZXIucmVnaXN0ZXIodHlwZSwgQ29vcmRpbmF0ZVN5c3RlbSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIExheW91dCBpcyBhIHNwZWNpYWwgc3RhZ2Ugb2YgdmlzdWFsIGVuY29kaW5nXG4gICAgICogTW9zdCB2aXN1YWwgZW5jb2RpbmcgbGlrZSBjb2xvciBhcmUgY29tbW9uIGZvciBkaWZmZXJlbnQgY2hhcnRcbiAgICAgKiBCdXQgZWFjaCBjaGFydCBoYXMgaXQncyBvd24gbGF5b3V0IGFsZ29yaXRobVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmlvcml0eT0xMDAwXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxheW91dEZ1bmNcbiAgICAgKi9cbiAgICBlY2hhcnRzLnJlZ2lzdGVyTGF5b3V0ID0gZnVuY3Rpb24gKHByaW9yaXR5LCBsYXlvdXRGdW5jKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJpb3JpdHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGxheW91dEZ1bmMgPSBwcmlvcml0eTtcbiAgICAgICAgICAgIHByaW9yaXR5ID0gUFJJT1JJVFlfVklTVUFMX0xBWU9VVDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgaWYgKGlzTmFOKHByaW9yaXR5KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rb3duIGxheW91dCBwcmlvcml0eScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZpc3VhbEZ1bmNzLnB1c2goe1xuICAgICAgICAgICAgcHJpbzogcHJpb3JpdHksXG4gICAgICAgICAgICBmdW5jOiBsYXlvdXRGdW5jLFxuICAgICAgICAgICAgaXNMYXlvdXQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJpb3JpdHk9MzAwMF1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB2aXN1YWxGdW5jXG4gICAgICovXG4gICAgZWNoYXJ0cy5yZWdpc3RlclZpc3VhbCA9IGZ1bmN0aW9uIChwcmlvcml0eSwgdmlzdWFsRnVuYykge1xuICAgICAgICBpZiAodHlwZW9mIHByaW9yaXR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2aXN1YWxGdW5jID0gcHJpb3JpdHk7XG4gICAgICAgICAgICBwcmlvcml0eSA9IFBSSU9SSVRZX1ZJU1VBTF9DSEFSVDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgaWYgKGlzTmFOKHByaW9yaXR5KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rb3duIHZpc3VhbCBwcmlvcml0eScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZpc3VhbEZ1bmNzLnB1c2goe1xuICAgICAgICAgICAgcHJpbzogcHJpb3JpdHksXG4gICAgICAgICAgICBmdW5jOiB2aXN1YWxGdW5jXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqL1xuICAgIGVjaGFydHMucmVnaXN0ZXJMb2FkaW5nID0gZnVuY3Rpb24gKG5hbWUsIGxvYWRpbmdGeCkge1xuICAgICAgICBsb2FkaW5nRWZmZWN0c1tuYW1lXSA9IGxvYWRpbmdGeDtcbiAgICB9O1xuXG5cbiAgICB2YXIgcGFyc2VDbGFzc1R5cGUgPSBDb21wb25lbnRNb2RlbC5wYXJzZUNsYXNzVHlwZTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3VwZXJDbGFzc11cbiAgICAgKi9cbiAgICBlY2hhcnRzLmV4dGVuZENvbXBvbmVudE1vZGVsID0gZnVuY3Rpb24gKG9wdHMsIHN1cGVyQ2xhc3MpIHtcbiAgICAgICAgdmFyIENsYXp6ID0gQ29tcG9uZW50TW9kZWw7XG4gICAgICAgIGlmIChzdXBlckNsYXNzKSB7XG4gICAgICAgICAgICB2YXIgY2xhc3NUeXBlID0gcGFyc2VDbGFzc1R5cGUoc3VwZXJDbGFzcyk7XG4gICAgICAgICAgICBDbGF6eiA9IENvbXBvbmVudE1vZGVsLmdldENsYXNzKGNsYXNzVHlwZS5tYWluLCBjbGFzc1R5cGUuc3ViLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ2xhenouZXh0ZW5kKG9wdHMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3VwZXJDbGFzc11cbiAgICAgKi9cbiAgICBlY2hhcnRzLmV4dGVuZENvbXBvbmVudFZpZXcgPSBmdW5jdGlvbiAob3B0cywgc3VwZXJDbGFzcykge1xuICAgICAgICB2YXIgQ2xhenogPSBDb21wb25lbnRWaWV3O1xuICAgICAgICBpZiAoc3VwZXJDbGFzcykge1xuICAgICAgICAgICAgdmFyIGNsYXNzVHlwZSA9IHBhcnNlQ2xhc3NUeXBlKHN1cGVyQ2xhc3MpO1xuICAgICAgICAgICAgQ2xhenogPSBDb21wb25lbnRWaWV3LmdldENsYXNzKGNsYXNzVHlwZS5tYWluLCBjbGFzc1R5cGUuc3ViLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ2xhenouZXh0ZW5kKG9wdHMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3VwZXJDbGFzc11cbiAgICAgKi9cbiAgICBlY2hhcnRzLmV4dGVuZFNlcmllc01vZGVsID0gZnVuY3Rpb24gKG9wdHMsIHN1cGVyQ2xhc3MpIHtcbiAgICAgICAgdmFyIENsYXp6ID0gU2VyaWVzTW9kZWw7XG4gICAgICAgIGlmIChzdXBlckNsYXNzKSB7XG4gICAgICAgICAgICBzdXBlckNsYXNzID0gJ3Nlcmllcy4nICsgc3VwZXJDbGFzcy5yZXBsYWNlKCdzZXJpZXMuJywgJycpO1xuICAgICAgICAgICAgdmFyIGNsYXNzVHlwZSA9IHBhcnNlQ2xhc3NUeXBlKHN1cGVyQ2xhc3MpO1xuICAgICAgICAgICAgQ2xhenogPSBTZXJpZXNNb2RlbC5nZXRDbGFzcyhjbGFzc1R5cGUubWFpbiwgY2xhc3NUeXBlLnN1YiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENsYXp6LmV4dGVuZChvcHRzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N1cGVyQ2xhc3NdXG4gICAgICovXG4gICAgZWNoYXJ0cy5leHRlbmRDaGFydFZpZXcgPSBmdW5jdGlvbiAob3B0cywgc3VwZXJDbGFzcykge1xuICAgICAgICB2YXIgQ2xhenogPSBDaGFydFZpZXc7XG4gICAgICAgIGlmIChzdXBlckNsYXNzKSB7XG4gICAgICAgICAgICBzdXBlckNsYXNzLnJlcGxhY2UoJ3Nlcmllcy4nLCAnJyk7XG4gICAgICAgICAgICB2YXIgY2xhc3NUeXBlID0gcGFyc2VDbGFzc1R5cGUoc3VwZXJDbGFzcyk7XG4gICAgICAgICAgICBDbGF6eiA9IENoYXJ0Vmlldy5nZXRDbGFzcyhjbGFzc1R5cGUubWFpbiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENsYXp6LmV4dGVuZChvcHRzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogWlJlbmRlciBuZWVkIGEgY2FudmFzIGNvbnRleHQgdG8gZG8gbWVhc3VyZVRleHQuXG4gICAgICogQnV0IGluIG5vZGUgZW52aXJvbm1lbnQgY2FudmFzIG1heSBiZSBjcmVhdGVkIGJ5IG5vZGUtY2FudmFzLlxuICAgICAqIFNvIHdlIG5lZWQgdG8gc3BlY2lmeSBob3cgdG8gY3JlYXRlIGEgY2FudmFzIGluc3RlYWQgb2YgdXNpbmcgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICAgKlxuICAgICAqIEJlIGNhcmVmdWwgb2YgdXNpbmcgaXQgaW4gdGhlIGJyb3dzZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjcmVhdG9yXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgdmFyIENhbnZhcyA9IHJlcXVpcmUoJ2NhbnZhcycpO1xuICAgICAqICAgICB2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoJ2VjaGFydHMnKTtcbiAgICAgKiAgICAgZWNoYXJ0cy5zZXRDYW52YXNDcmVhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgKiAgICAgICAgIC8vIFNtYWxsIHNpemUgaXMgZW5vdWdoLlxuICAgICAqICAgICAgICAgcmV0dXJuIG5ldyBDYW52YXMoMzIsIDMyKTtcbiAgICAgKiAgICAgfSk7XG4gICAgICovXG4gICAgZWNoYXJ0cy5zZXRDYW52YXNDcmVhdG9yID0gZnVuY3Rpb24gKGNyZWF0b3IpIHtcbiAgICAgICAgenJVdGlsLmNyZWF0ZUNhbnZhcyA9IGNyZWF0b3I7XG4gICAgfTtcblxuICAgIGVjaGFydHMucmVnaXN0ZXJWaXN1YWwoUFJJT1JJVFlfVklTVUFMX0dMT0JBTCwgcmVxdWlyZSgnLi92aXN1YWwvc2VyaWVzQ29sb3InKSk7XG4gICAgZWNoYXJ0cy5yZWdpc3RlclByZXByb2Nlc3NvcihyZXF1aXJlKCcuL3ByZXByb2Nlc3Nvci9iYWNrd2FyZENvbXBhdCcpKTtcbiAgICBlY2hhcnRzLnJlZ2lzdGVyTG9hZGluZygnZGVmYXVsdCcsIHJlcXVpcmUoJy4vbG9hZGluZy9kZWZhdWx0JykpO1xuXG4gICAgLy8gRGVmYXVsdCBhY3Rpb25cbiAgICBlY2hhcnRzLnJlZ2lzdGVyQWN0aW9uKHtcbiAgICAgICAgdHlwZTogJ2hpZ2hsaWdodCcsXG4gICAgICAgIGV2ZW50OiAnaGlnaGxpZ2h0JyxcbiAgICAgICAgdXBkYXRlOiAnaGlnaGxpZ2h0J1xuICAgIH0sIHpyVXRpbC5ub29wKTtcbiAgICBlY2hhcnRzLnJlZ2lzdGVyQWN0aW9uKHtcbiAgICAgICAgdHlwZTogJ2Rvd25wbGF5JyxcbiAgICAgICAgZXZlbnQ6ICdkb3ducGxheScsXG4gICAgICAgIHVwZGF0ZTogJ2Rvd25wbGF5J1xuICAgIH0sIHpyVXRpbC5ub29wKTtcblxuXG4gICAgLy8gLS0tLS0tLS1cbiAgICAvLyBFeHBvcnRzXG4gICAgLy8gLS0tLS0tLS1cbiAgICAvL1xuICAgIGVjaGFydHMuTGlzdCA9IHJlcXVpcmUoJy4vZGF0YS9MaXN0Jyk7XG4gICAgZWNoYXJ0cy5Nb2RlbCA9IHJlcXVpcmUoJy4vbW9kZWwvTW9kZWwnKTtcblxuICAgIGVjaGFydHMuZ3JhcGhpYyA9IHJlcXVpcmUoJy4vdXRpbC9ncmFwaGljJyk7XG4gICAgZWNoYXJ0cy5udW1iZXIgPSByZXF1aXJlKCcuL3V0aWwvbnVtYmVyJyk7XG4gICAgZWNoYXJ0cy5mb3JtYXQgPSByZXF1aXJlKCcuL3V0aWwvZm9ybWF0Jyk7XG4gICAgZWNoYXJ0cy5tYXRyaXggPSByZXF1aXJlKCd6cmVuZGVyL2NvcmUvbWF0cml4Jyk7XG4gICAgZWNoYXJ0cy52ZWN0b3IgPSByZXF1aXJlKCd6cmVuZGVyL2NvcmUvdmVjdG9yJyk7XG4gICAgZWNoYXJ0cy5jb2xvciA9IHJlcXVpcmUoJ3pyZW5kZXIvdG9vbC9jb2xvcicpO1xuXG4gICAgZWNoYXJ0cy51dGlsID0ge307XG4gICAgZWFjaChbXG4gICAgICAgICAgICAnbWFwJywgJ2VhY2gnLCAnZmlsdGVyJywgJ2luZGV4T2YnLCAnaW5oZXJpdHMnLFxuICAgICAgICAgICAgJ3JlZHVjZScsICdmaWx0ZXInLCAnYmluZCcsICdjdXJyeScsICdpc0FycmF5JyxcbiAgICAgICAgICAgICdpc1N0cmluZycsICdpc09iamVjdCcsICdpc0Z1bmN0aW9uJywgJ2V4dGVuZCcsICdkZWZhdWx0cydcbiAgICAgICAgXSxcbiAgICAgICAgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGVjaGFydHMudXRpbFtuYW1lXSA9IHpyVXRpbFtuYW1lXTtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGVjaGFydHMuUFJJT1JJVFkgPSB7XG4gICAgICAgIFBST0NFU1NPUjoge1xuICAgICAgICAgICAgRklMVEVSOiBQUklPUklUWV9QUk9DRVNTT1JfRklMVEVSLFxuICAgICAgICAgICAgU1RBVElTVElDOiBQUklPUklUWV9QUk9DRVNTT1JfU1RBVElTVElDXG4gICAgICAgIH0sXG4gICAgICAgIFZJU1VBTDoge1xuICAgICAgICAgICAgTEFZT1VUOiBQUklPUklUWV9WSVNVQUxfTEFZT1VULFxuICAgICAgICAgICAgR0xPQkFMOiBQUklPUklUWV9WSVNVQUxfR0xPQkFMLFxuICAgICAgICAgICAgQ0hBUlQ6IFBSSU9SSVRZX1ZJU1VBTF9DSEFSVCxcbiAgICAgICAgICAgIENPTVBPTkVOVDogUFJJT1JJVFlfVklTVUFMX0NPTVBPTkVOVCxcbiAgICAgICAgICAgIEJSVVNIOiBQUklPUklUWV9WSVNVQUxfQlJVU0hcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZWNoYXJ0cztcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvZWNoYXJ0cy9lY2hhcnRzLmpzXG4gKiogbW9kdWxlIGlkID0gNVxuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiLyoqXG4gKiBlY2hhcnRz6K6+5aSH546v5aKD6K+G5YirXG4gKlxuICogQGRlc2MgZWNoYXJ0c+WfuuS6jkNhbnZhc++8jOe6r0phdmFzY3JpcHTlm77ooajlupPvvIzmj5Dkvpvnm7Top4LvvIznlJ/liqjvvIzlj6/kuqTkupLvvIzlj6/kuKrmgKfljJblrprliLbnmoTmlbDmja7nu5/orqHlm77ooajjgIJcbiAqIEBhdXRob3IgZmlyZWRlW2ZpcmVkZUBmaXJlZGUudXNdXG4gKiBAZGVzYyB0aGFua3MgemVwdG8uXG4gKi9cbmRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVudiA9IHt9O1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBJbiBub2RlXG4gICAgICAgIGVudiA9IHtcbiAgICAgICAgICAgIGJyb3dzZXI6IHt9LFxuICAgICAgICAgICAgb3M6IHt9LFxuICAgICAgICAgICAgbm9kZTogdHJ1ZSxcbiAgICAgICAgICAgIC8vIEFzc3VtZSBjYW52YXMgaXMgc3VwcG9ydGVkXG4gICAgICAgICAgICBjYW52YXNTdXBwb3J0ZWQ6IHRydWVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVudiA9IGRldGVjdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW52O1xuXG4gICAgLy8gWmVwdG8uanNcbiAgICAvLyAoYykgMjAxMC0yMDEzIFRob21hcyBGdWNoc1xuICAgIC8vIFplcHRvLmpzIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG4gICAgZnVuY3Rpb24gZGV0ZWN0KHVhKSB7XG4gICAgICAgIHZhciBvcyA9IHt9O1xuICAgICAgICB2YXIgYnJvd3NlciA9IHt9O1xuICAgICAgICAvLyB2YXIgd2Via2l0ID0gdWEubWF0Y2goL1dlYltrS11pdFtcXC9dezAsMX0oW1xcZC5dKykvKTtcbiAgICAgICAgLy8gdmFyIGFuZHJvaWQgPSB1YS5tYXRjaCgvKEFuZHJvaWQpOz9bXFxzXFwvXSsoW1xcZC5dKyk/Lyk7XG4gICAgICAgIC8vIHZhciBpcGFkID0gdWEubWF0Y2goLyhpUGFkKS4qT1NcXHMoW1xcZF9dKykvKTtcbiAgICAgICAgLy8gdmFyIGlwb2QgPSB1YS5tYXRjaCgvKGlQb2QpKC4qT1NcXHMoW1xcZF9dKykpPy8pO1xuICAgICAgICAvLyB2YXIgaXBob25lID0gIWlwYWQgJiYgdWEubWF0Y2goLyhpUGhvbmVcXHNPUylcXHMoW1xcZF9dKykvKTtcbiAgICAgICAgLy8gdmFyIHdlYm9zID0gdWEubWF0Y2goLyh3ZWJPU3xocHdPUylbXFxzXFwvXShbXFxkLl0rKS8pO1xuICAgICAgICAvLyB2YXIgdG91Y2hwYWQgPSB3ZWJvcyAmJiB1YS5tYXRjaCgvVG91Y2hQYWQvKTtcbiAgICAgICAgLy8gdmFyIGtpbmRsZSA9IHVhLm1hdGNoKC9LaW5kbGVcXC8oW1xcZC5dKykvKTtcbiAgICAgICAgLy8gdmFyIHNpbGsgPSB1YS5tYXRjaCgvU2lsa1xcLyhbXFxkLl9dKykvKTtcbiAgICAgICAgLy8gdmFyIGJsYWNrYmVycnkgPSB1YS5tYXRjaCgvKEJsYWNrQmVycnkpLipWZXJzaW9uXFwvKFtcXGQuXSspLyk7XG4gICAgICAgIC8vIHZhciBiYjEwID0gdWEubWF0Y2goLyhCQjEwKS4qVmVyc2lvblxcLyhbXFxkLl0rKS8pO1xuICAgICAgICAvLyB2YXIgcmltdGFibGV0b3MgPSB1YS5tYXRjaCgvKFJJTVxcc1RhYmxldFxcc09TKVxccyhbXFxkLl0rKS8pO1xuICAgICAgICAvLyB2YXIgcGxheWJvb2sgPSB1YS5tYXRjaCgvUGxheUJvb2svKTtcbiAgICAgICAgLy8gdmFyIGNocm9tZSA9IHVhLm1hdGNoKC9DaHJvbWVcXC8oW1xcZC5dKykvKSB8fCB1YS5tYXRjaCgvQ3JpT1NcXC8oW1xcZC5dKykvKTtcbiAgICAgICAgdmFyIGZpcmVmb3ggPSB1YS5tYXRjaCgvRmlyZWZveFxcLyhbXFxkLl0rKS8pO1xuICAgICAgICAvLyB2YXIgc2FmYXJpID0gd2Via2l0ICYmIHVhLm1hdGNoKC9Nb2JpbGVcXC8vKSAmJiAhY2hyb21lO1xuICAgICAgICAvLyB2YXIgd2VidmlldyA9IHVhLm1hdGNoKC8oaVBob25lfGlQb2R8aVBhZCkuKkFwcGxlV2ViS2l0KD8hLipTYWZhcmkpLykgJiYgIWNocm9tZTtcbiAgICAgICAgdmFyIGllID0gdWEubWF0Y2goL01TSUVcXHMoW1xcZC5dKykvKVxuICAgICAgICAgICAgLy8gSUUgMTEgVHJpZGVudC83LjA7IHJ2OjExLjBcbiAgICAgICAgICAgIHx8IHVhLm1hdGNoKC9UcmlkZW50XFwvLis/cnY6KChbXFxkLl0rKSkvKTtcbiAgICAgICAgdmFyIGVkZ2UgPSB1YS5tYXRjaCgvRWRnZVxcLyhbXFxkLl0rKS8pOyAvLyBJRSAxMiBhbmQgMTIrXG5cbiAgICAgICAgLy8gVG9kbzogY2xlYW4gdGhpcyB1cCB3aXRoIGEgYmV0dGVyIE9TL2Jyb3dzZXIgc2VwZXJhdGlvbjpcbiAgICAgICAgLy8gLSBkaXNjZXJuIChtb3JlKSBiZXR3ZWVuIG11bHRpcGxlIGJyb3dzZXJzIG9uIGFuZHJvaWRcbiAgICAgICAgLy8gLSBkZWNpZGUgaWYga2luZGxlIGZpcmUgaW4gc2lsayBtb2RlIGlzIGFuZHJvaWQgb3Igbm90XG4gICAgICAgIC8vIC0gRmlyZWZveCBvbiBBbmRyb2lkIGRvZXNuJ3Qgc3BlY2lmeSB0aGUgQW5kcm9pZCB2ZXJzaW9uXG4gICAgICAgIC8vIC0gcG9zc2libHkgZGV2aWRlIGluIG9zLCBkZXZpY2UgYW5kIGJyb3dzZXIgaGFzaGVzXG5cbiAgICAgICAgLy8gaWYgKGJyb3dzZXIud2Via2l0ID0gISF3ZWJraXQpIGJyb3dzZXIudmVyc2lvbiA9IHdlYmtpdFsxXTtcblxuICAgICAgICAvLyBpZiAoYW5kcm9pZCkgb3MuYW5kcm9pZCA9IHRydWUsIG9zLnZlcnNpb24gPSBhbmRyb2lkWzJdO1xuICAgICAgICAvLyBpZiAoaXBob25lICYmICFpcG9kKSBvcy5pb3MgPSBvcy5pcGhvbmUgPSB0cnVlLCBvcy52ZXJzaW9uID0gaXBob25lWzJdLnJlcGxhY2UoL18vZywgJy4nKTtcbiAgICAgICAgLy8gaWYgKGlwYWQpIG9zLmlvcyA9IG9zLmlwYWQgPSB0cnVlLCBvcy52ZXJzaW9uID0gaXBhZFsyXS5yZXBsYWNlKC9fL2csICcuJyk7XG4gICAgICAgIC8vIGlmIChpcG9kKSBvcy5pb3MgPSBvcy5pcG9kID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGlwb2RbM10gPyBpcG9kWzNdLnJlcGxhY2UoL18vZywgJy4nKSA6IG51bGw7XG4gICAgICAgIC8vIGlmICh3ZWJvcykgb3Mud2Vib3MgPSB0cnVlLCBvcy52ZXJzaW9uID0gd2Vib3NbMl07XG4gICAgICAgIC8vIGlmICh0b3VjaHBhZCkgb3MudG91Y2hwYWQgPSB0cnVlO1xuICAgICAgICAvLyBpZiAoYmxhY2tiZXJyeSkgb3MuYmxhY2tiZXJyeSA9IHRydWUsIG9zLnZlcnNpb24gPSBibGFja2JlcnJ5WzJdO1xuICAgICAgICAvLyBpZiAoYmIxMCkgb3MuYmIxMCA9IHRydWUsIG9zLnZlcnNpb24gPSBiYjEwWzJdO1xuICAgICAgICAvLyBpZiAocmltdGFibGV0b3MpIG9zLnJpbXRhYmxldG9zID0gdHJ1ZSwgb3MudmVyc2lvbiA9IHJpbXRhYmxldG9zWzJdO1xuICAgICAgICAvLyBpZiAocGxheWJvb2spIGJyb3dzZXIucGxheWJvb2sgPSB0cnVlO1xuICAgICAgICAvLyBpZiAoa2luZGxlKSBvcy5raW5kbGUgPSB0cnVlLCBvcy52ZXJzaW9uID0ga2luZGxlWzFdO1xuICAgICAgICAvLyBpZiAoc2lsaykgYnJvd3Nlci5zaWxrID0gdHJ1ZSwgYnJvd3Nlci52ZXJzaW9uID0gc2lsa1sxXTtcbiAgICAgICAgLy8gaWYgKCFzaWxrICYmIG9zLmFuZHJvaWQgJiYgdWEubWF0Y2goL0tpbmRsZSBGaXJlLykpIGJyb3dzZXIuc2lsayA9IHRydWU7XG4gICAgICAgIC8vIGlmIChjaHJvbWUpIGJyb3dzZXIuY2hyb21lID0gdHJ1ZSwgYnJvd3Nlci52ZXJzaW9uID0gY2hyb21lWzFdO1xuICAgICAgICBpZiAoZmlyZWZveCkgYnJvd3Nlci5maXJlZm94ID0gdHJ1ZSwgYnJvd3Nlci52ZXJzaW9uID0gZmlyZWZveFsxXTtcbiAgICAgICAgLy8gaWYgKHNhZmFyaSAmJiAodWEubWF0Y2goL1NhZmFyaS8pIHx8ICEhb3MuaW9zKSkgYnJvd3Nlci5zYWZhcmkgPSB0cnVlO1xuICAgICAgICAvLyBpZiAod2VidmlldykgYnJvd3Nlci53ZWJ2aWV3ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGllKSB7XG4gICAgICAgICAgICBicm93c2VyLmllID0gdHJ1ZTsgYnJvd3Nlci52ZXJzaW9uID0gaWVbMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGllKSB7XG4gICAgICAgICAgICBicm93c2VyLmllID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyb3dzZXIudmVyc2lvbiA9IGllWzFdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlZGdlKSB7XG4gICAgICAgICAgICBicm93c2VyLmVkZ2UgPSB0cnVlO1xuICAgICAgICAgICAgYnJvd3Nlci52ZXJzaW9uID0gZWRnZVsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG9zLnRhYmxldCA9ICEhKGlwYWQgfHwgcGxheWJvb2sgfHwgKGFuZHJvaWQgJiYgIXVhLm1hdGNoKC9Nb2JpbGUvKSkgfHxcbiAgICAgICAgLy8gICAgIChmaXJlZm94ICYmIHVhLm1hdGNoKC9UYWJsZXQvKSkgfHwgKGllICYmICF1YS5tYXRjaCgvUGhvbmUvKSAmJiB1YS5tYXRjaCgvVG91Y2gvKSkpO1xuICAgICAgICAvLyBvcy5waG9uZSAgPSAhISghb3MudGFibGV0ICYmICFvcy5pcG9kICYmIChhbmRyb2lkIHx8IGlwaG9uZSB8fCB3ZWJvcyB8fFxuICAgICAgICAvLyAgICAgKGNocm9tZSAmJiB1YS5tYXRjaCgvQW5kcm9pZC8pKSB8fCAoY2hyb21lICYmIHVhLm1hdGNoKC9DcmlPU1xcLyhbXFxkLl0rKS8pKSB8fFxuICAgICAgICAvLyAgICAgKGZpcmVmb3ggJiYgdWEubWF0Y2goL01vYmlsZS8pKSB8fCAoaWUgJiYgdWEubWF0Y2goL1RvdWNoLykpKSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJyb3dzZXI6IGJyb3dzZXIsXG4gICAgICAgICAgICBvczogb3MsXG4gICAgICAgICAgICBub2RlOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIOWOn+eUn2NhbnZhc+aUr+aMge+8jOaUueaegeerr+eCueS6hlxuICAgICAgICAgICAgLy8gY2FudmFzU3VwcG9ydGVkIDogIShicm93c2VyLmllICYmIHBhcnNlRmxvYXQoYnJvd3Nlci52ZXJzaW9uKSA8IDkpXG4gICAgICAgICAgICBjYW52YXNTdXBwb3J0ZWQgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0ID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgICAgICAgLy8gQHNlZSA8aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80ODE3MDI5L3doYXRzLXRoZS1iZXN0LXdheS10by1kZXRlY3QtYS10b3VjaC1zY3JlZW4tZGV2aWNlLXVzaW5nLWphdmFzY3JpcHQ+XG4gICAgICAgICAgICAvLyB3b3JrcyBvbiBtb3N0IGJyb3dzZXJzXG4gICAgICAgICAgICAvLyBJRTEwLzExIGRvZXMgbm90IHN1cHBvcnQgdG91Y2ggZXZlbnQsIGFuZCBNUyBFZGdlIHN1cHBvcnRzIHRoZW0gYnV0IG5vdCBieVxuICAgICAgICAgICAgLy8gZGVmYXVsdCwgc28gd2UgZG9udCBjaGVjayBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgZm9yIHRoZW0gaGVyZS5cbiAgICAgICAgICAgIHRvdWNoRXZlbnRzU3VwcG9ydGVkOiAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgJiYgIWJyb3dzZXIuaWUgJiYgIWJyb3dzZXIuZWRnZSxcbiAgICAgICAgICAgIC8vIDxodHRwOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1wb2ludGVyJTIwZXZlbnQ+LlxuICAgICAgICAgICAgcG9pbnRlckV2ZW50c1N1cHBvcnRlZDogJ29ucG9pbnRlcmRvd24nIGluIHdpbmRvd1xuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggc3VwcG9ydHMgcG9pbnRlciBidXQgbm90IGJ5IGRlZmF1bHQsXG4gICAgICAgICAgICAgICAgLy8gb25seSBNUyBicm93c2VycyBhcmUgcmVsaWFibGUgb24gcG9pbnRlciBldmVudHMgY3VycmVudGx5LlxuICAgICAgICAgICAgICAgICYmIChicm93c2VyLmVkZ2UgfHwgKGJyb3dzZXIuaWUgJiYgYnJvd3Nlci52ZXJzaW9uID49IDEwKSlcbiAgICAgICAgfTtcbiAgICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL3pyZW5kZXIvY29yZS9lbnYuanNcbiAqKiBtb2R1bGUgaWQgPSA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCIvKipcbiAqIEVDaGFydHMgZ2xvYmFsIG1vZGVsXG4gKlxuICogQG1vZHVsZSB7ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9XG4gKlxuICovXG5cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvY29yZS91dGlsJyk7XG4gICAgdmFyIG1vZGVsVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvbW9kZWwnKTtcbiAgICB2YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyk7XG4gICAgdmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbiAgICB2YXIgZmlsdGVyID0genJVdGlsLmZpbHRlcjtcbiAgICB2YXIgbWFwID0genJVdGlsLm1hcDtcbiAgICB2YXIgaXNBcnJheSA9IHpyVXRpbC5pc0FycmF5O1xuICAgIHZhciBpbmRleE9mID0genJVdGlsLmluZGV4T2Y7XG4gICAgdmFyIGlzT2JqZWN0ID0genJVdGlsLmlzT2JqZWN0O1xuXG4gICAgdmFyIENvbXBvbmVudE1vZGVsID0gcmVxdWlyZSgnLi9Db21wb25lbnQnKTtcblxuICAgIHZhciBnbG9iYWxEZWZhdWx0ID0gcmVxdWlyZSgnLi9nbG9iYWxEZWZhdWx0Jyk7XG5cbiAgICB2YXIgT1BUSU9OX0lOTkVSX0tFWSA9ICdcXDBfZWNfaW5uZXInO1xuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbFxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvblxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IHBhcmVudE1vZGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRoZW1lXG4gICAgICovXG4gICAgdmFyIEdsb2JhbE1vZGVsID0gTW9kZWwuZXh0ZW5kKHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogR2xvYmFsTW9kZWwsXG5cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKG9wdGlvbiwgcGFyZW50TW9kZWwsIHRoZW1lLCBvcHRpb25NYW5hZ2VyKSB7XG4gICAgICAgICAgICB0aGVtZSA9IHRoZW1lIHx8IHt9O1xuXG4gICAgICAgICAgICB0aGlzLm9wdGlvbiA9IG51bGw7IC8vIE1hcmsgYXMgbm90IGluaXRpYWxpemVkLlxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH1cbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX3RoZW1lID0gbmV3IE1vZGVsKHRoZW1lKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvT3B0aW9uTWFuYWdlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fb3B0aW9uTWFuYWdlciA9IG9wdGlvbk1hbmFnZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0T3B0aW9uOiBmdW5jdGlvbiAob3B0aW9uLCBvcHRpb25QcmVwcm9jZXNzb3JGdW5jcykge1xuICAgICAgICAgICAgenJVdGlsLmFzc2VydChcbiAgICAgICAgICAgICAgICAhKE9QVElPTl9JTk5FUl9LRVkgaW4gb3B0aW9uKSxcbiAgICAgICAgICAgICAgICAncGxlYXNlIHVzZSBjaGFydC5nZXRPcHRpb24oKSdcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRoaXMuX29wdGlvbk1hbmFnZXIuc2V0T3B0aW9uKG9wdGlvbiwgb3B0aW9uUHJlcHJvY2Vzc29yRnVuY3MpO1xuXG4gICAgICAgICAgICB0aGlzLnJlc2V0T3B0aW9uKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIG51bGwvdW5kZWZpbmVkOiByZXNldCBhbGwuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICdyZWNyZWF0ZSc6IGZvcmNlIHJlY3JlYXRlIGFsbC5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgJ3RpbWVsaW5lJzogb25seSByZXNldCB0aW1lbGluZSBvcHRpb25cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgJ21lZGlhJzogb25seSByZXNldCBtZWRpYSBxdWVyeSBvcHRpb25cbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvcHRpb24gY2hhbmdlZC5cbiAgICAgICAgICovXG4gICAgICAgIHJlc2V0T3B0aW9uOiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBvcHRpb25NYW5hZ2VyID0gdGhpcy5fb3B0aW9uTWFuYWdlcjtcblxuICAgICAgICAgICAgaWYgKCF0eXBlIHx8IHR5cGUgPT09ICdyZWNyZWF0ZScpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmFzZU9wdGlvbiA9IG9wdGlvbk1hbmFnZXIubW91bnRPcHRpb24odHlwZSA9PT0gJ3JlY3JlYXRlJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9uIHx8IHR5cGUgPT09ICdyZWNyZWF0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdEJhc2UuY2FsbCh0aGlzLCBiYXNlT3B0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdG9yZURhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXJnZU9wdGlvbihiYXNlT3B0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0aW9uQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlID09PSAndGltZWxpbmUnIHx8IHR5cGUgPT09ICdtZWRpYScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3RvcmVEYXRhKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdHlwZSB8fCB0eXBlID09PSAncmVjcmVhdGUnIHx8IHR5cGUgPT09ICd0aW1lbGluZScpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGltZWxpbmVPcHRpb24gPSBvcHRpb25NYW5hZ2VyLmdldFRpbWVsaW5lT3B0aW9uKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRpbWVsaW5lT3B0aW9uICYmICh0aGlzLm1lcmdlT3B0aW9uKHRpbWVsaW5lT3B0aW9uKSwgb3B0aW9uQ2hhbmdlZCA9IHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXR5cGUgfHwgdHlwZSA9PT0gJ3JlY3JlYXRlJyB8fCB0eXBlID09PSAnbWVkaWEnKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lZGlhT3B0aW9ucyA9IG9wdGlvbk1hbmFnZXIuZ2V0TWVkaWFPcHRpb24odGhpcywgdGhpcy5fYXBpKTtcbiAgICAgICAgICAgICAgICBpZiAobWVkaWFPcHRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBlYWNoKG1lZGlhT3B0aW9ucywgZnVuY3Rpb24gKG1lZGlhT3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lcmdlT3B0aW9uKG1lZGlhT3B0aW9uLCBvcHRpb25DaGFuZ2VkID0gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbkNoYW5nZWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIG1lcmdlT3B0aW9uOiBmdW5jdGlvbiAobmV3T3B0aW9uKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uID0gdGhpcy5vcHRpb247XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50c01hcCA9IHRoaXMuX2NvbXBvbmVudHNNYXA7XG4gICAgICAgICAgICB2YXIgbmV3Q3B0VHlwZXMgPSBbXTtcblxuICAgICAgICAgICAgLy8g5aaC5p6c5LiN5a2Y5Zyo5a+55bqU55qEIGNvbXBvbmVudCBtb2RlbCDliJnnm7TmjqUgbWVyZ2VcbiAgICAgICAgICAgIGVhY2gobmV3T3B0aW9uLCBmdW5jdGlvbiAoY29tcG9uZW50T3B0aW9uLCBtYWluVHlwZSkge1xuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnRPcHRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFDb21wb25lbnRNb2RlbC5oYXNDbGFzcyhtYWluVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uW21haW5UeXBlXSA9IG9wdGlvblttYWluVHlwZV0gPT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgPyB6clV0aWwuY2xvbmUoY29tcG9uZW50T3B0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB6clV0aWwubWVyZ2Uob3B0aW9uW21haW5UeXBlXSwgY29tcG9uZW50T3B0aW9uLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NwdFR5cGVzLnB1c2gobWFpblR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBGSVhNRSBPUFRJT04g5ZCM5q2l5piv5ZCm6KaB5pS55Zue5Y6f5p2l55qEXG4gICAgICAgICAgICBDb21wb25lbnRNb2RlbC50b3BvbG9naWNhbFRyYXZlbChcbiAgICAgICAgICAgICAgICBuZXdDcHRUeXBlcywgQ29tcG9uZW50TW9kZWwuZ2V0QWxsQ2xhc3NNYWluVHlwZXMoKSwgdmlzaXRDb21wb25lbnQsIHRoaXNcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRoaXMuX3Nlcmllc0luZGljZXMgPSB0aGlzLl9zZXJpZXNJbmRpY2VzIHx8IFtdO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiB2aXNpdENvbXBvbmVudChtYWluVHlwZSwgZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0NwdE9wdGlvbkxpc3QgPSBtb2RlbFV0aWwubm9ybWFsaXplVG9BcnJheShuZXdPcHRpb25bbWFpblR5cGVdKTtcblxuICAgICAgICAgICAgICAgIHZhciBtYXBSZXN1bHQgPSBtb2RlbFV0aWwubWFwcGluZ1RvRXhpc3RzKFxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzTWFwW21haW5UeXBlXSwgbmV3Q3B0T3B0aW9uTGlzdFxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBtYWtlS2V5SW5mbyhtYWluVHlwZSwgbWFwUmVzdWx0KTtcblxuICAgICAgICAgICAgICAgIHZhciBkZXBlbmRlbnRNb2RlbHMgPSBnZXRDb21wb25lbnRzQnlUeXBlcyhcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50c01hcCwgZGVwZW5kZW5jaWVzXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIG9wdGlvblttYWluVHlwZV0gPSBbXTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzTWFwW21haW5UeXBlXSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZWFjaChtYXBSZXN1bHQsIGZ1bmN0aW9uIChyZXN1bHRJdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50TW9kZWwgPSByZXN1bHRJdGVtLmV4aXN0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Q3B0T3B0aW9uID0gcmVzdWx0SXRlbS5vcHRpb247XG5cbiAgICAgICAgICAgICAgICAgICAgenJVdGlsLmFzc2VydChcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzT2JqZWN0KG5ld0NwdE9wdGlvbikgfHwgY29tcG9uZW50TW9kZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRW1wdHkgY29tcG9uZW50IGRlZmluaXRpb24nXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc2lkZXIgd2hlcmUgaXMgbm8gbmV3IG9wdGlvbiBhbmQgc2hvdWxkIGJlIG1lcmdlZCB1c2luZyB7fSxcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VlIHJlbW92ZUVkZ2VBbmRBZGQgaW4gdG9wb2xvZ2ljYWxUcmF2ZWwgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbXBvbmVudE1vZGVsLmdldEFsbENsYXNzTWFpblR5cGVzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld0NwdE9wdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50TW9kZWwubWVyZ2VPcHRpb24oe30sIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50TW9kZWwub3B0aW9uVXBkYXRlZCh7fSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIENvbXBvbmVudE1vZGVsQ2xhc3MgPSBDb21wb25lbnRNb2RlbC5nZXRDbGFzcyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluVHlwZSwgcmVzdWx0SXRlbS5rZXlJbmZvLnN1YlR5cGUsIHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnRNb2RlbCAmJiBjb21wb25lbnRNb2RlbCBpbnN0YW5jZW9mIENvbXBvbmVudE1vZGVsQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRNb2RlbC5tZXJnZU9wdGlvbihuZXdDcHRPcHRpb24sIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE1vZGVsLm9wdGlvblVwZGF0ZWQobmV3Q3B0T3B0aW9uLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQRU5ESU5HIEdsb2JhbCBhcyBwYXJlbnQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHRyYU9wdCA9IHpyVXRpbC5leHRlbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcGVuZGVudE1vZGVsczogZGVwZW5kZW50TW9kZWxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50SW5kZXg6IGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdEl0ZW0ua2V5SW5mb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50TW9kZWwgPSBuZXcgQ29tcG9uZW50TW9kZWxDbGFzcyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q3B0T3B0aW9uLCB0aGlzLCB0aGlzLCBleHRyYU9wdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50TW9kZWwuaW5pdChuZXdDcHRPcHRpb24sIHRoaXMsIHRoaXMsIGV4dHJhT3B0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIG9wdGlvblVwZGF0ZWQgYWZ0ZXIgaW5pdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXdDcHRPcHRpb24gaGFzIGJlZW4gdXNlZCBhcyBjb21wb25lbnRNb2RlbC5vcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgbWF5IGJlIG1lcmdlZCB3aXRoIHRoZW1lIGFuZCBkZWZhdWx0LCBzbyBwYXNzIG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBhdm9pZCBjb25mdXNpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50TW9kZWwub3B0aW9uVXBkYXRlZChudWxsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHNNYXBbbWFpblR5cGVdW2luZGV4XSA9IGNvbXBvbmVudE1vZGVsO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25bbWFpblR5cGVdW2luZGV4XSA9IGNvbXBvbmVudE1vZGVsLm9wdGlvbjtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgICAgIC8vIEJhY2t1cCBzZXJpZXMgZm9yIGZpbHRlcmluZy5cbiAgICAgICAgICAgICAgICBpZiAobWFpblR5cGUgPT09ICdzZXJpZXMnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Nlcmllc0luZGljZXMgPSBjcmVhdGVTZXJpZXNJbmRpY2VzKGNvbXBvbmVudHNNYXAuc2VyaWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBvcHRpb24gZm9yIG91dHB1dCAoY2xvbmVkIG9wdGlvbiBhbmQgaW5uZXIgaW5mbyByZW1vdmVkKVxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGdldE9wdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbiA9IHpyVXRpbC5jbG9uZSh0aGlzLm9wdGlvbik7XG5cbiAgICAgICAgICAgIGVhY2gob3B0aW9uLCBmdW5jdGlvbiAob3B0cywgbWFpblR5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoQ29tcG9uZW50TW9kZWwuaGFzQ2xhc3MobWFpblR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRzID0gbW9kZWxVdGlsLm5vcm1hbGl6ZVRvQXJyYXkob3B0cyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBvcHRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgb3B0aW9ucyB3aXRoIGlubmVyIGlkLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsVXRpbC5pc0lkSW5uZXIob3B0c1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvcHRpb25bbWFpblR5cGVdID0gb3B0cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbltPUFRJT05fSU5ORVJfS0VZXTtcblxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRUaGVtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RoZW1lO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWFpblR5cGVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtpZHg9MF1cbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvbW9kZWwvQ29tcG9uZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q29tcG9uZW50OiBmdW5jdGlvbiAobWFpblR5cGUsIGlkeCkge1xuICAgICAgICAgICAgdmFyIGxpc3QgPSB0aGlzLl9jb21wb25lbnRzTWFwW21haW5UeXBlXTtcbiAgICAgICAgICAgIGlmIChsaXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RbaWR4IHx8IDBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZGl0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb25kaXRpb24ubWFpblR5cGVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25kaXRpb24uc3ViVHlwZV0gSWYgaWdub3JlLCBvbmx5IHF1ZXJ5IGJ5IG1haW5UeXBlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZGl0aW9uLmluZGV4XSBFaXRoZXIgaW5wdXQgaW5kZXggb3IgaWQgb3IgbmFtZS5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25kaXRpb24uaWRdIEVpdGhlciBpbnB1dCBpbmRleCBvciBpZCBvciBuYW1lLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmRpdGlvbi5uYW1lXSBFaXRoZXIgaW5wdXQgaW5kZXggb3IgaWQgb3IgbmFtZS5cbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudD59XG4gICAgICAgICAqL1xuICAgICAgICBxdWVyeUNvbXBvbmVudHM6IGZ1bmN0aW9uIChjb25kaXRpb24pIHtcbiAgICAgICAgICAgIHZhciBtYWluVHlwZSA9IGNvbmRpdGlvbi5tYWluVHlwZTtcbiAgICAgICAgICAgIGlmICghbWFpblR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbmRleCA9IGNvbmRpdGlvbi5pbmRleDtcbiAgICAgICAgICAgIHZhciBpZCA9IGNvbmRpdGlvbi5pZDtcbiAgICAgICAgICAgIHZhciBuYW1lID0gY29uZGl0aW9uLm5hbWU7XG5cbiAgICAgICAgICAgIHZhciBjcHRzID0gdGhpcy5fY29tcG9uZW50c01hcFttYWluVHlwZV07XG5cbiAgICAgICAgICAgIGlmICghY3B0cyB8fCAhY3B0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KGluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IFtpbmRleF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZpbHRlcihtYXAoaW5kZXgsIGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNwdHNbaWR4XTtcbiAgICAgICAgICAgICAgICB9KSwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISF2YWw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzSWRBcnJheSA9IGlzQXJyYXkoaWQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZpbHRlcihjcHRzLCBmdW5jdGlvbiAoY3B0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoaXNJZEFycmF5ICYmIGluZGV4T2YoaWQsIGNwdC5pZCkgPj0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8ICghaXNJZEFycmF5ICYmIGNwdC5pZCA9PT0gaWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzTmFtZUFycmF5ID0gaXNBcnJheShuYW1lKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmaWx0ZXIoY3B0cywgZnVuY3Rpb24gKGNwdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGlzTmFtZUFycmF5ICYmIGluZGV4T2YobmFtZSwgY3B0Lm5hbWUpID49IDApXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCAoIWlzTmFtZUFycmF5ICYmIGNwdC5uYW1lID09PSBuYW1lKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFJldHVybiBhbGwgY29tcG9uZW50cyB3aXRoIG1haW5UeXBlXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY3B0cztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlckJ5U3ViVHlwZShyZXN1bHQsIGNvbmRpdGlvbik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbnRlcmZhY2UgaXMgZGlmZmVyZW50IGZyb20gcXVlcnlDb21wb25lbnRzLFxuICAgICAgICAgKiB3aGljaCBpcyBjb252ZW5pZW50IGZvciBpbm5lciB1c2FnZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHVzYWdlXG4gICAgICAgICAqIHZhciByZXN1bHQgPSBmaW5kQ29tcG9uZW50cyhcbiAgICAgICAgICogICAgIHttYWluVHlwZTogJ2RhdGFab29tJywgcXVlcnk6IHtkYXRhWm9vbUlkOiAnYWJjJ319XG4gICAgICAgICAqICk7XG4gICAgICAgICAqIHZhciByZXN1bHQgPSBmaW5kQ29tcG9uZW50cyhcbiAgICAgICAgICogICAgIHttYWluVHlwZTogJ3NlcmllcycsIHN1YlR5cGU6ICdwaWUnLCBxdWVyeToge3Nlcmllc05hbWU6ICd1aW8nfX1cbiAgICAgICAgICogKTtcbiAgICAgICAgICogdmFyIHJlc3VsdCA9IGZpbmRDb21wb25lbnRzKFxuICAgICAgICAgKiAgICAge21haW5UeXBlOiAnc2VyaWVzJ30sXG4gICAgICAgICAqICAgICBmdW5jdGlvbiAobW9kZWwsIGluZGV4KSB7Li4ufVxuICAgICAgICAgKiApO1xuICAgICAgICAgKiAvLyByZXN1bHQgbGlrZSBbY29tcG9uZW50MCwgY29tcG9ubmV0MSwgLi4uXVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZGl0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb25kaXRpb24ubWFpblR5cGUgTWFuZGF0b3J5LlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmRpdGlvbi5zdWJUeXBlXSBPcHRpb25hbC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25kaXRpb24ucXVlcnldIGxpa2Uge3h4eEluZGV4LCB4eHhJZCwgeHh4TmFtZX0sXG4gICAgICAgICAqICAgICAgICB3aGVyZSB4eHggaXMgbWFpblR5cGUuXG4gICAgICAgICAqICAgICAgICBJZiBxdWVyeSBhdHRyaWJ1dGUgaXMgbnVsbC91bmRlZmluZWQgb3IgaGFzIG5vIGluZGV4L2lkL25hbWUsXG4gICAgICAgICAqICAgICAgICBkbyBub3QgZmlsdGVyaW5nIGJ5IHF1ZXJ5IGNvbmRpdGlvbnMsIHdoaWNoIGlzIGNvbnZlbmllbnQgZm9yXG4gICAgICAgICAqICAgICAgICBuby1wYXlsb2FkIHNpdHVhdGlvbnMgb3Igd2hlbiB0YXJnZXQgb2YgYWN0aW9uIGlzIGdsb2JhbC5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmRpdGlvbi5maWx0ZXJdIHBhcmFtZXRlcjogY29tcG9uZW50LCByZXR1cm4gYm9vbGVhbi5cbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudD59XG4gICAgICAgICAqL1xuICAgICAgICBmaW5kQ29tcG9uZW50czogZnVuY3Rpb24gKGNvbmRpdGlvbikge1xuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gY29uZGl0aW9uLnF1ZXJ5O1xuICAgICAgICAgICAgdmFyIG1haW5UeXBlID0gY29uZGl0aW9uLm1haW5UeXBlO1xuXG4gICAgICAgICAgICB2YXIgcXVlcnlDb25kID0gZ2V0UXVlcnlDb25kKHF1ZXJ5KTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBxdWVyeUNvbmRcbiAgICAgICAgICAgICAgICA/IHRoaXMucXVlcnlDb21wb25lbnRzKHF1ZXJ5Q29uZClcbiAgICAgICAgICAgICAgICA6IHRoaXMuX2NvbXBvbmVudHNNYXBbbWFpblR5cGVdO1xuXG4gICAgICAgICAgICByZXR1cm4gZG9GaWx0ZXIoZmlsdGVyQnlTdWJUeXBlKHJlc3VsdCwgY29uZGl0aW9uKSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFF1ZXJ5Q29uZChxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4QXR0ciA9IG1haW5UeXBlICsgJ0luZGV4JztcbiAgICAgICAgICAgICAgICB2YXIgaWRBdHRyID0gbWFpblR5cGUgKyAnSWQnO1xuICAgICAgICAgICAgICAgIHZhciBuYW1lQXR0ciA9IG1haW5UeXBlICsgJ05hbWUnO1xuICAgICAgICAgICAgICAgIHJldHVybiBxICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHEuaGFzT3duUHJvcGVydHkoaW5kZXhBdHRyKVxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgcS5oYXNPd25Qcm9wZXJ0eShpZEF0dHIpXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCBxLmhhc093blByb3BlcnR5KG5hbWVBdHRyKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFpblR5cGU6IG1haW5UeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3ViVHlwZSB3aWxsIGJlIGZpbHRlcmVkIGZpbmFsbHkuXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogcVtpbmRleEF0dHJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHFbaWRBdHRyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHFbbmFtZUF0dHJdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBkb0ZpbHRlcihyZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uZGl0aW9uLmZpbHRlclxuICAgICAgICAgICAgICAgICAgICAgPyBmaWx0ZXIocmVzLCBjb25kaXRpb24uZmlsdGVyKVxuICAgICAgICAgICAgICAgICAgICAgOiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB1c2FnZVxuICAgICAgICAgKiBlYWNoQ29tcG9uZW50KCdsZWdlbmQnLCBmdW5jdGlvbiAobGVnZW5kTW9kZWwsIGluZGV4KSB7XG4gICAgICAgICAqICAgICAuLi5cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqIGVhY2hDb21wb25lbnQoZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUsIG1vZGVsLCBpbmRleCkge1xuICAgICAgICAgKiAgICAgLy8gY29tcG9uZW50VHlwZSBkb2VzIG5vdCBpbmNsdWRlIHN1YlR5cGVcbiAgICAgICAgICogICAgIC8vIChjb21wb25lbnRUeXBlIGlzICd4eHgnIGJ1dCBub3QgJ3h4eC5hYScpXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBlYWNoQ29tcG9uZW50KFxuICAgICAgICAgKiAgICAge21haW5UeXBlOiAnZGF0YVpvb20nLCBxdWVyeToge2RhdGFab29tSWQ6ICdhYmMnfX0sXG4gICAgICAgICAqICAgICBmdW5jdGlvbiAobW9kZWwsIGluZGV4KSB7Li4ufVxuICAgICAgICAgKiApO1xuICAgICAgICAgKiBlYWNoQ29tcG9uZW50KFxuICAgICAgICAgKiAgICAge21haW5UeXBlOiAnc2VyaWVzJywgc3ViVHlwZTogJ3BpZScsIHF1ZXJ5OiB7c2VyaWVzTmFtZTogJ3Vpbyd9fSxcbiAgICAgICAgICogICAgIGZ1bmN0aW9uIChtb2RlbCwgaW5kZXgpIHsuLi59XG4gICAgICAgICAqICk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdD19IG1haW5UeXBlIFdoZW4gbWFpblR5cGUgaXMgb2JqZWN0LCB0aGUgZGVmaW5pdGlvblxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyB0aGUgc2FtZSBhcyB0aGUgbWV0aG9kICdmaW5kQ29tcG9uZW50cycuXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgZWFjaENvbXBvbmVudDogZnVuY3Rpb24gKG1haW5UeXBlLCBjYiwgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudHNNYXAgPSB0aGlzLl9jb21wb25lbnRzTWFwO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1haW5UeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGNiO1xuICAgICAgICAgICAgICAgIGNiID0gbWFpblR5cGU7XG4gICAgICAgICAgICAgICAgZWFjaChjb21wb25lbnRzTWFwLCBmdW5jdGlvbiAoY29tcG9uZW50cywgY29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBlYWNoKGNvbXBvbmVudHMsIGZ1bmN0aW9uIChjb21wb25lbnQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIGNvbXBvbmVudFR5cGUsIGNvbXBvbmVudCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHpyVXRpbC5pc1N0cmluZyhtYWluVHlwZSkpIHtcbiAgICAgICAgICAgICAgICBlYWNoKGNvbXBvbmVudHNNYXBbbWFpblR5cGVdLCBjYiwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc09iamVjdChtYWluVHlwZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcXVlcnlSZXN1bHQgPSB0aGlzLmZpbmRDb21wb25lbnRzKG1haW5UeXBlKTtcbiAgICAgICAgICAgICAgICBlYWNoKHF1ZXJ5UmVzdWx0LCBjYiwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXM+fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U2VyaWVzQnlOYW1lOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIHNlcmllcyA9IHRoaXMuX2NvbXBvbmVudHNNYXAuc2VyaWVzO1xuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcihzZXJpZXMsIGZ1bmN0aW9uIChvbmVTZXJpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb25lU2VyaWVzLm5hbWUgPT09IG5hbWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHNlcmllc0luZGV4XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc31cbiAgICAgICAgICovXG4gICAgICAgIGdldFNlcmllc0J5SW5kZXg6IGZ1bmN0aW9uIChzZXJpZXNJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHNNYXAuc2VyaWVzW3Nlcmllc0luZGV4XTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN1YlR5cGVcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllcz59XG4gICAgICAgICAqL1xuICAgICAgICBnZXRTZXJpZXNCeVR5cGU6IGZ1bmN0aW9uIChzdWJUeXBlKSB7XG4gICAgICAgICAgICB2YXIgc2VyaWVzID0gdGhpcy5fY29tcG9uZW50c01hcC5zZXJpZXM7XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyKHNlcmllcywgZnVuY3Rpb24gKG9uZVNlcmllcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBvbmVTZXJpZXMuc3ViVHlwZSA9PT0gc3ViVHlwZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOmVjaGFydHMvbW9kZWwvU2VyaWVzPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFNlcmllczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHNNYXAuc2VyaWVzLnNsaWNlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFmdGVyIGZpbHRlcmluZywgc2VyaWVzIG1heSBiZSBkaWZmZXJlbnRcbiAgICAgICAgICogZnJvbWUgcmF3IHNlcmllcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICogQHBhcmFtIHsqfSBjb250ZXh0XG4gICAgICAgICAqL1xuICAgICAgICBlYWNoU2VyaWVzOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGFzc2VydFNlcmllc0luaXRpYWxpemVkKHRoaXMpO1xuICAgICAgICAgICAgZWFjaCh0aGlzLl9zZXJpZXNJbmRpY2VzLCBmdW5jdGlvbiAocmF3U2VyaWVzSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VyaWVzID0gdGhpcy5fY29tcG9uZW50c01hcC5zZXJpZXNbcmF3U2VyaWVzSW5kZXhdO1xuICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgc2VyaWVzLCByYXdTZXJpZXNJbmRleCk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSXRlcmF0ZSByYXcgc2VyaWVzIGJlZm9yZSBmaWx0ZXJlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICogQHBhcmFtIHsqfSBjb250ZXh0XG4gICAgICAgICAqL1xuICAgICAgICBlYWNoUmF3U2VyaWVzOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGVhY2godGhpcy5fY29tcG9uZW50c01hcC5zZXJpZXMsIGNiLCBjb250ZXh0KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWZ0ZXIgZmlsdGVyaW5nLCBzZXJpZXMgbWF5IGJlIGRpZmZlcmVudC5cbiAgICAgICAgICogZnJvbWUgcmF3IHNlcmllcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcm1hIHtzdHJpbmd9IHN1YlR5cGVcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICogQHBhcmFtIHsqfSBjb250ZXh0XG4gICAgICAgICAqL1xuICAgICAgICBlYWNoU2VyaWVzQnlUeXBlOiBmdW5jdGlvbiAoc3ViVHlwZSwgY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGFzc2VydFNlcmllc0luaXRpYWxpemVkKHRoaXMpO1xuICAgICAgICAgICAgZWFjaCh0aGlzLl9zZXJpZXNJbmRpY2VzLCBmdW5jdGlvbiAocmF3U2VyaWVzSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VyaWVzID0gdGhpcy5fY29tcG9uZW50c01hcC5zZXJpZXNbcmF3U2VyaWVzSW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChzZXJpZXMuc3ViVHlwZSA9PT0gc3ViVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHNlcmllcywgcmF3U2VyaWVzSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJdGVyYXRlIHJhdyBzZXJpZXMgYmVmb3JlIGZpbHRlcmVkIG9mIGdpdmVuIHR5cGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJtYSB7c3RyaW5nfSBzdWJUeXBlXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgZWFjaFJhd1Nlcmllc0J5VHlwZTogZnVuY3Rpb24gKHN1YlR5cGUsIGNiLCBjb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZWFjaCh0aGlzLmdldFNlcmllc0J5VHlwZShzdWJUeXBlKSwgY2IsIGNvbnRleHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc30gc2VyaWVzTW9kZWxcbiAgICAgICAgICovXG4gICAgICAgIGlzU2VyaWVzRmlsdGVyZWQ6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgYXNzZXJ0U2VyaWVzSW5pdGlhbGl6ZWQodGhpcyk7XG4gICAgICAgICAgICByZXR1cm4genJVdGlsLmluZGV4T2YodGhpcy5fc2VyaWVzSW5kaWNlcywgc2VyaWVzTW9kZWwuY29tcG9uZW50SW5kZXgpIDwgMDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICogQHBhcmFtIHsqfSBjb250ZXh0XG4gICAgICAgICAqL1xuICAgICAgICBmaWx0ZXJTZXJpZXM6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgICAgICAgICAgYXNzZXJ0U2VyaWVzSW5pdGlhbGl6ZWQodGhpcyk7XG4gICAgICAgICAgICB2YXIgZmlsdGVyZWRTZXJpZXMgPSBmaWx0ZXIoXG4gICAgICAgICAgICAgICAgdGhpcy5fY29tcG9uZW50c01hcC5zZXJpZXMsIGNiLCBjb250ZXh0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5fc2VyaWVzSW5kaWNlcyA9IGNyZWF0ZVNlcmllc0luZGljZXMoZmlsdGVyZWRTZXJpZXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlc3RvcmVEYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50c01hcCA9IHRoaXMuX2NvbXBvbmVudHNNYXA7XG5cbiAgICAgICAgICAgIHRoaXMuX3Nlcmllc0luZGljZXMgPSBjcmVhdGVTZXJpZXNJbmRpY2VzKGNvbXBvbmVudHNNYXAuc2VyaWVzKTtcblxuICAgICAgICAgICAgdmFyIGNvbXBvbmVudFR5cGVzID0gW107XG4gICAgICAgICAgICBlYWNoKGNvbXBvbmVudHNNYXAsIGZ1bmN0aW9uIChjb21wb25lbnRzLCBjb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50VHlwZXMucHVzaChjb21wb25lbnRUeXBlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBDb21wb25lbnRNb2RlbC50b3BvbG9naWNhbFRyYXZlbChcbiAgICAgICAgICAgICAgICBjb21wb25lbnRUeXBlcyxcbiAgICAgICAgICAgICAgICBDb21wb25lbnRNb2RlbC5nZXRBbGxDbGFzc01haW5UeXBlcygpLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjb21wb25lbnRUeXBlLCBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZWFjaChjb21wb25lbnRzTWFwW2NvbXBvbmVudFR5cGVdLCBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQucmVzdG9yZURhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZVRoZW1lKG9wdGlvbiwgdGhlbWUpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGVtZSkge1xuICAgICAgICAgICAgLy8g5aaC5p6c5pyJIGNvbXBvbmVudCBtb2RlbCDliJnmiorlhbfkvZPnmoQgbWVyZ2Ug6YC76L6R5Lqk57uZ6K+lIG1vZGVsIOWkhOeQhlxuICAgICAgICAgICAgaWYgKCFDb21wb25lbnRNb2RlbC5oYXNDbGFzcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhlbWVbbmFtZV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbltuYW1lXSA9ICFvcHRpb25bbmFtZV1cbiAgICAgICAgICAgICAgICAgICAgICAgID8genJVdGlsLmNsb25lKHRoZW1lW25hbWVdKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB6clV0aWwubWVyZ2Uob3B0aW9uW25hbWVdLCB0aGVtZVtuYW1lXSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbltuYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25bbmFtZV0gPSB0aGVtZVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaXRCYXNlKGJhc2VPcHRpb24pIHtcbiAgICAgICAgYmFzZU9wdGlvbiA9IGJhc2VPcHRpb247XG5cbiAgICAgICAgLy8gVXNpbmcgT1BUSU9OX0lOTkVSX0tFWSB0byBtYXJrIHRoYXQgdGhpcyBvcHRpb24gY2FuIG5vdCBiZSB1c2VkIG91dHNpZGUsXG4gICAgICAgIC8vIGkuZS4gYGNoYXJ0LnNldE9wdGlvbihjaGFydC5nZXRNb2RlbCgpLm9wdGlvbik7YCBpcyBmb3JiaWRlbi5cbiAgICAgICAgdGhpcy5vcHRpb24gPSB7fTtcbiAgICAgICAgdGhpcy5vcHRpb25bT1BUSU9OX0lOTkVSX0tFWV0gPSAxO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIEFycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbD4+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY29tcG9uZW50c01hcCA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXBwaW5nIGJldHdlZW4gZmlsdGVyZWQgc2VyaWVzIGxpc3QgYW5kIHJhdyBzZXJpZXMgbGlzdC5cbiAgICAgICAgICoga2V5OiBmaWx0ZXJlZCBzZXJpZXMgaW5kaWNlcywgdmFsdWU6IHJhdyBzZXJpZXMgaW5kaWNlcy5cbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudWJtZXI+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2VyaWVzSW5kaWNlcyA9IG51bGw7XG5cbiAgICAgICAgbWVyZ2VUaGVtZShiYXNlT3B0aW9uLCB0aGlzLl90aGVtZS5vcHRpb24pO1xuXG4gICAgICAgIC8vIFRPRE8gTmVlZHMgY2xvbmUgd2hlbiBtZXJnaW5nIHRvIHRoZSB1bmV4aXN0ZWQgcHJvcGVydHlcbiAgICAgICAgenJVdGlsLm1lcmdlKGJhc2VPcHRpb24sIGdsb2JhbERlZmF1bHQsIGZhbHNlKTtcblxuICAgICAgICB0aGlzLm1lcmdlT3B0aW9uKGJhc2VPcHRpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz58c3RyaW5nfSB0eXBlcyBtb2RlbCB0eXBlc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0ga2V5OiB7c3RyaW5nfSB0eXBlLCB2YWx1ZToge0FycmF5LjxPYmplY3Q+fSBtb2RlbHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRDb21wb25lbnRzQnlUeXBlcyhjb21wb25lbnRzTWFwLCB0eXBlcykge1xuICAgICAgICBpZiAoIXpyVXRpbC5pc0FycmF5KHR5cGVzKSkge1xuICAgICAgICAgICAgdHlwZXMgPSB0eXBlcyA/IFt0eXBlc10gOiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXQgPSB7fTtcbiAgICAgICAgZWFjaCh0eXBlcywgZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIHJldFt0eXBlXSA9IChjb21wb25lbnRzTWFwW3R5cGVdIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1ha2VLZXlJbmZvKG1haW5UeXBlLCBtYXBSZXN1bHQpIHtcbiAgICAgICAgLy8gV2UgdXNlIHRoaXMgaWQgdG8gaGFzaCBjb21wb25lbnQgbW9kZWxzIGFuZCB2aWV3IGluc3RhbmNlc1xuICAgICAgICAvLyBpbiBlY2hhcnRzLiBpZCBjYW4gYmUgc3BlY2lmaWVkIGJ5IHVzZXIsIG9yIGF1dG8gZ2VuZXJhdGVkLlxuXG4gICAgICAgIC8vIFRoZSBpZCBnZW5lcmF0aW9uIHJ1bGUgZW5zdXJlcyBuZXcgdmlldyBpbnN0YW5jZSBhcmUgYWJsZVxuICAgICAgICAvLyB0byBtYXBwZWQgdG8gb2xkIGluc3RhbmNlIHdoZW4gc2V0T3B0aW9uIGFyZSBjYWxsZWQgaW5cbiAgICAgICAgLy8gbm8tbWVyZ2UgbW9kZS4gU28gd2UgZ2VuZXJhdGUgbW9kZWwgaWQgYnkgbmFtZSBhbmQgcGx1c1xuICAgICAgICAvLyB0eXBlIGluIHZpZXcgaWQuXG5cbiAgICAgICAgLy8gbmFtZSBjYW4gYmUgZHVwbGljYXRlZCBhbW9uZyBjb21wb25lbnRzLCB3aGljaCBpcyBjb252ZW5pZW50XG4gICAgICAgIC8vIHRvIHNwZWNpZnkgbXVsdGkgY29tcG9uZW50cyAobGlrZSBzZXJpZXMpIGJ5IG9uZSBuYW1lLlxuXG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IGVhY2ggaWQgaXMgZGlzdGluY3QuXG4gICAgICAgIHZhciBpZE1hcCA9IHt9O1xuXG4gICAgICAgIGVhY2gobWFwUmVzdWx0LCBmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBleGlzdENwdCA9IGl0ZW0uZXhpc3Q7XG4gICAgICAgICAgICBleGlzdENwdCAmJiAoaWRNYXBbZXhpc3RDcHQuaWRdID0gaXRlbSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGVhY2gobWFwUmVzdWx0LCBmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBvcHQgPSBpdGVtLm9wdGlvbjtcblxuICAgICAgICAgICAgenJVdGlsLmFzc2VydChcbiAgICAgICAgICAgICAgICAhb3B0IHx8IG9wdC5pZCA9PSBudWxsIHx8ICFpZE1hcFtvcHQuaWRdIHx8IGlkTWFwW29wdC5pZF0gPT09IGl0ZW0sXG4gICAgICAgICAgICAgICAgJ2lkIGR1cGxpY2F0ZXM6ICcgKyAob3B0ICYmIG9wdC5pZClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIG9wdCAmJiBvcHQuaWQgIT0gbnVsbCAmJiAoaWRNYXBbb3B0LmlkXSA9IGl0ZW0pO1xuXG4gICAgICAgICAgICAvLyBDb21wbGV0ZSBzdWJUeXBlXG4gICAgICAgICAgICBpZiAoaXNPYmplY3Qob3B0KSkge1xuICAgICAgICAgICAgICAgIHZhciBzdWJUeXBlID0gZGV0ZXJtaW5lU3ViVHlwZShtYWluVHlwZSwgb3B0LCBpdGVtLmV4aXN0KTtcbiAgICAgICAgICAgICAgICBpdGVtLmtleUluZm8gPSB7bWFpblR5cGU6IG1haW5UeXBlLCBzdWJUeXBlOiBzdWJUeXBlfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gTWFrZSBuYW1lIGFuZCBpZC5cbiAgICAgICAgZWFjaChtYXBSZXN1bHQsIGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIGV4aXN0Q3B0ID0gaXRlbS5leGlzdDtcbiAgICAgICAgICAgIHZhciBvcHQgPSBpdGVtLm9wdGlvbjtcbiAgICAgICAgICAgIHZhciBrZXlJbmZvID0gaXRlbS5rZXlJbmZvO1xuXG4gICAgICAgICAgICBpZiAoIWlzT2JqZWN0KG9wdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG5hbWUgY2FuIGJlIG92ZXJ3aXR0ZW4uIENvbnNpZGVyIGNhc2U6IGF4aXMubmFtZSA9ICcyMGttJy5cbiAgICAgICAgICAgIC8vIEJ1dCBpZCBnZW5lcmF0ZWQgYnkgbmFtZSB3aWxsIG5vdCBiZSBjaGFuZ2VkLCB3aGljaCBhZmZlY3RcbiAgICAgICAgICAgIC8vIG9ubHkgaW4gdGhhdCBjYXNlOiBzZXRPcHRpb24gd2l0aCAnbm90IG1lcmdlIG1vZGUnIGFuZCB2aWV3XG4gICAgICAgICAgICAvLyBpbnN0YW5jZSB3aWxsIGJlIHJlY3JlYXRlZCwgd2hpY2ggY2FuIGJlIGFjY2VwdGVkLlxuICAgICAgICAgICAga2V5SW5mby5uYW1lID0gb3B0Lm5hbWUgIT0gbnVsbFxuICAgICAgICAgICAgICAgID8gb3B0Lm5hbWUgKyAnJ1xuICAgICAgICAgICAgICAgIDogZXhpc3RDcHRcbiAgICAgICAgICAgICAgICA/IGV4aXN0Q3B0Lm5hbWVcbiAgICAgICAgICAgICAgICA6ICdcXDAtJztcblxuICAgICAgICAgICAgaWYgKGV4aXN0Q3B0KSB7XG4gICAgICAgICAgICAgICAga2V5SW5mby5pZCA9IGV4aXN0Q3B0LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0LmlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBrZXlJbmZvLmlkID0gb3B0LmlkICsgJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDb25zaWRlciB0aGlzIHNpdHVhdG9pbjpcbiAgICAgICAgICAgICAgICAvLyAgb3B0aW9uQTogW3tuYW1lOiAnYSd9LCB7bmFtZTogJ2EnfSwgey4ufV1cbiAgICAgICAgICAgICAgICAvLyAgb3B0aW9uQiBbey4ufSwge25hbWU6ICdhJ30sIHtuYW1lOiAnYSd9XVxuICAgICAgICAgICAgICAgIC8vIFNlcmllcyB3aXRoIHRoZSBzYW1lIG5hbWUgYmV0d2VlbiBvcHRpb25BIGFuZCBvcHRpb25CXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIG1hcHBlZC5cbiAgICAgICAgICAgICAgICB2YXIgaWROdW0gPSAwO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAga2V5SW5mby5pZCA9ICdcXDAnICsga2V5SW5mby5uYW1lICsgJ1xcMCcgKyBpZE51bSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoaWRNYXBba2V5SW5mby5pZF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZE1hcFtrZXlJbmZvLmlkXSA9IGl0ZW07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRldGVybWluZVN1YlR5cGUobWFpblR5cGUsIG5ld0NwdE9wdGlvbiwgZXhpc3RDb21wb25lbnQpIHtcbiAgICAgICAgdmFyIHN1YlR5cGUgPSBuZXdDcHRPcHRpb24udHlwZVxuICAgICAgICAgICAgPyBuZXdDcHRPcHRpb24udHlwZVxuICAgICAgICAgICAgOiBleGlzdENvbXBvbmVudFxuICAgICAgICAgICAgPyBleGlzdENvbXBvbmVudC5zdWJUeXBlXG4gICAgICAgICAgICAvLyBVc2UgZGV0ZXJtaW5lU3ViVHlwZSBvbmx5IHdoZW4gdGhlcmUgaXMgbm8gZXhpc3RDb21wb25lbnQuXG4gICAgICAgICAgICA6IENvbXBvbmVudE1vZGVsLmRldGVybWluZVN1YlR5cGUobWFpblR5cGUsIG5ld0NwdE9wdGlvbik7XG5cbiAgICAgICAgLy8gdG9vbHRpcCwgbWFya2xpbmUsIG1hcmtwb2ludCBtYXkgYWx3YXlzIGhhcyBubyBzdWJUeXBlXG4gICAgICAgIHJldHVybiBzdWJUeXBlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVNlcmllc0luZGljZXMoc2VyaWVzTW9kZWxzKSB7XG4gICAgICAgIHJldHVybiBtYXAoc2VyaWVzTW9kZWxzLCBmdW5jdGlvbiAoc2VyaWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWVzLmNvbXBvbmVudEluZGV4O1xuICAgICAgICB9KSB8fCBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWx0ZXJCeVN1YlR5cGUoY29tcG9uZW50cywgY29uZGl0aW9uKSB7XG4gICAgICAgIC8vIFVzaW5nIGhhc093blByb3BlcnR5IGZvciByZXN0cmljdC4gQ29uc2lkZXJcbiAgICAgICAgLy8gc3ViVHlwZSBpcyB1bmRlZmluZWQgaW4gdXNlciBwYXlsb2FkLlxuICAgICAgICByZXR1cm4gY29uZGl0aW9uLmhhc093blByb3BlcnR5KCdzdWJUeXBlJylcbiAgICAgICAgICAgID8gZmlsdGVyKGNvbXBvbmVudHMsIGZ1bmN0aW9uIChjcHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3B0LnN1YlR5cGUgPT09IGNvbmRpdGlvbi5zdWJUeXBlO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogY29tcG9uZW50cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NlcnRTZXJpZXNJbml0aWFsaXplZChlY01vZGVsKSB7XG4gICAgICAgIC8vIENvbXBvbmVudHMgdGhhdCB1c2UgX3Nlcmllc0luZGljZXMgc2hvdWxkIGRlcGVuZHMgb24gc2VyaWVzIGNvbXBvbmVudCxcbiAgICAgICAgLy8gd2hpY2ggbWFrZSBzdXJlIHRoYXQgdGhlaXIgaW5pdGlhbGl6YXRpb24gaXMgYWZ0ZXIgc2VyaWVzLlxuICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgaWYgKCFlY01vZGVsLl9zZXJpZXNJbmRpY2VzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJpZXMgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHpyVXRpbC5taXhpbihHbG9iYWxNb2RlbCwgcmVxdWlyZSgnLi9taXhpbi9jb2xvclBhbGV0dGUnKSk7XG5cbiAgICByZXR1cm4gR2xvYmFsTW9kZWw7XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL2VjaGFydHMvbW9kZWwvR2xvYmFsLmpzXG4gKiogbW9kdWxlIGlkID0gN1xuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvY29yZS91dGlsXG4gKi9cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlKSB7XG5cbiAgICAvLyDnlKjkuo7lpITnkIZtZXJnZeaXtuaXoOazlemBjeWOhkRhdGXnrYnlr7nosaHnmoTpl67pophcbiAgICB2YXIgQlVJTFRJTl9PQkpFQ1QgPSB7XG4gICAgICAgICdbb2JqZWN0IEZ1bmN0aW9uXSc6IDEsXG4gICAgICAgICdbb2JqZWN0IFJlZ0V4cF0nOiAxLFxuICAgICAgICAnW29iamVjdCBEYXRlXSc6IDEsXG4gICAgICAgICdbb2JqZWN0IEVycm9yXSc6IDEsXG4gICAgICAgICdbb2JqZWN0IENhbnZhc0dyYWRpZW50XSc6IDEsXG4gICAgICAgICdbb2JqZWN0IENhbnZhc1BhdHRlcm5dJzogMSxcbiAgICAgICAgLy8gSW4gbm9kZS1jYW52YXMgSW1hZ2UgY2FuIGJlIENhbnZhcy5JbWFnZVxuICAgICAgICAnW29iamVjdCBJbWFnZV0nOiAxXG4gICAgfTtcblxuICAgIHZhciBvYmpUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbiAgICB2YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbiAgICB2YXIgbmF0aXZlRm9yRWFjaCA9IGFycmF5UHJvdG8uZm9yRWFjaDtcbiAgICB2YXIgbmF0aXZlRmlsdGVyID0gYXJyYXlQcm90by5maWx0ZXI7XG4gICAgdmFyIG5hdGl2ZVNsaWNlID0gYXJyYXlQcm90by5zbGljZTtcbiAgICB2YXIgbmF0aXZlTWFwID0gYXJyYXlQcm90by5tYXA7XG4gICAgdmFyIG5hdGl2ZVJlZHVjZSA9IGFycmF5UHJvdG8ucmVkdWNlO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSBzb3VyY2VcbiAgICAgKiBAcmV0dXJuIHsqfSDmi7fotJ3lkI7nmoTmlrDlr7nosaFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZShzb3VyY2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT0gJ29iamVjdCcgJiYgc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gc291cmNlO1xuICAgICAgICAgICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBjbG9uZShzb3VyY2VbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICFpc0J1aWxkSW5PYmplY3Qoc291cmNlKVxuICAgICAgICAgICAgICAgIC8vIOaYr+WQpuS4uiBkb20g5a+56LGhXG4gICAgICAgICAgICAgICAgJiYgIWlzRG9tKHNvdXJjZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGNsb25lKHNvdXJjZVtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHsqfSBzb3VyY2VcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvdmVyd3JpdGU9ZmFsc2VdXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG92ZXJ3cml0ZSkge1xuICAgICAgICAvLyBXZSBzaG91bGQgZXNjYXBzZSB0aGF0IHNvdXJjZSBpcyBzdHJpbmdcbiAgICAgICAgLy8gYW5kIGVudGVyIGZvciAuLi4gaW4gLi4uXG4gICAgICAgIGlmICghaXNPYmplY3Qoc291cmNlKSB8fCAhaXNPYmplY3QodGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG92ZXJ3cml0ZSA/IGNsb25lKHNvdXJjZSkgOiB0YXJnZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0UHJvcCA9IHRhcmdldFtrZXldO1xuICAgICAgICAgICAgICAgIHZhciBzb3VyY2VQcm9wID0gc291cmNlW2tleV07XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3Qoc291cmNlUHJvcClcbiAgICAgICAgICAgICAgICAgICAgJiYgaXNPYmplY3QodGFyZ2V0UHJvcClcbiAgICAgICAgICAgICAgICAgICAgJiYgIWlzQXJyYXkoc291cmNlUHJvcClcbiAgICAgICAgICAgICAgICAgICAgJiYgIWlzQXJyYXkodGFyZ2V0UHJvcClcbiAgICAgICAgICAgICAgICAgICAgJiYgIWlzRG9tKHNvdXJjZVByb3ApXG4gICAgICAgICAgICAgICAgICAgICYmICFpc0RvbSh0YXJnZXRQcm9wKVxuICAgICAgICAgICAgICAgICAgICAmJiAhaXNCdWlsZEluT2JqZWN0KHNvdXJjZVByb3ApXG4gICAgICAgICAgICAgICAgICAgICYmICFpc0J1aWxkSW5PYmplY3QodGFyZ2V0UHJvcClcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6c6ZyA6KaB6YCS5b2S6KaG55uW77yM5bCx6YCS5b2S6LCD55SobWVyZ2VcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2UodGFyZ2V0UHJvcCwgc291cmNlUHJvcCwgb3ZlcndyaXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3ZlcndyaXRlIHx8ICEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5ZCm5YiZ5Y+q5aSE55CGb3ZlcndyaXRl5Li6dHJ1Ze+8jOaIluiAheWcqOebruagh+WvueixoeS4reayoeacieatpOWxnuaAp+eahOaDheWGtVxuICAgICAgICAgICAgICAgICAgICAvLyBOT1RF77yM5ZyoIHRhcmdldFtrZXldIOS4jeWtmOWcqOeahOaXtuWAmeS5n+aYr+ebtOaOpeimhuebllxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IGNsb25lKHNvdXJjZVtrZXldLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRhcmdldEFuZFNvdXJjZXMgVGhlIGZpcnN0IGl0ZW0gaXMgdGFyZ2V0LCBhbmQgdGhlIHJlc3RzIGFyZSBzb3VyY2UuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3ZlcndyaXRlPWZhbHNlXVxuICAgICAqIEByZXR1cm4geyp9IHRhcmdldFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlQWxsKHRhcmdldEFuZFNvdXJjZXMsIG92ZXJ3cml0ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0QW5kU291cmNlc1swXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IHRhcmdldEFuZFNvdXJjZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG1lcmdlKHJlc3VsdCwgdGFyZ2V0QW5kU291cmNlc1tpXSwgb3ZlcndyaXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHsqfSBzb3VyY2VcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgc291cmNlKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7Kn0gc291cmNlXG4gICAgICogQHBhcmFtIHtib29sZW59IFtvdmVybGF5PWZhbHNlXVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWZhdWx0cyh0YXJnZXQsIHNvdXJjZSwgb3ZlcmxheSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSlcbiAgICAgICAgICAgICAgICAmJiAob3ZlcmxheSA/IHNvdXJjZVtrZXldICE9IG51bGwgOiB0YXJnZXRba2V5XSA9PSBudWxsKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNhbnZhcygpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIH1cbiAgICAvLyBGSVhNRVxuICAgIHZhciBfY3R4O1xuICAgIGZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gICAgICAgIGlmICghX2N0eCkge1xuICAgICAgICAgICAgLy8gVXNlIHV0aWwuY3JlYXRlQ2FudmFzIGluc3RlYWQgb2YgY3JlYXRlQ2FudmFzXG4gICAgICAgICAgICAvLyBiZWNhdXNlIGNyZWF0ZUNhbnZhcyBtYXkgYmUgb3ZlcndyaXR0ZW4gaW4gZGlmZmVyZW50IGVudmlyb25tZW50XG4gICAgICAgICAgICBfY3R4ID0gdXRpbC5jcmVhdGVDYW52YXMoKS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfY3R4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOafpeivouaVsOe7hOS4reWFg+e0oOeahGluZGV4XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgICAgaWYgKGFycmF5LmluZGV4T2YpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXkuaW5kZXhPZih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJyYXlbaV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5p6E6YCg57G757un5om/5YWz57O7XG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2xhenog5rqQ57G7XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYmFzZUNsYXp6IOWfuuexu1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaGVyaXRzKGNsYXp6LCBiYXNlQ2xhenopIHtcbiAgICAgICAgdmFyIGNsYXp6UHJvdG90eXBlID0gY2xhenoucHJvdG90eXBlO1xuICAgICAgICBmdW5jdGlvbiBGKCkge31cbiAgICAgICAgRi5wcm90b3R5cGUgPSBiYXNlQ2xhenoucHJvdG90eXBlO1xuICAgICAgICBjbGF6ei5wcm90b3R5cGUgPSBuZXcgRigpO1xuXG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gY2xhenpQcm90b3R5cGUpIHtcbiAgICAgICAgICAgIGNsYXp6LnByb3RvdHlwZVtwcm9wXSA9IGNsYXp6UHJvdG90eXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICAgIGNsYXp6LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNsYXp6O1xuICAgICAgICBjbGF6ei5zdXBlckNsYXNzID0gYmFzZUNsYXp6O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IHNvcmNlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBvdmVybGF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWl4aW4odGFyZ2V0LCBzb3VyY2UsIG92ZXJsYXkpIHtcbiAgICAgICAgdGFyZ2V0ID0gJ3Byb3RvdHlwZScgaW4gdGFyZ2V0ID8gdGFyZ2V0LnByb3RvdHlwZSA6IHRhcmdldDtcbiAgICAgICAgc291cmNlID0gJ3Byb3RvdHlwZScgaW4gc291cmNlID8gc291cmNlLnByb3RvdHlwZSA6IHNvdXJjZTtcblxuICAgICAgICBkZWZhdWx0cyh0YXJnZXQsIHNvdXJjZSwgb3ZlcmxheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheXxUeXBlZEFycmF5fSBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheUxpa2UoZGF0YSkge1xuICAgICAgICBpZiAoISBkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGVvZiBkYXRhLmxlbmd0aCA9PSAnbnVtYmVyJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmlbDnu4TmiJblr7nosaHpgY3ljoZcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9ialxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlYWNoKG9iaiwgY2IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmouZm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gbmF0aXZlRm9yRWFjaCkge1xuICAgICAgICAgICAgb2JqLmZvckVhY2goY2IsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmlbDnu4TmmKDlsIRcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2JqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0XVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcChvYmosIGNiLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLm1hcCAmJiBvYmoubWFwID09PSBuYXRpdmVNYXApIHtcbiAgICAgICAgICAgIHJldHVybiBvYmoubWFwKGNiLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjYi5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9ialxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFttZW1vXVxuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlKG9iaiwgY2IsIG1lbW8sIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmoucmVkdWNlICYmIG9iai5yZWR1Y2UgPT09IG5hdGl2ZVJlZHVjZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iai5yZWR1Y2UoY2IsIG1lbW8sIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIG1lbW8gPSBjYi5jYWxsKGNvbnRleHQsIG1lbW8sIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5pWw57uE6L+H5rukXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9ialxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWx0ZXIob2JqLCBjYiwgY29udGV4dCkge1xuICAgICAgICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iai5maWx0ZXIgJiYgb2JqLmZpbHRlciA9PT0gbmF0aXZlRmlsdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLmZpbHRlcihjYiwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNiLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9ialtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaVsOe7hOmhueafpeaJvlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvYmpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZChvYmosIGNiLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY2IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmNcbiAgICAgKiBAcGFyYW0geyp9IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5kKGZ1bmMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzLmNvbmNhdChuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY1xuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1cnJ5KGZ1bmMpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzLmNvbmNhdChuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBTdHJpbmddJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICAgICAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCAoISF2YWx1ZSAmJiB0eXBlID09ICdvYmplY3QnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNCdWlsZEluT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhIUJVSUxUSU5fT0JKRUNUW29ialRvU3RyaW5nLmNhbGwodmFsdWUpXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNEb20odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICYmIHZhbHVlLm5vZGVUeXBlID09PSAxXG4gICAgICAgICAgICAgICAmJiB0eXBlb2YodmFsdWUubm9kZU5hbWUpID09ICdzdHJpbmcnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHZhbHVlMSBpcyBub3QgbnVsbCwgdGhlbiByZXR1cm4gdmFsdWUxLCBvdGhlcndpc2UganVkZ2V0IHJlc3Qgb2YgdmFsdWVzLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcmV0dXJuIHsqfSBGaW5hbCB2YWx1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJldHJpZXZlKHZhbHVlcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEluZGV4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZEluZGV4XG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2xpY2UoKSB7XG4gICAgICAgIHJldHVybiBGdW5jdGlvbi5jYWxsLmFwcGx5KG5hdGl2ZVNsaWNlLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbmRpdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHV0aWwgPSB7XG4gICAgICAgIGluaGVyaXRzOiBpbmhlcml0cyxcbiAgICAgICAgbWl4aW46IG1peGluLFxuICAgICAgICBjbG9uZTogY2xvbmUsXG4gICAgICAgIG1lcmdlOiBtZXJnZSxcbiAgICAgICAgbWVyZ2VBbGw6IG1lcmdlQWxsLFxuICAgICAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICAgICAgZGVmYXVsdHM6IGRlZmF1bHRzLFxuICAgICAgICBnZXRDb250ZXh0OiBnZXRDb250ZXh0LFxuICAgICAgICBjcmVhdGVDYW52YXM6IGNyZWF0ZUNhbnZhcyxcbiAgICAgICAgaW5kZXhPZjogaW5kZXhPZixcbiAgICAgICAgc2xpY2U6IHNsaWNlLFxuICAgICAgICBmaW5kOiBmaW5kLFxuICAgICAgICBpc0FycmF5TGlrZTogaXNBcnJheUxpa2UsXG4gICAgICAgIGVhY2g6IGVhY2gsXG4gICAgICAgIG1hcDogbWFwLFxuICAgICAgICByZWR1Y2U6IHJlZHVjZSxcbiAgICAgICAgZmlsdGVyOiBmaWx0ZXIsXG4gICAgICAgIGJpbmQ6IGJpbmQsXG4gICAgICAgIGN1cnJ5OiBjdXJyeSxcbiAgICAgICAgaXNBcnJheTogaXNBcnJheSxcbiAgICAgICAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICAgICAgICBpc09iamVjdDogaXNPYmplY3QsXG4gICAgICAgIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gICAgICAgIGlzQnVpbGRJbk9iamVjdDogaXNCdWlsZEluT2JqZWN0LFxuICAgICAgICBpc0RvbTogaXNEb20sXG4gICAgICAgIHJldHJpZXZlOiByZXRyaWV2ZSxcbiAgICAgICAgYXNzZXJ0OiBhc3NlcnQsXG4gICAgICAgIG5vb3A6IGZ1bmN0aW9uICgpIHt9XG4gICAgfTtcbiAgICByZXR1cm4gdXRpbDtcbn0pO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC96cmVuZGVyL2NvcmUvdXRpbC5qc1xuICoqIG1vZHVsZSBpZCA9IDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsImRlZmluZShmdW5jdGlvbihyZXF1aXJlKSB7XG5cbiAgICB2YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoJy4vZm9ybWF0Jyk7XG4gICAgdmFyIG51Ym1lclV0aWwgPSByZXF1aXJlKCcuL251bWJlcicpO1xuICAgIHZhciBNb2RlbCA9IHJlcXVpcmUoJy4uL21vZGVsL01vZGVsJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvY29yZS91dGlsJyk7XG5cbiAgICB2YXIgbW9kZWxVdGlsID0ge307XG5cbiAgICAvKipcbiAgICAgKiBJZiB2YWx1ZSBpcyBub3QgYXJyYXksIHRoZW4gdHJhbnNsYXRlIGl0IHRvIGFycmF5LlxuICAgICAqIEBwYXJhbSAgeyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7QXJyYXl9IFt2YWx1ZV0gb3IgdmFsdWVcbiAgICAgKi9cbiAgICBtb2RlbFV0aWwubm9ybWFsaXplVG9BcnJheSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBBcnJheVxuICAgICAgICAgICAgPyB2YWx1ZVxuICAgICAgICAgICAgOiB2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgICA/IFtdXG4gICAgICAgICAgICA6IFt2YWx1ZV07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN5bmMgZGVmYXVsdCBvcHRpb24gYmV0d2VlbiBub3JtYWwgYW5kIGVtcGhhc2lzIGxpa2UgYHBvc2l0aW9uYCBhbmQgYHNob3dgXG4gICAgICogSW4gY2FzZSBzb21lIG9uZSB3aWxsIHdyaXRlIGNvZGUgbGlrZVxuICAgICAqICAgICBsYWJlbDoge1xuICAgICAqICAgICAgICAgbm9ybWFsOiB7XG4gICAgICogICAgICAgICAgICAgc2hvdzogZmFsc2UsXG4gICAgICogICAgICAgICAgICAgcG9zaXRpb246ICdvdXRzaWRlJyxcbiAgICAgKiAgICAgICAgICAgICB0ZXh0U3R5bGU6IHtcbiAgICAgKiAgICAgICAgICAgICAgICAgZm9udFNpemU6IDE4XG4gICAgICogICAgICAgICAgICAgfVxuICAgICAqICAgICAgICAgfSxcbiAgICAgKiAgICAgICAgIGVtcGhhc2lzOiB7XG4gICAgICogICAgICAgICAgICAgc2hvdzogdHJ1ZVxuICAgICAqICAgICAgICAgfVxuICAgICAqICAgICB9XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHN1Yk9wdHNcbiAgICAgKi9cbiAgICAgbW9kZWxVdGlsLmRlZmF1bHRFbXBoYXNpcyA9IGZ1bmN0aW9uIChvcHQsIHN1Yk9wdHMpIHtcbiAgICAgICAgaWYgKG9wdCkge1xuICAgICAgICAgICAgdmFyIGVtcGhhc2lzT3B0ID0gb3B0LmVtcGhhc2lzID0gb3B0LmVtcGhhc2lzIHx8IHt9O1xuICAgICAgICAgICAgdmFyIG5vcm1hbE9wdCA9IG9wdC5ub3JtYWwgPSBvcHQubm9ybWFsIHx8IHt9O1xuXG4gICAgICAgICAgICAvLyBEZWZhdWx0IGVtcGhhc2lzIG9wdGlvbiBmcm9tIG5vcm1hbFxuICAgICAgICAgICAgenJVdGlsLmVhY2goc3ViT3B0cywgZnVuY3Rpb24gKHN1Yk9wdE5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0genJVdGlsLnJldHJpZXZlKGVtcGhhc2lzT3B0W3N1Yk9wdE5hbWVdLCBub3JtYWxPcHRbc3ViT3B0TmFtZV0pO1xuICAgICAgICAgICAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBlbXBoYXNpc09wdFtzdWJPcHROYW1lXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2RlbFV0aWwuTEFCRUxfT1BUSU9OUyA9IFsncG9zaXRpb24nLCAnc2hvdycsICd0ZXh0U3R5bGUnLCAnZGlzdGFuY2UnLCAnZm9ybWF0dGVyJ107XG5cbiAgICAvKipcbiAgICAgKiBkYXRhIGNvdWxkIGJlIFsxMiwgMjMyMywge3ZhbHVlOiAyMjN9LCBbMTIyMSwgMjNdLCB7dmFsdWU6IFsyLCAyM119XVxuICAgICAqIFRoaXMgaGVscGVyIG1ldGhvZCByZXRpZXZlcyB2YWx1ZSBmcm9tIGRhdGEuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfERhdGV8QXJyYXl8T2JqZWN0fSBkYXRhSXRlbVxuICAgICAqIEByZXR1cm4ge251bWJlcnxzdHJpbmd8RGF0ZXxBcnJheS48bnVtYmVyfHN0cmluZ3xEYXRlPn1cbiAgICAgKi9cbiAgICBtb2RlbFV0aWwuZ2V0RGF0YUl0ZW1WYWx1ZSA9IGZ1bmN0aW9uIChkYXRhSXRlbSkge1xuICAgICAgICAvLyBQZXJmb3JtYW5jZSBzZW5zaXRpdmUuXG4gICAgICAgIHJldHVybiBkYXRhSXRlbSAmJiAoZGF0YUl0ZW0udmFsdWUgPT0gbnVsbCA/IGRhdGFJdGVtIDogZGF0YUl0ZW0udmFsdWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBkYXRhIGNvdWxkIGJlIFsxMiwgMjMyMywge3ZhbHVlOiAyMjN9LCBbMTIyMSwgMjNdLCB7dmFsdWU6IFsyLCAyM119XVxuICAgICAqIFRoaXMgaGVscGVyIG1ldGhvZCBkZXRlcm1pbmUgaWYgZGF0YUl0ZW0gaGFzIGV4dHJhIG9wdGlvbiBiZXNpZGVzIHZhbHVlXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfERhdGV8QXJyYXl8T2JqZWN0fSBkYXRhSXRlbVxuICAgICAqL1xuICAgIG1vZGVsVXRpbC5pc0RhdGFJdGVtT3B0aW9uID0gZnVuY3Rpb24gKGRhdGFJdGVtKSB7XG4gICAgICAgIHJldHVybiB6clV0aWwuaXNPYmplY3QoZGF0YUl0ZW0pXG4gICAgICAgICAgICAmJiAhKGRhdGFJdGVtIGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgICAgICAgLy8gLy8gbWFya0xpbmUgZGF0YSBjYW4gYmUgYXJyYXlcbiAgICAgICAgICAgIC8vICYmICEoZGF0YUl0ZW1bMF0gJiYgenJVdGlsLmlzT2JqZWN0KGRhdGFJdGVtWzBdKSAmJiAhKGRhdGFJdGVtWzBdIGluc3RhbmNlb2YgQXJyYXkpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBoZWxwZXIgbWV0aG9kIGNvbnZlcnQgdmFsdWUgaW4gZGF0YS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ8RGF0ZX0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IFtkaW1JbmZvXSBJZiBzdHJpbmcgKGxpa2UgJ3gnKSwgZGltVHlwZSBkZWZhdWx0cyAnbnVtYmVyJy5cbiAgICAgKi9cbiAgICBtb2RlbFV0aWwuY29udmVyRGF0YVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBkaW1JbmZvKSB7XG4gICAgICAgIC8vIFBlcmZvcm1hbmNlIHNlbnNpdGl2ZS5cbiAgICAgICAgdmFyIGRpbVR5cGUgPSBkaW1JbmZvICYmIGRpbUluZm8udHlwZTtcbiAgICAgICAgaWYgKGRpbVR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRpbVR5cGUgPT09ICd0aW1lJyAmJiAhaXNGaW5pdGUodmFsdWUpICYmIHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09ICctJykge1xuICAgICAgICAgICAgdmFsdWUgPSArbnVibWVyVXRpbC5wYXJzZURhdGUodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGltVHlwZSBkZWZhdWx0cyAnbnVtYmVyJy5cbiAgICAgICAgLy8gSWYgZGltVHlwZSBpcyBub3Qgb3JkaW5hbCBhbmQgdmFsdWUgaXMgbnVsbCBvciB1bmRlZmluZWQgb3IgTmFOIG9yICctJyxcbiAgICAgICAgLy8gcGFyc2UgdG8gTmFOLlxuICAgICAgICByZXR1cm4gKHZhbHVlID09IG51bGwgfHwgdmFsdWUgPT09ICcnKVxuICAgICAgICAgICAgPyBOYU4gOiArdmFsdWU7IC8vIElmIHN0cmluZyAobGlrZSAnLScpLCB1c2luZyAnKycgcGFyc2UgdG8gTmFOXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG1vZGVsIHByb3h5IHRvIGJlIHVzZWQgaW4gdG9vbHRpcCBmb3IgZWRnZSBkYXRhLCBtYXJrTGluZSBkYXRhLCBtYXJrUG9pbnQgZGF0YS5cbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdC5zZXJpZXNJbmRleF1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdC5uYW1lXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0Lm1haW5UeXBlXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0LnN1YlR5cGVdXG4gICAgICovXG4gICAgbW9kZWxVdGlsLmNyZWF0ZURhdGFGb3JtYXRNb2RlbCA9IGZ1bmN0aW9uIChkYXRhLCBvcHQpIHtcbiAgICAgICAgdmFyIG1vZGVsID0gbmV3IE1vZGVsKCk7XG4gICAgICAgIHpyVXRpbC5taXhpbihtb2RlbCwgbW9kZWxVdGlsLmRhdGFGb3JtYXRNaXhpbik7XG4gICAgICAgIG1vZGVsLnNlcmllc0luZGV4ID0gb3B0LnNlcmllc0luZGV4O1xuICAgICAgICBtb2RlbC5uYW1lID0gb3B0Lm5hbWUgfHwgJyc7XG4gICAgICAgIG1vZGVsLm1haW5UeXBlID0gb3B0Lm1haW5UeXBlO1xuICAgICAgICBtb2RlbC5zdWJUeXBlID0gb3B0LnN1YlR5cGU7XG5cbiAgICAgICAgbW9kZWwuZ2V0RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbW9kZWw7XG4gICAgfTtcblxuICAgIC8vIFBFTkRJTkcgQSBsaXR0bGUgdWdseVxuICAgIG1vZGVsVXRpbC5kYXRhRm9ybWF0TWl4aW4gPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgcGFyYW1zIGZvciBmb3JtYXR0ZXJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGRhdGFJbmRleFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2RhdGFUeXBlXVxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBnZXREYXRhUGFyYW1zOiBmdW5jdGlvbiAoZGF0YUluZGV4LCBkYXRhVHlwZSkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdldERhdGEoZGF0YVR5cGUpO1xuXG4gICAgICAgICAgICB2YXIgc2VyaWVzSW5kZXggPSB0aGlzLnNlcmllc0luZGV4O1xuICAgICAgICAgICAgdmFyIHNlcmllc05hbWUgPSB0aGlzLm5hbWU7XG5cbiAgICAgICAgICAgIHZhciByYXdWYWx1ZSA9IHRoaXMuZ2V0UmF3VmFsdWUoZGF0YUluZGV4LCBkYXRhVHlwZSk7XG4gICAgICAgICAgICB2YXIgcmF3RGF0YUluZGV4ID0gZGF0YS5nZXRSYXdJbmRleChkYXRhSW5kZXgpO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBkYXRhLmdldE5hbWUoZGF0YUluZGV4LCB0cnVlKTtcbiAgICAgICAgICAgIHZhciBpdGVtT3B0ID0gZGF0YS5nZXRSYXdEYXRhSXRlbShkYXRhSW5kZXgpO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudFR5cGU6IHRoaXMubWFpblR5cGUsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50U3ViVHlwZTogdGhpcy5zdWJUeXBlLFxuICAgICAgICAgICAgICAgIHNlcmllc1R5cGU6IHRoaXMubWFpblR5cGUgPT09ICdzZXJpZXMnID8gdGhpcy5zdWJUeXBlIDogbnVsbCxcbiAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogc2VyaWVzSW5kZXgsXG4gICAgICAgICAgICAgICAgc2VyaWVzTmFtZTogc2VyaWVzTmFtZSxcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgIGRhdGFJbmRleDogcmF3RGF0YUluZGV4LFxuICAgICAgICAgICAgICAgIGRhdGE6IGl0ZW1PcHQsXG4gICAgICAgICAgICAgICAgZGF0YVR5cGU6IGRhdGFUeXBlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByYXdWYWx1ZSxcbiAgICAgICAgICAgICAgICBjb2xvcjogZGF0YS5nZXRJdGVtVmlzdWFsKGRhdGFJbmRleCwgJ2NvbG9yJyksXG5cbiAgICAgICAgICAgICAgICAvLyBQYXJhbSBuYW1lIGxpc3QgZm9yIG1hcHBpbmcgYGFgLCBgYmAsIGBjYCwgYGRgLCBgZWBcbiAgICAgICAgICAgICAgICAkdmFyczogWydzZXJpZXNOYW1lJywgJ25hbWUnLCAndmFsdWUnXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRm9ybWF0IGxhYmVsXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhSW5kZXhcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdGF0dXM9J25vcm1hbCddICdub3JtYWwnIG9yICdlbXBoYXNpcydcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtkYXRhVHlwZV1cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtkaW1JbmRleF1cbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Rm9ybWF0dGVkTGFiZWw6IGZ1bmN0aW9uIChkYXRhSW5kZXgsIHN0YXR1cywgZGF0YVR5cGUsIGRpbUluZGV4KSB7XG4gICAgICAgICAgICBzdGF0dXMgPSBzdGF0dXMgfHwgJ25vcm1hbCc7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RGF0YShkYXRhVHlwZSk7XG4gICAgICAgICAgICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoZGF0YUluZGV4KTtcblxuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMuZ2V0RGF0YVBhcmFtcyhkYXRhSW5kZXgsIGRhdGFUeXBlKTtcbiAgICAgICAgICAgIGlmIChkaW1JbmRleCAhPSBudWxsICYmIChwYXJhbXMudmFsdWUgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMudmFsdWUgPSBwYXJhbXMudmFsdWVbZGltSW5kZXhdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVyID0gaXRlbU1vZGVsLmdldChbJ2xhYmVsJywgc3RhdHVzLCAnZm9ybWF0dGVyJ10pO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlcihwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0VXRpbC5mb3JtYXRUcGwoZm9ybWF0dGVyLCBwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgcmF3IHZhbHVlIGluIG9wdGlvblxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZGF0YVR5cGVdXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGdldFJhd1ZhbHVlOiBmdW5jdGlvbiAoaWR4LCBkYXRhVHlwZSkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdldERhdGEoZGF0YVR5cGUpO1xuICAgICAgICAgICAgdmFyIGRhdGFJdGVtID0gZGF0YS5nZXRSYXdEYXRhSXRlbShpZHgpO1xuICAgICAgICAgICAgaWYgKGRhdGFJdGVtICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHpyVXRpbC5pc09iamVjdChkYXRhSXRlbSkgJiYgIShkYXRhSXRlbSBpbnN0YW5jZW9mIEFycmF5KSlcbiAgICAgICAgICAgICAgICAgICAgPyBkYXRhSXRlbS52YWx1ZSA6IGRhdGFJdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG91bGQgYmUgaW1wbGVtZW50ZWQuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhSW5kZXhcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbbXVsdGlwbGVTZXJpZXM9ZmFsc2VdXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGF0YVR5cGVdXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gdG9vbHRpcCBzdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGZvcm1hdFRvb2x0aXA6IHpyVXRpbC5ub29wXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1hcHBpbmcgdG8gZXhpc3RzIGZvciBtZXJnZS5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fEFycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Db21wb25lbnQ+fSBleGlzdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdHxBcnJheS48T2JqZWN0Pn0gbmV3Q3B0T3B0aW9uc1xuICAgICAqIEByZXR1cm4ge0FycmF5LjxPYmplY3Q+fSBSZXN1bHQsIGxpa2UgW3tleGlzdDogLi4uLCBvcHRpb246IC4uLn0sIHt9XSxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpY2ggb3JkZXIgaXMgdGhlIHNhbWUgYXMgZXhpc3RzLlxuICAgICAqL1xuICAgIG1vZGVsVXRpbC5tYXBwaW5nVG9FeGlzdHMgPSBmdW5jdGlvbiAoZXhpc3RzLCBuZXdDcHRPcHRpb25zKSB7XG4gICAgICAgIC8vIE1hcHBpbmcgYnkgdGhlIG9yZGVyIGJ5IG9yaWdpbmFsIG9wdGlvbiAoYnV0IG5vdCBvcmRlciBvZlxuICAgICAgICAvLyBuZXcgb3B0aW9uKSBpbiBtZXJnZSBtb2RlLiBCZWNhdXNlIHdlIHNob3VsZCBlbnN1cmVcbiAgICAgICAgLy8gc29tZSBzcGVjaWZpZWQgaW5kZXggKGxpa2UgeEF4aXNJbmRleCkgaXMgY29uc2lzdGVudCB3aXRoXG4gICAgICAgIC8vIG9yaWdpbmFsIG9wdGlvbiwgd2hpY2ggaXMgZWFzeSB0byB1bmRlcnN0YW5kLCBlc3BhdGlhbGx5IGluXG4gICAgICAgIC8vIG1lZGlhIHF1ZXJ5LiBBbmQgaW4gbW9zdCBjYXNlLCBtZXJnZSBvcHRpb24gaXMgdXNlZCB0b1xuICAgICAgICAvLyB1cGRhdGUgcGFydGlhbCBvcHRpb24gYnV0IG5vdCBiZSBleHBlY3RlZCB0byBjaGFuZ2Ugb3JkZXIuXG4gICAgICAgIG5ld0NwdE9wdGlvbnMgPSAobmV3Q3B0T3B0aW9ucyB8fCBbXSkuc2xpY2UoKTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0genJVdGlsLm1hcChleGlzdHMgfHwgW10sIGZ1bmN0aW9uIChvYmosIGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4ge2V4aXN0OiBvYmp9O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBNYXBwaW5nIGJ5IGlkIG9yIG5hbWUgaWYgc3BlY2lmaWVkLlxuICAgICAgICB6clV0aWwuZWFjaChuZXdDcHRPcHRpb25zLCBmdW5jdGlvbiAoY3B0T3B0aW9uLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKCF6clV0aWwuaXNPYmplY3QoY3B0T3B0aW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWQgaGFzIGhpZ2hlc3QgcHJpb3JpdHkuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0W2ldLm9wdGlvbiAvLyBDb25zaWRlciBuYW1lOiB0d28gbWFwIHRvIG9uZS5cbiAgICAgICAgICAgICAgICAgICAgJiYgY3B0T3B0aW9uLmlkICE9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgJiYgcmVzdWx0W2ldLmV4aXN0LmlkID09PSBjcHRPcHRpb24uaWQgKyAnJ1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0ub3B0aW9uID0gY3B0T3B0aW9uO1xuICAgICAgICAgICAgICAgICAgICBuZXdDcHRPcHRpb25zW2luZGV4XSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0ID0gcmVzdWx0W2ldLmV4aXN0O1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0W2ldLm9wdGlvbiAvLyBDb25zaWRlciBuYW1lOiB0d28gbWFwIHRvIG9uZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FuIG5vdCBtYXRjaCB3aGVuIGJvdGggaWRzIGV4aXN0IGJ1dCBkaWZmZXJlbnQuXG4gICAgICAgICAgICAgICAgICAgICYmIChleGlzdC5pZCA9PSBudWxsIHx8IGNwdE9wdGlvbi5pZCA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAmJiBjcHRPcHRpb24ubmFtZSAhPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICYmICFtb2RlbFV0aWwuaXNJZElubmVyKGNwdE9wdGlvbilcbiAgICAgICAgICAgICAgICAgICAgJiYgIW1vZGVsVXRpbC5pc0lkSW5uZXIoZXhpc3QpXG4gICAgICAgICAgICAgICAgICAgICYmIGV4aXN0Lm5hbWUgPT09IGNwdE9wdGlvbi5uYW1lICsgJydcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldLm9wdGlvbiA9IGNwdE9wdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q3B0T3B0aW9uc1tpbmRleF0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBPdGhlcndpc2UgbWFwcGluZyBieSBpbmRleC5cbiAgICAgICAgenJVdGlsLmVhY2gobmV3Q3B0T3B0aW9ucywgZnVuY3Rpb24gKGNwdE9wdGlvbiwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghenJVdGlsLmlzT2JqZWN0KGNwdE9wdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0ID0gcmVzdWx0W2ldLmV4aXN0O1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0W2ldLm9wdGlvblxuICAgICAgICAgICAgICAgICAgICAmJiAhbW9kZWxVdGlsLmlzSWRJbm5lcihleGlzdClcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2F1dGlvbjpcbiAgICAgICAgICAgICAgICAgICAgLy8gRG8gbm90IG92ZXJ3cml0ZSBpZC4gQnV0IG5hbWUgY2FuIGJlIG92ZXJ3cml0dGVuLFxuICAgICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIGF4aXMgdXNlIG5hbWUgYXMgJ3Nob3cgbGFiZWwgdGV4dCcuXG4gICAgICAgICAgICAgICAgICAgIC8vICdleGlzdCcgYWx3YXlzIGhhcyBpZCBhbmQgbmFtZSBhbmQgd2UgZG9udFxuICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIGNoZWNrIGl0LlxuICAgICAgICAgICAgICAgICAgICAmJiBjcHRPcHRpb24uaWQgPT0gbnVsbFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0ub3B0aW9uID0gY3B0T3B0aW9uO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpID49IHJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7b3B0aW9uOiBjcHRPcHRpb259KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjcHRPcHRpb25cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIG1vZGVsVXRpbC5pc0lkSW5uZXIgPSBmdW5jdGlvbiAoY3B0T3B0aW9uKSB7XG4gICAgICAgIHJldHVybiB6clV0aWwuaXNPYmplY3QoY3B0T3B0aW9uKVxuICAgICAgICAgICAgJiYgY3B0T3B0aW9uLmlkXG4gICAgICAgICAgICAmJiAoY3B0T3B0aW9uLmlkICsgJycpLmluZGV4T2YoJ1xcMF9lY19cXDAnKSA9PT0gMDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQSBoZWxwZXIgZm9yIHJlbW92aW5nIGR1cGxpY2F0ZSBpdGVtcyBiZXR3ZWVuIGJhdGNoQSBhbmQgYmF0Y2hCLFxuICAgICAqIGFuZCBpbiB0aGVtc2VsdmVzLCBhbmQgY2F0ZWdvcml6ZSBieSBzZXJpZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBiYXRjaEEgTGlrZTogW3tzZXJpZXNJZDogMiwgZGF0YUluZGV4OiBbMzIsIDQsIDVdfSwgLi4uXVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGJhdGNoQiBMaWtlOiBbe3Nlcmllc0lkOiAyLCBkYXRhSW5kZXg6IFszMiwgNCwgNV19LCAuLi5dXG4gICAgICogQHJldHVybiB7QXJyYXkuPEFycmF5LjxPYmplY3Q+LCBBcnJheS48T2JqZWN0Pj59IHJlc3VsdDogW3Jlc3VsdEJhdGNoQSwgcmVzdWx0QmF0Y2hCXVxuICAgICAqL1xuICAgIG1vZGVsVXRpbC5jb21wcmVzc0JhdGNoZXMgPSBmdW5jdGlvbiAoYmF0Y2hBLCBiYXRjaEIpIHtcbiAgICAgICAgdmFyIG1hcEEgPSB7fTtcbiAgICAgICAgdmFyIG1hcEIgPSB7fTtcblxuICAgICAgICBtYWtlTWFwKGJhdGNoQSB8fCBbXSwgbWFwQSk7XG4gICAgICAgIG1ha2VNYXAoYmF0Y2hCIHx8IFtdLCBtYXBCLCBtYXBBKTtcblxuICAgICAgICByZXR1cm4gW21hcFRvQXJyYXkobWFwQSksIG1hcFRvQXJyYXkobWFwQildO1xuXG4gICAgICAgIGZ1bmN0aW9uIG1ha2VNYXAoc291cmNlQmF0Y2gsIG1hcCwgb3RoZXJNYXApIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2VCYXRjaC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBzZXJpZXNJZCA9IHNvdXJjZUJhdGNoW2ldLnNlcmllc0lkO1xuICAgICAgICAgICAgICAgIHZhciBkYXRhSW5kaWNlcyA9IG1vZGVsVXRpbC5ub3JtYWxpemVUb0FycmF5KHNvdXJjZUJhdGNoW2ldLmRhdGFJbmRleCk7XG4gICAgICAgICAgICAgICAgdmFyIG90aGVyRGF0YUluZGljZXMgPSBvdGhlck1hcCAmJiBvdGhlck1hcFtzZXJpZXNJZF07XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbGVuaiA9IGRhdGFJbmRpY2VzLmxlbmd0aDsgaiA8IGxlbmo7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YUluZGV4ID0gZGF0YUluZGljZXNbal07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyRGF0YUluZGljZXMgJiYgb3RoZXJEYXRhSW5kaWNlc1tkYXRhSW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdGhlckRhdGFJbmRpY2VzW2RhdGFJbmRleF0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgKG1hcFtzZXJpZXNJZF0gfHwgKG1hcFtzZXJpZXNJZF0gPSB7fSkpW2RhdGFJbmRleF0gPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbWFwVG9BcnJheShtYXAsIGlzRGF0YSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBtYXApIHtcbiAgICAgICAgICAgICAgICBpZiAobWFwLmhhc093blByb3BlcnR5KGkpICYmIG1hcFtpXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCtpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhSW5kaWNlcyA9IG1hcFRvQXJyYXkobWFwW2ldLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFJbmRpY2VzLmxlbmd0aCAmJiByZXN1bHQucHVzaCh7c2VyaWVzSWQ6IGksIGRhdGFJbmRleDogZGF0YUluZGljZXN9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIG1vZGVsVXRpbDtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvZWNoYXJ0cy91dGlsL21vZGVsLmpzXG4gKiogbW9kdWxlIGlkID0gOVxuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9jb3JlL3V0aWwnKTtcbiAgICB2YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoJy4vbnVtYmVyJyk7XG4gICAgdmFyIHRleHRDb250YWluID0gcmVxdWlyZSgnenJlbmRlci9jb250YWluL3RleHQnKTtcblxuICAgIHZhciBmb3JtYXRVdGlsID0ge307XG4gICAgLyoqXG4gICAgICog5q+P5LiJ5L2N6buY6K6k5YqgLOagvOW8j+WMllxuICAgICAqIEB0eXBlIHtzdHJpbmd8bnVtYmVyfSB4XG4gICAgICovXG4gICAgZm9ybWF0VXRpbC5hZGRDb21tYXMgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICBpZiAoaXNOYU4oeCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnLSc7XG4gICAgICAgIH1cbiAgICAgICAgeCA9ICh4ICsgJycpLnNwbGl0KCcuJyk7XG4gICAgICAgIHJldHVybiB4WzBdLnJlcGxhY2UoLyhcXGR7MSwzfSkoPz0oPzpcXGR7M30pKyg/IVxcZCkpL2csJyQxLCcpXG4gICAgICAgICAgICAgICArICh4Lmxlbmd0aCA+IDEgPyAoJy4nICsgeFsxXSkgOiAnJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHN0clxuICAgICAqL1xuICAgIGZvcm1hdFV0aWwudG9DYW1lbENhc2UgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8tKC4pL2csIGZ1bmN0aW9uKG1hdGNoLCBncm91cDEpIHtcbiAgICAgICAgICAgIHJldHVybiBncm91cDEudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZSBjc3MgbGlrZWQgYXJyYXkgY29uZmlndXJhdGlvblxuICAgICAqIGUuZy5cbiAgICAgKiAgMyA9PiBbMywgMywgMywgM11cbiAgICAgKiAgWzQsIDJdID0+IFs0LCAyLCA0LCAyXVxuICAgICAqICBbNCwgMywgMl0gPT4gWzQsIDMsIDIsIDNdXG4gICAgICogQHBhcmFtIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IHZhbFxuICAgICAqL1xuICAgIGZvcm1hdFV0aWwubm9ybWFsaXplQ3NzQXJyYXkgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHZhciBsZW4gPSB2YWwubGVuZ3RoO1xuICAgICAgICBpZiAodHlwZW9mICh2YWwpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIFt2YWwsIHZhbCwgdmFsLCB2YWxdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlbiA9PT0gMikge1xuICAgICAgICAgICAgLy8gdmVydGljYWwgfCBob3Jpem9udGFsXG4gICAgICAgICAgICByZXR1cm4gW3ZhbFswXSwgdmFsWzFdLCB2YWxbMF0sIHZhbFsxXV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuID09PSAzKSB7XG4gICAgICAgICAgICAvLyB0b3AgfCBob3Jpem9udGFsIHwgYm90dG9tXG4gICAgICAgICAgICByZXR1cm4gW3ZhbFswXSwgdmFsWzFdLCB2YWxbMl0sIHZhbFsxXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9O1xuXG4gICAgZm9ybWF0VXRpbC5lbmNvZGVIVE1MID0gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHNvdXJjZSlcbiAgICAgICAgICAgIC5yZXBsYWNlKC8mL2csICcmYW1wOycpXG4gICAgICAgICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgICAgICAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpXG4gICAgICAgICAgICAucmVwbGFjZSgvJy9nLCAnJiMzOTsnKTtcbiAgICB9O1xuXG4gICAgdmFyIFRQTF9WQVJfQUxJQVMgPSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ2cnXTtcblxuICAgIHZhciB3cmFwVmFyID0gZnVuY3Rpb24gKHZhck5hbWUsIHNlcmllc0lkeCkge1xuICAgICAgICByZXR1cm4gJ3snICsgdmFyTmFtZSArIChzZXJpZXNJZHggPT0gbnVsbCA/ICcnIDogc2VyaWVzSWR4KSArICd9JztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGVtcGxhdGUgZm9ybWF0dGVyXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSB0cGxcbiAgICAgKiBAcGFyYW0gIHtBcnJheS48T2JqZWN0PnxPYmplY3R9IHBhcmFtc0xpc3RcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZm9ybWF0VXRpbC5mb3JtYXRUcGwgPSBmdW5jdGlvbiAodHBsLCBwYXJhbXNMaXN0KSB7XG4gICAgICAgIGlmICghenJVdGlsLmlzQXJyYXkocGFyYW1zTGlzdCkpIHtcbiAgICAgICAgICAgIHBhcmFtc0xpc3QgPSBbcGFyYW1zTGlzdF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlcmllc0xlbiA9IHBhcmFtc0xpc3QubGVuZ3RoO1xuICAgICAgICBpZiAoIXNlcmllc0xlbikge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyICR2YXJzID0gcGFyYW1zTGlzdFswXS4kdmFycyB8fCBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAkdmFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGFsaWFzID0gVFBMX1ZBUl9BTElBU1tpXTtcbiAgICAgICAgICAgIHRwbCA9IHRwbC5yZXBsYWNlKHdyYXBWYXIoYWxpYXMpLCAgd3JhcFZhcihhbGlhcywgMCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHNlcmllc0lkeCA9IDA7IHNlcmllc0lkeCA8IHNlcmllc0xlbjsgc2VyaWVzSWR4KyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgJHZhcnMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICB0cGwgPSB0cGwucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgd3JhcFZhcihUUExfVkFSX0FMSUFTW2tdLCBzZXJpZXNJZHgpLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXNMaXN0W3Nlcmllc0lkeF1bJHZhcnNba11dXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cGw7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICB2YXIgczJkID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyIDwgMTAgPyAoJzAnICsgc3RyKSA6IHN0cjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSVNPIERhdGUgZm9ybWF0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRwbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZvcm1hdFV0aWwuZm9ybWF0VGltZSA9IGZ1bmN0aW9uICh0cGwsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0cGwgPT09ICd3ZWVrJ1xuICAgICAgICAgICAgfHwgdHBsID09PSAnbW9udGgnXG4gICAgICAgICAgICB8fCB0cGwgPT09ICdxdWFydGVyJ1xuICAgICAgICAgICAgfHwgdHBsID09PSAnaGFsZi15ZWFyJ1xuICAgICAgICAgICAgfHwgdHBsID09PSAneWVhcidcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0cGwgPSAnTU0tZGRcXG55eXl5JztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRlID0gbnVtYmVyVXRpbC5wYXJzZURhdGUodmFsdWUpO1xuICAgICAgICB2YXIgeSA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgdmFyIE0gPSBkYXRlLmdldE1vbnRoKCkgKyAxO1xuICAgICAgICB2YXIgZCA9IGRhdGUuZ2V0RGF0ZSgpO1xuICAgICAgICB2YXIgaCA9IGRhdGUuZ2V0SG91cnMoKTtcbiAgICAgICAgdmFyIG0gPSBkYXRlLmdldE1pbnV0ZXMoKTtcbiAgICAgICAgdmFyIHMgPSBkYXRlLmdldFNlY29uZHMoKTtcblxuICAgICAgICB0cGwgPSB0cGwucmVwbGFjZSgnTU0nLCBzMmQoTSkpXG4gICAgICAgICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgLnJlcGxhY2UoJ3l5eXknLCB5KVxuICAgICAgICAgICAgLnJlcGxhY2UoJ3l5JywgeSAlIDEwMClcbiAgICAgICAgICAgIC5yZXBsYWNlKCdkZCcsIHMyZChkKSlcbiAgICAgICAgICAgIC5yZXBsYWNlKCdkJywgZClcbiAgICAgICAgICAgIC5yZXBsYWNlKCdoaCcsIHMyZChoKSlcbiAgICAgICAgICAgIC5yZXBsYWNlKCdoJywgaClcbiAgICAgICAgICAgIC5yZXBsYWNlKCdtbScsIHMyZChtKSlcbiAgICAgICAgICAgIC5yZXBsYWNlKCdtJywgbSlcbiAgICAgICAgICAgIC5yZXBsYWNlKCdzcycsIHMyZChzKSlcbiAgICAgICAgICAgIC5yZXBsYWNlKCdzJywgcyk7XG5cbiAgICAgICAgcmV0dXJuIHRwbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FwaXRhbCBmaXJzdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZm9ybWF0VXRpbC5jYXBpdGFsRmlyc3QgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIgPyBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyKDEpIDogc3RyO1xuICAgIH07XG5cbiAgICBmb3JtYXRVdGlsLnRydW5jYXRlVGV4dCA9IHRleHRDb250YWluLnRydW5jYXRlVGV4dDtcblxuICAgIHJldHVybiBmb3JtYXRVdGlsO1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC9lY2hhcnRzL3V0aWwvZm9ybWF0LmpzXG4gKiogbW9kdWxlIGlkID0gMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsIi8qKlxuICog5pWw5YC85aSE55CG5qih5Z2XXG4gKiBAbW9kdWxlIGVjaGFydHMvdXRpbC9udW1iZXJcbiAqL1xuXG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuICAgIHZhciBudW1iZXIgPSB7fTtcblxuICAgIHZhciBSQURJQU5fRVBTSUxPTiA9IDFlLTQ7XG5cbiAgICBmdW5jdGlvbiBfdHJpbShzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKy8sICcnKS5yZXBsYWNlKC9cXHMrJC8sICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaW5lYXIgbWFwcGluZyBhIHZhbHVlIGZyb20gZG9tYWluIHRvIHJhbmdlXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTplY2hhcnRzL3V0aWwvbnVtYmVyXG4gICAgICogQHBhcmFtICB7KG51bWJlcnxBcnJheS48bnVtYmVyPil9IHZhbFxuICAgICAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSBkb21haW4gRG9tYWluIGV4dGVudCBkb21haW5bMF0gY2FuIGJlIGJpZ2dlciB0aGFuIGRvbWFpblsxXVxuICAgICAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSByYW5nZSAgUmFuZ2UgZXh0ZW50IHJhbmdlWzBdIGNhbiBiZSBiaWdnZXIgdGhhbiByYW5nZVsxXVxuICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IGNsYW1wXG4gICAgICogQHJldHVybiB7KG51bWJlcnxBcnJheS48bnVtYmVyPn1cbiAgICAgKi9cbiAgICBudW1iZXIubGluZWFyTWFwID0gZnVuY3Rpb24gKHZhbCwgZG9tYWluLCByYW5nZSwgY2xhbXApIHtcbiAgICAgICAgdmFyIHN1YkRvbWFpbiA9IGRvbWFpblsxXSAtIGRvbWFpblswXTtcbiAgICAgICAgdmFyIHN1YlJhbmdlID0gcmFuZ2VbMV0gLSByYW5nZVswXTtcblxuICAgICAgICBpZiAoc3ViRG9tYWluID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gc3ViUmFuZ2UgPT09IDBcbiAgICAgICAgICAgICAgICA/IHJhbmdlWzBdXG4gICAgICAgICAgICAgICAgOiAocmFuZ2VbMF0gKyByYW5nZVsxXSkgLyAyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXZvaWQgYWNjdXJhY3kgcHJvYmxlbSBpbiBlZGdlLCBzdWNoIGFzXG4gICAgICAgIC8vIDE0Ni4zOSAtIDYyLjgzID09PSA4My41NTk5OTk5OTk5OTk5OS5cbiAgICAgICAgLy8gU2VlIGVjaGFydHMvdGVzdC91dC9zcGVjL3V0aWwvbnVtYmVyLmpzI2xpbmVhck1hcCNhY2N1cmFjeUVycm9yXG4gICAgICAgIC8vIEl0IGlzIGEgbGl0dGxlIHZlcmJvc2UgZm9yIGVmZmljaWVuY3kgY29uc2lkZXJpbmcgdGhpcyBtZXRob2RcbiAgICAgICAgLy8gaXMgYSBob3RzcG90LlxuICAgICAgICBpZiAoY2xhbXApIHtcbiAgICAgICAgICAgIGlmIChzdWJEb21haW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbCA8PSBkb21haW5bMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWwgPj0gZG9tYWluWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByYW5nZVsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsID49IGRvbWFpblswXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA8PSBkb21haW5bMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2YWwgPT09IGRvbWFpblswXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWwgPT09IGRvbWFpblsxXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAodmFsIC0gZG9tYWluWzBdKSAvIHN1YkRvbWFpbiAqIHN1YlJhbmdlICsgcmFuZ2VbMF07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBwZXJjZW50IHN0cmluZyB0byBhYnNvbHV0ZSBudW1iZXIuXG4gICAgICogUmV0dXJucyBOYU4gaWYgcGVyY2VudCBpcyBub3QgYSB2YWxpZCBzdHJpbmcgb3IgbnVtYmVyXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTplY2hhcnRzL3V0aWwvbnVtYmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBwZXJjZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFsbFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBudW1iZXIucGFyc2VQZXJjZW50ID0gZnVuY3Rpb24ocGVyY2VudCwgYWxsKSB7XG4gICAgICAgIHN3aXRjaCAocGVyY2VudCkge1xuICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICAgICAgcGVyY2VudCA9ICc1MCUnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgIHBlcmNlbnQgPSAnMCUnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICBwZXJjZW50ID0gJzEwMCUnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcGVyY2VudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmIChfdHJpbShwZXJjZW50KS5tYXRjaCgvJSQvKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHBlcmNlbnQpIC8gMTAwICogYWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChwZXJjZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwZXJjZW50ID09IG51bGwgPyBOYU4gOiArcGVyY2VudDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRml4IHJvdW5kaW5nIGVycm9yIG9mIGZsb2F0IG51bWJlcnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBudW1iZXIucm91bmQgPSBmdW5jdGlvbiAoeCwgcHJlY2lzaW9uKSB7XG4gICAgICAgIGlmIChwcmVjaXNpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJlY2lzaW9uID0gMTA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUEVORElOR1xuICAgICAgICByZXR1cm4gKygreCkudG9GaXhlZChwcmVjaXNpb24pO1xuICAgIH07XG5cbiAgICBudW1iZXIuYXNjID0gZnVuY3Rpb24gKGFycikge1xuICAgICAgICBhcnIuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHByZWNpc2lvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWxcbiAgICAgKi9cbiAgICBudW1iZXIuZ2V0UHJlY2lzaW9uID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB2YWwgPSArdmFsO1xuICAgICAgICBpZiAoaXNOYU4odmFsKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXQgaXMgbXVjaCBmYXN0ZXIgdGhhbiBtZXRob2RzIGNvbnZlcnRpbmcgbnVtYmVyIHRvIHN0cmluZyBhcyBmb2xsb3dzXG4gICAgICAgIC8vICAgICAgdmFyIHRtcCA9IHZhbC50b1N0cmluZygpO1xuICAgICAgICAvLyAgICAgIHJldHVybiB0bXAubGVuZ3RoIC0gMSAtIHRtcC5pbmRleE9mKCcuJyk7XG4gICAgICAgIC8vIGVzcGVjaWFsbHkgd2hlbiBwcmVjaXNpb24gaXMgbG93XG4gICAgICAgIHZhciBlID0gMTtcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgd2hpbGUgKE1hdGgucm91bmQodmFsICogZSkgLyBlICE9PSB2YWwpIHtcbiAgICAgICAgICAgIGUgKj0gMTA7XG4gICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9O1xuXG4gICAgbnVtYmVyLmdldFByZWNpc2lvblNhZmUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHZhciBzdHIgPSB2YWwudG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIGRvdEluZGV4ID0gc3RyLmluZGV4T2YoJy4nKTtcbiAgICAgICAgaWYgKGRvdEluZGV4IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0ci5sZW5ndGggLSAxIC0gZG90SW5kZXg7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGRhdGFFeHRlbnRcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBwaXhlbEV4dGVudFxuICAgICAqIEByZXR1cm4ge251bWJlcn0gIHByZWNpc2lvblxuICAgICAqL1xuICAgIG51bWJlci5nZXRQaXhlbFByZWNpc2lvbiA9IGZ1bmN0aW9uIChkYXRhRXh0ZW50LCBwaXhlbEV4dGVudCkge1xuICAgICAgICB2YXIgbG9nID0gTWF0aC5sb2c7XG4gICAgICAgIHZhciBMTjEwID0gTWF0aC5MTjEwO1xuICAgICAgICB2YXIgZGF0YVF1YW50aXR5ID0gTWF0aC5mbG9vcihsb2coZGF0YUV4dGVudFsxXSAtIGRhdGFFeHRlbnRbMF0pIC8gTE4xMCk7XG4gICAgICAgIHZhciBzaXplUXVhbnRpdHkgPSBNYXRoLnJvdW5kKGxvZyhNYXRoLmFicyhwaXhlbEV4dGVudFsxXSAtIHBpeGVsRXh0ZW50WzBdKSkgLyBMTjEwKTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KFxuICAgICAgICAgICAgLWRhdGFRdWFudGl0eSArIHNpemVRdWFudGl0eSxcbiAgICAgICAgICAgIDBcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgLy8gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsIGllIGRvIG5vdCBzdXBwb3J0LlxuICAgIG51bWJlci5NQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuICAgIC8qKlxuICAgICAqIFRvIDAgLSAyICogUEksIGNvbnNpZGVyaW5nIG5lZ2F0aXZlIHJhZGlhbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaWFuXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIG51bWJlci5yZW1SYWRpYW4gPSBmdW5jdGlvbiAocmFkaWFuKSB7XG4gICAgICAgIHZhciBwaTIgPSBNYXRoLlBJICogMjtcbiAgICAgICAgcmV0dXJuIChyYWRpYW4gJSBwaTIgKyBwaTIpICUgcGkyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3R5cGV9IHJhZGlhblxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgbnVtYmVyLmlzUmFkaWFuQXJvdW5kWmVybyA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbCA+IC1SQURJQU5fRVBTSUxPTiAmJiB2YWwgPCBSQURJQU5fRVBTSUxPTjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8RGF0ZXxudW1iZXJ9IHZhbHVlXG4gICAgICogQHJldHVybiB7RGF0ZX0gZGF0ZVxuICAgICAqL1xuICAgIG51bWJlci5wYXJzZURhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIFRyZWF0IGFzIElTTyBmb3JtYXQuIFNlZSBpc3N1ZSAjMzYyM1xuICAgICAgICAgICAgdmFyIHJldCA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChpc05hTigrcmV0KSkge1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FIG5ldyBEYXRlKCcxOTcwLTAxLTAxJykgaXMgVVRDLCBuZXcgRGF0ZSgnMTk3MC8wMS8wMScpIGlzIGxvY2FsXG4gICAgICAgICAgICAgICAgcmV0ID0gbmV3IERhdGUobmV3IERhdGUodmFsdWUucmVwbGFjZSgvLS9nLCAnLycpKSAtIG5ldyBEYXRlKCcxOTcwLzAxLzAxJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShNYXRoLnJvdW5kKHZhbHVlKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFF1YW50aXR5IG9mIGEgbnVtYmVyLiBlLmcuIDAuMSwgMSwgMTAsIDEwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gdmFsXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIG51bWJlci5xdWFudGl0eSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KDEwLCBNYXRoLmZsb29yKE1hdGgubG9nKHZhbCkgLyBNYXRoLkxOMTApKTtcbiAgICB9O1xuXG4gICAgLy8gXCJOaWNlIE51bWJlcnMgZm9yIEdyYXBoIExhYmVsc1wiIG9mIEdyYXBoaWMgR2Vtc1xuICAgIC8qKlxuICAgICAqIGZpbmQgYSDigJxuaWNl4oCdIG51bWJlciBhcHByb3hpbWF0ZWx5IGVxdWFsIHRvIHguIFJvdW5kIHRoZSBudW1iZXIgaWYgcm91bmQgPSB0cnVlLCB0YWtlIGNlaWxpbmcgaWYgcm91bmQgPSBmYWxzZVxuICAgICAqIFRoZSBwcmltYXJ5IG9ic2VydmF0aW9uIGlzIHRoYXQgdGhlIOKAnG5pY2VzdOKAnSBudW1iZXJzIGluIGRlY2ltYWwgYXJlIDEsIDIsIGFuZCA1LCBhbmQgYWxsIHBvd2VyLW9mLXRlbiBtdWx0aXBsZXMgb2YgdGhlc2UgbnVtYmVycy5cbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHZhbFxuICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IHJvdW5kXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIG51bWJlci5uaWNlID0gZnVuY3Rpb24gKHZhbCwgcm91bmQpIHtcbiAgICAgICAgdmFyIGV4cDEwID0gbnVtYmVyLnF1YW50aXR5KHZhbCk7XG4gICAgICAgIHZhciBmID0gdmFsIC8gZXhwMTA7IC8vIGJldHdlZW4gMSBhbmQgMTBcbiAgICAgICAgdmFyIG5mO1xuICAgICAgICBpZiAocm91bmQpIHtcbiAgICAgICAgICAgIGlmIChmIDwgMS41KSB7IG5mID0gMTsgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZiA8IDIuNSkgeyBuZiA9IDI7IH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGYgPCA0KSB7IG5mID0gMzsgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZiA8IDcpIHsgbmYgPSA1OyB9XG4gICAgICAgICAgICBlbHNlIHsgbmYgPSAxMDsgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGYgPCAxKSB7IG5mID0gMTsgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZiA8IDIpIHsgbmYgPSAyOyB9XG4gICAgICAgICAgICBlbHNlIGlmIChmIDwgMykgeyBuZiA9IDM7IH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGYgPCA1KSB7IG5mID0gNTsgfVxuICAgICAgICAgICAgZWxzZSB7IG5mID0gMTA7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmYgKiBleHAxMDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIG51bWJlcjtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvZWNoYXJ0cy91dGlsL251bWJlci5qc1xuICoqIG1vZHVsZSBpZCA9IDExXG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCJkZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuICAgIHZhciB0ZXh0V2lkdGhDYWNoZSA9IHt9O1xuICAgIHZhciB0ZXh0V2lkdGhDYWNoZUNvdW50ZXIgPSAwO1xuICAgIHZhciBURVhUX0NBQ0hFX01BWCA9IDUwMDA7XG5cbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCcuLi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xuICAgIHZhciByZXRyaWV2ZSA9IHV0aWwucmV0cmlldmU7XG5cbiAgICBmdW5jdGlvbiBnZXRUZXh0V2lkdGgodGV4dCwgdGV4dEZvbnQpIHtcbiAgICAgICAgdmFyIGtleSA9IHRleHQgKyAnOicgKyB0ZXh0Rm9udDtcbiAgICAgICAgaWYgKHRleHRXaWR0aENhY2hlW2tleV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0V2lkdGhDYWNoZVtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRleHRMaW5lcyA9ICh0ZXh0ICsgJycpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgdmFyIHdpZHRoID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRleHRMaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1lYXN1cmVUZXh0IOWPr+S7peiiq+imhuebluS7peWFvOWuueS4jeaUr+aMgSBDYW52YXMg55qE546v5aKDXG4gICAgICAgICAgICB3aWR0aCA9IE1hdGgubWF4KHRleHRDb250YWluLm1lYXN1cmVUZXh0KHRleHRMaW5lc1tpXSwgdGV4dEZvbnQpLndpZHRoLCB3aWR0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dFdpZHRoQ2FjaGVDb3VudGVyID4gVEVYVF9DQUNIRV9NQVgpIHtcbiAgICAgICAgICAgIHRleHRXaWR0aENhY2hlQ291bnRlciA9IDA7XG4gICAgICAgICAgICB0ZXh0V2lkdGhDYWNoZSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRleHRXaWR0aENhY2hlQ291bnRlcisrO1xuICAgICAgICB0ZXh0V2lkdGhDYWNoZVtrZXldID0gd2lkdGg7XG5cbiAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRleHRSZWN0KHRleHQsIHRleHRGb250LCB0ZXh0QWxpZ24sIHRleHRCYXNlbGluZSkge1xuICAgICAgICB2YXIgdGV4dExpbmVMZW4gPSAoKHRleHQgfHwgJycpICsgJycpLnNwbGl0KCdcXG4nKS5sZW5ndGg7XG5cbiAgICAgICAgdmFyIHdpZHRoID0gZ2V0VGV4dFdpZHRoKHRleHQsIHRleHRGb250KTtcbiAgICAgICAgLy8gRklYTUUg6auY5bqm6K6h566X5q+U6L6D57KX5pq0XG4gICAgICAgIHZhciBsaW5lSGVpZ2h0ID0gZ2V0VGV4dFdpZHRoKCflm70nLCB0ZXh0Rm9udCk7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0ZXh0TGluZUxlbiAqIGxpbmVIZWlnaHQ7XG5cbiAgICAgICAgdmFyIHJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAvLyBUZXh0IGhhcyBhIHNwZWNpYWwgbGluZSBoZWlnaHQgcHJvcGVydHlcbiAgICAgICAgcmVjdC5saW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcblxuICAgICAgICBzd2l0Y2ggKHRleHRCYXNlbGluZSkge1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIGNhc2UgJ2FscGhhYmV0aWMnOlxuICAgICAgICAgICAgICAgIHJlY3QueSAtPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICAgICAgICByZWN0LnkgLT0gbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBjYXNlICdoYW5naW5nJzpcbiAgICAgICAgICAgIC8vIGNhc2UgJ3RvcCc6XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGSVhNRSBSaWdodCB0byBsZWZ0IGxhbmd1YWdlXG4gICAgICAgIHN3aXRjaCAodGV4dEFsaWduKSB7XG4gICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIHJlY3QueCAtPSByZWN0LndpZHRoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICByZWN0LnggLT0gcmVjdC53aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBjYXNlICdzdGFydCc6XG4gICAgICAgICAgICAvLyBjYXNlICdsZWZ0JzpcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkanVzdFRleHRQb3NpdGlvbk9uUmVjdCh0ZXh0UG9zaXRpb24sIHJlY3QsIHRleHRSZWN0LCBkaXN0YW5jZSkge1xuXG4gICAgICAgIHZhciB4ID0gcmVjdC54O1xuICAgICAgICB2YXIgeSA9IHJlY3QueTtcblxuICAgICAgICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgIHZhciB3aWR0aCA9IHJlY3Qud2lkdGg7XG5cbiAgICAgICAgdmFyIHRleHRIZWlnaHQgPSB0ZXh0UmVjdC5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyIC0gdGV4dEhlaWdodCAvIDI7XG5cbiAgICAgICAgdmFyIHRleHRBbGlnbiA9ICdsZWZ0JztcblxuICAgICAgICBzd2l0Y2ggKHRleHRQb3NpdGlvbikge1xuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgeCAtPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICB4ICs9IGRpc3RhbmNlICsgd2lkdGg7XG4gICAgICAgICAgICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgeSAtPSBkaXN0YW5jZSArIHRleHRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHkgKz0gaGVpZ2h0ICsgZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnNpZGUnOlxuICAgICAgICAgICAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHkgKz0gaGFsZkhlaWdodDtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZUxlZnQnOlxuICAgICAgICAgICAgICAgIHggKz0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZVJpZ2h0JzpcbiAgICAgICAgICAgICAgICB4ICs9IHdpZHRoIC0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnNpZGVUb3AnOlxuICAgICAgICAgICAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHkgKz0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnNpZGVCb3R0b20nOlxuICAgICAgICAgICAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHkgKz0gaGVpZ2h0IC0gdGV4dEhlaWdodCAtIGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zaWRlVG9wTGVmdCc6XG4gICAgICAgICAgICAgICAgeCArPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB5ICs9IGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZVRvcFJpZ2h0JzpcbiAgICAgICAgICAgICAgICB4ICs9IHdpZHRoIC0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgeSArPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zaWRlQm90dG9tTGVmdCc6XG4gICAgICAgICAgICAgICAgeCArPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB5ICs9IGhlaWdodCAtIHRleHRIZWlnaHQgLSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZUJvdHRvbVJpZ2h0JzpcbiAgICAgICAgICAgICAgICB4ICs9IHdpZHRoIC0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgeSArPSBoZWlnaHQgLSB0ZXh0SGVpZ2h0IC0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiAndG9wJ1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNob3cgZWxsaXBzaXMgaWYgb3ZlcmZsb3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRleHRcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGNvbnRhaW5lcldpZHRoXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0Rm9udFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gW2VsbGlwc2lzPScuLi4nXVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5tYXhJdGVyYXRpb25zPTNdXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5taW5DaGFyPTBdIElmIHRydW5jYXRlIHJlc3VsdCBhcmUgbGVzc1xuICAgICAqICAgICAgICAgICAgICAgICAgdGhlbiBtaW5DaGFyLCBlbGxpcHNpcyB3aWxsIG5vdCBzaG93LCB3aGljaCBpc1xuICAgICAqICAgICAgICAgICAgICAgICAgYmV0dGVyIGZvciB1c2VyIGhpbnQgaW4gc29tZSBjYXNlcy5cbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLnBsYWNlaG9sZGVyPScnXSBXaGVuIGFsbCB0cnVuY2F0ZWQsIHVzZSB0aGUgcGxhY2Vob2xkZXIuXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRydW5jYXRlVGV4dCh0ZXh0LCBjb250YWluZXJXaWR0aCwgdGV4dEZvbnQsIGVsbGlwc2lzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghY29udGFpbmVyV2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIGVsbGlwc2lzID0gcmV0cmlldmUoZWxsaXBzaXMsICcuLi4nKTtcbiAgICAgICAgdmFyIG1heEl0ZXJhdGlvbnMgPSByZXRyaWV2ZShvcHRpb25zLm1heEl0ZXJhdGlvbnMsIDIpO1xuICAgICAgICB2YXIgbWluQ2hhciA9IHJldHJpZXZlKG9wdGlvbnMubWluQ2hhciwgMCk7XG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIC8vIE90aGVyIGxhbmd1YWdlcz9cbiAgICAgICAgdmFyIGNuQ2hhcldpZHRoID0gZ2V0VGV4dFdpZHRoKCflm70nLCB0ZXh0Rm9udCk7XG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIC8vIENvbnNpZGVyIHByb3BvcnRpb25hbCBmb250P1xuICAgICAgICB2YXIgYXNjQ2hhcldpZHRoID0gZ2V0VGV4dFdpZHRoKCdhJywgdGV4dEZvbnQpO1xuICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSByZXRyaWV2ZShvcHRpb25zLnBsYWNlaG9sZGVyLCAnJyk7XG5cbiAgICAgICAgLy8gRXhhbXBsZSAxOiBtaW5DaGFyOiAzLCB0ZXh0OiAnYXNkZnp4Y3YnLCB0cnVuY2F0ZSByZXN1bHQ6ICdhc2RmJywgYnV0IG5vdDogJ2EuLi4nLlxuICAgICAgICAvLyBFeGFtcGxlIDI6IG1pbkNoYXI6IDMsIHRleHQ6ICfnu7TluqYnLCB0cnVuY2F0ZSByZXN1bHQ6ICfnu7QnLCBidXQgbm90OiAnLi4uJy5cbiAgICAgICAgdmFyIGNvbnRlbnRXaWR0aCA9IGNvbnRhaW5lcldpZHRoID0gTWF0aC5tYXgoMCwgY29udGFpbmVyV2lkdGggLSAxKTsgLy8gUmVzZXJ2ZSBzb21lIGdhcC5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW5DaGFyICYmIGNvbnRlbnRXaWR0aCA+PSBhc2NDaGFyV2lkdGg7IGkrKykge1xuICAgICAgICAgICAgY29udGVudFdpZHRoIC09IGFzY0NoYXJXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbGxpcHNpc1dpZHRoID0gZ2V0VGV4dFdpZHRoKGVsbGlwc2lzKTtcbiAgICAgICAgaWYgKGVsbGlwc2lzV2lkdGggPiBjb250ZW50V2lkdGgpIHtcbiAgICAgICAgICAgIGVsbGlwc2lzID0gJyc7XG4gICAgICAgICAgICBlbGxpcHNpc1dpZHRoID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRlbnRXaWR0aCA9IGNvbnRhaW5lcldpZHRoIC0gZWxsaXBzaXNXaWR0aDtcblxuICAgICAgICB2YXIgdGV4dExpbmVzID0gKHRleHQgKyAnJykuc3BsaXQoJ1xcbicpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0ZXh0TGluZSA9IHRleHRMaW5lc1tpXTtcbiAgICAgICAgICAgIHZhciBsaW5lV2lkdGggPSBnZXRUZXh0V2lkdGgodGV4dExpbmUsIHRleHRGb250KTtcblxuICAgICAgICAgICAgaWYgKGxpbmVXaWR0aCA8PSBjb250YWluZXJXaWR0aCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDs7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChsaW5lV2lkdGggPD0gY29udGVudFdpZHRoIHx8IGogPj0gbWF4SXRlcmF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0TGluZSArPSBlbGxpcHNpcztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHN1Ykxlbmd0aCA9IGogPT09IDBcbiAgICAgICAgICAgICAgICAgICAgPyBlc3RpbWF0ZUxlbmd0aCh0ZXh0TGluZSwgY29udGVudFdpZHRoLCBhc2NDaGFyV2lkdGgsIGNuQ2hhcldpZHRoKVxuICAgICAgICAgICAgICAgICAgICA6IGxpbmVXaWR0aCA+IDBcbiAgICAgICAgICAgICAgICAgICAgPyBNYXRoLmZsb29yKHRleHRMaW5lLmxlbmd0aCAqIGNvbnRlbnRXaWR0aCAvIGxpbmVXaWR0aClcbiAgICAgICAgICAgICAgICAgICAgOiAwO1xuXG4gICAgICAgICAgICAgICAgdGV4dExpbmUgPSB0ZXh0TGluZS5zdWJzdHIoMCwgc3ViTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGggPSBnZXRUZXh0V2lkdGgodGV4dExpbmUsIHRleHRGb250KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRleHRMaW5lID09PSAnJykge1xuICAgICAgICAgICAgICAgIHRleHRMaW5lID0gcGxhY2Vob2xkZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRleHRMaW5lc1tpXSA9IHRleHRMaW5lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRleHRMaW5lcy5qb2luKCdcXG4nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlc3RpbWF0ZUxlbmd0aCh0ZXh0LCBjb250ZW50V2lkdGgsIGFzY0NoYXJXaWR0aCwgY25DaGFyV2lkdGgpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gMDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICBmb3IgKHZhciBsZW4gPSB0ZXh0Lmxlbmd0aDsgaSA8IGxlbiAmJiB3aWR0aCA8IGNvbnRlbnRXaWR0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICB3aWR0aCArPSAoMCA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSAxMjcpID8gYXNjQ2hhcldpZHRoIDogY25DaGFyV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuXG4gICAgdmFyIHRleHRDb250YWluID0ge1xuXG4gICAgICAgIGdldFdpZHRoOiBnZXRUZXh0V2lkdGgsXG5cbiAgICAgICAgZ2V0Qm91bmRpbmdSZWN0OiBnZXRUZXh0UmVjdCxcblxuICAgICAgICBhZGp1c3RUZXh0UG9zaXRpb25PblJlY3Q6IGFkanVzdFRleHRQb3NpdGlvbk9uUmVjdCxcblxuICAgICAgICB0cnVuY2F0ZVRleHQ6IHRydW5jYXRlVGV4dCxcblxuICAgICAgICBtZWFzdXJlVGV4dDogZnVuY3Rpb24gKHRleHQsIHRleHRGb250KSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdXRpbC5nZXRDb250ZXh0KCk7XG4gICAgICAgICAgICBjdHguZm9udCA9IHRleHRGb250IHx8ICcxMnB4IHNhbnMtc2VyaWYnO1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5tZWFzdXJlVGV4dCh0ZXh0KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gdGV4dENvbnRhaW47XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL3pyZW5kZXIvY29udGFpbi90ZXh0LmpzXG4gKiogbW9kdWxlIGlkID0gMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsIi8qKlxuICogQG1vZHVsZSBlY2hhcnRzL2NvcmUvQm91bmRpbmdSZWN0XG4gKi9cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuL3ZlY3RvcicpO1xuICAgIHZhciBtYXRyaXggPSByZXF1aXJlKCcuL21hdHJpeCcpO1xuXG4gICAgdmFyIHYyQXBwbHlUcmFuc2Zvcm0gPSB2ZWMyLmFwcGx5VHJhbnNmb3JtO1xuICAgIHZhciBtYXRoTWluID0gTWF0aC5taW47XG4gICAgdmFyIG1hdGhBYnMgPSBNYXRoLmFicztcbiAgICB2YXIgbWF0aE1heCA9IE1hdGgubWF4O1xuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJvdW5kaW5nUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG5cbiAgICBCb3VuZGluZ1JlY3QucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBCb3VuZGluZ1JlY3QsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3R9IG90aGVyXG4gICAgICAgICAqL1xuICAgICAgICB1bmlvbjogZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgICAgICB2YXIgeCA9IG1hdGhNaW4ob3RoZXIueCwgdGhpcy54KTtcbiAgICAgICAgICAgIHZhciB5ID0gbWF0aE1pbihvdGhlci55LCB0aGlzLnkpO1xuXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gbWF0aE1heChcbiAgICAgICAgICAgICAgICAgICAgb3RoZXIueCArIG90aGVyLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnggKyB0aGlzLndpZHRoXG4gICAgICAgICAgICAgICAgKSAtIHg7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IG1hdGhNYXgoXG4gICAgICAgICAgICAgICAgICAgIG90aGVyLnkgKyBvdGhlci5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueSArIHRoaXMuaGVpZ2h0XG4gICAgICAgICAgICAgICAgKSAtIHk7XG4gICAgICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbVxuICAgICAgICAgKiBAbWV0aG9kc1xuICAgICAgICAgKi9cbiAgICAgICAgYXBwbHlUcmFuc2Zvcm06IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWluID0gW107XG4gICAgICAgICAgICB2YXIgbWF4ID0gW107XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIHVzYWdlIGxpa2UgdGhpc1xuICAgICAgICAgICAgICAgIC8vIGVsLmdldEJvdW5kaW5nUmVjdCgpLmFwcGx5VHJhbnNmb3JtKGVsLnRyYW5zZm9ybSlcbiAgICAgICAgICAgICAgICAvLyBBbmQgZWxlbWVudCBoYXMgbm8gdHJhbnNmb3JtXG4gICAgICAgICAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWluWzBdID0gdGhpcy54O1xuICAgICAgICAgICAgICAgIG1pblsxXSA9IHRoaXMueTtcbiAgICAgICAgICAgICAgICBtYXhbMF0gPSB0aGlzLnggKyB0aGlzLndpZHRoO1xuICAgICAgICAgICAgICAgIG1heFsxXSA9IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgdjJBcHBseVRyYW5zZm9ybShtaW4sIG1pbiwgbSk7XG4gICAgICAgICAgICAgICAgdjJBcHBseVRyYW5zZm9ybShtYXgsIG1heCwgbSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnggPSBtYXRoTWluKG1pblswXSwgbWF4WzBdKTtcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSBtYXRoTWluKG1pblsxXSwgbWF4WzFdKTtcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gbWF0aEFicyhtYXhbMF0gLSBtaW5bMF0pO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gbWF0aEFicyhtYXhbMV0gLSBtaW5bMV0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoKSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsY3VsYXRlIG1hdHJpeCBvZiB0cmFuc2Zvcm1pbmcgZnJvbSBzZWxmIHRvIHRhcmdldCByZWN0XG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fSBiXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgY2FsY3VsYXRlVHJhbnNmb3JtOiBmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHN4ID0gYi53aWR0aCAvIGEud2lkdGg7XG4gICAgICAgICAgICB2YXIgc3kgPSBiLmhlaWdodCAvIGEuaGVpZ2h0O1xuXG4gICAgICAgICAgICB2YXIgbSA9IG1hdHJpeC5jcmVhdGUoKTtcblxuICAgICAgICAgICAgLy8g55+p6Zi15Y+z5LmYXG4gICAgICAgICAgICBtYXRyaXgudHJhbnNsYXRlKG0sIG0sIFstYS54LCAtYS55XSk7XG4gICAgICAgICAgICBtYXRyaXguc2NhbGUobSwgbSwgW3N4LCBzeV0pO1xuICAgICAgICAgICAgbWF0cml4LnRyYW5zbGF0ZShtLCBtLCBbYi54LCBiLnldKTtcblxuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7KG1vZHVsZTplY2hhcnRzL2NvcmUvQm91bmRpbmdSZWN0fE9iamVjdCl9IGJcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGludGVyc2VjdDogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgIHZhciBhID0gdGhpcztcbiAgICAgICAgICAgIHZhciBheDAgPSBhLng7XG4gICAgICAgICAgICB2YXIgYXgxID0gYS54ICsgYS53aWR0aDtcbiAgICAgICAgICAgIHZhciBheTAgPSBhLnk7XG4gICAgICAgICAgICB2YXIgYXkxID0gYS55ICsgYS5oZWlnaHQ7XG5cbiAgICAgICAgICAgIHZhciBieDAgPSBiLng7XG4gICAgICAgICAgICB2YXIgYngxID0gYi54ICsgYi53aWR0aDtcbiAgICAgICAgICAgIHZhciBieTAgPSBiLnk7XG4gICAgICAgICAgICB2YXIgYnkxID0gYi55ICsgYi5oZWlnaHQ7XG5cbiAgICAgICAgICAgIHJldHVybiAhIChheDEgPCBieDAgfHwgYngxIDwgYXgwIHx8IGF5MSA8IGJ5MCB8fCBieTEgPCBheTApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbnRhaW46IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4geCA+PSByZWN0LnhcbiAgICAgICAgICAgICAgICAmJiB4IDw9IChyZWN0LnggKyByZWN0LndpZHRoKVxuICAgICAgICAgICAgICAgICYmIHkgPj0gcmVjdC55XG4gICAgICAgICAgICAgICAgJiYgeSA8PSAocmVjdC55ICsgcmVjdC5oZWlnaHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nUmVjdCh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb3B5IGZyb20gYW5vdGhlciByZWN0XG4gICAgICAgICAqL1xuICAgICAgICBjb3B5OiBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgICAgIHRoaXMueCA9IG90aGVyLng7XG4gICAgICAgICAgICB0aGlzLnkgPSBvdGhlci55O1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IG90aGVyLndpZHRoO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBvdGhlci5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIEJvdW5kaW5nUmVjdDtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvenJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzXG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCJkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgIHZhciBBcnJheUN0b3IgPSB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IEFycmF5XG4gICAgICAgIDogRmxvYXQzMkFycmF5O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gVmVjdG9yMlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIOS6jOe7tOWQkemHj+exu1xuICAgICAqIEBleHBvcnRzIHpyZW5kZXIvdG9vbC92ZWN0b3JcbiAgICAgKi9cbiAgICB2YXIgdmVjdG9yID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICog5Yib5bu65LiA5Liq5ZCR6YePXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF1cbiAgICAgICAgICogQHJldHVybiB7VmVjdG9yMn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSBuZXcgQXJyYXlDdG9yKDIpO1xuICAgICAgICAgICAgaWYgKHggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0WzBdID0geDtcbiAgICAgICAgICAgIG91dFsxXSA9IHk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlpI3liLblkJHph4/mlbDmja5cbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAgICAgICAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gICAgICAgICAqL1xuICAgICAgICBjb3B5OiBmdW5jdGlvbiAob3V0LCB2KSB7XG4gICAgICAgICAgICBvdXRbMF0gPSB2WzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gdlsxXTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWFi+mahuS4gOS4quWQkemHj1xuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAgICAgICAgICogQHJldHVybiB7VmVjdG9yMn1cbiAgICAgICAgICovXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdmFyIG91dCA9IG5ldyBBcnJheUN0b3IoMik7XG4gICAgICAgICAgICBvdXRbMF0gPSB2WzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gdlsxXTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuvue9ruWQkemHj+eahOS4pOS4qumhuVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gYVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gYlxuICAgICAgICAgKiBAcmV0dXJuIHtWZWN0b3IyfSDnu5PmnpxcbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgICAgICAgICAgb3V0WzBdID0gYTtcbiAgICAgICAgICAgIG91dFsxXSA9IGI7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/nm7jliqBcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqL1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uIChvdXQsIHYxLCB2Mikge1xuICAgICAgICAgICAgb3V0WzBdID0gdjFbMF0gKyB2MlswXTtcbiAgICAgICAgICAgIG91dFsxXSA9IHYxWzFdICsgdjJbMV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/nvKnmlL7lkI7nm7jliqBcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gICAgICAgICAqL1xuICAgICAgICBzY2FsZUFuZEFkZDogZnVuY3Rpb24gKG91dCwgdjEsIHYyLCBhKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSB2MVswXSArIHYyWzBdICogYTtcbiAgICAgICAgICAgIG91dFsxXSA9IHYxWzFdICsgdjJbMV0gKiBhO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP55u45YePXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKi9cbiAgICAgICAgc3ViOiBmdW5jdGlvbiAob3V0LCB2MSwgdjIpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHYxWzBdIC0gdjJbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSB2MVsxXSAtIHYyWzFdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP6ZW/5bqmXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBsZW46IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMubGVuU3F1YXJlKHYpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP6ZW/5bqm5bmz5pa5XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBsZW5TcXVhcmU6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gdlswXSAqIHZbMF0gKyB2WzFdICogdlsxXTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP5LmY5rOVXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKi9cbiAgICAgICAgbXVsOiBmdW5jdGlvbiAob3V0LCB2MSwgdjIpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHYxWzBdICogdjJbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSB2MVsxXSAqIHYyWzFdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP6Zmk5rOVXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKi9cbiAgICAgICAgZGl2OiBmdW5jdGlvbiAob3V0LCB2MSwgdjIpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHYxWzBdIC8gdjJbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSB2MVsxXSAvIHYyWzFdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP54K55LmYXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBkb3Q6IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICAgICAgICAgIHJldHVybiB2MVswXSAqIHYyWzBdICsgdjFbMV0gKiB2MlsxXTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5ZCR6YeP57yp5pS+XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc1xuICAgICAgICAgKi9cbiAgICAgICAgc2NhbGU6IGZ1bmN0aW9uIChvdXQsIHYsIHMpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHZbMF0gKiBzO1xuICAgICAgICAgICAgb3V0WzFdID0gdlsxXSAqIHM7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/lvZLkuIDljJZcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAgICAgICAqL1xuICAgICAgICBub3JtYWxpemU6IGZ1bmN0aW9uIChvdXQsIHYpIHtcbiAgICAgICAgICAgIHZhciBkID0gdmVjdG9yLmxlbih2KTtcbiAgICAgICAgICAgIGlmIChkID09PSAwKSB7XG4gICAgICAgICAgICAgICAgb3V0WzBdID0gMDtcbiAgICAgICAgICAgICAgICBvdXRbMV0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0WzBdID0gdlswXSAvIGQ7XG4gICAgICAgICAgICAgICAgb3V0WzFdID0gdlsxXSAvIGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorqHnrpflkJHph4/pl7Tot53nprtcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGRpc3RhbmNlOiBmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KFxuICAgICAgICAgICAgICAgICh2MVswXSAtIHYyWzBdKSAqICh2MVswXSAtIHYyWzBdKVxuICAgICAgICAgICAgICAgICsgKHYxWzFdIC0gdjJbMV0pICogKHYxWzFdIC0gdjJbMV0pXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/ot53nprvlubPmlrlcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGRpc3RhbmNlU3F1YXJlOiBmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgICAgICAgICByZXR1cm4gKHYxWzBdIC0gdjJbMF0pICogKHYxWzBdIC0gdjJbMF0pXG4gICAgICAgICAgICAgICAgKyAodjFbMV0gLSB2MlsxXSkgKiAodjFbMV0gLSB2MlsxXSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaxgui0n+WQkemHj1xuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAgICAgICAgICovXG4gICAgICAgIG5lZ2F0ZTogZnVuY3Rpb24gKG91dCwgdikge1xuICAgICAgICAgICAgb3V0WzBdID0gLXZbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSAtdlsxXTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaPkuWAvOS4pOS4queCuVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHRcbiAgICAgICAgICovXG4gICAgICAgIGxlcnA6IGZ1bmN0aW9uIChvdXQsIHYxLCB2MiwgdCkge1xuICAgICAgICAgICAgb3V0WzBdID0gdjFbMF0gKyB0ICogKHYyWzBdIC0gdjFbMF0pO1xuICAgICAgICAgICAgb3V0WzFdID0gdjFbMV0gKyB0ICogKHYyWzFdIC0gdjFbMV0pO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog55+p6Zi15bem5LmY5ZCR6YePXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG1cbiAgICAgICAgICovXG4gICAgICAgIGFwcGx5VHJhbnNmb3JtOiBmdW5jdGlvbiAob3V0LCB2LCBtKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHZbMF07XG4gICAgICAgICAgICB2YXIgeSA9IHZbMV07XG4gICAgICAgICAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5ICsgbVs0XTtcbiAgICAgICAgICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHkgKyBtWzVdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaxguS4pOS4quWQkemHj+acgOWwj+WAvFxuICAgICAgICAgKiBAcGFyYW0gIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtICB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtICB7VmVjdG9yMn0gdjJcbiAgICAgICAgICovXG4gICAgICAgIG1pbjogZnVuY3Rpb24gKG91dCwgdjEsIHYyKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSBNYXRoLm1pbih2MVswXSwgdjJbMF0pO1xuICAgICAgICAgICAgb3V0WzFdID0gTWF0aC5taW4odjFbMV0sIHYyWzFdKTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmsYLkuKTkuKrlkJHph4/mnIDlpKflgLxcbiAgICAgICAgICogQHBhcmFtICB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSAge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSAge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqL1xuICAgICAgICBtYXg6IGZ1bmN0aW9uIChvdXQsIHYxLCB2Mikge1xuICAgICAgICAgICAgb3V0WzBdID0gTWF0aC5tYXgodjFbMF0sIHYyWzBdKTtcbiAgICAgICAgICAgIG91dFsxXSA9IE1hdGgubWF4KHYxWzFdLCB2MlsxXSk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZlY3Rvci5sZW5ndGggPSB2ZWN0b3IubGVuO1xuICAgIHZlY3Rvci5sZW5ndGhTcXVhcmUgPSB2ZWN0b3IubGVuU3F1YXJlO1xuICAgIHZlY3Rvci5kaXN0ID0gdmVjdG9yLmRpc3RhbmNlO1xuICAgIHZlY3Rvci5kaXN0U3F1YXJlID0gdmVjdG9yLmRpc3RhbmNlU3F1YXJlO1xuXG4gICAgcmV0dXJuIHZlY3Rvcjtcbn0pO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC96cmVuZGVyL2NvcmUvdmVjdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsImRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgdmFyIEFycmF5Q3RvciA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gQXJyYXlcbiAgICAgICAgOiBGbG9hdDMyQXJyYXk7XG4gICAgLyoqXG4gICAgICogM3gy55+p6Zi15pON5L2c57G7XG4gICAgICogQGV4cG9ydHMgenJlbmRlci90b29sL21hdHJpeFxuICAgICAqL1xuICAgIHZhciBtYXRyaXggPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliJvlu7rkuIDkuKrljZXkvY3nn6npmLVcbiAgICAgICAgICogQHJldHVybiB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0gbmV3IEFycmF5Q3Rvcig2KTtcbiAgICAgICAgICAgIG1hdHJpeC5pZGVudGl0eShvdXQpO1xuXG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u55+p6Zi15Li65Y2V5L2N55+p6Zi1XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAgICAgICAgICovXG4gICAgICAgIGlkZW50aXR5IDogZnVuY3Rpb24ob3V0KSB7XG4gICAgICAgICAgICBvdXRbMF0gPSAxO1xuICAgICAgICAgICAgb3V0WzFdID0gMDtcbiAgICAgICAgICAgIG91dFsyXSA9IDA7XG4gICAgICAgICAgICBvdXRbM10gPSAxO1xuICAgICAgICAgICAgb3V0WzRdID0gMDtcbiAgICAgICAgICAgIG91dFs1XSA9IDA7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5aSN5Yi255+p6Zi1XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG1cbiAgICAgICAgICovXG4gICAgICAgIGNvcHk6IGZ1bmN0aW9uKG91dCwgbSkge1xuICAgICAgICAgICAgb3V0WzBdID0gbVswXTtcbiAgICAgICAgICAgIG91dFsxXSA9IG1bMV07XG4gICAgICAgICAgICBvdXRbMl0gPSBtWzJdO1xuICAgICAgICAgICAgb3V0WzNdID0gbVszXTtcbiAgICAgICAgICAgIG91dFs0XSA9IG1bNF07XG4gICAgICAgICAgICBvdXRbNV0gPSBtWzVdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOefqemYteebuOS5mFxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBtMVxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gbTJcbiAgICAgICAgICovXG4gICAgICAgIG11bCA6IGZ1bmN0aW9uIChvdXQsIG0xLCBtMikge1xuICAgICAgICAgICAgLy8gQ29uc2lkZXIgbWF0cml4Lm11bChtLCBtMiwgbSk7XG4gICAgICAgICAgICAvLyB3aGVyZSBvdXQgaXMgdGhlIHNhbWUgYXMgbTIuXG4gICAgICAgICAgICAvLyBTbyB1c2UgdGVtcCB2YXJpYWJsZSB0byBlc2NhcGUgZXJyb3IuXG4gICAgICAgICAgICB2YXIgb3V0MCA9IG0xWzBdICogbTJbMF0gKyBtMVsyXSAqIG0yWzFdO1xuICAgICAgICAgICAgdmFyIG91dDEgPSBtMVsxXSAqIG0yWzBdICsgbTFbM10gKiBtMlsxXTtcbiAgICAgICAgICAgIHZhciBvdXQyID0gbTFbMF0gKiBtMlsyXSArIG0xWzJdICogbTJbM107XG4gICAgICAgICAgICB2YXIgb3V0MyA9IG0xWzFdICogbTJbMl0gKyBtMVszXSAqIG0yWzNdO1xuICAgICAgICAgICAgdmFyIG91dDQgPSBtMVswXSAqIG0yWzRdICsgbTFbMl0gKiBtMls1XSArIG0xWzRdO1xuICAgICAgICAgICAgdmFyIG91dDUgPSBtMVsxXSAqIG0yWzRdICsgbTFbM10gKiBtMls1XSArIG0xWzVdO1xuICAgICAgICAgICAgb3V0WzBdID0gb3V0MDtcbiAgICAgICAgICAgIG91dFsxXSA9IG91dDE7XG4gICAgICAgICAgICBvdXRbMl0gPSBvdXQyO1xuICAgICAgICAgICAgb3V0WzNdID0gb3V0MztcbiAgICAgICAgICAgIG91dFs0XSA9IG91dDQ7XG4gICAgICAgICAgICBvdXRbNV0gPSBvdXQ1O1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW5s+enu+WPmOaNolxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBhXG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSB2XG4gICAgICAgICAqL1xuICAgICAgICB0cmFuc2xhdGUgOiBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICAgICAgICAgIG91dFswXSA9IGFbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSBhWzFdO1xuICAgICAgICAgICAgb3V0WzJdID0gYVsyXTtcbiAgICAgICAgICAgIG91dFszXSA9IGFbM107XG4gICAgICAgICAgICBvdXRbNF0gPSBhWzRdICsgdlswXTtcbiAgICAgICAgICAgIG91dFs1XSA9IGFbNV0gKyB2WzFdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaXi+i9rOWPmOaNolxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBhXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYWRcbiAgICAgICAgICovXG4gICAgICAgIHJvdGF0ZSA6IGZ1bmN0aW9uKG91dCwgYSwgcmFkKSB7XG4gICAgICAgICAgICB2YXIgYWEgPSBhWzBdO1xuICAgICAgICAgICAgdmFyIGFjID0gYVsyXTtcbiAgICAgICAgICAgIHZhciBhdHggPSBhWzRdO1xuICAgICAgICAgICAgdmFyIGFiID0gYVsxXTtcbiAgICAgICAgICAgIHZhciBhZCA9IGFbM107XG4gICAgICAgICAgICB2YXIgYXR5ID0gYVs1XTtcbiAgICAgICAgICAgIHZhciBzdCA9IE1hdGguc2luKHJhZCk7XG4gICAgICAgICAgICB2YXIgY3QgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgICAgICAgICBvdXRbMF0gPSBhYSAqIGN0ICsgYWIgKiBzdDtcbiAgICAgICAgICAgIG91dFsxXSA9IC1hYSAqIHN0ICsgYWIgKiBjdDtcbiAgICAgICAgICAgIG91dFsyXSA9IGFjICogY3QgKyBhZCAqIHN0O1xuICAgICAgICAgICAgb3V0WzNdID0gLWFjICogc3QgKyBjdCAqIGFkO1xuICAgICAgICAgICAgb3V0WzRdID0gY3QgKiBhdHggKyBzdCAqIGF0eTtcbiAgICAgICAgICAgIG91dFs1XSA9IGN0ICogYXR5IC0gc3QgKiBhdHg7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog57yp5pS+5Y+Y5o2iXG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IGFcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IHZcbiAgICAgICAgICovXG4gICAgICAgIHNjYWxlIDogZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgICAgICAgICB2YXIgdnggPSB2WzBdO1xuICAgICAgICAgICAgdmFyIHZ5ID0gdlsxXTtcbiAgICAgICAgICAgIG91dFswXSA9IGFbMF0gKiB2eDtcbiAgICAgICAgICAgIG91dFsxXSA9IGFbMV0gKiB2eTtcbiAgICAgICAgICAgIG91dFsyXSA9IGFbMl0gKiB2eDtcbiAgICAgICAgICAgIG91dFszXSA9IGFbM10gKiB2eTtcbiAgICAgICAgICAgIG91dFs0XSA9IGFbNF0gKiB2eDtcbiAgICAgICAgICAgIG91dFs1XSA9IGFbNV0gKiB2eTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmsYLpgIbnn6npmLVcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gYVxuICAgICAgICAgKi9cbiAgICAgICAgaW52ZXJ0IDogZnVuY3Rpb24ob3V0LCBhKSB7XG5cbiAgICAgICAgICAgIHZhciBhYSA9IGFbMF07XG4gICAgICAgICAgICB2YXIgYWMgPSBhWzJdO1xuICAgICAgICAgICAgdmFyIGF0eCA9IGFbNF07XG4gICAgICAgICAgICB2YXIgYWIgPSBhWzFdO1xuICAgICAgICAgICAgdmFyIGFkID0gYVszXTtcbiAgICAgICAgICAgIHZhciBhdHkgPSBhWzVdO1xuXG4gICAgICAgICAgICB2YXIgZGV0ID0gYWEgKiBhZCAtIGFiICogYWM7XG4gICAgICAgICAgICBpZiAoIWRldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgICAgICAgICBvdXRbMF0gPSBhZCAqIGRldDtcbiAgICAgICAgICAgIG91dFsxXSA9IC1hYiAqIGRldDtcbiAgICAgICAgICAgIG91dFsyXSA9IC1hYyAqIGRldDtcbiAgICAgICAgICAgIG91dFszXSA9IGFhICogZGV0O1xuICAgICAgICAgICAgb3V0WzRdID0gKGFjICogYXR5IC0gYWQgKiBhdHgpICogZGV0O1xuICAgICAgICAgICAgb3V0WzVdID0gKGFiICogYXR4IC0gYWEgKiBhdHkpICogZGV0O1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gbWF0cml4O1xufSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL3pyZW5kZXIvY29yZS9tYXRyaXguanNcbiAqKiBtb2R1bGUgaWQgPSAxNVxuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiLyoqXG4gKiBAbW9kdWxlIGVjaGFydHMvbW9kZWwvTW9kZWxcbiAqL1xuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9jb3JlL3V0aWwnKTtcbiAgICB2YXIgY2xhenpVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9jbGF6eicpO1xuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvblxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IFtwYXJlbnRNb2RlbF1cbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gW2VjTW9kZWxdXG4gICAgICovXG4gICAgZnVuY3Rpb24gTW9kZWwob3B0aW9uLCBwYXJlbnRNb2RlbCwgZWNNb2RlbCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfVxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGFyZW50TW9kZWwgPSBwYXJlbnRNb2RlbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVjTW9kZWwgPSBlY01vZGVsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wdGlvbiA9IG9wdGlvbjtcblxuICAgICAgICAvLyBTaW1wbGUgb3B0aW1pemF0aW9uXG4gICAgICAgIC8vIGlmICh0aGlzLmluaXQpIHtcbiAgICAgICAgLy8gICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDQpIHtcbiAgICAgICAgLy8gICAgICAgICB0aGlzLmluaXQob3B0aW9uLCBwYXJlbnRNb2RlbCwgZWNNb2RlbCwgZXh0cmFPcHQpO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyAgICAgZWxzZSB7XG4gICAgICAgIC8vICAgICAgICAgdGhpcy5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIH1cbiAgICB9XG5cbiAgICBNb2RlbC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IE1vZGVsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb2RlbCDnmoTliJ3lp4vljJblh73mlbBcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgaW5pdDogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5LuO5paw55qEIE9wdGlvbiBtZXJnZVxuICAgICAgICAgKi9cbiAgICAgICAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgICAgIHpyVXRpbC5tZXJnZSh0aGlzLm9wdGlvbiwgb3B0aW9uLCB0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbaWdub3JlUGFyZW50PWZhbHNlXVxuICAgICAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAocGF0aCwgaWdub3JlUGFyZW50KSB7XG4gICAgICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5zcGxpdCgnLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb2JqID0gdGhpcy5vcHRpb247XG4gICAgICAgICAgICB2YXIgcGFyZW50TW9kZWwgPSB0aGlzLnBhcmVudE1vZGVsO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIGVtcHR5XG4gICAgICAgICAgICAgICAgaWYgKCFwYXRoW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBvYmogY291bGQgYmUgbnVtYmVyL3N0cmluZy8uLi4gKGxpa2UgMClcbiAgICAgICAgICAgICAgICBvYmogPSAob2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSA/IG9ialtwYXRoW2ldXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmogPT0gbnVsbCAmJiBwYXJlbnRNb2RlbCAmJiAhaWdub3JlUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgb2JqID0gcGFyZW50TW9kZWwuZ2V0KHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpZ25vcmVQYXJlbnQ9ZmFsc2VdXG4gICAgICAgICAqIEByZXR1cm4geyp9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRTaGFsbG93OiBmdW5jdGlvbiAoa2V5LCBpZ25vcmVQYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbjtcblxuICAgICAgICAgICAgdmFyIHZhbCA9IG9wdGlvbiA9PSBudWxsID8gb3B0aW9uIDogb3B0aW9uW2tleV07XG4gICAgICAgICAgICB2YXIgcGFyZW50TW9kZWwgPSB0aGlzLnBhcmVudE1vZGVsO1xuICAgICAgICAgICAgaWYgKHZhbCA9PSBudWxsICYmIHBhcmVudE1vZGVsICYmICFpZ25vcmVQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBwYXJlbnRNb2RlbC5nZXRTaGFsbG93KGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBbcGFyZW50TW9kZWxdXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TW9kZWw6IGZ1bmN0aW9uIChwYXRoLCBwYXJlbnRNb2RlbCkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IHRoaXMuZ2V0KHBhdGgsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHRoaXNQYXJlbnRNb2RlbCA9IHRoaXMucGFyZW50TW9kZWw7XG4gICAgICAgICAgICB2YXIgbW9kZWwgPSBuZXcgTW9kZWwoXG4gICAgICAgICAgICAgICAgb2JqLCBwYXJlbnRNb2RlbCB8fCAodGhpc1BhcmVudE1vZGVsICYmIHRoaXNQYXJlbnRNb2RlbC5nZXRNb2RlbChwYXRoKSksXG4gICAgICAgICAgICAgICAgdGhpcy5lY01vZGVsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBtb2RlbCBoYXMgb3B0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb24gPT0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICByZXN0b3JlRGF0YTogZnVuY3Rpb24gKCkge30sXG5cbiAgICAgICAgLy8gUGVuZGluZ1xuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIEN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKHpyVXRpbC5jbG9uZSh0aGlzLm9wdGlvbikpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldFJlYWRPbmx5OiBmdW5jdGlvbiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgY2xhenpVdGlsLnNldFJlYWRPbmx5KHRoaXMsIHByb3BlcnRpZXMpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIEVuYWJsZSBNb2RlbC5leHRlbmQuXG4gICAgY2xhenpVdGlsLmVuYWJsZUNsYXNzRXh0ZW5kKE1vZGVsKTtcblxuICAgIHZhciBtaXhpbiA9IHpyVXRpbC5taXhpbjtcbiAgICBtaXhpbihNb2RlbCwgcmVxdWlyZSgnLi9taXhpbi9saW5lU3R5bGUnKSk7XG4gICAgbWl4aW4oTW9kZWwsIHJlcXVpcmUoJy4vbWl4aW4vYXJlYVN0eWxlJykpO1xuICAgIG1peGluKE1vZGVsLCByZXF1aXJlKCcuL21peGluL3RleHRTdHlsZScpKTtcbiAgICBtaXhpbihNb2RlbCwgcmVxdWlyZSgnLi9taXhpbi9pdGVtU3R5bGUnKSk7XG5cbiAgICByZXR1cm4gTW9kZWw7XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL2VjaGFydHMvbW9kZWwvTW9kZWwuanNcbiAqKiBtb2R1bGUgaWQgPSAxNlxuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9jb3JlL3V0aWwnKTtcblxuICAgIHZhciBjbGF6eiA9IHt9O1xuXG4gICAgdmFyIFRZUEVfREVMSU1JVEVSID0gJy4nO1xuICAgIHZhciBJU19DT05UQUlORVIgPSAnX19fRUNfX0NPTVBPTkVOVF9fQ09OVEFJTkVSX19fJztcbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgdmFyIHBhcnNlQ2xhc3NUeXBlID0gY2xhenoucGFyc2VDbGFzc1R5cGUgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSkge1xuICAgICAgICB2YXIgcmV0ID0ge21haW46ICcnLCBzdWI6ICcnfTtcbiAgICAgICAgaWYgKGNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFR5cGUgPSBjb21wb25lbnRUeXBlLnNwbGl0KFRZUEVfREVMSU1JVEVSKTtcbiAgICAgICAgICAgIHJldC5tYWluID0gY29tcG9uZW50VHlwZVswXSB8fCAnJztcbiAgICAgICAgICAgIHJldC5zdWIgPSBjb21wb25lbnRUeXBlWzFdIHx8ICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgY2xhenouZW5hYmxlQ2xhc3NFeHRlbmQgPSBmdW5jdGlvbiAoUm9vdENsYXNzKSB7XG5cbiAgICAgICAgUm9vdENsYXNzLiRjb25zdHJ1Y3RvciA9IFJvb3RDbGFzcztcbiAgICAgICAgUm9vdENsYXNzLmV4dGVuZCA9IGZ1bmN0aW9uIChwcm90bykge1xuICAgICAgICAgICAgdmFyIHN1cGVyQ2xhc3MgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIEV4dGVuZGVkQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcm90by4kY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXJDbGFzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdG8uJGNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgenJVdGlsLmV4dGVuZChFeHRlbmRlZENsYXNzLnByb3RvdHlwZSwgcHJvdG8pO1xuXG4gICAgICAgICAgICBFeHRlbmRlZENsYXNzLmV4dGVuZCA9IHRoaXMuZXh0ZW5kO1xuICAgICAgICAgICAgRXh0ZW5kZWRDbGFzcy5zdXBlckNhbGwgPSBzdXBlckNhbGw7XG4gICAgICAgICAgICBFeHRlbmRlZENsYXNzLnN1cGVyQXBwbHkgPSBzdXBlckFwcGx5O1xuICAgICAgICAgICAgenJVdGlsLmluaGVyaXRzKEV4dGVuZGVkQ2xhc3MsIHRoaXMpO1xuICAgICAgICAgICAgRXh0ZW5kZWRDbGFzcy5zdXBlckNsYXNzID0gc3VwZXJDbGFzcztcblxuICAgICAgICAgICAgcmV0dXJuIEV4dGVuZGVkQ2xhc3M7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIHN1cGVyQ2FsbCBzaG91bGQgaGF2ZSBjbGFzcyBpbmZvLCB3aGljaCBjYW4gbm90IGJlIGZldGNoIGZyb20gJ3RoaXMnLlxuICAgIC8vIENvbnNpZGVyIHRoaXMgY2FzZTpcbiAgICAvLyBjbGFzcyBBIGhhcyBtZXRob2QgZixcbiAgICAvLyBjbGFzcyBCIGluaGVyaXRzIGNsYXNzIEEsIG92ZXJyaWRlcyBtZXRob2QgZiwgZiBjYWxsIHN1cGVyQXBwbHkoJ2YnKSxcbiAgICAvLyBjbGFzcyBDIGluaGVyaXRzIGNsYXNzIEIsIGRvIG5vdCBvdmVycmlkZXMgbWV0aG9kIGYsXG4gICAgLy8gdGhlbiB3aGVuIG1ldGhvZCBvZiBjbGFzcyBDIGlzIGNhbGxlZCwgZGVhZCBsb29wIG9jY3VyZWQuXG4gICAgZnVuY3Rpb24gc3VwZXJDYWxsKGNvbnRleHQsIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSB6clV0aWwuc2xpY2UoYXJndW1lbnRzLCAyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXJDbGFzcy5wcm90b3R5cGVbbWV0aG9kTmFtZV0uYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3VwZXJBcHBseShjb250ZXh0LCBtZXRob2ROYW1lLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyQ2xhc3MucHJvdG90eXBlW21ldGhvZE5hbWVdLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRpdHlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVnaXN0ZXJXaGVuRXh0ZW5kXVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjbGF6ei5lbmFibGVDbGFzc01hbmFnZW1lbnQgPSBmdW5jdGlvbiAoZW50aXR5LCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wb25lbnQgbW9kZWwgY2xhc3Nlc1xuICAgICAgICAgKiBrZXk6IGNvbXBvbmVudFR5cGUsXG4gICAgICAgICAqIHZhbHVlOlxuICAgICAgICAgKiAgICAgY29tcG9uZW50Q2xhc3MsIHdoZW4gY29tcG9uZW50VHlwZSBpcyAneHh4J1xuICAgICAgICAgKiAgICAgb3IgT2JqZWN0LjxzdWJLZXksIGNvbXBvbmVudENsYXNzPiwgd2hlbiBjb21wb25lbnRUeXBlIGlzICd4eHgueXknXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgc3RvcmFnZSA9IHt9O1xuXG4gICAgICAgIGVudGl0eS5yZWdpc3RlckNsYXNzID0gZnVuY3Rpb24gKENsYXp6LCBjb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudFR5cGUgPSBwYXJzZUNsYXNzVHlwZShjb21wb25lbnRUeXBlKTtcblxuICAgICAgICAgICAgICAgIGlmICghY29tcG9uZW50VHlwZS5zdWIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdG9yYWdlW2NvbXBvbmVudFR5cGUubWFpbl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oY29tcG9uZW50VHlwZS5tYWluICsgJyBleGlzdHMuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dID0gQ2xheno7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbXBvbmVudFR5cGUuc3ViICE9PSBJU19DT05UQUlORVIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IG1ha2VDb250YWluZXIoY29tcG9uZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcltjb21wb25lbnRUeXBlLnN1Yl0gPSBDbGF6ejtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQ2xheno7XG4gICAgICAgIH07XG5cbiAgICAgICAgZW50aXR5LmdldENsYXNzID0gZnVuY3Rpb24gKGNvbXBvbmVudFR5cGVNYWluLCBzdWJUeXBlLCB0aHJvd1doZW5Ob3RGb3VuZCkge1xuICAgICAgICAgICAgdmFyIENsYXp6ID0gc3RvcmFnZVtjb21wb25lbnRUeXBlTWFpbl07XG5cbiAgICAgICAgICAgIGlmIChDbGF6eiAmJiBDbGF6eltJU19DT05UQUlORVJdKSB7XG4gICAgICAgICAgICAgICAgQ2xhenogPSBzdWJUeXBlID8gQ2xhenpbc3ViVHlwZV0gOiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhyb3dXaGVuTm90Rm91bmQgJiYgIUNsYXp6KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnQ29tcG9uZW50ICcgKyBjb21wb25lbnRUeXBlTWFpbiArICcuJyArIChzdWJUeXBlIHx8ICcnKSArICcgbm90IGV4aXN0cy4gTG9hZCBpdCBmaXJzdC4nXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIENsYXp6O1xuICAgICAgICB9O1xuXG4gICAgICAgIGVudGl0eS5nZXRDbGFzc2VzQnlNYWluVHlwZSA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICBjb21wb25lbnRUeXBlID0gcGFyc2VDbGFzc1R5cGUoY29tcG9uZW50VHlwZSk7XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIHZhciBvYmogPSBzdG9yYWdlW2NvbXBvbmVudFR5cGUubWFpbl07XG5cbiAgICAgICAgICAgIGlmIChvYmogJiYgb2JqW0lTX0NPTlRBSU5FUl0pIHtcbiAgICAgICAgICAgICAgICB6clV0aWwuZWFjaChvYmosIGZ1bmN0aW9uIChvLCB0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgIT09IElTX0NPTlRBSU5FUiAmJiByZXN1bHQucHVzaChvKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9iaik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgZW50aXR5Lmhhc0NsYXNzID0gZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgICAgIC8vIEp1c3QgY29uc2lkZXIgY29tcG9uZW50VHlwZS5tYWluLlxuICAgICAgICAgICAgY29tcG9uZW50VHlwZSA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuICEhc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gTGlrZSBbJ2FhJywgJ2JiJ10sIGJ1dCBjYW4gbm90IGJlIFsnYWEueHgnXVxuICAgICAgICAgKi9cbiAgICAgICAgZW50aXR5LmdldEFsbENsYXNzTWFpblR5cGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHR5cGVzID0gW107XG4gICAgICAgICAgICB6clV0aWwuZWFjaChzdG9yYWdlLCBmdW5jdGlvbiAob2JqLCB0eXBlKSB7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCh0eXBlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBhIG1haW4gdHlwZSBpcyBjb250YWluZXIgYW5kIGhhcyBzdWIgdHlwZXNcbiAgICAgICAgICogQHBhcmFtICB7c3RyaW5nfSAgbWFpblR5cGVcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGVudGl0eS5oYXNTdWJUeXBlcyA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICBjb21wb25lbnRUeXBlID0gcGFyc2VDbGFzc1R5cGUoY29tcG9uZW50VHlwZSk7XG4gICAgICAgICAgICB2YXIgb2JqID0gc3RvcmFnZVtjb21wb25lbnRUeXBlLm1haW5dO1xuICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBvYmpbSVNfQ09OVEFJTkVSXTtcbiAgICAgICAgfTtcblxuICAgICAgICBlbnRpdHkucGFyc2VDbGFzc1R5cGUgPSBwYXJzZUNsYXNzVHlwZTtcblxuICAgICAgICBmdW5jdGlvbiBtYWtlQ29udGFpbmVyKGNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBzdG9yYWdlW2NvbXBvbmVudFR5cGUubWFpbl07XG4gICAgICAgICAgICBpZiAoIWNvbnRhaW5lciB8fCAhY29udGFpbmVyW0lTX0NPTlRBSU5FUl0pIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSBzdG9yYWdlW2NvbXBvbmVudFR5cGUubWFpbl0gPSB7fTtcbiAgICAgICAgICAgICAgICBjb250YWluZXJbSVNfQ09OVEFJTkVSXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMucmVnaXN0ZXJXaGVuRXh0ZW5kKSB7XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxFeHRlbmQgPSBlbnRpdHkuZXh0ZW5kO1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsRXh0ZW5kKSB7XG4gICAgICAgICAgICAgICAgZW50aXR5LmV4dGVuZCA9IGZ1bmN0aW9uIChwcm90bykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgRXh0ZW5kZWRDbGFzcyA9IG9yaWdpbmFsRXh0ZW5kLmNhbGwodGhpcywgcHJvdG8pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW50aXR5LnJlZ2lzdGVyQ2xhc3MoRXh0ZW5kZWRDbGFzcywgcHJvdG8udHlwZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbnRpdHk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fSBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgY2xhenouc2V0UmVhZE9ubHkgPSBmdW5jdGlvbiAob2JqLCBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIC8vIEZJWE1FIEl0IHNlZW1zIGJyb2tlbiBpbiBJRTggc2ltdWxhdGlvbiBvZiBJRTExXG4gICAgICAgIC8vIGlmICghenJVdGlsLmlzQXJyYXkocHJvcGVydGllcykpIHtcbiAgICAgICAgLy8gICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzICE9IG51bGwgPyBbcHJvcGVydGllc10gOiBbXTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyB6clV0aWwuZWFjaChwcm9wZXJ0aWVzLCBmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAvLyAgICAgdmFyIHZhbHVlID0gb2JqW3Byb3BdO1xuXG4gICAgICAgIC8vICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHlcbiAgICAgICAgLy8gICAgICAgICAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCB7XG4gICAgICAgIC8vICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSwgd3JpdGFibGU6IGZhbHNlXG4gICAgICAgIC8vICAgICAgICAgfSk7XG4gICAgICAgIC8vICAgICB6clV0aWwuaXNBcnJheShvYmpbcHJvcF0pXG4gICAgICAgIC8vICAgICAgICAgJiYgT2JqZWN0LmZyZWV6ZVxuICAgICAgICAvLyAgICAgICAgICYmIE9iamVjdC5mcmVlemUob2JqW3Byb3BdKTtcbiAgICAgICAgLy8gfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBjbGF6ejtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvZWNoYXJ0cy91dGlsL2NsYXp6LmpzXG4gKiogbW9kdWxlIGlkID0gMTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsImRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuICAgIHZhciBnZXRMaW5lU3R5bGUgPSByZXF1aXJlKCcuL21ha2VTdHlsZU1hcHBlcicpKFxuICAgICAgICBbXG4gICAgICAgICAgICBbJ2xpbmVXaWR0aCcsICd3aWR0aCddLFxuICAgICAgICAgICAgWydzdHJva2UnLCAnY29sb3InXSxcbiAgICAgICAgICAgIFsnb3BhY2l0eSddLFxuICAgICAgICAgICAgWydzaGFkb3dCbHVyJ10sXG4gICAgICAgICAgICBbJ3NoYWRvd09mZnNldFgnXSxcbiAgICAgICAgICAgIFsnc2hhZG93T2Zmc2V0WSddLFxuICAgICAgICAgICAgWydzaGFkb3dDb2xvciddXG4gICAgICAgIF1cbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldExpbmVTdHlsZTogZnVuY3Rpb24gKGV4Y2x1ZGVzKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBnZXRMaW5lU3R5bGUuY2FsbCh0aGlzLCBleGNsdWRlcyk7XG4gICAgICAgICAgICB2YXIgbGluZURhc2ggPSB0aGlzLmdldExpbmVEYXNoKCk7XG4gICAgICAgICAgICBsaW5lRGFzaCAmJiAoc3R5bGUubGluZURhc2ggPSBsaW5lRGFzaCk7XG4gICAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0TGluZURhc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsaW5lVHlwZSA9IHRoaXMuZ2V0KCd0eXBlJyk7XG4gICAgICAgICAgICByZXR1cm4gKGxpbmVUeXBlID09PSAnc29saWQnIHx8IGxpbmVUeXBlID09IG51bGwpID8gbnVsbFxuICAgICAgICAgICAgICAgIDogKGxpbmVUeXBlID09PSAnZGFzaGVkJyA/IFs1LCA1XSA6IFsyLCAyXSk7XG4gICAgICAgIH1cbiAgICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC9lY2hhcnRzL21vZGVsL21peGluL2xpbmVTdHlsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCIvLyBUT0RPIFBhcnNlIHNoYWRvdyBzdHlsZVxuLy8gVE9ETyBPbmx5IHNoYWxsb3cgcGF0aCBzdXBwb3J0XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9jb3JlL3V0aWwnKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAocHJvcGVydGllcykge1xuICAgICAgICAvLyBOb3JtYWxpemVcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXByb3BlcnRpZXNbaV1bMV0pIHtcbiAgICAgICAgICAgICAgIHByb3BlcnRpZXNbaV1bMV0gPSBwcm9wZXJ0aWVzW2ldWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXhjbHVkZXMpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BOYW1lID0gcHJvcGVydGllc1tpXVsxXTtcbiAgICAgICAgICAgICAgICBpZiAoZXhjbHVkZXMgJiYgenJVdGlsLmluZGV4T2YoZXhjbHVkZXMsIHByb3BOYW1lKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gdGhpcy5nZXRTaGFsbG93KHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVbcHJvcGVydGllc1tpXVswXV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgICB9O1xuICAgIH07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL2VjaGFydHMvbW9kZWwvbWl4aW4vbWFrZVN0eWxlTWFwcGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsImRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldEFyZWFTdHlsZTogcmVxdWlyZSgnLi9tYWtlU3R5bGVNYXBwZXInKShcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBbJ2ZpbGwnLCAnY29sb3InXSxcbiAgICAgICAgICAgICAgICBbJ3NoYWRvd0JsdXInXSxcbiAgICAgICAgICAgICAgICBbJ3NoYWRvd09mZnNldFgnXSxcbiAgICAgICAgICAgICAgICBbJ3NoYWRvd09mZnNldFknXSxcbiAgICAgICAgICAgICAgICBbJ29wYWNpdHknXSxcbiAgICAgICAgICAgICAgICBbJ3NoYWRvd0NvbG9yJ11cbiAgICAgICAgICAgIF1cbiAgICAgICAgKVxuICAgIH07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL2VjaGFydHMvbW9kZWwvbWl4aW4vYXJlYVN0eWxlLmpzXG4gKiogbW9kdWxlIGlkID0gMjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsImRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG4gICAgdmFyIHRleHRDb250YWluID0gcmVxdWlyZSgnenJlbmRlci9jb250YWluL3RleHQnKTtcblxuICAgIGZ1bmN0aW9uIGdldFNoYWxsb3cobW9kZWwsIHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIG1vZGVsICYmIG1vZGVsLmdldFNoYWxsb3cocGF0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBjb2xvciBwcm9wZXJ0eSBvciBnZXQgY29sb3IgZnJvbSBvcHRpb24udGV4dFN0eWxlLmNvbG9yXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGdldFRleHRDb2xvcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGVjTW9kZWwgPSB0aGlzLmVjTW9kZWw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTaGFsbG93KCdjb2xvcicpXG4gICAgICAgICAgICAgICAgfHwgKGVjTW9kZWwgJiYgZWNNb2RlbC5nZXQoJ3RleHRTdHlsZS5jb2xvcicpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGZvbnQgc3RyaW5nIGZyb20gZm9udFN0eWxlLCBmb250V2VpZ2h0LCBmb250U2l6ZSwgZm9udEZhbWlseVxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRGb250OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZWNNb2RlbCA9IHRoaXMuZWNNb2RlbDtcbiAgICAgICAgICAgIHZhciBnVGV4dFN0eWxlTW9kZWwgPSBlY01vZGVsICYmIGVjTW9kZWwuZ2V0TW9kZWwoJ3RleHRTdHlsZScpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBpbiBub2RlLWNhbnZhcyBmb250V2VpZ2h0IGlzIGJlZm9yZSBmb250U3R5bGVcbiAgICAgICAgICAgICAgICB0aGlzLmdldFNoYWxsb3coJ2ZvbnRTdHlsZScpIHx8IGdldFNoYWxsb3coZ1RleHRTdHlsZU1vZGVsLCAnZm9udFN0eWxlJyksXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRTaGFsbG93KCdmb250V2VpZ2h0JykgfHwgZ2V0U2hhbGxvdyhnVGV4dFN0eWxlTW9kZWwsICdmb250V2VpZ2h0JyksXG4gICAgICAgICAgICAgICAgKHRoaXMuZ2V0U2hhbGxvdygnZm9udFNpemUnKSB8fCBnZXRTaGFsbG93KGdUZXh0U3R5bGVNb2RlbCwgJ2ZvbnRTaXplJykgfHwgMTIpICsgJ3B4JyxcbiAgICAgICAgICAgICAgICB0aGlzLmdldFNoYWxsb3coJ2ZvbnRGYW1pbHknKSB8fCBnZXRTaGFsbG93KGdUZXh0U3R5bGVNb2RlbCwgJ2ZvbnRGYW1pbHknKSB8fCAnc2Fucy1zZXJpZidcbiAgICAgICAgICAgIF0uam9pbignICcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFRleHRSZWN0OiBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAgICAgdmFyIHRleHRTdHlsZSA9IHRoaXMuZ2V0KCd0ZXh0U3R5bGUnKSB8fCB7fTtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QoXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICB0aGlzLmdldEZvbnQoKSxcbiAgICAgICAgICAgICAgICB0ZXh0U3R5bGUuYWxpZ24sXG4gICAgICAgICAgICAgICAgdGV4dFN0eWxlLmJhc2VsaW5lXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRydW5jYXRlVGV4dDogZnVuY3Rpb24gKHRleHQsIGNvbnRhaW5lcldpZHRoLCBlbGxpcHNpcywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRleHRDb250YWluLnRydW5jYXRlVGV4dChcbiAgICAgICAgICAgICAgICB0ZXh0LCBjb250YWluZXJXaWR0aCwgdGhpcy5nZXRGb250KCksIGVsbGlwc2lzLCBvcHRpb25zXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvZWNoYXJ0cy9tb2RlbC9taXhpbi90ZXh0U3R5bGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG4gICAgdmFyIGdldEl0ZW1TdHlsZSA9IHJlcXVpcmUoJy4vbWFrZVN0eWxlTWFwcGVyJykoXG4gICAgICAgIFtcbiAgICAgICAgICAgIFsnZmlsbCcsICdjb2xvciddLFxuICAgICAgICAgICAgWydzdHJva2UnLCAnYm9yZGVyQ29sb3InXSxcbiAgICAgICAgICAgIFsnbGluZVdpZHRoJywgJ2JvcmRlcldpZHRoJ10sXG4gICAgICAgICAgICBbJ29wYWNpdHknXSxcbiAgICAgICAgICAgIFsnc2hhZG93Qmx1ciddLFxuICAgICAgICAgICAgWydzaGFkb3dPZmZzZXRYJ10sXG4gICAgICAgICAgICBbJ3NoYWRvd09mZnNldFknXSxcbiAgICAgICAgICAgIFsnc2hhZG93Q29sb3InXVxuICAgICAgICBdXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXRJdGVtU3R5bGU6IGZ1bmN0aW9uIChleGNsdWRlcykge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gZ2V0SXRlbVN0eWxlLmNhbGwodGhpcywgZXhjbHVkZXMpO1xuICAgICAgICAgICAgdmFyIGxpbmVEYXNoID0gdGhpcy5nZXRCb3JkZXJMaW5lRGFzaCgpO1xuICAgICAgICAgICAgbGluZURhc2ggJiYgKHN0eWxlLmxpbmVEYXNoID0gbGluZURhc2gpO1xuICAgICAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEJvcmRlckxpbmVEYXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGluZVR5cGUgPSB0aGlzLmdldCgnYm9yZGVyVHlwZScpO1xuICAgICAgICAgICAgcmV0dXJuIChsaW5lVHlwZSA9PT0gJ3NvbGlkJyB8fCBsaW5lVHlwZSA9PSBudWxsKSA/IG51bGxcbiAgICAgICAgICAgICAgICA6IChsaW5lVHlwZSA9PT0gJ2Rhc2hlZCcgPyBbNSwgNV0gOiBbMSwgMV0pO1xuICAgICAgICB9XG4gICAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvZWNoYXJ0cy9tb2RlbC9taXhpbi9pdGVtU3R5bGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyMlxuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiLyoqXG4gKiBDb21wb25lbnQgbW9kZWxcbiAqXG4gKiBAbW9kdWxlIGVjaGFydHMvbW9kZWwvQ29tcG9uZW50XG4gKi9cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlKSB7XG5cbiAgICB2YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvY29yZS91dGlsJyk7XG4gICAgdmFyIGFycmF5UHVzaCA9IEFycmF5LnByb3RvdHlwZS5wdXNoO1xuICAgIHZhciBjb21wb25lbnRVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9jb21wb25lbnQnKTtcbiAgICB2YXIgY2xhenpVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9jbGF6eicpO1xuICAgIHZhciBsYXlvdXQgPSByZXF1aXJlKCcuLi91dGlsL2xheW91dCcpO1xuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25cbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBwYXJlbnRNb2RlbFxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IGVjTW9kZWxcbiAgICAgKi9cbiAgICB2YXIgQ29tcG9uZW50TW9kZWwgPSBNb2RlbC5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdjb21wb25lbnQnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGlkOiAnJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICBuYW1lOiAnJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBtYWluVHlwZTogJycsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgc3ViVHlwZTogJycsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgY29tcG9uZW50SW5kZXg6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGRlZmF1bHRPcHRpb246IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9XG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgZWNNb2RlbDogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICoga2V5OiBjb21wb25lbnRUeXBlXG4gICAgICAgICAqIHZhbHVlOiAgQ29tcG9uZW50IG1vZGVsIGxpc3QsIGNhbiBub3QgYmUgbnVsbC5cbiAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBBcnJheS48bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWw+Pn1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICBkZXBlbmRlbnRNb2RlbHM6IFtdLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHVpZDogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3VwcG9ydCBtZXJnZSBsYXlvdXQgcGFyYW1zLlxuICAgICAgICAgKiBPbmx5IHN1cHBvcnQgJ2JveCcgbm93IChsZWZ0L3JpZ2h0L3RvcC9ib3R0b20vd2lkdGgvaGVpZ2h0KS5cbiAgICAgICAgICogQHR5cGUge3N0cmluZ3xPYmplY3R9IE9iamVjdCBjYW4gYmUge2lnbm9yZVNpemU6IHRydWV9XG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgbGF5b3V0TW9kZTogbnVsbCxcblxuICAgICAgICAkY29uc3RydWN0b3I6IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsLCBleHRyYU9wdCkge1xuICAgICAgICAgICAgTW9kZWwuY2FsbCh0aGlzLCBvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsLCBleHRyYU9wdCk7XG5cbiAgICAgICAgICAgIC8vIFNldCBkZXBlbmRlbnRNb2RlbHMsIGNvbXBvbmVudEluZGV4LCBuYW1lLCBpZCwgbWFpblR5cGUsIHN1YlR5cGUuXG4gICAgICAgICAgICB6clV0aWwuZXh0ZW5kKHRoaXMsIGV4dHJhT3B0KTtcblxuICAgICAgICAgICAgdGhpcy51aWQgPSBjb21wb25lbnRVdGlsLmdldFVJRCgnY29tcG9uZW50TW9kZWwnKTtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsLCBleHRyYU9wdCkge1xuICAgICAgICAgICAgdGhpcy5tZXJnZURlZmF1bHRBbmRUaGVtZShvcHRpb24sIGVjTW9kZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1lcmdlRGVmYXVsdEFuZFRoZW1lOiBmdW5jdGlvbiAob3B0aW9uLCBlY01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgbGF5b3V0TW9kZSA9IHRoaXMubGF5b3V0TW9kZTtcbiAgICAgICAgICAgIHZhciBpbnB1dFBvc2l0aW9uUGFyYW1zID0gbGF5b3V0TW9kZVxuICAgICAgICAgICAgICAgID8gbGF5b3V0LmdldExheW91dFBhcmFtcyhvcHRpb24pIDoge307XG5cbiAgICAgICAgICAgIHZhciB0aGVtZU1vZGVsID0gZWNNb2RlbC5nZXRUaGVtZSgpO1xuICAgICAgICAgICAgenJVdGlsLm1lcmdlKG9wdGlvbiwgdGhlbWVNb2RlbC5nZXQodGhpcy5tYWluVHlwZSkpO1xuICAgICAgICAgICAgenJVdGlsLm1lcmdlKG9wdGlvbiwgdGhpcy5nZXREZWZhdWx0T3B0aW9uKCkpO1xuXG4gICAgICAgICAgICBpZiAobGF5b3V0TW9kZSkge1xuICAgICAgICAgICAgICAgIGxheW91dC5tZXJnZUxheW91dFBhcmFtKG9wdGlvbiwgaW5wdXRQb3NpdGlvblBhcmFtcywgbGF5b3V0TW9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgICAgIHpyVXRpbC5tZXJnZSh0aGlzLm9wdGlvbiwgb3B0aW9uLCB0cnVlKTtcblxuICAgICAgICAgICAgdmFyIGxheW91dE1vZGUgPSB0aGlzLmxheW91dE1vZGU7XG4gICAgICAgICAgICBpZiAobGF5b3V0TW9kZSkge1xuICAgICAgICAgICAgICAgIGxheW91dC5tZXJnZUxheW91dFBhcmFtKHRoaXMub3B0aW9uLCBvcHRpb24sIGxheW91dE1vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEhvb2tlciBhZnRlciBpbml0IG9yIG1lcmdlT3B0aW9uXG4gICAgICAgIG9wdGlvblVwZGF0ZWQ6IGZ1bmN0aW9uIChuZXdDcHRPcHRpb24sIGlzSW5pdCkge30sXG5cbiAgICAgICAgZ2V0RGVmYXVsdE9wdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KCdfX2RlZmF1bHRPcHRpb24nKSkge1xuICAgICAgICAgICAgICAgIHZhciBvcHRMaXN0ID0gW107XG4gICAgICAgICAgICAgICAgdmFyIENsYXNzID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgICAgICB3aGlsZSAoQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdCA9IENsYXNzLnByb3RvdHlwZS5kZWZhdWx0T3B0aW9uO1xuICAgICAgICAgICAgICAgICAgICBvcHQgJiYgb3B0TGlzdC5wdXNoKG9wdCk7XG4gICAgICAgICAgICAgICAgICAgIENsYXNzID0gQ2xhc3Muc3VwZXJDbGFzcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbiA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBvcHRMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb24gPSB6clV0aWwubWVyZ2UoZGVmYXVsdE9wdGlvbiwgb3B0TGlzdFtpXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX19kZWZhdWx0T3B0aW9uID0gZGVmYXVsdE9wdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZGVmYXVsdE9wdGlvbjtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICAvLyBSZXNldCBDb21wb25lbnRNb2RlbC5leHRlbmQsIGFkZCBwcmVDb25zdHJ1Y3QuXG4gICAgLy8gY2xhenpVdGlsLmVuYWJsZUNsYXNzRXh0ZW5kKFxuICAgIC8vICAgICBDb21wb25lbnRNb2RlbCxcbiAgICAvLyAgICAgZnVuY3Rpb24gKG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwsIGV4dHJhT3B0KSB7XG4gICAgLy8gICAgICAgICAvLyBTZXQgZGVwZW5kZW50TW9kZWxzLCBjb21wb25lbnRJbmRleCwgbmFtZSwgaWQsIG1haW5UeXBlLCBzdWJUeXBlLlxuICAgIC8vICAgICAgICAgenJVdGlsLmV4dGVuZCh0aGlzLCBleHRyYU9wdCk7XG5cbiAgICAvLyAgICAgICAgIHRoaXMudWlkID0gY29tcG9uZW50VXRpbC5nZXRVSUQoJ2NvbXBvbmVudE1vZGVsJyk7XG5cbiAgICAvLyAgICAgICAgIC8vIHRoaXMuc2V0UmVhZE9ubHkoW1xuICAgIC8vICAgICAgICAgLy8gICAgICd0eXBlJywgJ2lkJywgJ3VpZCcsICduYW1lJywgJ21haW5UeXBlJywgJ3N1YlR5cGUnLFxuICAgIC8vICAgICAgICAgLy8gICAgICdkZXBlbmRlbnRNb2RlbHMnLCAnY29tcG9uZW50SW5kZXgnXG4gICAgLy8gICAgICAgICAvLyBdKTtcbiAgICAvLyAgICAgfVxuICAgIC8vICk7XG5cbiAgICAvLyBBZGQgY2FwYWJpbGl0eSBvZiByZWdpc3RlckNsYXNzLCBnZXRDbGFzcywgaGFzQ2xhc3MsIHJlZ2lzdGVyU3ViVHlwZURlZmF1bHRlciBhbmQgc28gb24uXG4gICAgY2xhenpVdGlsLmVuYWJsZUNsYXNzTWFuYWdlbWVudChcbiAgICAgICAgQ29tcG9uZW50TW9kZWwsIHtyZWdpc3RlcldoZW5FeHRlbmQ6IHRydWV9XG4gICAgKTtcbiAgICBjb21wb25lbnRVdGlsLmVuYWJsZVN1YlR5cGVEZWZhdWx0ZXIoQ29tcG9uZW50TW9kZWwpO1xuXG4gICAgLy8gQWRkIGNhcGFiaWxpdHkgb2YgQ29tcG9uZW50TW9kZWwudG9wb2xvZ2ljYWxUcmF2ZWwuXG4gICAgY29tcG9uZW50VXRpbC5lbmFibGVUb3BvbG9naWNhbFRyYXZlbChDb21wb25lbnRNb2RlbCwgZ2V0RGVwZW5kZW5jaWVzKTtcblxuICAgIGZ1bmN0aW9uIGdldERlcGVuZGVuY2llcyhjb21wb25lbnRUeXBlKSB7XG4gICAgICAgIHZhciBkZXBzID0gW107XG4gICAgICAgIHpyVXRpbC5lYWNoKENvbXBvbmVudE1vZGVsLmdldENsYXNzZXNCeU1haW5UeXBlKGNvbXBvbmVudFR5cGUpLCBmdW5jdGlvbiAoQ2xhenopIHtcbiAgICAgICAgICAgIGFycmF5UHVzaC5hcHBseShkZXBzLCBDbGF6ei5wcm90b3R5cGUuZGVwZW5kZW5jaWVzIHx8IFtdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEVuc3VyZSBtYWluIHR5cGVcbiAgICAgICAgcmV0dXJuIHpyVXRpbC5tYXAoZGVwcywgZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBjbGF6elV0aWwucGFyc2VDbGFzc1R5cGUodHlwZSkubWFpbjtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgenJVdGlsLm1peGluKENvbXBvbmVudE1vZGVsLCByZXF1aXJlKCcuL21peGluL2JveExheW91dCcpKTtcblxuICAgIHJldHVybiBDb21wb25lbnRNb2RlbDtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvZWNoYXJ0cy9tb2RlbC9Db21wb25lbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAyM1xuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUpIHtcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2NvcmUvdXRpbCcpO1xuICAgIHZhciBjbGF6eiA9IHJlcXVpcmUoJy4vY2xhenonKTtcblxuICAgIHZhciBwYXJzZUNsYXNzVHlwZSA9IGNsYXp6LnBhcnNlQ2xhc3NUeXBlO1xuXG4gICAgdmFyIGJhc2UgPSAwO1xuXG4gICAgdmFyIGNvbXBvbmVudFV0aWwgPSB7fTtcblxuICAgIHZhciBERUxJTUlURVIgPSAnXyc7XG5cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgY29tcG9uZW50VXRpbC5nZXRVSUQgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAvLyBDb25zaWRlcmluZyB0aGUgY2FzZSBvZiBjcm9zc2luZyBqcyBjb250ZXh0LFxuICAgICAgICAvLyB1c2UgTWF0aC5yYW5kb20gdG8gbWFrZSBpZCBhcyB1bmlxdWUgYXMgcG9zc2libGUuXG4gICAgICAgIHJldHVybiBbKHR5cGUgfHwgJycpLCBiYXNlKyssIE1hdGgucmFuZG9tKCldLmpvaW4oREVMSU1JVEVSKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgY29tcG9uZW50VXRpbC5lbmFibGVTdWJUeXBlRGVmYXVsdGVyID0gZnVuY3Rpb24gKGVudGl0eSkge1xuXG4gICAgICAgIHZhciBzdWJUeXBlRGVmYXVsdGVycyA9IHt9O1xuXG4gICAgICAgIGVudGl0eS5yZWdpc3RlclN1YlR5cGVEZWZhdWx0ZXIgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSwgZGVmYXVsdGVyKSB7XG4gICAgICAgICAgICBjb21wb25lbnRUeXBlID0gcGFyc2VDbGFzc1R5cGUoY29tcG9uZW50VHlwZSk7XG4gICAgICAgICAgICBzdWJUeXBlRGVmYXVsdGVyc1tjb21wb25lbnRUeXBlLm1haW5dID0gZGVmYXVsdGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIGVudGl0eS5kZXRlcm1pbmVTdWJUeXBlID0gZnVuY3Rpb24gKGNvbXBvbmVudFR5cGUsIG9wdGlvbikge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBvcHRpb24udHlwZTtcbiAgICAgICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRUeXBlTWFpbiA9IHBhcnNlQ2xhc3NUeXBlKGNvbXBvbmVudFR5cGUpLm1haW47XG4gICAgICAgICAgICAgICAgaWYgKGVudGl0eS5oYXNTdWJUeXBlcyhjb21wb25lbnRUeXBlKSAmJiBzdWJUeXBlRGVmYXVsdGVyc1tjb21wb25lbnRUeXBlTWFpbl0pIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IHN1YlR5cGVEZWZhdWx0ZXJzW2NvbXBvbmVudFR5cGVNYWluXShvcHRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBlbnRpdHk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRvcG9sb2dpY2FsIHRyYXZlbCBvbiBBY3Rpdml0eSBOZXR3b3JrIChBY3Rpdml0eSBPbiBWZXJ0aWNlcykuXG4gICAgICogRGVwZW5kZW5jaWVzIGlzIGRlZmluZWQgaW4gTW9kZWwucHJvdG90eXBlLmRlcGVuZGVuY2llcywgbGlrZSBbJ3hBeGlzJywgJ3lBeGlzJ10uXG4gICAgICpcbiAgICAgKiBJZiAneEF4aXMnIG9yICd5QXhpcycgaXMgYWJzZW50IGluIGNvbXBvbmVudFR5cGVMaXN0LCBqdXN0IGlnbm9yZSBpdCBpbiB0b3BvbG9neS5cbiAgICAgKlxuICAgICAqIElmIHRoZXJlIGlzIGNpcmNsZSBkZXBlbmRlbmNleSwgRXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gICAgICpcbiAgICAgKi9cbiAgICBjb21wb25lbnRVdGlsLmVuYWJsZVRvcG9sb2dpY2FsVHJhdmVsID0gZnVuY3Rpb24gKGVudGl0eSwgZGVwZW5kZW5jeUdldHRlcikge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHRhcmdldE5hbWVMaXN0IFRhcmdldCBDb21wb25lbnQgdHlwZSBsaXN0LlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYW4gYmUgWydhYScsICdiYicsICdhYS54eCddXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGZ1bGxOYW1lTGlzdCBCeSB3aGljaCB3ZSBjYW4gYnVpbGQgZGVwZW5kZW5jeSBncmFwaC5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgUGFyYW1zOiBjb21wb25lbnRUeXBlLCBkZXBlbmRlbmNpZXMuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IFNjb3BlIG9mIGNhbGxiYWNrLlxuICAgICAgICAgKi9cbiAgICAgICAgZW50aXR5LnRvcG9sb2dpY2FsVHJhdmVsID0gZnVuY3Rpb24gKHRhcmdldE5hbWVMaXN0LCBmdWxsTmFtZUxpc3QsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAoIXRhcmdldE5hbWVMaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG1ha2VEZXBuZGVuY3lHcmFwaChmdWxsTmFtZUxpc3QpO1xuICAgICAgICAgICAgdmFyIGdyYXBoID0gcmVzdWx0LmdyYXBoO1xuICAgICAgICAgICAgdmFyIHN0YWNrID0gcmVzdWx0Lm5vRW50cnlMaXN0O1xuXG4gICAgICAgICAgICB2YXIgdGFyZ2V0TmFtZVNldCA9IHt9O1xuICAgICAgICAgICAgenJVdGlsLmVhY2godGFyZ2V0TmFtZUxpc3QsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0TmFtZVNldFtuYW1lXSA9IHRydWU7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyQ29tcG9uZW50VHlwZSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIHZhciBjdXJyVmVydGV4ID0gZ3JhcGhbY3VyckNvbXBvbmVudFR5cGVdO1xuICAgICAgICAgICAgICAgIHZhciBpc0luVGFyZ2V0TmFtZVNldCA9ICEhdGFyZ2V0TmFtZVNldFtjdXJyQ29tcG9uZW50VHlwZV07XG4gICAgICAgICAgICAgICAgaWYgKGlzSW5UYXJnZXROYW1lU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgY3VyckNvbXBvbmVudFR5cGUsIGN1cnJWZXJ0ZXgub3JpZ2luYWxEZXBzLnNsaWNlKCkpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGFyZ2V0TmFtZVNldFtjdXJyQ29tcG9uZW50VHlwZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHpyVXRpbC5lYWNoKFxuICAgICAgICAgICAgICAgICAgICBjdXJyVmVydGV4LnN1Y2Nlc3NvcixcbiAgICAgICAgICAgICAgICAgICAgaXNJblRhcmdldE5hbWVTZXQgPyByZW1vdmVFZGdlQW5kQWRkIDogcmVtb3ZlRWRnZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKHRhcmdldE5hbWVTZXQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NpcmNsZSBkZXBlbmRlbmN5IG1heSBleGlzdHMnKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiByZW1vdmVFZGdlKHN1Y2NDb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgZ3JhcGhbc3VjY0NvbXBvbmVudFR5cGVdLmVudHJ5Q291bnQtLTtcbiAgICAgICAgICAgICAgICBpZiAoZ3JhcGhbc3VjY0NvbXBvbmVudFR5cGVdLmVudHJ5Q291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChzdWNjQ29tcG9uZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb25zaWRlciB0aGlzIGNhc2U6IGxlZ2VuZCBkZXBlbmRzIG9uIHNlcmllcywgYW5kIHdlIGNhbGxcbiAgICAgICAgICAgIC8vIGNoYXJ0LnNldE9wdGlvbih7c2VyaWVzOiBbLi4uXX0pLCB3aGVyZSBvbmx5IHNlcmllcyBpcyBpbiBvcHRpb24uXG4gICAgICAgICAgICAvLyBJZiB3ZSBkbyBub3QgaGF2ZSAncmVtb3ZlRWRnZUFuZEFkZCcsIGxlZ2VuZE1vZGVsLm1lcmdlT3B0aW9uIHdpbGxcbiAgICAgICAgICAgIC8vIG5vdCBiZSBjYWxsZWQsIGJ1dCBvbmx5IHNlcmVpcy5tZXJnZU9wdGlvbiBpcyBjYWxsZWQuIFRodXMgbGVnZW5kXG4gICAgICAgICAgICAvLyBoYXZlIG5vIGNoYW5jZSB0byB1cGRhdGUgaXRzIGxvY2FsIHJlY29yZCBhYm91dCBzZXJpZXMgKGxpa2Ugd2hpY2hcbiAgICAgICAgICAgIC8vIG5hbWUgb2Ygc2VyaWVzIGlzIGF2YWlsYWJsZSBpbiBsZWdlbmQpLlxuICAgICAgICAgICAgZnVuY3Rpb24gcmVtb3ZlRWRnZUFuZEFkZChzdWNjQ29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgICAgIHRhcmdldE5hbWVTZXRbc3VjY0NvbXBvbmVudFR5cGVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZW1vdmVFZGdlKHN1Y2NDb21wb25lbnRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVwbmRlbmN5R3JhcGg6IHtPYmplY3R9XG4gICAgICAgICAqIGtleTogY29ucG9uZW50VHlwZSxcbiAgICAgICAgICogdmFsdWU6IHtcbiAgICAgICAgICogICAgIHN1Y2Nlc3NvcjogW2NvbnBvbmVudFR5cGVzLi4uXSxcbiAgICAgICAgICogICAgIG9yaWdpbmFsRGVwczogW2NvbnBvbmVudFR5cGVzLi4uXSxcbiAgICAgICAgICogICAgIGVudHJ5Q291bnQ6IHtudW1iZXJ9XG4gICAgICAgICAqIH1cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIG1ha2VEZXBuZGVuY3lHcmFwaChmdWxsTmFtZUxpc3QpIHtcbiAgICAgICAgICAgIHZhciBncmFwaCA9IHt9O1xuICAgICAgICAgICAgdmFyIG5vRW50cnlMaXN0ID0gW107XG5cbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKGZ1bGxOYW1lTGlzdCwgZnVuY3Rpb24gKG5hbWUpIHtcblxuICAgICAgICAgICAgICAgIHZhciB0aGlzSXRlbSA9IGNyZWF0ZURlcGVuZGVuY3lHcmFwaEl0ZW0oZ3JhcGgsIG5hbWUpO1xuICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbERlcHMgPSB0aGlzSXRlbS5vcmlnaW5hbERlcHMgPSBkZXBlbmRlbmN5R2V0dGVyKG5hbWUpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGF2YWlsYWJsZURlcHMgPSBnZXRBdmFpbGFibGVEZXBlbmRlbmNpZXMob3JpZ2luYWxEZXBzLCBmdWxsTmFtZUxpc3QpO1xuICAgICAgICAgICAgICAgIHRoaXNJdGVtLmVudHJ5Q291bnQgPSBhdmFpbGFibGVEZXBzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAodGhpc0l0ZW0uZW50cnlDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBub0VudHJ5TGlzdC5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHpyVXRpbC5lYWNoKGF2YWlsYWJsZURlcHMsIGZ1bmN0aW9uIChkZXBlbmRlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh6clV0aWwuaW5kZXhPZih0aGlzSXRlbS5wcmVkZWNlc3NvciwgZGVwZW5kZW50TmFtZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzSXRlbS5wcmVkZWNlc3Nvci5wdXNoKGRlcGVuZGVudE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aGF0SXRlbSA9IGNyZWF0ZURlcGVuZGVuY3lHcmFwaEl0ZW0oZ3JhcGgsIGRlcGVuZGVudE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoenJVdGlsLmluZGV4T2YodGhhdEl0ZW0uc3VjY2Vzc29yLCBkZXBlbmRlbnROYW1lKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXRJdGVtLnN1Y2Nlc3Nvci5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHtncmFwaDogZ3JhcGgsIG5vRW50cnlMaXN0OiBub0VudHJ5TGlzdH07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVEZXBlbmRlbmN5R3JhcGhJdGVtKGdyYXBoLCBuYW1lKSB7XG4gICAgICAgICAgICBpZiAoIWdyYXBoW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgZ3JhcGhbbmFtZV0gPSB7cHJlZGVjZXNzb3I6IFtdLCBzdWNjZXNzb3I6IFtdfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBncmFwaFtuYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldEF2YWlsYWJsZURlcGVuZGVuY2llcyhvcmlnaW5hbERlcHMsIGZ1bGxOYW1lTGlzdCkge1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZURlcHMgPSBbXTtcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKG9yaWdpbmFsRGVwcywgZnVuY3Rpb24gKGRlcCkge1xuICAgICAgICAgICAgICAgIHpyVXRpbC5pbmRleE9mKGZ1bGxOYW1lTGlzdCwgZGVwKSA+PSAwICYmIGF2YWlsYWJsZURlcHMucHVzaChkZXApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYXZhaWxhYmxlRGVwcztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gY29tcG9uZW50VXRpbDtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvZWNoYXJ0cy91dGlsL2NvbXBvbmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCIvLyBMYXlvdXQgaGVscGVycyBmb3IgZWFjaCBjb21wb25lbnQgcG9zaXRpb25pbmdcbmRlZmluZShmdW5jdGlvbihyZXF1aXJlKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvY29yZS91dGlsJyk7XG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3QnKTtcbiAgICB2YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoJy4vbnVtYmVyJyk7XG4gICAgdmFyIGZvcm1hdFV0aWwgPSByZXF1aXJlKCcuL2Zvcm1hdCcpO1xuICAgIHZhciBwYXJzZVBlcmNlbnQgPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudDtcbiAgICB2YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xuXG4gICAgdmFyIGxheW91dCA9IHt9O1xuXG4gICAgdmFyIExPQ0FUSU9OX1BBUkFNUyA9IFsnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJywgJ3dpZHRoJywgJ2hlaWdodCddO1xuXG4gICAgZnVuY3Rpb24gYm94TGF5b3V0KG9yaWVudCwgZ3JvdXAsIGdhcCwgbWF4V2lkdGgsIG1heEhlaWdodCkge1xuICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgIHZhciB5ID0gMDtcbiAgICAgICAgaWYgKG1heFdpZHRoID09IG51bGwpIHtcbiAgICAgICAgICAgIG1heFdpZHRoID0gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heEhlaWdodCA9PSBudWxsKSB7XG4gICAgICAgICAgICBtYXhIZWlnaHQgPSBJbmZpbml0eTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VycmVudExpbmVNYXhTaXplID0gMDtcbiAgICAgICAgZ3JvdXAuZWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZCwgaWR4KSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBjaGlsZC5wb3NpdGlvbjtcbiAgICAgICAgICAgIHZhciByZWN0ID0gY2hpbGQuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgICAgICB2YXIgbmV4dENoaWxkID0gZ3JvdXAuY2hpbGRBdChpZHggKyAxKTtcbiAgICAgICAgICAgIHZhciBuZXh0Q2hpbGRSZWN0ID0gbmV4dENoaWxkICYmIG5leHRDaGlsZC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgIHZhciBuZXh0WDtcbiAgICAgICAgICAgIHZhciBuZXh0WTtcbiAgICAgICAgICAgIGlmIChvcmllbnQgPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgICAgIHZhciBtb3ZlWCA9IHJlY3Qud2lkdGggKyAobmV4dENoaWxkUmVjdCA/ICgtbmV4dENoaWxkUmVjdC54ICsgcmVjdC54KSA6IDApO1xuICAgICAgICAgICAgICAgIG5leHRYID0geCArIG1vdmVYO1xuICAgICAgICAgICAgICAgIC8vIFdyYXAgd2hlbiB3aWR0aCBleGNlZWRzIG1heFdpZHRoIG9yIG1lZXQgYSBgbmV3bGluZWAgZ3JvdXBcbiAgICAgICAgICAgICAgICBpZiAobmV4dFggPiBtYXhXaWR0aCB8fCBjaGlsZC5uZXdsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgICAgICAgICBuZXh0WCA9IG1vdmVYO1xuICAgICAgICAgICAgICAgICAgICB5ICs9IGN1cnJlbnRMaW5lTWF4U2l6ZSArIGdhcDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudExpbmVNYXhTaXplID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGluZU1heFNpemUgPSBNYXRoLm1heChjdXJyZW50TGluZU1heFNpemUsIHJlY3QuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbW92ZVkgPSByZWN0LmhlaWdodCArIChuZXh0Q2hpbGRSZWN0ID8gKC1uZXh0Q2hpbGRSZWN0LnkgKyByZWN0LnkpIDogMCk7XG4gICAgICAgICAgICAgICAgbmV4dFkgPSB5ICsgbW92ZVk7XG4gICAgICAgICAgICAgICAgLy8gV3JhcCB3aGVuIHdpZHRoIGV4Y2VlZHMgbWF4SGVpZ2h0IG9yIG1lZXQgYSBgbmV3bGluZWAgZ3JvdXBcbiAgICAgICAgICAgICAgICBpZiAobmV4dFkgPiBtYXhIZWlnaHQgfHwgY2hpbGQubmV3bGluZSkge1xuICAgICAgICAgICAgICAgICAgICB4ICs9IGN1cnJlbnRMaW5lTWF4U2l6ZSArIGdhcDtcbiAgICAgICAgICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG5leHRZID0gbW92ZVk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lTWF4U2l6ZSA9IHJlY3Qud2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGluZU1heFNpemUgPSBNYXRoLm1heChjdXJyZW50TGluZU1heFNpemUsIHJlY3Qud2lkdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNoaWxkLm5ld2xpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBvc2l0aW9uWzBdID0geDtcbiAgICAgICAgICAgIHBvc2l0aW9uWzFdID0geTtcblxuICAgICAgICAgICAgb3JpZW50ID09PSAnaG9yaXpvbnRhbCdcbiAgICAgICAgICAgICAgICA/ICh4ID0gbmV4dFggKyBnYXApXG4gICAgICAgICAgICAgICAgOiAoeSA9IG5leHRZICsgZ2FwKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVkJveCBvciBIQm94IGxheW91dGluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcmllbnRcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH0gZ3JvdXBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ2FwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aD1JbmZpbml0eV1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodD1JbmZpbml0eV1cbiAgICAgKi9cbiAgICBsYXlvdXQuYm94ID0gYm94TGF5b3V0O1xuXG4gICAgLyoqXG4gICAgICogVkJveCBsYXlvdXRpbmdcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH0gZ3JvdXBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ2FwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aD1JbmZpbml0eV1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodD1JbmZpbml0eV1cbiAgICAgKi9cbiAgICBsYXlvdXQudmJveCA9IHpyVXRpbC5jdXJyeShib3hMYXlvdXQsICd2ZXJ0aWNhbCcpO1xuXG4gICAgLyoqXG4gICAgICogSEJveCBsYXlvdXRpbmdcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH0gZ3JvdXBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ2FwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aD1JbmZpbml0eV1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodD1JbmZpbml0eV1cbiAgICAgKi9cbiAgICBsYXlvdXQuaGJveCA9IHpyVXRpbC5jdXJyeShib3hMYXlvdXQsICdob3Jpem9udGFsJyk7XG5cbiAgICAvKipcbiAgICAgKiBJZiB4IG9yIHgyIGlzIG5vdCBzcGVjaWZpZWQgb3IgJ2NlbnRlcicgJ2xlZnQnICdyaWdodCcsXG4gICAgICogdGhlIHdpZHRoIHdvdWxkIGJlIGFzIGxvbmcgYXMgcG9zc2libGUuXG4gICAgICogSWYgeSBvciB5MiBpcyBub3Qgc3BlY2lmaWVkIG9yICdtaWRkbGUnICd0b3AnICdib3R0b20nLFxuICAgICAqIHRoZSBoZWlnaHQgd291bGQgYmUgYXMgbG9uZyBhcyBwb3NzaWJsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbkluZm9cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ueF1cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ueV1cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ueDJdXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLnkyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250YWluZXJSZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBtYXJnaW5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHt3aWR0aCwgaGVpZ2h0fVxuICAgICAqL1xuICAgIGxheW91dC5nZXRBdmFpbGFibGVTaXplID0gZnVuY3Rpb24gKHBvc2l0aW9uSW5mbywgY29udGFpbmVyUmVjdCwgbWFyZ2luKSB7XG4gICAgICAgIHZhciBjb250YWluZXJXaWR0aCA9IGNvbnRhaW5lclJlY3Qud2lkdGg7XG4gICAgICAgIHZhciBjb250YWluZXJIZWlnaHQgPSBjb250YWluZXJSZWN0LmhlaWdodDtcblxuICAgICAgICB2YXIgeCA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8ueCwgY29udGFpbmVyV2lkdGgpO1xuICAgICAgICB2YXIgeSA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8ueSwgY29udGFpbmVySGVpZ2h0KTtcbiAgICAgICAgdmFyIHgyID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby54MiwgY29udGFpbmVyV2lkdGgpO1xuICAgICAgICB2YXIgeTIgPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLnkyLCBjb250YWluZXJIZWlnaHQpO1xuXG4gICAgICAgIChpc05hTih4KSB8fCBpc05hTihwYXJzZUZsb2F0KHBvc2l0aW9uSW5mby54KSkpICYmICh4ID0gMCk7XG4gICAgICAgIChpc05hTih4MikgfHwgaXNOYU4ocGFyc2VGbG9hdChwb3NpdGlvbkluZm8ueDIpKSkgJiYgKHgyID0gY29udGFpbmVyV2lkdGgpO1xuICAgICAgICAoaXNOYU4oeSkgfHwgaXNOYU4ocGFyc2VGbG9hdChwb3NpdGlvbkluZm8ueSkpKSAmJiAoeSA9IDApO1xuICAgICAgICAoaXNOYU4oeTIpIHx8IGlzTmFOKHBhcnNlRmxvYXQocG9zaXRpb25JbmZvLnkyKSkpICYmICh5MiA9IGNvbnRhaW5lckhlaWdodCk7XG5cbiAgICAgICAgbWFyZ2luID0gZm9ybWF0VXRpbC5ub3JtYWxpemVDc3NBcnJheShtYXJnaW4gfHwgMCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiBNYXRoLm1heCh4MiAtIHggLSBtYXJnaW5bMV0gLSBtYXJnaW5bM10sIDApLFxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLm1heCh5MiAtIHkgLSBtYXJnaW5bMF0gLSBtYXJnaW5bMl0sIDApXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHBvc2l0aW9uIGluZm8uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb25JbmZvXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLmxlZnRdXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLnRvcF1cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ucmlnaHRdXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLmJvdHRvbV1cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ud2lkdGhdXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8uYXNwZWN0XSBBc3BlY3QgaXMgd2lkdGggLyBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGFpbmVyUmVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW21hcmdpbl1cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fVxuICAgICAqL1xuICAgIGxheW91dC5nZXRMYXlvdXRSZWN0ID0gZnVuY3Rpb24gKFxuICAgICAgICBwb3NpdGlvbkluZm8sIGNvbnRhaW5lclJlY3QsIG1hcmdpblxuICAgICkge1xuICAgICAgICBtYXJnaW4gPSBmb3JtYXRVdGlsLm5vcm1hbGl6ZUNzc0FycmF5KG1hcmdpbiB8fCAwKTtcblxuICAgICAgICB2YXIgY29udGFpbmVyV2lkdGggPSBjb250YWluZXJSZWN0LndpZHRoO1xuICAgICAgICB2YXIgY29udGFpbmVySGVpZ2h0ID0gY29udGFpbmVyUmVjdC5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIGxlZnQgPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLmxlZnQsIGNvbnRhaW5lcldpZHRoKTtcbiAgICAgICAgdmFyIHRvcCA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkluZm8udG9wLCBjb250YWluZXJIZWlnaHQpO1xuICAgICAgICB2YXIgcmlnaHQgPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLnJpZ2h0LCBjb250YWluZXJXaWR0aCk7XG4gICAgICAgIHZhciBib3R0b20gPSBwYXJzZVBlcmNlbnQocG9zaXRpb25JbmZvLmJvdHRvbSwgY29udGFpbmVySGVpZ2h0KTtcbiAgICAgICAgdmFyIHdpZHRoID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby53aWR0aCwgY29udGFpbmVyV2lkdGgpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uSW5mby5oZWlnaHQsIGNvbnRhaW5lckhlaWdodCk7XG5cbiAgICAgICAgdmFyIHZlcnRpY2FsTWFyZ2luID0gbWFyZ2luWzJdICsgbWFyZ2luWzBdO1xuICAgICAgICB2YXIgaG9yaXpvbnRhbE1hcmdpbiA9IG1hcmdpblsxXSArIG1hcmdpblszXTtcbiAgICAgICAgdmFyIGFzcGVjdCA9IHBvc2l0aW9uSW5mby5hc3BlY3Q7XG5cbiAgICAgICAgLy8gSWYgd2lkdGggaXMgbm90IHNwZWNpZmllZCwgY2FsY3VsYXRlIHdpZHRoIGZyb20gbGVmdCBhbmQgcmlnaHRcbiAgICAgICAgaWYgKGlzTmFOKHdpZHRoKSkge1xuICAgICAgICAgICAgd2lkdGggPSBjb250YWluZXJXaWR0aCAtIHJpZ2h0IC0gaG9yaXpvbnRhbE1hcmdpbiAtIGxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmFOKGhlaWdodCkpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IGNvbnRhaW5lckhlaWdodCAtIGJvdHRvbSAtIHZlcnRpY2FsTWFyZ2luIC0gdG9wO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2lkdGggYW5kIGhlaWdodCBhcmUgbm90IGdpdmVuXG4gICAgICAgIC8vIDEuIEdyYXBoIHNob3VsZCBub3QgZXhjZWVkcyB0aGUgY29udGFpbmVyXG4gICAgICAgIC8vIDIuIEFzcGVjdCBtdXN0IGJlIGtlZXBlZFxuICAgICAgICAvLyAzLiBHcmFwaCBzaG91bGQgdGFrZSB0aGUgc3BhY2UgYXMgbW9yZSBhcyBwb3NzaWJsZVxuICAgICAgICBpZiAoaXNOYU4od2lkdGgpICYmIGlzTmFOKGhlaWdodCkpIHtcbiAgICAgICAgICAgIGlmIChhc3BlY3QgPiBjb250YWluZXJXaWR0aCAvIGNvbnRhaW5lckhlaWdodCkge1xuICAgICAgICAgICAgICAgIHdpZHRoID0gY29udGFpbmVyV2lkdGggKiAwLjg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBjb250YWluZXJIZWlnaHQgKiAwLjg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXNwZWN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB3aWR0aCBvciBoZWlnaHQgd2l0aCBnaXZlbiBhc3BlY3RcbiAgICAgICAgICAgIGlmIChpc05hTih3aWR0aCkpIHtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IGFzcGVjdCAqIGhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc05hTihoZWlnaHQpKSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBsZWZ0IGlzIG5vdCBzcGVjaWZpZWQsIGNhbGN1bGF0ZSBsZWZ0IGZyb20gcmlnaHQgYW5kIHdpZHRoXG4gICAgICAgIGlmIChpc05hTihsZWZ0KSkge1xuICAgICAgICAgICAgbGVmdCA9IGNvbnRhaW5lcldpZHRoIC0gcmlnaHQgLSB3aWR0aCAtIGhvcml6b250YWxNYXJnaW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmFOKHRvcCkpIHtcbiAgICAgICAgICAgIHRvcCA9IGNvbnRhaW5lckhlaWdodCAtIGJvdHRvbSAtIGhlaWdodCAtIHZlcnRpY2FsTWFyZ2luO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWxpZ24gbGVmdCBhbmQgdG9wXG4gICAgICAgIHN3aXRjaCAocG9zaXRpb25JbmZvLmxlZnQgfHwgcG9zaXRpb25JbmZvLnJpZ2h0KSB7XG4gICAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgICAgIGxlZnQgPSBjb250YWluZXJXaWR0aCAvIDIgLSB3aWR0aCAvIDIgLSBtYXJnaW5bM107XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgbGVmdCA9IGNvbnRhaW5lcldpZHRoIC0gd2lkdGggLSBob3Jpem9udGFsTWFyZ2luO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAocG9zaXRpb25JbmZvLnRvcCB8fCBwb3NpdGlvbkluZm8uYm90dG9tKSB7XG4gICAgICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICB0b3AgPSBjb250YWluZXJIZWlnaHQgLyAyIC0gaGVpZ2h0IC8gMiAtIG1hcmdpblswXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgdG9wID0gY29udGFpbmVySGVpZ2h0IC0gaGVpZ2h0IC0gdmVydGljYWxNYXJnaW47XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgc29tZXRoaW5nIGlzIHdyb25nIGFuZCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQgYXJlIGNhbGN1bGF0ZWQgYXMgTmFOXG4gICAgICAgIGxlZnQgPSBsZWZ0IHx8IDA7XG4gICAgICAgIHRvcCA9IHRvcCB8fCAwO1xuICAgICAgICBpZiAoaXNOYU4od2lkdGgpKSB7XG4gICAgICAgICAgICAvLyBXaWR0aCBtYXkgYmUgTmFOIGlmIG9ubHkgb25lIHZhbHVlIGlzIGdpdmVuIGV4Y2VwdCB3aWR0aFxuICAgICAgICAgICAgd2lkdGggPSBjb250YWluZXJXaWR0aCAtIGxlZnQgLSAocmlnaHQgfHwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmFOKGhlaWdodCkpIHtcbiAgICAgICAgICAgIC8vIEhlaWdodCBtYXkgYmUgTmFOIGlmIG9ubHkgb25lIHZhbHVlIGlzIGdpdmVuIGV4Y2VwdCBoZWlnaHRcbiAgICAgICAgICAgIGhlaWdodCA9IGNvbnRhaW5lckhlaWdodCAtIHRvcCAtIChib3R0b20gfHwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QobGVmdCArIG1hcmdpblszXSwgdG9wICsgbWFyZ2luWzBdLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgcmVjdC5tYXJnaW4gPSBtYXJnaW47XG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQb3NpdGlvbiBncm91cCBvZiBjb21wb25lbnQgaW4gdmlld3BvcnRcbiAgICAgKiAgR3JvdXAgcG9zaXRpb24gaXMgc3BlY2lmaWVkIGJ5IGVpdGhlclxuICAgICAqICB7bGVmdCwgdG9wfSwge3JpZ2h0LCBib3R0b219XG4gICAgICogIElmIGFsbCBwcm9wZXJ0aWVzIGV4aXN0cywgcmlnaHQgYW5kIGJvdHRvbSB3aWxsIGJlIGlnb25yZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2NvbnRhaW5lci9Hcm91cH0gZ3JvdXBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb25JbmZvXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLmxlZnRdXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLnRvcF1cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtwb3NpdGlvbkluZm8ucmlnaHRdXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcG9zaXRpb25JbmZvLmJvdHRvbV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGFpbmVyUmVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbWFyZ2luXG4gICAgICovXG4gICAgbGF5b3V0LnBvc2l0aW9uR3JvdXAgPSBmdW5jdGlvbiAoXG4gICAgICAgIGdyb3VwLCBwb3NpdGlvbkluZm8sIGNvbnRhaW5lclJlY3QsIG1hcmdpblxuICAgICkge1xuICAgICAgICB2YXIgZ3JvdXBSZWN0ID0gZ3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCk7XG5cbiAgICAgICAgcG9zaXRpb25JbmZvID0genJVdGlsLmV4dGVuZCh6clV0aWwuY2xvbmUocG9zaXRpb25JbmZvKSwge1xuICAgICAgICAgICAgd2lkdGg6IGdyb3VwUmVjdC53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogZ3JvdXBSZWN0LmhlaWdodFxuICAgICAgICB9KTtcblxuICAgICAgICBwb3NpdGlvbkluZm8gPSBsYXlvdXQuZ2V0TGF5b3V0UmVjdChcbiAgICAgICAgICAgIHBvc2l0aW9uSW5mbywgY29udGFpbmVyUmVjdCwgbWFyZ2luXG4gICAgICAgICk7XG5cbiAgICAgICAgZ3JvdXAuYXR0cigncG9zaXRpb24nLCBbXG4gICAgICAgICAgICBwb3NpdGlvbkluZm8ueCAtIGdyb3VwUmVjdC54LFxuICAgICAgICAgICAgcG9zaXRpb25JbmZvLnkgLSBncm91cFJlY3QueVxuICAgICAgICBdKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29uc2lkZXIgQ2FzZTpcbiAgICAgKiBXaGVuIGRlZnVsYXQgb3B0aW9uIGhhcyB7bGVmdDogMCwgd2lkdGg6IDEwMH0sIGFuZCB3ZSBzZXQge3JpZ2h0OiAwfVxuICAgICAqIHRocm91Z2ggc2V0T3B0aW9uIG9yIG1lZGlhIHF1ZXJ5LCB1c2luZyBub3JtYWwgenJVdGlsLm1lcmdlIHdpbGwgY2F1c2VcbiAgICAgKiB7cmlnaHQ6IDB9IGRvZXMgbm90IHRha2UgZWZmZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBDb21wb25lbnRNb2RlbC5leHRlbmQoe1xuICAgICAqICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICogICAgICAgICAuLi5cbiAgICAgKiAgICAgICAgIHZhciBpbnB1dFBvc2l0aW9uUGFyYW1zID0gbGF5b3V0LmdldExheW91dFBhcmFtcyhvcHRpb24pO1xuICAgICAqICAgICAgICAgdGhpcy5tZXJnZU9wdGlvbihpbnB1dFBvc2l0aW9uUGFyYW1zKTtcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChuZXdPcHRpb24pIHtcbiAgICAgKiAgICAgICAgIG5ld09wdGlvbiAmJiB6clV0aWwubWVyZ2UodGhpc09wdGlvbiwgbmV3T3B0aW9uLCB0cnVlKTtcbiAgICAgKiAgICAgICAgIGxheW91dC5tZXJnZUxheW91dFBhcmFtKHRoaXNPcHRpb24sIG5ld09wdGlvbik7XG4gICAgICogICAgIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRPcHRpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbmV3T3B0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBbb3B0XVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdC5pZ25vcmVTaXplPWZhbHNlXSBTb21lIGNvbXBvbmVudCBtdXN0IGhhcyB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgICAqL1xuICAgIGxheW91dC5tZXJnZUxheW91dFBhcmFtID0gZnVuY3Rpb24gKHRhcmdldE9wdGlvbiwgbmV3T3B0aW9uLCBvcHQpIHtcbiAgICAgICAgIXpyVXRpbC5pc09iamVjdChvcHQpICYmIChvcHQgPSB7fSk7XG4gICAgICAgIHZhciBoTmFtZXMgPSBbJ3dpZHRoJywgJ2xlZnQnLCAncmlnaHQnXTsgLy8gT3JkZXIgYnkgcHJpb3JpdHkuXG4gICAgICAgIHZhciB2TmFtZXMgPSBbJ2hlaWdodCcsICd0b3AnLCAnYm90dG9tJ107IC8vIE9yZGVyIGJ5IHByaW9yaXR5LlxuICAgICAgICB2YXIgaFJlc3VsdCA9IG1lcmdlKGhOYW1lcyk7XG4gICAgICAgIHZhciB2UmVzdWx0ID0gbWVyZ2Uodk5hbWVzKTtcblxuICAgICAgICBjb3B5KGhOYW1lcywgdGFyZ2V0T3B0aW9uLCBoUmVzdWx0KTtcbiAgICAgICAgY29weSh2TmFtZXMsIHRhcmdldE9wdGlvbiwgdlJlc3VsdCk7XG5cbiAgICAgICAgZnVuY3Rpb24gbWVyZ2UobmFtZXMpIHtcbiAgICAgICAgICAgIHZhciBuZXdQYXJhbXMgPSB7fTtcbiAgICAgICAgICAgIHZhciBuZXdWYWx1ZUNvdW50ID0gMDtcbiAgICAgICAgICAgIHZhciBtZXJnZWQgPSB7fTtcbiAgICAgICAgICAgIHZhciBtZXJnZWRWYWx1ZUNvdW50ID0gMDtcbiAgICAgICAgICAgIHZhciBlbm91Z2hQYXJhbU51bWJlciA9IG9wdC5pZ25vcmVTaXplID8gMSA6IDI7XG5cbiAgICAgICAgICAgIGVhY2gobmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkW25hbWVdID0gdGFyZ2V0T3B0aW9uW25hbWVdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlYWNoKG5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIC8vIENvbnNpZGVyIGNhc2U6IG5ld09wdGlvbi53aWR0aCBpcyBudWxsLCB3aGljaCBpc1xuICAgICAgICAgICAgICAgIC8vIHNldCBieSB1c2VyIGZvciByZW1vdmluZyB3aWR0aCBzZXR0aW5nLlxuICAgICAgICAgICAgICAgIGhhc1Byb3AobmV3T3B0aW9uLCBuYW1lKSAmJiAobmV3UGFyYW1zW25hbWVdID0gbWVyZ2VkW25hbWVdID0gbmV3T3B0aW9uW25hbWVdKTtcbiAgICAgICAgICAgICAgICBoYXNWYWx1ZShuZXdQYXJhbXMsIG5hbWUpICYmIG5ld1ZhbHVlQ291bnQrKztcbiAgICAgICAgICAgICAgICBoYXNWYWx1ZShtZXJnZWQsIG5hbWUpICYmIG1lcmdlZFZhbHVlQ291bnQrKztcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBDYXNlOiBuZXdPcHRpb246IHt3aWR0aDogLi4uLCByaWdodDogLi4ufSxcbiAgICAgICAgICAgIC8vIG9yIHRhcmdldE9wdGlvbjoge3JpZ2h0OiAuLi59IGFuZCBuZXdPcHRpb246IHt3aWR0aDogLi4ufSxcbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIGNvbmZsaWN0IHdoZW4gbWVyZ2VkIG9ubHkgaGFzIHBhcmFtcyBjb3VudFxuICAgICAgICAgICAgLy8gbGl0dGxlIHRoYW4gZW5vdWdoUGFyYW1OdW1iZXIuXG4gICAgICAgICAgICBpZiAobWVyZ2VkVmFsdWVDb3VudCA9PT0gZW5vdWdoUGFyYW1OdW1iZXIgfHwgIW5ld1ZhbHVlQ291bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2FzZTogbmV3T3B0aW9uOiB7d2lkdGg6IC4uLiwgcmlnaHQ6IC4uLn0sXG4gICAgICAgICAgICAvLyBUaGFuIHdlIGNhbiBtYWtlIHN1cmUgdXNlciBvbmx5IHdhbnQgdGhvc2UgdHdvLCBhbmQgaWdub3JlXG4gICAgICAgICAgICAvLyBhbGwgb3JpZ2luIHBhcmFtcyBpbiB0YXJnZXRPcHRpb24uXG4gICAgICAgICAgICBlbHNlIGlmIChuZXdWYWx1ZUNvdW50ID49IGVub3VnaFBhcmFtTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld1BhcmFtcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIENob3NlIGFub3RoZXIgcGFyYW0gZnJvbSB0YXJnZXRPcHRpb24gYnkgcHJpb3JpdHkuXG4gICAgICAgICAgICAgICAgLy8gV2hlbiAnaWdub3JlU2l6ZScsIGVub3VnaFBhcmFtTnVtYmVyIGlzIDEgYW5kIHRob3NlIHdpbGwgbm90IGhhcHBlbi5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFzUHJvcChuZXdQYXJhbXMsIG5hbWUpICYmIGhhc1Byb3AodGFyZ2V0T3B0aW9uLCBuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UGFyYW1zW25hbWVdID0gdGFyZ2V0T3B0aW9uW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld1BhcmFtcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGhhc1Byb3Aob2JqLCBuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLmhhc093blByb3BlcnR5KG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaGFzVmFsdWUob2JqLCBuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqW25hbWVdICE9IG51bGwgJiYgb2JqW25hbWVdICE9PSAnYXV0byc7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb3B5KG5hbWVzLCB0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgICAgICAgZWFjaChuYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0gPSBzb3VyY2VbbmFtZV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSAnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJywgJ3dpZHRoJywgJ2hlaWdodCcgZnJvbSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gUmVzdWx0IGNvbnRhaW5zIHRob3NlIHByb3BzLlxuICAgICAqL1xuICAgIGxheW91dC5nZXRMYXlvdXRQYXJhbXMgPSBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIHJldHVybiBsYXlvdXQuY29weUxheW91dFBhcmFtcyh7fSwgc291cmNlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbScsICd3aWR0aCcsICdoZWlnaHQnIGZyb20gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFJlc3VsdCBjb250YWlucyB0aG9zZSBwcm9wcy5cbiAgICAgKi9cbiAgICBsYXlvdXQuY29weUxheW91dFBhcmFtcyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgICBzb3VyY2UgJiYgdGFyZ2V0ICYmIGVhY2goTE9DQVRJT05fUEFSQU1TLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgc291cmNlLmhhc093blByb3BlcnR5KG5hbWUpICYmICh0YXJnZXRbbmFtZV0gPSBzb3VyY2VbbmFtZV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGxheW91dDtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvZWNoYXJ0cy91dGlsL2xheW91dC5qc1xuICoqIG1vZHVsZSBpZCA9IDI1XG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCJkZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGdldEJveExheW91dFBhcmFtczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsZWZ0OiB0aGlzLmdldCgnbGVmdCcpLFxuICAgICAgICAgICAgICAgIHRvcDogdGhpcy5nZXQoJ3RvcCcpLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiB0aGlzLmdldCgncmlnaHQnKSxcbiAgICAgICAgICAgICAgICBib3R0b206IHRoaXMuZ2V0KCdib3R0b20nKSxcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5nZXQoJ3dpZHRoJyksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmdldCgnaGVpZ2h0JylcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC9lY2hhcnRzL21vZGVsL21peGluL2JveExheW91dC5qc1xuICoqIG1vZHVsZSBpZCA9IDI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCJkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwbGF0Zm9ybSA9ICcnO1xuICAgIC8vIE5hdmlnYXRvciBub3QgZXhpc3RzIGluIG5vZGVcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcGxhdGZvcm0gPSBuYXZpZ2F0b3IucGxhdGZvcm0gfHwgJyc7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIC8vIOWFqOWbvum7mOiupOiDjOaZr1xuICAgICAgICAvLyBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDApJyxcblxuICAgICAgICAvLyBodHRwczovL2RyaWJiYmxlLmNvbS9zaG90cy8xMDY1OTYwLUluZm9ncmFwaGljLVBpZS1jaGFydC12aXN1YWxpemF0aW9uXG4gICAgICAgIC8vIGNvbG9yOiBbJyM1NzkzZjMnLCAnI2QxNGE2MScsICcjZmQ5YzM1JywgJyM2NzViYmEnLCAnI2ZlYzQyYycsICcjZGQ0NDQ0JywgJyNkNGRmNWEnLCAnI2NkNDg3MCddLFxuICAgICAgICAvLyDmtYXoibJcbiAgICAgICAgLy8gY29sb3I6IFsnI2JjZDNiYicsICcjZTg4ZjcwJywgJyNlZGMxYTUnLCAnIzlkYzVjOCcsICcjZTFlOGM4JywgJyM3YjdjNjgnLCAnI2U1YjViNScsICcjZjBiNDg5JywgJyM5MjhlYTgnLCAnI2JkYTI5YSddLFxuICAgICAgICAvLyBjb2xvcjogWycjY2M1NjY0JywgJyM5YmQ2ZWMnLCAnI2VhOTQ2ZScsICcjOGFjYWFhJywgJyNmMWVjNjQnLCAnI2VlODY4NicsICcjYTQ4ZGMxJywgJyM1ZGE2YmMnLCAnI2I5ZGNhZSddLFxuICAgICAgICAvLyDmt7HoibJcbiAgICAgICAgY29sb3I6IFsnI2MyMzUzMScsJyMyZjQ1NTQnLCAnIzYxYTBhOCcsICcjZDQ4MjY1JywgJyM5MWM3YWUnLCcjNzQ5ZjgzJywgICcjY2E4NjIyJywgJyNiZGEyOWEnLCcjNmU3MDc0JywgJyM1NDY1NzAnLCAnI2M0Y2NkMyddLFxuXG4gICAgICAgIC8vIOm7mOiupOmcgOimgSBHcmlkIOmFjee9rumhuVxuICAgICAgICAvLyBncmlkOiB7fSxcbiAgICAgICAgLy8g5Li76aKY77yM5Li76aKYXG4gICAgICAgIHRleHRTdHlsZToge1xuICAgICAgICAgICAgLy8gY29sb3I6ICcjMDAwJyxcbiAgICAgICAgICAgIC8vIGRlY29yYXRpb246ICdub25lJyxcbiAgICAgICAgICAgIC8vIFBFTkRJTkdcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IHBsYXRmb3JtLm1hdGNoKC9eV2luLykgPyAnTWljcm9zb2Z0IFlhSGVpJyA6ICdzYW5zLXNlcmlmJyxcbiAgICAgICAgICAgIC8vIGZvbnRGYW1pbHk6ICdBcmlhbCwgVmVyZGFuYSwgc2Fucy1zZXJpZicsXG4gICAgICAgICAgICBmb250U2l6ZTogMTIsXG4gICAgICAgICAgICBmb250U3R5bGU6ICdub3JtYWwnLFxuICAgICAgICAgICAgZm9udFdlaWdodDogJ25vcm1hbCdcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBodHRwOi8vYmxvZ3MuYWRvYmUuY29tL3dlYnBsYXRmb3JtLzIwMTQvMDIvMjQvdXNpbmctYmxlbmQtbW9kZXMtaW4taHRtbC1jYW52YXMvXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXG4gICAgICAgIC8vIERlZmF1bHQgaXMgc291cmNlLW92ZXJcbiAgICAgICAgYmxlbmRNb2RlOiBudWxsLFxuXG4gICAgICAgIGFuaW1hdGlvbjogdHJ1ZSxcbiAgICAgICAgYW5pbWF0aW9uRHVyYXRpb246IDEwMDAsXG4gICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uVXBkYXRlOiAzMDAsXG4gICAgICAgIGFuaW1hdGlvbkVhc2luZzogJ2V4cG9uZW50aWFsT3V0JyxcbiAgICAgICAgYW5pbWF0aW9uRWFzaW5nVXBkYXRlOiAnY3ViaWNPdXQnLFxuXG4gICAgICAgIGFuaW1hdGlvblRocmVzaG9sZDogMjAwMCxcbiAgICAgICAgLy8gQ29uZmlndXJhdGlvbiBmb3IgcHJvZ3Jlc3NpdmUvaW5jcmVtZW50YWwgcmVuZGVyaW5nXG4gICAgICAgIHByb2dyZXNzaXZlVGhyZXNob2xkOiAzMDAwLFxuICAgICAgICBwcm9ncmVzc2l2ZTogNDAwLFxuXG4gICAgICAgIC8vIFRocmVzaG9sZCBvZiBpZiB1c2Ugc2luZ2xlIGhvdmVyIGxheWVyIHRvIG9wdGltaXplLlxuICAgICAgICBob3ZlckxheWVyVGhyZXNob2xkOiAzMDAwXG4gICAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvZWNoYXJ0cy9tb2RlbC9nbG9iYWxEZWZhdWx0LmpzXG4gKiogbW9kdWxlIGlkID0gMjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsImRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2xlYXJDb2xvclBhbGV0dGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbG9ySWR4ID0gMDtcbiAgICAgICAgICAgIHRoaXMuX2NvbG9yTmFtZU1hcCA9IHt9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldENvbG9yRnJvbVBhbGV0dGU6IGZ1bmN0aW9uIChuYW1lLCBzY29wZSkge1xuICAgICAgICAgICAgc2NvcGUgPSBzY29wZSB8fCB0aGlzO1xuICAgICAgICAgICAgdmFyIGNvbG9ySWR4ID0gc2NvcGUuX2NvbG9ySWR4IHx8IDA7XG4gICAgICAgICAgICB2YXIgY29sb3JOYW1lTWFwID0gc2NvcGUuX2NvbG9yTmFtZU1hcCB8fCAoc2NvcGUuX2NvbG9yTmFtZU1hcCA9IHt9KTtcbiAgICAgICAgICAgIGlmIChjb2xvck5hbWVNYXBbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sb3JOYW1lTWFwW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvbG9yUGFsZXR0ZSA9IHRoaXMuZ2V0KCdjb2xvcicsIHRydWUpIHx8IFtdO1xuICAgICAgICAgICAgaWYgKCFjb2xvclBhbGV0dGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY29sb3IgPSBjb2xvclBhbGV0dGVbY29sb3JJZHhdO1xuICAgICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBjb2xvck5hbWVNYXBbbmFtZV0gPSBjb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNjb3BlLl9jb2xvcklkeCA9IChjb2xvcklkeCArIDEpICUgY29sb3JQYWxldHRlLmxlbmd0aDtcblxuICAgICAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgICAgICB9XG4gICAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvZWNoYXJ0cy9tb2RlbC9taXhpbi9jb2xvclBhbGV0dGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyOFxuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2NvcmUvdXRpbCcpO1xuXG4gICAgdmFyIGVjaGFydHNBUElMaXN0ID0gW1xuICAgICAgICAnZ2V0RG9tJywgJ2dldFpyJywgJ2dldFdpZHRoJywgJ2dldEhlaWdodCcsICdkaXNwYXRjaEFjdGlvbicsICdpc0Rpc3Bvc2VkJyxcbiAgICAgICAgJ29uJywgJ29mZicsICdnZXREYXRhVVJMJywgJ2dldENvbm5lY3RlZERhdGFVUkwnLCAnZ2V0TW9kZWwnLCAnZ2V0T3B0aW9uJ1xuICAgIF07XG5cbiAgICBmdW5jdGlvbiBFeHRlbnNpb25BUEkoY2hhcnRJbnN0YW5jZSkge1xuICAgICAgICB6clV0aWwuZWFjaChlY2hhcnRzQVBJTGlzdCwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB6clV0aWwuYmluZChjaGFydEluc3RhbmNlW25hbWVdLCBjaGFydEluc3RhbmNlKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEV4dGVuc2lvbkFQSTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvZWNoYXJ0cy9FeHRlbnNpb25BUEkuanNcbiAqKiBtb2R1bGUgaWQgPSAyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBjb29yZGluYXRlU3lzdGVtQ3JlYXRvcnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIENvb3JkaW5hdGVTeXN0ZW1NYW5hZ2VyKCkge1xuXG4gICAgICAgIHRoaXMuX2Nvb3JkaW5hdGVTeXN0ZW1zID0gW107XG4gICAgfVxuXG4gICAgQ29vcmRpbmF0ZVN5c3RlbU1hbmFnZXIucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBDb29yZGluYXRlU3lzdGVtTWFuYWdlcixcblxuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgICAgIHZhciBjb29yZGluYXRlU3lzdGVtcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgdHlwZSBpbiBjb29yZGluYXRlU3lzdGVtQ3JlYXRvcnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGlzdCA9IGNvb3JkaW5hdGVTeXN0ZW1DcmVhdG9yc1t0eXBlXS5jcmVhdGUoZWNNb2RlbCwgYXBpKTtcbiAgICAgICAgICAgICAgICBsaXN0ICYmIChjb29yZGluYXRlU3lzdGVtcyA9IGNvb3JkaW5hdGVTeXN0ZW1zLmNvbmNhdChsaXN0KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2Nvb3JkaW5hdGVTeXN0ZW1zID0gY29vcmRpbmF0ZVN5c3RlbXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgICAgICB2YXIgY29vcmRpbmF0ZVN5c3RlbXMgPSB0aGlzLl9jb29yZGluYXRlU3lzdGVtcztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRpbmF0ZVN5c3RlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBNVVNUIGhhdmVcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlU3lzdGVtc1tpXS51cGRhdGUgJiYgY29vcmRpbmF0ZVN5c3RlbXNbaV0udXBkYXRlKGVjTW9kZWwsIGFwaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQ29vcmRpbmF0ZVN5c3RlbU1hbmFnZXIucmVnaXN0ZXIgPSBmdW5jdGlvbiAodHlwZSwgY29vcmRpbmF0ZVN5c3RlbUNyZWF0b3IpIHtcbiAgICAgICAgY29vcmRpbmF0ZVN5c3RlbUNyZWF0b3JzW3R5cGVdID0gY29vcmRpbmF0ZVN5c3RlbUNyZWF0b3I7XG4gICAgfTtcblxuICAgIENvb3JkaW5hdGVTeXN0ZW1NYW5hZ2VyLmdldCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHJldHVybiBjb29yZGluYXRlU3lzdGVtQ3JlYXRvcnNbdHlwZV07XG4gICAgfTtcblxuICAgIHJldHVybiBDb29yZGluYXRlU3lzdGVtTWFuYWdlcjtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvZWNoYXJ0cy9Db29yZGluYXRlU3lzdGVtLmpzXG4gKiogbW9kdWxlIGlkID0gMzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsIi8qKlxuICogRUNoYXJ0cyBvcHRpb24gbWFuYWdlclxuICpcbiAqIEBtb2R1bGUge2VjaGFydHMvbW9kZWwvT3B0aW9uTWFuYWdlcn1cbiAqL1xuXG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2NvcmUvdXRpbCcpO1xuICAgIHZhciBtb2RlbFV0aWwgPSByZXF1aXJlKCcuLi91dGlsL21vZGVsJyk7XG4gICAgdmFyIENvbXBvbmVudE1vZGVsID0gcmVxdWlyZSgnLi9Db21wb25lbnQnKTtcbiAgICB2YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xuICAgIHZhciBjbG9uZSA9IHpyVXRpbC5jbG9uZTtcbiAgICB2YXIgbWFwID0genJVdGlsLm1hcDtcbiAgICB2YXIgbWVyZ2UgPSB6clV0aWwubWVyZ2U7XG5cbiAgICB2YXIgUVVFUllfUkVHID0gL14obWlufG1heCk/KC4rKSQvO1xuXG4gICAgLyoqXG4gICAgICogVEVSTSBFWFBMQU5BVElPTlM6XG4gICAgICpcbiAgICAgKiBbb3B0aW9uXTpcbiAgICAgKlxuICAgICAqICAgICBBbiBvYmplY3QgdGhhdCBjb250YWlucyBkZWZpbml0aW9ucyBvZiBjb21wb25lbnRzLiBGb3IgZXhhbXBsZTpcbiAgICAgKiAgICAgdmFyIG9wdGlvbiA9IHtcbiAgICAgKiAgICAgICAgIHRpdGxlOiB7Li4ufSxcbiAgICAgKiAgICAgICAgIGxlZ2VuZDogey4uLn0sXG4gICAgICogICAgICAgICB2aXN1YWxNYXA6IHsuLi59LFxuICAgICAqICAgICAgICAgc2VyaWVzOiBbXG4gICAgICogICAgICAgICAgICAge2RhdGE6IFsuLi5dfSxcbiAgICAgKiAgICAgICAgICAgICB7ZGF0YTogWy4uLl19LFxuICAgICAqICAgICAgICAgICAgIC4uLlxuICAgICAqICAgICAgICAgXVxuICAgICAqICAgICB9O1xuICAgICAqXG4gICAgICogW3Jhd09wdGlvbl06XG4gICAgICpcbiAgICAgKiAgICAgQW4gb2JqZWN0IGlucHV0IHRvIGVjaGFydHMuc2V0T3B0aW9uLiAncmF3T3B0aW9uJyBtYXkgYmUgYW5cbiAgICAgKiAgICAgJ29wdGlvbicsIG9yIG1heSBiZSBhbiBvYmplY3QgY29udGFpbnMgbXVsdGktb3B0aW9ucy4gRm9yIGV4YW1wbGU6XG4gICAgICogICAgIHZhciBvcHRpb24gPSB7XG4gICAgICogICAgICAgICBiYXNlT3B0aW9uOiB7XG4gICAgICogICAgICAgICAgICAgdGl0bGU6IHsuLi59LFxuICAgICAqICAgICAgICAgICAgIGxlZ2VuZDogey4uLn0sXG4gICAgICogICAgICAgICAgICAgc2VyaWVzOiBbXG4gICAgICogICAgICAgICAgICAgICAgIHtkYXRhOiBbLi4uXX0sXG4gICAgICogICAgICAgICAgICAgICAgIHtkYXRhOiBbLi4uXX0sXG4gICAgICogICAgICAgICAgICAgICAgIC4uLlxuICAgICAqICAgICAgICAgICAgIF1cbiAgICAgKiAgICAgICAgIH0sXG4gICAgICogICAgICAgICB0aW1lbGluZTogey4uLn0sXG4gICAgICogICAgICAgICBvcHRpb25zOiBbXG4gICAgICogICAgICAgICAgICAge3RpdGxlOiB7Li4ufSwgc2VyaWVzOiB7ZGF0YTogWy4uLl19fSxcbiAgICAgKiAgICAgICAgICAgICB7dGl0bGU6IHsuLi59LCBzZXJpZXM6IHtkYXRhOiBbLi4uXX19LFxuICAgICAqICAgICAgICAgICAgIC4uLlxuICAgICAqICAgICAgICAgXSxcbiAgICAgKiAgICAgICAgIG1lZGlhOiBbXG4gICAgICogICAgICAgICAgICAge1xuICAgICAqICAgICAgICAgICAgICAgICBxdWVyeToge21heFdpZHRoOiAzMjB9LFxuICAgICAqICAgICAgICAgICAgICAgICBvcHRpb246IHtzZXJpZXM6IHt4OiAyMH0sIHZpc3VhbE1hcDoge3Nob3c6IGZhbHNlfX1cbiAgICAgKiAgICAgICAgICAgICB9LFxuICAgICAqICAgICAgICAgICAgIHtcbiAgICAgKiAgICAgICAgICAgICAgICAgcXVlcnk6IHttaW5XaWR0aDogMzIwLCBtYXhXaWR0aDogNzIwfSxcbiAgICAgKiAgICAgICAgICAgICAgICAgb3B0aW9uOiB7c2VyaWVzOiB7eDogNTAwfSwgdmlzdWFsTWFwOiB7c2hvdzogdHJ1ZX19XG4gICAgICogICAgICAgICAgICAgfSxcbiAgICAgKiAgICAgICAgICAgICB7XG4gICAgICogICAgICAgICAgICAgICAgIG9wdGlvbjoge3Nlcmllczoge3g6IDEyMDB9LCB2aXN1YWxNYXA6IHtzaG93OiB0cnVlfX1cbiAgICAgKiAgICAgICAgICAgICB9XG4gICAgICogICAgICAgICBdXG4gICAgICogICAgIH07XG4gICAgICpcbiAgICAgKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvbW9kZWwvT3B0aW9uTWFuYWdlclxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBPcHRpb25NYW5hZ2VyKGFwaSkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYXBpID0gYXBpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90aW1lbGluZU9wdGlvbnMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbWVkaWFMaXN0ID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9tZWRpYURlZmF1bHQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIC0xLCBtZWFucyBkZWZhdWx0LlxuICAgICAgICAgKiBlbXB0eSBtZWFucyBubyBtZWRpYS5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY3VycmVudE1lZGlhSW5kaWNlcyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fb3B0aW9uQmFja3VwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbmV3QmFzZU9wdGlvbjtcbiAgICB9XG5cbiAgICAvLyB0aW1lbGluZS5ub3RNZXJnZSBpcyBub3Qgc3VwcG9ydGVkIGluIGVjMy4gRmlyc3RseSB0aGVyZSBpcyByZWFybHlcbiAgICAvLyBjYXNlIHRoYXQgbm90TWVyZ2UgaXMgbmVlZGVkLiBTZWNvbmRseSBzdXBwb3J0aW5nICdub3RNZXJnZScgcmVxdWlyZXNcbiAgICAvLyByYXdPcHRpb24gY2xvbmVkIGFuZCBiYWNrdXBlZCB3aGVuIHRpbWVsaW5lIGNoYW5nZWQsIHdoaWNoIGRvZXMgbm9cbiAgICAvLyBnb29kIHRvIHBlcmZvcm1hbmNlLiBXaGF0J3MgbW9yZSwgdGhhdCBib3RoIHRpbWVsaW5lIGFuZCBzZXRPcHRpb25cbiAgICAvLyBtZXRob2Qgc3VwcGx5ICdub3RNZXJnZScgYnJpbmdzIGNvbXBsZXggYW5kIHNvbWUgcHJvYmxlbXMuXG4gICAgLy8gQ29uc2lkZXIgdGhpcyBjYXNlOlxuICAgIC8vIChzdGVwMSkgY2hhcnQuc2V0T3B0aW9uKHt0aW1lbGluZToge25vdE1lcmdlOiBmYWxzZX0sIC4uLn0sIGZhbHNlKTtcbiAgICAvLyAoc3RlcDIpIGNoYXJ0LnNldE9wdGlvbih7dGltZWxpbmU6IHtub3RNZXJnZTogdHJ1ZX0sIC4uLn0sIGZhbHNlKTtcblxuICAgIE9wdGlvbk1hbmFnZXIucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBPcHRpb25NYW5hZ2VyLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSByYXdPcHRpb24gUmF3IG9wdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48RnVuY3Rpb24+fSBvcHRpb25QcmVwcm9jZXNzb3JGdW5jc1xuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEluaXQgb3B0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBzZXRPcHRpb246IGZ1bmN0aW9uIChyYXdPcHRpb24sIG9wdGlvblByZXByb2Nlc3NvckZ1bmNzKSB7XG4gICAgICAgICAgICByYXdPcHRpb24gPSBjbG9uZShyYXdPcHRpb24sIHRydWUpO1xuXG4gICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgLy8g5aaC5p6cIHRpbWVsaW5lIG9wdGlvbnMg5oiW6ICFIG1lZGlhIOS4reiuvue9ruS6huafkOS4quWxnuaAp++8jOiAjGJhc2VPcHRpb27kuK3msqHmnInorr7nva7vvIzliJnov5vooYzorablkYrjgIJcblxuICAgICAgICAgICAgdmFyIG9sZE9wdGlvbkJhY2t1cCA9IHRoaXMuX29wdGlvbkJhY2t1cDtcbiAgICAgICAgICAgIHZhciBuZXdQYXJzZWRPcHRpb24gPSBwYXJzZVJhd09wdGlvbi5jYWxsKFxuICAgICAgICAgICAgICAgIHRoaXMsIHJhd09wdGlvbiwgb3B0aW9uUHJlcHJvY2Vzc29yRnVuY3MsICFvbGRPcHRpb25CYWNrdXBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLl9uZXdCYXNlT3B0aW9uID0gbmV3UGFyc2VkT3B0aW9uLmJhc2VPcHRpb247XG5cbiAgICAgICAgICAgIC8vIEZvciBzZXRPcHRpb24gYXQgc2Vjb25kIHRpbWUgKHVzaW5nIG1lcmdlIG1vZGUpO1xuICAgICAgICAgICAgaWYgKG9sZE9wdGlvbkJhY2t1cCkge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgYmFzZU9wdGlvbiBjYW4gYmUgbWVyZ2VkLlxuICAgICAgICAgICAgICAgIG1lcmdlT3B0aW9uKG9sZE9wdGlvbkJhY2t1cC5iYXNlT3B0aW9uLCBuZXdQYXJzZWRPcHRpb24uYmFzZU9wdGlvbik7XG5cbiAgICAgICAgICAgICAgICAvLyBGb3Igc2ltcGxpY2l0eSwgdGltZWxpbmUgb3B0aW9ucyBhbmQgbWVkaWEgb3B0aW9ucyBkbyBub3Qgc3VwcG9ydCBtZXJnZSxcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGlzLCBpZiB5b3UgYHNldE9wdGlvbmAgdHdpY2UgYW5kIGJvdGggaGFzIHRpbWVsaW5lIG9wdGlvbnMsIHRoZSBsYXR0ZXJcbiAgICAgICAgICAgICAgICAvLyB0aW1lbGluZSBvcGl0b25zIHdpbGwgbm90IGJlIG1lcmdlZCB0byB0aGUgZm9ybWVycywgYnV0IGp1c3Qgc3Vic3RpdHVkZSB0aGVtLlxuICAgICAgICAgICAgICAgIGlmIChuZXdQYXJzZWRPcHRpb24udGltZWxpbmVPcHRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBvbGRPcHRpb25CYWNrdXAudGltZWxpbmVPcHRpb25zID0gbmV3UGFyc2VkT3B0aW9uLnRpbWVsaW5lT3B0aW9ucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5ld1BhcnNlZE9wdGlvbi5tZWRpYUxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZE9wdGlvbkJhY2t1cC5tZWRpYUxpc3QgPSBuZXdQYXJzZWRPcHRpb24ubWVkaWFMaXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV3UGFyc2VkT3B0aW9uLm1lZGlhRGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICBvbGRPcHRpb25CYWNrdXAubWVkaWFEZWZhdWx0ID0gbmV3UGFyc2VkT3B0aW9uLm1lZGlhRGVmYXVsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25CYWNrdXAgPSBuZXdQYXJzZWRPcHRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNSZWNyZWF0ZVxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBtb3VudE9wdGlvbjogZnVuY3Rpb24gKGlzUmVjcmVhdGUpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25CYWNrdXAgPSB0aGlzLl9vcHRpb25CYWNrdXA7XG5cbiAgICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgICAgIC8vIOWmguaenOayoeaciXJlc2V05Yqf6IO95YiZ5LiNY2xvbmXjgIJcblxuICAgICAgICAgICAgdGhpcy5fdGltZWxpbmVPcHRpb25zID0gbWFwKG9wdGlvbkJhY2t1cC50aW1lbGluZU9wdGlvbnMsIGNsb25lKTtcbiAgICAgICAgICAgIHRoaXMuX21lZGlhTGlzdCA9IG1hcChvcHRpb25CYWNrdXAubWVkaWFMaXN0LCBjbG9uZSk7XG4gICAgICAgICAgICB0aGlzLl9tZWRpYURlZmF1bHQgPSBjbG9uZShvcHRpb25CYWNrdXAubWVkaWFEZWZhdWx0KTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRNZWRpYUluZGljZXMgPSBbXTtcblxuICAgICAgICAgICAgcmV0dXJuIGNsb25lKGlzUmVjcmVhdGVcbiAgICAgICAgICAgICAgICAvLyB0aGlzLl9vcHRpb25CYWNrdXAuYmFzZU9wdGlvbiwgd2hpY2ggaXMgY3JlYXRlZCBhdCB0aGUgZmlyc3QgYHNldE9wdGlvbmBcbiAgICAgICAgICAgICAgICAvLyBjYWxsZWQsIGFuZCBpcyBtZXJnZWQgaW50byBldmVyeSBuZXcgb3B0aW9uIGJ5IGlubmVyIG1ldGhvZCBgbWVyZ2VPcHRpb25gXG4gICAgICAgICAgICAgICAgLy8gZWFjaCB0aW1lIGBzZXRPcHRpb25gIGNhbGxlZCwgY2FuIGJlIG9ubHkgdXNlZCBpbiBgaXNSZWNyZWF0ZWAsIGJlY2F1c2VcbiAgICAgICAgICAgICAgICAvLyBpdHMgcmVsaWFiaWxpdHkgaXMgdW5kZXIgc3VzcGljaW9uLiBJbiBvdGhlciBjYXNlcyBvcHRpb24gbWVyZ2UgaXNcbiAgICAgICAgICAgICAgICAvLyBwcm9mb3JtZWQgYnkgYG1vZGVsLm1lcmdlT3B0aW9uYC5cbiAgICAgICAgICAgICAgICA/IG9wdGlvbkJhY2t1cC5iYXNlT3B0aW9uIDogdGhpcy5fbmV3QmFzZU9wdGlvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VGltZWxpbmVPcHRpb246IGZ1bmN0aW9uIChlY01vZGVsKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uO1xuICAgICAgICAgICAgdmFyIHRpbWVsaW5lT3B0aW9ucyA9IHRoaXMuX3RpbWVsaW5lT3B0aW9ucztcblxuICAgICAgICAgICAgaWYgKHRpbWVsaW5lT3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBnZXRUaW1lbGluZU9wdGlvbiBjYW4gb25seSBiZSBjYWxsZWQgYWZ0ZXIgZWNNb2RlbCBpbml0ZWQsXG4gICAgICAgICAgICAgICAgLy8gc28gd2UgY2FuIGdldCBjdXJyZW50SW5kZXggZnJvbSB0aW1lbGluZU1vZGVsLlxuICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZU1vZGVsID0gZWNNb2RlbC5nZXRDb21wb25lbnQoJ3RpbWVsaW5lJyk7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVsaW5lTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uID0gY2xvbmUoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lbGluZU9wdGlvbnNbdGltZWxpbmVNb2RlbC5nZXRDdXJyZW50SW5kZXgoKV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48T2JqZWN0Pn1cbiAgICAgICAgICovXG4gICAgICAgIGdldE1lZGlhT3B0aW9uOiBmdW5jdGlvbiAoZWNNb2RlbCkge1xuICAgICAgICAgICAgdmFyIGVjV2lkdGggPSB0aGlzLl9hcGkuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIHZhciBlY0hlaWdodCA9IHRoaXMuX2FwaS5nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIHZhciBtZWRpYUxpc3QgPSB0aGlzLl9tZWRpYUxpc3Q7XG4gICAgICAgICAgICB2YXIgbWVkaWFEZWZhdWx0ID0gdGhpcy5fbWVkaWFEZWZhdWx0O1xuICAgICAgICAgICAgdmFyIGluZGljZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICAgICAgLy8gTm8gbWVkaWEgZGVmaW5lZC5cbiAgICAgICAgICAgIGlmICghbWVkaWFMaXN0Lmxlbmd0aCAmJiAhbWVkaWFEZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTXVsdGkgbWVkaWEgbWF5IGJlIGFwcGxpZWQsIHRoZSBsYXR0ZXIgZGVmaW5lZCBtZWRpYSBoYXMgaGlnaGVyIHByaW9yaXR5LlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG1lZGlhTGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChhcHBseU1lZGlhUXVlcnkobWVkaWFMaXN0W2ldLnF1ZXJ5LCBlY1dpZHRoLCBlY0hlaWdodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgIC8vIOaYr+WQpm1lZGlhRGVmYXVsdOW6lOivpeW8uuWItueUqOaIt+iuvue9ru+8jOWQpuWImeWPr+iDveS/ruaUueS4jeiDveWbnuW9kuOAglxuICAgICAgICAgICAgaWYgKCFpbmRpY2VzLmxlbmd0aCAmJiBtZWRpYURlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICBpbmRpY2VzID0gWy0xXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGluZGljZXMubGVuZ3RoICYmICFpbmRpY2VzRXF1YWxzKGluZGljZXMsIHRoaXMuX2N1cnJlbnRNZWRpYUluZGljZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbWFwKGluZGljZXMsIGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmUoXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9PT0gLTEgPyBtZWRpYURlZmF1bHQub3B0aW9uIDogbWVkaWFMaXN0W2luZGV4XS5vcHRpb25cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSByZXR1cm4gbm90aGluZy5cblxuICAgICAgICAgICAgdGhpcy5fY3VycmVudE1lZGlhSW5kaWNlcyA9IGluZGljZXM7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcGFyc2VSYXdPcHRpb24ocmF3T3B0aW9uLCBvcHRpb25QcmVwcm9jZXNzb3JGdW5jcywgaXNOZXcpIHtcbiAgICAgICAgdmFyIHRpbWVsaW5lT3B0aW9ucyA9IFtdO1xuICAgICAgICB2YXIgbWVkaWFMaXN0ID0gW107XG4gICAgICAgIHZhciBtZWRpYURlZmF1bHQ7XG4gICAgICAgIHZhciBiYXNlT3B0aW9uO1xuXG4gICAgICAgIC8vIENvbXBhdGlibGUgd2l0aCBlYzIuXG4gICAgICAgIHZhciB0aW1lbGluZU9wdCA9IHJhd09wdGlvbi50aW1lbGluZTtcblxuICAgICAgICBpZiAocmF3T3B0aW9uLmJhc2VPcHRpb24pIHtcbiAgICAgICAgICAgIGJhc2VPcHRpb24gPSByYXdPcHRpb24uYmFzZU9wdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZvciB0aW1lbGluZVxuICAgICAgICBpZiAodGltZWxpbmVPcHQgfHwgcmF3T3B0aW9uLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIGJhc2VPcHRpb24gPSBiYXNlT3B0aW9uIHx8IHt9O1xuICAgICAgICAgICAgdGltZWxpbmVPcHRpb25zID0gKHJhd09wdGlvbi5vcHRpb25zIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9yIG1lZGlhIHF1ZXJ5XG4gICAgICAgIGlmIChyYXdPcHRpb24ubWVkaWEpIHtcbiAgICAgICAgICAgIGJhc2VPcHRpb24gPSBiYXNlT3B0aW9uIHx8IHt9O1xuICAgICAgICAgICAgdmFyIG1lZGlhID0gcmF3T3B0aW9uLm1lZGlhO1xuICAgICAgICAgICAgZWFjaChtZWRpYSwgZnVuY3Rpb24gKHNpbmdsZU1lZGlhKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNpbmdsZU1lZGlhICYmIHNpbmdsZU1lZGlhLm9wdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2luZ2xlTWVkaWEucXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lZGlhTGlzdC5wdXNoKHNpbmdsZU1lZGlhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghbWVkaWFEZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGZpcnN0IG1lZGlhIGRlZmF1bHQuXG4gICAgICAgICAgICAgICAgICAgICAgICBtZWRpYURlZmF1bHQgPSBzaW5nbGVNZWRpYTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9yIG5vcm1hbCBvcHRpb25cbiAgICAgICAgaWYgKCFiYXNlT3B0aW9uKSB7XG4gICAgICAgICAgICBiYXNlT3B0aW9uID0gcmF3T3B0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IHRpbWVsaW5lT3B0IHRvIGJhc2VPcHRpb24gaW4gZWMzLFxuICAgICAgICAvLyB3aGljaCBpcyBjb252ZW5pZW50IGZvciBtZXJnZSBvcHRpb24uXG4gICAgICAgIGlmICghYmFzZU9wdGlvbi50aW1lbGluZSkge1xuICAgICAgICAgICAgYmFzZU9wdGlvbi50aW1lbGluZSA9IHRpbWVsaW5lT3B0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHJlcHJvY2Vzcy5cbiAgICAgICAgZWFjaChbYmFzZU9wdGlvbl0uY29uY2F0KHRpbWVsaW5lT3B0aW9ucylcbiAgICAgICAgICAgIC5jb25jYXQoenJVdGlsLm1hcChtZWRpYUxpc3QsIGZ1bmN0aW9uIChtZWRpYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZWRpYS5vcHRpb247XG4gICAgICAgICAgICB9KSksXG4gICAgICAgICAgICBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgZWFjaChvcHRpb25QcmVwcm9jZXNzb3JGdW5jcywgZnVuY3Rpb24gKHByZVByb2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlUHJvY2VzcyhvcHRpb24sIGlzTmV3KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmFzZU9wdGlvbjogYmFzZU9wdGlvbixcbiAgICAgICAgICAgIHRpbWVsaW5lT3B0aW9uczogdGltZWxpbmVPcHRpb25zLFxuICAgICAgICAgICAgbWVkaWFEZWZhdWx0OiBtZWRpYURlZmF1bHQsXG4gICAgICAgICAgICBtZWRpYUxpc3Q6IG1lZGlhTGlzdFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzZWUgPGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtbWVkaWFxdWVyaWVzLyNtZWRpYTE+XG4gICAgICogU3VwcG9ydDogd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW9cbiAgICAgKiBDYW4gdXNlIG1heCBvciBtaW4gYXMgcHJlZml4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFwcGx5TWVkaWFRdWVyeShxdWVyeSwgZWNXaWR0aCwgZWNIZWlnaHQpIHtcbiAgICAgICAgdmFyIHJlYWxNYXAgPSB7XG4gICAgICAgICAgICB3aWR0aDogZWNXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogZWNIZWlnaHQsXG4gICAgICAgICAgICBhc3BlY3RyYXRpbzogZWNXaWR0aCAvIGVjSGVpZ2h0IC8vIGxvd3NlciBjYXNlIGZvciBjb252ZW5pZW50Y2UuXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGFwcGxpY2F0YWJsZSA9IHRydWU7XG5cbiAgICAgICAgenJVdGlsLmVhY2gocXVlcnksIGZ1bmN0aW9uICh2YWx1ZSwgYXR0cikge1xuICAgICAgICAgICAgdmFyIG1hdGNoZWQgPSBhdHRyLm1hdGNoKFFVRVJZX1JFRyk7XG5cbiAgICAgICAgICAgIGlmICghbWF0Y2hlZCB8fCAhbWF0Y2hlZFsxXSB8fCAhbWF0Y2hlZFsyXSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gbWF0Y2hlZFsxXTtcbiAgICAgICAgICAgIHZhciByZWFsQXR0ciA9IG1hdGNoZWRbMl0udG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgaWYgKCFjb21wYXJlKHJlYWxNYXBbcmVhbEF0dHJdLCB2YWx1ZSwgb3BlcmF0b3IpKSB7XG4gICAgICAgICAgICAgICAgYXBwbGljYXRhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBhcHBsaWNhdGFibGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcGFyZShyZWFsLCBleHBlY3QsIG9wZXJhdG9yKSB7XG4gICAgICAgIGlmIChvcGVyYXRvciA9PT0gJ21pbicpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFsID49IGV4cGVjdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVyYXRvciA9PT0gJ21heCcpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFsIDw9IGV4cGVjdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gRXF1YWxzXG4gICAgICAgICAgICByZXR1cm4gcmVhbCA9PT0gZXhwZWN0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5kaWNlc0VxdWFscyhpbmRpY2VzMSwgaW5kaWNlczIpIHtcbiAgICAgICAgLy8gaW5kaWNlcyBpcyBhbHdheXMgb3JkZXIgYnkgYXNjIGFuZCBoYXMgb25seSBmaW5pdGUgbnVtYmVyLlxuICAgICAgICByZXR1cm4gaW5kaWNlczEuam9pbignLCcpID09PSBpbmRpY2VzMi5qb2luKCcsJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uc2lkZXIgY2FzZTpcbiAgICAgKiBgY2hhcnQuc2V0T3B0aW9uKG9wdDEpO2BcbiAgICAgKiBUaGVuIHVzZXIgZG8gc29tZSBpbnRlcmFjdGlvbiBsaWtlIGRhdGFab29tLCBkYXRhVmlldyBjaGFuZ2luZy5cbiAgICAgKiBgY2hhcnQuc2V0T3B0aW9uKG9wdDIpO2BcbiAgICAgKiBUaGVuIHVzZXIgcHJlc3MgJ3Jlc2V0IGJ1dHRvbicgaW4gdG9vbGJveC5cbiAgICAgKlxuICAgICAqIEFmdGVyIGRvaW5nIHRoYXQgYWxsIG9mIHRoZSBpbnRlcmFjdGlvbiBlZmZlY3RzIHNob3VsZCBiZSByZXNldCwgdGhlXG4gICAgICogY2hhcnQgc2hvdWxkIGJlIHRoZSBzYW1lIGFzIHRoZSByZXN1bHQgb2YgaW52b2tlXG4gICAgICogYGNoYXJ0LnNldE9wdGlvbihvcHQxKTsgY2hhcnQuc2V0T3B0aW9uKG9wdDIpO2AuXG4gICAgICpcbiAgICAgKiBBbHRob3VnaCBpdCBpcyBub3QgYWJsZSBlbnN1cmUgdGhhdFxuICAgICAqIGBjaGFydC5zZXRPcHRpb24ob3B0MSk7IGNoYXJ0LnNldE9wdGlvbihvcHQyKTtgIGlzIGVxdWl2YWxlbnRzIHRvXG4gICAgICogYGNoYXJ0LnNldE9wdGlvbihtZXJnZShvcHQxLCBvcHQyKSk7YCBleGFjdGx5LFxuICAgICAqIHRoaXMgbWlnaHQgYmUgdGhlIG9ubHkgc2ltcGxlIHdheSB0byBpbXBsZW1lbnQgdGhhdCBmZWF0dXJlLlxuICAgICAqXG4gICAgICogTUVNTzogV2UndmUgY29uc2lkZXJlZCBzb21lIG90aGVyIGFwcHJvYWNoZXM6XG4gICAgICogMS4gRWFjaCBtb2RlbCBoYW5kbGUgaXRzIHNlbGYgcmVzdG9yYXRpb24gYnV0IG5vdCB1bmlmb3JtIHRyZWF0bWVudC5cbiAgICAgKiAgICAgKFRvbyBjb21wbGV4IGluIGxvZ2ljIGFuZCBlcnJvci1wcm9uZSlcbiAgICAgKiAyLiBVc2UgYSBzaGFkb3cgZWNNb2RlbC4gKFBlcmZvcm1hY2UgZXhwZW5zaXZlKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlT3B0aW9uKG9sZE9wdGlvbiwgbmV3T3B0aW9uKSB7XG4gICAgICAgIG5ld09wdGlvbiA9IG5ld09wdGlvbiB8fCB7fTtcblxuICAgICAgICBlYWNoKG5ld09wdGlvbiwgZnVuY3Rpb24gKG5ld0NwdE9wdCwgbWFpblR5cGUpIHtcbiAgICAgICAgICAgIGlmIChuZXdDcHRPcHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9sZENwdE9wdCA9IG9sZE9wdGlvblttYWluVHlwZV07XG5cbiAgICAgICAgICAgIGlmICghQ29tcG9uZW50TW9kZWwuaGFzQ2xhc3MobWFpblR5cGUpKSB7XG4gICAgICAgICAgICAgICAgb2xkT3B0aW9uW21haW5UeXBlXSA9IG1lcmdlKG9sZENwdE9wdCwgbmV3Q3B0T3B0LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld0NwdE9wdCA9IG1vZGVsVXRpbC5ub3JtYWxpemVUb0FycmF5KG5ld0NwdE9wdCk7XG4gICAgICAgICAgICAgICAgb2xkQ3B0T3B0ID0gbW9kZWxVdGlsLm5vcm1hbGl6ZVRvQXJyYXkob2xkQ3B0T3B0KTtcblxuICAgICAgICAgICAgICAgIHZhciBtYXBSZXN1bHQgPSBtb2RlbFV0aWwubWFwcGluZ1RvRXhpc3RzKG9sZENwdE9wdCwgbmV3Q3B0T3B0KTtcblxuICAgICAgICAgICAgICAgIG9sZE9wdGlvblttYWluVHlwZV0gPSBtYXAobWFwUmVzdWx0LCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGl0ZW0ub3B0aW9uICYmIGl0ZW0uZXhpc3QpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG1lcmdlKGl0ZW0uZXhpc3QsIGl0ZW0ub3B0aW9uLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAoaXRlbS5leGlzdCB8fCBpdGVtLm9wdGlvbik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBPcHRpb25NYW5hZ2VyO1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC9lY2hhcnRzL21vZGVsL09wdGlvbk1hbmFnZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2NvcmUvdXRpbCcpO1xuICAgIHZhciBmb3JtYXRVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9mb3JtYXQnKTtcbiAgICB2YXIgbW9kZWxVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9tb2RlbCcpO1xuICAgIHZhciBDb21wb25lbnRNb2RlbCA9IHJlcXVpcmUoJy4vQ29tcG9uZW50Jyk7XG4gICAgdmFyIGNvbG9yUGFsZXR0ZU1peGluID0gcmVxdWlyZSgnLi9taXhpbi9jb2xvclBhbGV0dGUnKTtcbiAgICB2YXIgZW52ID0gcmVxdWlyZSgnenJlbmRlci9jb3JlL2VudicpO1xuXG4gICAgdmFyIGVuY29kZUhUTUwgPSBmb3JtYXRVdGlsLmVuY29kZUhUTUw7XG4gICAgdmFyIGFkZENvbW1hcyA9IGZvcm1hdFV0aWwuYWRkQ29tbWFzO1xuXG4gICAgdmFyIFNlcmllc01vZGVsID0gQ29tcG9uZW50TW9kZWwuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnc2VyaWVzLl9fYmFzZV9fJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICBzZXJpZXNJbmRleDogMCxcblxuICAgICAgICAvLyBjb29kaW5hdGVTeXN0ZW0gd2lsbCBiZSBpbmplY3RlZCBpbiB0aGUgZWNoYXJ0cy9Db29yZGluYXRlU3lzdGVtXG4gICAgICAgIGNvb3JkaW5hdGVTeXN0ZW06IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGRlZmF1bHRPcHRpb246IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERhdGEgcHJvdmlkZWQgZm9yIGxlZ2VuZFxuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICAvLyBQRU5ESU5HXG4gICAgICAgIGxlZ2VuZERhdGFQcm92aWRlcjogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWNjZXNzIHBhdGggb2YgY29sb3IgZm9yIHZpc3VhbFxuICAgICAgICAgKi9cbiAgICAgICAgdmlzdWFsQ29sb3JBY2Nlc3NQYXRoOiAnaXRlbVN0eWxlLm5vcm1hbC5jb2xvcicsXG5cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKG9wdGlvbiwgcGFyZW50TW9kZWwsIGVjTW9kZWwsIGV4dHJhT3B0KSB7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnNlcmllc0luZGV4ID0gdGhpcy5jb21wb25lbnRJbmRleDtcblxuICAgICAgICAgICAgdGhpcy5tZXJnZURlZmF1bHRBbmRUaGVtZShvcHRpb24sIGVjTW9kZWwpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R8bW9kdWxlOmVjaGFydHMvZGF0YS9UcmVlfG1vZHVsZTplY2hhcnRzL2RhdGEvR3JhcGh9XG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9kYXRhQmVmb3JlUHJvY2Vzc2VkID0gdGhpcy5nZXRJbml0aWFsRGF0YShvcHRpb24sIGVjTW9kZWwpO1xuXG4gICAgICAgICAgICAvLyBJZiB3ZSByZXZlcnNlIHRoZSBvcmRlciAobWFrZSB0aGlzLl9kYXRhIGZpcnN0bHksIGFuZCB0aGVuIG1ha2VcbiAgICAgICAgICAgIC8vIHRoaXMuX2RhdGFCZWZvcmVQcm9jZXNzZWQgYnkgY2xvbmVTaGFsbG93KSwgY2xvbmVTaGFsbG93IHdpbGxcbiAgICAgICAgICAgIC8vIGNhdXNlIHRoaXMuX2RhdGEuZ3JhcGguZGF0YSAhPT0gdGhpcy5fZGF0YSB3aGVuIHVzaW5nXG4gICAgICAgICAgICAvLyBtb2R1bGU6ZWNoYXJ0cy9kYXRhL0dyYXBoIG9yIG1vZHVsZTplY2hhcnRzL2RhdGEvVHJlZS5cbiAgICAgICAgICAgIC8vIFNlZSBtb2R1bGU6ZWNoYXJ0cy9kYXRhL2hlbHBlci9saW5rTGlzdFxuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IHRoaXMuX2RhdGFCZWZvcmVQcm9jZXNzZWQuY2xvbmVTaGFsbG93KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFV0aWwgZm9yIG1lcmdlIGRlZmF1bHQgYW5kIHRoZW1lIHRvIG9wdGlvblxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvblxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICAgICAgICovXG4gICAgICAgIG1lcmdlRGVmYXVsdEFuZFRoZW1lOiBmdW5jdGlvbiAob3B0aW9uLCBlY01vZGVsKSB7XG4gICAgICAgICAgICB6clV0aWwubWVyZ2UoXG4gICAgICAgICAgICAgICAgb3B0aW9uLFxuICAgICAgICAgICAgICAgIGVjTW9kZWwuZ2V0VGhlbWUoKS5nZXQodGhpcy5zdWJUeXBlKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHpyVXRpbC5tZXJnZShvcHRpb24sIHRoaXMuZ2V0RGVmYXVsdE9wdGlvbigpKTtcblxuICAgICAgICAgICAgLy8gRGVmYXVsdCBsYWJlbCBlbXBoYXNpcyBgcG9zaXRpb25gIGFuZCBgc2hvd2BcbiAgICAgICAgICAgIC8vIEZJWE1FIFNldCBsYWJlbCBpbiBtZXJnZU9wdGlvblxuICAgICAgICAgICAgbW9kZWxVdGlsLmRlZmF1bHRFbXBoYXNpcyhvcHRpb24ubGFiZWwsIG1vZGVsVXRpbC5MQUJFTF9PUFRJT05TKTtcblxuICAgICAgICAgICAgdGhpcy5maWxsRGF0YVRleHRTdHlsZShvcHRpb24uZGF0YSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWVyZ2VPcHRpb246IGZ1bmN0aW9uIChuZXdTZXJpZXNPcHRpb24sIGVjTW9kZWwpIHtcbiAgICAgICAgICAgIG5ld1Nlcmllc09wdGlvbiA9IHpyVXRpbC5tZXJnZSh0aGlzLm9wdGlvbiwgbmV3U2VyaWVzT3B0aW9uLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuZmlsbERhdGFUZXh0U3R5bGUobmV3U2VyaWVzT3B0aW9uLmRhdGEpO1xuXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0SW5pdGlhbERhdGEobmV3U2VyaWVzT3B0aW9uLCBlY01vZGVsKTtcbiAgICAgICAgICAgIC8vIFRPRE8gTWVyZ2UgZGF0YT9cbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGF0YUJlZm9yZVByb2Nlc3NlZCA9IGRhdGEuY2xvbmVTaGFsbG93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmlsbERhdGFUZXh0U3R5bGU6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAvLyBEZWZhdWx0IGRhdGEgbGFiZWwgZW1waGFzaXMgYHBvc2l0aW9uYCBhbmQgYHNob3dgXG4gICAgICAgICAgICAvLyBGSVhNRSBUcmVlIHN0cnVjdHVyZSBkYXRhID9cbiAgICAgICAgICAgIC8vIEZJWE1FIFBlcmZvcm1hbmNlID9cbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW2ldICYmIGRhdGFbaV0ubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsVXRpbC5kZWZhdWx0RW1waGFzaXMoZGF0YVtpXS5sYWJlbCwgbW9kZWxVdGlsLkxBQkVMX09QVElPTlMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0IGEgZGF0YSBzdHJ1Y3R1cmUgZnJvbSBkYXRhIHJlbGF0ZWQgb3B0aW9uIGluIHNlcmllc1xuICAgICAgICAgKiBNdXN0IGJlIG92ZXJ3cml0dGVuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRJbml0aWFsRGF0YTogZnVuY3Rpb24gKCkge30sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZGF0YVR5cGVdXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH1cbiAgICAgICAgICovXG4gICAgICAgIGdldERhdGE6IGZ1bmN0aW9uIChkYXRhVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFUeXBlID09IG51bGwgPyB0aGlzLl9kYXRhIDogdGhpcy5fZGF0YS5nZXRMaW5rZWREYXRhKGRhdGFUeXBlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9IGRhdGFcbiAgICAgICAgICovXG4gICAgICAgIHNldERhdGE6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGRhdGEgYmVmb3JlIHByb2Nlc3NlZFxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRSYXdEYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YUJlZm9yZVByb2Nlc3NlZDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29vcmQgZGltZW5zaW9uIHRvIGRhdGEgZGltZW5zaW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBCeSBkZWZhdWx0IHRoZSByZXN1bHQgaXMgdGhlIHNhbWUgYXMgZGltZW5zaW9ucyBvZiBzZXJpZXMgZGF0YS5cbiAgICAgICAgICogQnV0IGluIHNvbWUgc2VyaWVzIGRhdGEgZGltZW5zaW9ucyBhcmUgZGlmZmVyZW50IGZyb20gY29vcmQgZGltZW5zaW9ucyAoaS5lLlxuICAgICAgICAgKiBjYW5kbGVzdGljayBhbmQgYm94cGxvdCkuIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGhhbmRsZSB0aG9zZSBjYXNlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQ29vcmQgZGltZW5zaW9uIHRvIGRhdGEgZGltZW5zaW9uIGNhbiBiZSBvbmUtdG8tbWFueVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29vcmREaW1cbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IGRpbWVuc2lvbnMgb24gdGhlIGF4aXMuXG4gICAgICAgICAqL1xuICAgICAgICBjb29yZERpbVRvRGF0YURpbTogZnVuY3Rpb24gKGNvb3JkRGltKSB7XG4gICAgICAgICAgICByZXR1cm4gW2Nvb3JkRGltXTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydCBkYXRhIGRpbWVuc2lvbiB0byBjb29yZCBkaW1lbnNpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gZGF0YURpbVxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBkYXRhRGltVG9Db29yZERpbTogZnVuY3Rpb24gKGRhdGFEaW0pIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhRGltO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYmFzZSBheGlzIGlmIGhhcyBjb29yZGluYXRlIHN5c3RlbSBhbmQgaGFzIGF4aXMuXG4gICAgICAgICAqIEJ5IGRlZmF1bHQgdXNlIGNvb3JkU3lzLmdldEJhc2VBeGlzKCk7XG4gICAgICAgICAqIENhbiBiZSBvdmVycmlkZWQgZm9yIHNvbWUgY2hhcnQuXG4gICAgICAgICAqIEByZXR1cm4ge3R5cGV9IGRlc2NyaXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBnZXRCYXNlQXhpczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvb3JkU3lzID0gdGhpcy5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICAgICAgcmV0dXJuIGNvb3JkU3lzICYmIGNvb3JkU3lzLmdldEJhc2VBeGlzICYmIGNvb3JkU3lzLmdldEJhc2VBeGlzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRklYTUVcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmF1bHQgdG9vbHRpcCBmb3JtYXR0ZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGRhdGFJbmRleFxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFttdWx0aXBsZVNlcmllcz1mYWxzZV1cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtkYXRhVHlwZV1cbiAgICAgICAgICovXG4gICAgICAgIGZvcm1hdFRvb2x0aXA6IGZ1bmN0aW9uIChkYXRhSW5kZXgsIG11bHRpcGxlU2VyaWVzLCBkYXRhVHlwZSkge1xuICAgICAgICAgICAgZnVuY3Rpb24gZm9ybWF0QXJyYXlWYWx1ZSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB6clV0aWwubWFwKHZhbHVlLCBmdW5jdGlvbiAodmFsLCBpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpbUluZm8gPSBkYXRhLmdldERpbWVuc2lvbkluZm8oaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpbVR5cGUgPSBkaW1JbmZvICYmIGRpbUluZm8udHlwZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpbVR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkaW1UeXBlID09PSAndGltZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtdWx0aXBsZVNlcmllcyA/ICcnIDogZm9ybWF0VXRpbC5mb3JtYXRUaW1lKCd5eXl5L21tL2RkIGhoOm1tOnNzJywgdmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRDb21tYXModmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIXZhbDtcbiAgICAgICAgICAgICAgICB9KS5qb2luKCcsICcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0UmF3VmFsdWUoZGF0YUluZGV4KTtcbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZWRWYWx1ZSA9IHpyVXRpbC5pc0FycmF5KHZhbHVlKVxuICAgICAgICAgICAgICAgID8gZm9ybWF0QXJyYXlWYWx1ZSh2YWx1ZSkgOiBhZGRDb21tYXModmFsdWUpO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBkYXRhLmdldE5hbWUoZGF0YUluZGV4KTtcbiAgICAgICAgICAgIHZhciBjb2xvciA9IGRhdGEuZ2V0SXRlbVZpc3VhbChkYXRhSW5kZXgsICdjb2xvcicpO1xuICAgICAgICAgICAgdmFyIGNvbG9yRWwgPSAnPHNwYW4gc3R5bGU9XCJkaXNwbGF5OmlubGluZS1ibG9jazttYXJnaW4tcmlnaHQ6NXB4OydcbiAgICAgICAgICAgICAgICArICdib3JkZXItcmFkaXVzOjEwcHg7d2lkdGg6OXB4O2hlaWdodDo5cHg7YmFja2dyb3VuZC1jb2xvcjonICsgY29sb3IgKyAnXCI+PC9zcGFuPic7XG5cbiAgICAgICAgICAgIHZhciBzZXJpZXNOYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgIGlmIChzZXJpZXNOYW1lID09PSAnXFwwLScpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3Qgc2hvdyAnLSdcbiAgICAgICAgICAgICAgICBzZXJpZXNOYW1lID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gIW11bHRpcGxlU2VyaWVzXG4gICAgICAgICAgICAgICAgPyAoKHNlcmllc05hbWUgJiYgZW5jb2RlSFRNTChzZXJpZXNOYW1lKSArICc8YnIgLz4nKSArIGNvbG9yRWxcbiAgICAgICAgICAgICAgICAgICAgKyAobmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBlbmNvZGVIVE1MKG5hbWUpICsgJyA6ICcgKyBmb3JtYXR0ZWRWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBmb3JtYXR0ZWRWYWx1ZSlcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IChjb2xvckVsICsgZW5jb2RlSFRNTCh0aGlzLm5hbWUpICsgJyA6ICcgKyBmb3JtYXR0ZWRWYWx1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBpZkVuYWJsZUFuaW1hdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGVudi5ub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uRW5hYmxlZCA9IHRoaXMuZ2V0U2hhbGxvdygnYW5pbWF0aW9uJyk7XG4gICAgICAgICAgICBpZiAoYW5pbWF0aW9uRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldERhdGEoKS5jb3VudCgpID4gdGhpcy5nZXRTaGFsbG93KCdhbmltYXRpb25UaHJlc2hvbGQnKSkge1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25FbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFuaW1hdGlvbkVuYWJsZWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzdG9yZURhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSB0aGlzLl9kYXRhQmVmb3JlUHJvY2Vzc2VkLmNsb25lU2hhbGxvdygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldENvbG9yRnJvbVBhbGV0dGU6IGZ1bmN0aW9uIChuYW1lLCBzY29wZSkge1xuICAgICAgICAgICAgdmFyIGVjTW9kZWwgPSB0aGlzLmVjTW9kZWw7XG4gICAgICAgICAgICAvLyBQRU5ESU5HXG4gICAgICAgICAgICB2YXIgY29sb3IgPSBjb2xvclBhbGV0dGVNaXhpbi5nZXRDb2xvckZyb21QYWxldHRlLmNhbGwodGhpcywgbmFtZSwgc2NvcGUpO1xuICAgICAgICAgICAgaWYgKCFjb2xvcikge1xuICAgICAgICAgICAgICAgIGNvbG9yID0gZWNNb2RlbC5nZXRDb2xvckZyb21QYWxldHRlKG5hbWUsIHNjb3BlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb2xvcjtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRBeGlzVG9vbHRpcERhdGFJbmRleDogbnVsbFxuICAgIH0pO1xuXG4gICAgenJVdGlsLm1peGluKFNlcmllc01vZGVsLCBtb2RlbFV0aWwuZGF0YUZvcm1hdE1peGluKTtcbiAgICB6clV0aWwubWl4aW4oU2VyaWVzTW9kZWwsIGNvbG9yUGFsZXR0ZU1peGluKTtcblxuICAgIHJldHVybiBTZXJpZXNNb2RlbDtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvZWNoYXJ0cy9tb2RlbC9TZXJpZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAzMlxuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cbiAgICB2YXIgR3JvdXAgPSByZXF1aXJlKCd6cmVuZGVyL2NvbnRhaW5lci9Hcm91cCcpO1xuICAgIHZhciBjb21wb25lbnRVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9jb21wb25lbnQnKTtcbiAgICB2YXIgY2xhenpVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9jbGF6eicpO1xuXG4gICAgdmFyIENvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb250YWluZXIvR3JvdXB9XG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ncm91cCA9IG5ldyBHcm91cCgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudWlkID0gY29tcG9uZW50VXRpbC5nZXRVSUQoJ3ZpZXdDb21wb25lbnQnKTtcbiAgICB9O1xuXG4gICAgQ29tcG9uZW50LnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogQ29tcG9uZW50LFxuXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHt9LFxuXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKGNvbXBvbmVudE1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHt9LFxuXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHt9XG4gICAgfTtcblxuICAgIHZhciBjb21wb25lbnRQcm90byA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gICAgY29tcG9uZW50UHJvdG8udXBkYXRlVmlld1xuICAgICAgICA9IGNvbXBvbmVudFByb3RvLnVwZGF0ZUxheW91dFxuICAgICAgICA9IGNvbXBvbmVudFByb3RvLnVwZGF0ZVZpc3VhbFxuICAgICAgICA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgICAgICAgICAvLyBEbyBub3RoaW5nO1xuICAgICAgICB9O1xuICAgIC8vIEVuYWJsZSBDb21wb25lbnQuZXh0ZW5kLlxuICAgIGNsYXp6VXRpbC5lbmFibGVDbGFzc0V4dGVuZChDb21wb25lbnQpO1xuXG4gICAgLy8gRW5hYmxlIGNhcGFiaWxpdHkgb2YgcmVnaXN0ZXJDbGFzcywgZ2V0Q2xhc3MsIGhhc0NsYXNzLCByZWdpc3RlclN1YlR5cGVEZWZhdWx0ZXIgYW5kIHNvIG9uLlxuICAgIGNsYXp6VXRpbC5lbmFibGVDbGFzc01hbmFnZW1lbnQoQ29tcG9uZW50LCB7cmVnaXN0ZXJXaGVuRXh0ZW5kOiB0cnVlfSk7XG5cbiAgICByZXR1cm4gQ29tcG9uZW50O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC9lY2hhcnRzL3ZpZXcvQ29tcG9uZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsIi8qKlxuICogR3JvdXDmmK/kuIDkuKrlrrnlmajvvIzlj6/ku6Xmj5LlhaXlrZDoioLngrnvvIxHcm91cOeahOWPmOaNouS5n+S8muiiq+W6lOeUqOWIsOWtkOiKgueCueS4ilxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvR3JvdXBcbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIEdyb3VwID0gcmVxdWlyZSgnenJlbmRlci9jb250YWluZXIvR3JvdXAnKTtcbiAqICAgICB2YXIgQ2lyY2xlID0gcmVxdWlyZSgnenJlbmRlci9ncmFwaGljL3NoYXBlL0NpcmNsZScpO1xuICogICAgIHZhciBnID0gbmV3IEdyb3VwKCk7XG4gKiAgICAgZy5wb3NpdGlvblswXSA9IDEwMDtcbiAqICAgICBnLnBvc2l0aW9uWzFdID0gMTAwO1xuICogICAgIGcuYWRkKG5ldyBDaXJjbGUoe1xuICogICAgICAgICBzdHlsZToge1xuICogICAgICAgICAgICAgeDogMTAwLFxuICogICAgICAgICAgICAgeTogMTAwLFxuICogICAgICAgICAgICAgcjogMjAsXG4gKiAgICAgICAgIH1cbiAqICAgICB9KSk7XG4gKiAgICAgenIuYWRkKGcpO1xuICovXG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgRWxlbWVudCA9IHJlcXVpcmUoJy4uL0VsZW1lbnQnKTtcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnLi4vY29yZS9Cb3VuZGluZ1JlY3QnKTtcblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0dyb3VwXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZVxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsXG4gICAgICovXG4gICAgdmFyIEdyb3VwID0gZnVuY3Rpb24gKG9wdHMpIHtcblxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgICAgICBFbGVtZW50LmNhbGwodGhpcywgb3B0cyk7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdHMpIHtcbiAgICAgICAgICAgIHRoaXNba2V5XSA9IG9wdHNba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NoaWxkcmVuID0gW107XG5cbiAgICAgICAgdGhpcy5fX3N0b3JhZ2UgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX19kaXJ0eSA9IHRydWU7XG4gICAgfTtcblxuICAgIEdyb3VwLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogR3JvdXAsXG5cbiAgICAgICAgaXNHcm91cDogdHJ1ZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHR5cGU6ICdncm91cCcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaJgOacieWtkOWtmeWFg+e0oOaYr+WQpuWTjeW6lOm8oOagh+S6i+S7tlxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvY29udGFpbmVyL0dyb3VwI3NpbGVudFxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHNpbGVudDogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6enJlbmRlci9FbGVtZW50Pn1cbiAgICAgICAgICovXG4gICAgICAgIGNoaWxkcmVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4uc2xpY2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W5oyH5a6aIGluZGV4IOeahOWEv+WtkOiKgueCuVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGlkeFxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9FbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgY2hpbGRBdDogZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuW2lkeF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPluaMh+WumuWQjeWtl+eahOWEv+WtkOiKgueCuVxuICAgICAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWVcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIGNoaWxkT2ZOYW1lOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGNoaWxkQ291bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa3u+WKoOWtkOiKgueCueWIsOacgOWQjlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGNoaWxkXG4gICAgICAgICAqL1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkICYmIGNoaWxkICE9PSB0aGlzICYmIGNoaWxkLnBhcmVudCAhPT0gdGhpcykge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW4ucHVzaChjaGlsZCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9kb0FkZChjaGlsZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqDlrZDoioLngrnlnKggbmV4dFNpYmxpbmcg5LmL5YmNXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gY2hpbGRcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBuZXh0U2libGluZ1xuICAgICAgICAgKi9cbiAgICAgICAgYWRkQmVmb3JlOiBmdW5jdGlvbiAoY2hpbGQsIG5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgJiYgY2hpbGQgIT09IHRoaXMgJiYgY2hpbGQucGFyZW50ICE9PSB0aGlzXG4gICAgICAgICAgICAgICAgJiYgbmV4dFNpYmxpbmcgJiYgbmV4dFNpYmxpbmcucGFyZW50ID09PSB0aGlzKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gY2hpbGRyZW4uaW5kZXhPZihuZXh0U2libGluZyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGlkeCwgMCwgY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb0FkZChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBfZG9BZGQ6IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIGNoaWxkLnBhcmVudC5yZW1vdmUoY2hpbGQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IHRoaXMuX19zdG9yYWdlO1xuICAgICAgICAgICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuICAgICAgICAgICAgaWYgKHN0b3JhZ2UgJiYgc3RvcmFnZSAhPT0gY2hpbGQuX19zdG9yYWdlKSB7XG5cbiAgICAgICAgICAgICAgICBzdG9yYWdlLmFkZFRvTWFwKGNoaWxkKTtcblxuICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmFkZENoaWxkcmVuVG9TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgenIgJiYgenIucmVmcmVzaCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnp7vpmaTlrZDoioLngrlcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBjaGlsZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHZhciB6ciA9IHRoaXMuX196cjtcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gdGhpcy5fX3N0b3JhZ2U7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblxuICAgICAgICAgICAgdmFyIGlkeCA9IHpyVXRpbC5pbmRleE9mKGNoaWxkcmVuLCBjaGlsZCk7XG4gICAgICAgICAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGlkeCwgMSk7XG5cbiAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChzdG9yYWdlKSB7XG5cbiAgICAgICAgICAgICAgICBzdG9yYWdlLmRlbEZyb21NYXAoY2hpbGQuaWQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHpyICYmIHpyLnJlZnJlc2goKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOenu+mZpOaJgOacieWtkOiKgueCuVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlQWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gdGhpcy5fX3N0b3JhZ2U7XG4gICAgICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZS5kZWxGcm9tTWFwKGNoaWxkLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLmRlbENoaWxkcmVuRnJvbVN0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDpgY3ljobmiYDmnInlrZDoioLngrlcbiAgICAgICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAgICAgICAqIEBwYXJhbSAge30gICBjb250ZXh0XG4gICAgICAgICAqL1xuICAgICAgICBlYWNoQ2hpbGQ6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCBjaGlsZCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5rex5bqm5LyY5YWI6YGN5Y6G5omA5pyJ5a2Q5a2Z6IqC54K5XG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcGFyYW0gIHt9ICAgY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgY2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09ICdncm91cCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQudHJhdmVyc2UoY2IsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZENoaWxkcmVuVG9TdG9yYWdlOiBmdW5jdGlvbiAoc3RvcmFnZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIHN0b3JhZ2UuYWRkVG9NYXAoY2hpbGQpO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmFkZENoaWxkcmVuVG9TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkZWxDaGlsZHJlbkZyb21TdG9yYWdlOiBmdW5jdGlvbiAoc3RvcmFnZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIHN0b3JhZ2UuZGVsRnJvbU1hcChjaGlsZC5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlydHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX19kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKGluY2x1ZGVDaGlsZHJlbikge1xuICAgICAgICAgICAgLy8gVE9ETyBDYWNoaW5nXG4gICAgICAgICAgICAvLyBUT0RPIFRyYW5zZm9ybVxuICAgICAgICAgICAgdmFyIHJlY3QgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHRtcFJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KDAsIDAsIDAsIDApO1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gaW5jbHVkZUNoaWxkcmVuIHx8IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgICAgICAgdmFyIHRtcE1hdCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmlnbm9yZSB8fCBjaGlsZC5pbnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkUmVjdCA9IGNoaWxkLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSBjaGlsZC5nZXRMb2NhbFRyYW5zZm9ybSh0bXBNYXQpO1xuICAgICAgICAgICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wUmVjdC5jb3B5KGNoaWxkUmVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHRtcFJlY3QuYXBwbHlUcmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgcmVjdCA9IHJlY3QgfHwgdG1wUmVjdC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICByZWN0LnVuaW9uKHRtcFJlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdCA9IHJlY3QgfHwgY2hpbGRSZWN0LmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlY3QudW5pb24oY2hpbGRSZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVjdCB8fCB0bXBSZWN0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHpyVXRpbC5pbmhlcml0cyhHcm91cCwgRWxlbWVudCk7XG5cbiAgICByZXR1cm4gR3JvdXA7XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL3pyZW5kZXIvY29udGFpbmVyL0dyb3VwLmpzXG4gKiogbW9kdWxlIGlkID0gMzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsIi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL0VsZW1lbnRcbiAqL1xuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgZ3VpZCA9IHJlcXVpcmUoJy4vY29yZS9ndWlkJyk7XG4gICAgdmFyIEV2ZW50ZnVsID0gcmVxdWlyZSgnLi9taXhpbi9FdmVudGZ1bCcpO1xuICAgIHZhciBUcmFuc2Zvcm1hYmxlID0gcmVxdWlyZSgnLi9taXhpbi9UcmFuc2Zvcm1hYmxlJyk7XG4gICAgdmFyIEFuaW1hdGFibGUgPSByZXF1aXJlKCcuL21peGluL0FuaW1hdGFibGUnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnLi9jb3JlL3V0aWwnKTtcblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9FbGVtZW50XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMge21vZHVsZTp6cmVuZGVyL21peGluL0FuaW1hdGFibGV9XG4gICAgICogQGV4dGVuZHMge21vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGV9XG4gICAgICogQGV4dGVuZHMge21vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsfVxuICAgICAqL1xuICAgIHZhciBFbGVtZW50ID0gZnVuY3Rpb24gKG9wdHMpIHtcblxuICAgICAgICBUcmFuc2Zvcm1hYmxlLmNhbGwodGhpcywgb3B0cyk7XG4gICAgICAgIEV2ZW50ZnVsLmNhbGwodGhpcywgb3B0cyk7XG4gICAgICAgIEFuaW1hdGFibGUuY2FsbCh0aGlzLCBvcHRzKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICog55S75biD5YWD57SgSURcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSBvcHRzLmlkIHx8IGd1aWQoKTtcbiAgICB9O1xuXG4gICAgRWxlbWVudC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWFg+e0oOexu+Wei1xuICAgICAgICAgKiBFbGVtZW50IHR5cGVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHR5cGU6ICdlbGVtZW50JyxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5YWD57Sg5ZCN5a2XXG4gICAgICAgICAqIEVsZW1lbnQgbmFtZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgbmFtZTogJycsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFpSZW5kZXIg5a6e5L6L5a+56LGh77yM5Lya5ZyoIGVsZW1lbnQg5re75Yqg5YiwIHpyZW5kZXIg5a6e5L6L5Lit5ZCO6Ieq5Yqo6LWL5YC8XG4gICAgICAgICAqIFpSZW5kZXIgaW5zdGFuY2Ugd2lsbCBiZSBhc3NpZ25lZCB3aGVuIGVsZW1lbnQgaXMgYXNzb2NpYXRlZCB3aXRoIHpyZW5kZXJcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL0VsZW1lbnQjX196clxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn1cbiAgICAgICAgICovXG4gICAgICAgIF9fenI6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWbvuW9ouaYr+WQpuW/veeVpe+8jOS4unRydWXml7blv73nlaXlm77lvaLnmoTnu5jliLbku6Xlj4rkuovku7bop6blj5FcbiAgICAgICAgICogSWYgaWdub3JlIGRyYXdpbmcgYW5kIGV2ZW50cyBvZiB0aGUgZWxlbWVudCBvYmplY3RcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL0VsZW1lbnQjaWdub3JlXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgaWdub3JlOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog55So5LqO6KOB5Ymq55qE6Lev5b6EKHNoYXBlKe+8jOaJgOaciSBHcm91cCDlhoXnmoTot6/lvoTlnKjnu5jliLbml7bpg73kvJrooqvov5nkuKrot6/lvoToo4HliapcbiAgICAgICAgICog6K+l6Lev5b6E5Lya57un5om/6KKr6KOB5YeP5a+56LGh55qE5Y+Y5o2iXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGh9XG4gICAgICAgICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMmRjb250ZXh0LyNjbGlwcGluZy1yZWdpb25cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICBjbGlwUGF0aDogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRHJpZnQgZWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGR4IGR4IG9uIHRoZSBnbG9iYWwgc3BhY2VcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBkeSBkeSBvbiB0aGUgZ2xvYmFsIHNwYWNlXG4gICAgICAgICAqL1xuICAgICAgICBkcmlmdDogZnVuY3Rpb24gKGR4LCBkeSkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRyYWdnYWJsZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hvcml6b250YWwnOlxuICAgICAgICAgICAgICAgICAgICBkeSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3ZlcnRpY2FsJzpcbiAgICAgICAgICAgICAgICAgICAgZHggPSAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgICAgIG0gPSB0aGlzLnRyYW5zZm9ybSA9IFsxLCAwLCAwLCAxLCAwLCAwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1bNF0gKz0gZHg7XG4gICAgICAgICAgICBtWzVdICs9IGR5O1xuXG4gICAgICAgICAgICB0aGlzLmRlY29tcG9zZVRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhvb2sgYmVmb3JlIHVwZGF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgYmVmb3JlVXBkYXRlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhvb2sgYWZ0ZXIgdXBkYXRlXG4gICAgICAgICAqL1xuICAgICAgICBhZnRlclVwZGF0ZTogZnVuY3Rpb24gKCkge30sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgZWFjaCBmcmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICogQHBhcmFtICB7fSAgIGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIHRyYXZlcnNlOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHt9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBhdHRyS1Y6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAncG9zaXRpb24nIHx8IGtleSA9PT0gJ3NjYWxlJyB8fCBrZXkgPT09ICdvcmlnaW4nKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29weSB0aGUgYXJyYXlcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHRoaXNba2V5XSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFswXSA9IHZhbHVlWzBdO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbMV0gPSB2YWx1ZVsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSGlkZSB0aGUgZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgaGlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5pZ25vcmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3cgdGhlIGVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIHNob3c6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuaWdub3JlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBrZXlcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYXR0cjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0cktWKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoenJVdGlsLmlzT2JqZWN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIGtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5Lmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJLVihuYW1lLCBrZXlbbmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmRpcnR5KGZhbHNlKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRofSBjbGlwUGF0aFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0Q2xpcFBhdGg6IGZ1bmN0aW9uIChjbGlwUGF0aCkge1xuICAgICAgICAgICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuICAgICAgICAgICAgaWYgKHpyKSB7XG4gICAgICAgICAgICAgICAgY2xpcFBhdGguYWRkU2VsZlRvWnIoenIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZW1vdmUgcHJldmlvdXMgY2xpcCBwYXRoXG4gICAgICAgICAgICBpZiAodGhpcy5jbGlwUGF0aCAmJiB0aGlzLmNsaXBQYXRoICE9PSBjbGlwUGF0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2xpcFBhdGgoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jbGlwUGF0aCA9IGNsaXBQYXRoO1xuICAgICAgICAgICAgY2xpcFBhdGguX196ciA9IHpyO1xuICAgICAgICAgICAgY2xpcFBhdGguX19jbGlwVGFyZ2V0ID0gdGhpcztcblxuICAgICAgICAgICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVDbGlwUGF0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNsaXBQYXRoID0gdGhpcy5jbGlwUGF0aDtcbiAgICAgICAgICAgIGlmIChjbGlwUGF0aCkge1xuICAgICAgICAgICAgICAgIGlmIChjbGlwUGF0aC5fX3pyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsaXBQYXRoLnJlbW92ZVNlbGZGcm9tWnIoY2xpcFBhdGguX196cik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2xpcFBhdGguX196ciA9IG51bGw7XG4gICAgICAgICAgICAgICAgY2xpcFBhdGguX19jbGlwVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaXBQYXRoID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgc2VsZiBmcm9tIHpyZW5kZXIgaW5zdGFuY2UuXG4gICAgICAgICAqIE5vdCByZWN1cnNpdmVseSBiZWNhdXNlIGl0IHdpbGwgYmUgaW52b2tlZCB3aGVuIGVsZW1lbnQgYWRkZWQgdG8gc3RvcmFnZS5cbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfSB6clxuICAgICAgICAgKi9cbiAgICAgICAgYWRkU2VsZlRvWnI6IGZ1bmN0aW9uICh6cikge1xuICAgICAgICAgICAgdGhpcy5fX3pyID0genI7XG4gICAgICAgICAgICAvLyDmt7vliqDliqjnlLtcbiAgICAgICAgICAgIHZhciBhbmltYXRvcnMgPSB0aGlzLmFuaW1hdG9ycztcbiAgICAgICAgICAgIGlmIChhbmltYXRvcnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaW1hdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB6ci5hbmltYXRpb24uYWRkQW5pbWF0b3IoYW5pbWF0b3JzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNsaXBQYXRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGlwUGF0aC5hZGRTZWxmVG9acih6cik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBzZWxmIGZyb20genJlbmRlciBpbnN0YW5jZS5cbiAgICAgICAgICogTm90IHJlY3Vyc2l2ZWx5IGJlY2F1c2UgaXQgd2lsbCBiZSBpbnZva2VkIHdoZW4gZWxlbWVudCBhZGRlZCB0byBzdG9yYWdlLlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9IHpyXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVTZWxmRnJvbVpyOiBmdW5jdGlvbiAoenIpIHtcbiAgICAgICAgICAgIHRoaXMuX196ciA9IG51bGw7XG4gICAgICAgICAgICAvLyDnp7vpmaTliqjnlLtcbiAgICAgICAgICAgIHZhciBhbmltYXRvcnMgPSB0aGlzLmFuaW1hdG9ycztcbiAgICAgICAgICAgIGlmIChhbmltYXRvcnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaW1hdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB6ci5hbmltYXRpb24ucmVtb3ZlQW5pbWF0b3IoYW5pbWF0b3JzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNsaXBQYXRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGlwUGF0aC5yZW1vdmVTZWxmRnJvbVpyKHpyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB6clV0aWwubWl4aW4oRWxlbWVudCwgQW5pbWF0YWJsZSk7XG4gICAgenJVdGlsLm1peGluKEVsZW1lbnQsIFRyYW5zZm9ybWFibGUpO1xuICAgIHpyVXRpbC5taXhpbihFbGVtZW50LCBFdmVudGZ1bCk7XG5cbiAgICByZXR1cm4gRWxlbWVudDtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvenJlbmRlci9FbGVtZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsIi8qKlxuICogenJlbmRlcjog55Sf5oiQ5ZSv5LiAaWRcbiAqXG4gKiBAYXV0aG9yIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgIHZhciBpZFN0YXJ0ID0gMHgwOTA3O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGlkU3RhcnQrKztcbiAgICB9O1xufSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL3pyZW5kZXIvY29yZS9ndWlkLmpzXG4gKiogbW9kdWxlIGlkID0gMzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsIi8qKlxuICog5LqL5Lu25omp5bGVXG4gKiBAbW9kdWxlIHpyZW5kZXIvbWl4aW4vRXZlbnRmdWxcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG4gICAgdmFyIGFycnlTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAgIC8qKlxuICAgICAqIOS6i+S7tuWIhuWPkeWZqFxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBFdmVudGZ1bCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fJGhhbmRsZXJzID0ge307XG4gICAgfTtcblxuICAgIEV2ZW50ZnVsLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogRXZlbnRmdWwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWNleasoeinpuWPkee7keWumu+8jHRyaWdnZXLlkI7plIDmr4FcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOWTjeW6lOWHveaVsFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgb25lOiBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVycztcblxuICAgICAgICAgICAgaWYgKCFoYW5kbGVyIHx8ICFldmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIV9oW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgIF9oW2V2ZW50XSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9oW2V2ZW50XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChfaFtldmVudF1baV0uaCA9PT0gaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9oW2V2ZW50XS5wdXNoKHtcbiAgICAgICAgICAgICAgICBoOiBoYW5kbGVyLFxuICAgICAgICAgICAgICAgIG9uZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjdHg6IGNvbnRleHQgfHwgdGhpc1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnu5Hlrprkuovku7ZcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOS6i+S7tuWkhOeQhuWHveaVsFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdXG4gICAgICAgICAqL1xuICAgICAgICBvbjogZnVuY3Rpb24gKGV2ZW50LCBoYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgX2ggPSB0aGlzLl8kaGFuZGxlcnM7XG5cbiAgICAgICAgICAgIGlmICghaGFuZGxlciB8fCAhZXZlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFfaFtldmVudF0pIHtcbiAgICAgICAgICAgICAgICBfaFtldmVudF0gPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfaFtldmVudF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoX2hbZXZlbnRdW2ldLmggPT09IGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfaFtldmVudF0ucHVzaCh7XG4gICAgICAgICAgICAgICAgaDogaGFuZGxlcixcbiAgICAgICAgICAgICAgICBvbmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGN0eDogY29udGV4dCB8fCB0aGlzXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpue7keWumuS6huS6i+S7tlxuICAgICAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBldmVudFxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgaXNTaWxlbnQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzO1xuICAgICAgICAgICAgcmV0dXJuIF9oW2V2ZW50XSAmJiBfaFtldmVudF0ubGVuZ3RoO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDop6Pnu5Hkuovku7ZcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl0g5LqL5Lu25aSE55CG5Ye95pWwXG4gICAgICAgICAqL1xuICAgICAgICBvZmY6IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlcikge1xuICAgICAgICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzO1xuXG4gICAgICAgICAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fJGhhbmRsZXJzID0ge307XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9oW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3TGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IF9oW2V2ZW50XS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaFtldmVudF1baV1bJ2gnXSAhPSBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGlzdC5wdXNoKF9oW2V2ZW50XVtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX2hbZXZlbnRdID0gbmV3TGlzdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX2hbZXZlbnRdICYmIF9oW2V2ZW50XS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF9oW2V2ZW50XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgX2hbZXZlbnRdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5LqL5Lu25YiG5Y+RXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIOS6i+S7tuexu+Wei1xuICAgICAgICAgKi9cbiAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl8kaGFuZGxlcnNbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICB2YXIgYXJnTGVuID0gYXJncy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJnTGVuID4gMykge1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJyeVNsaWNlLmNhbGwoYXJncywgMSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzW3R5cGVdO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBfaC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIGFkdmlzZSBmcm9tIGJhY2tib25lXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYXJnTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKF9oW2ldWydjdHgnXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKF9oW2ldWydjdHgnXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKF9oW2ldWydjdHgnXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhdmUgbW9yZSB0aGFuIDIgZ2l2ZW4gYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5hcHBseShfaFtpXVsnY3R4J10sIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9oW2ldWydvbmUnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2guc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDluKbmnIljb250ZXh055qE5LqL5Lu25YiG5Y+RLCDmnIDlkI7kuIDkuKrlj4LmlbDmmK/kuovku7blm57osIPnmoRjb250ZXh0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIOS6i+S7tuexu+Wei1xuICAgICAgICAgKi9cbiAgICAgICAgdHJpZ2dlcldpdGhDb250ZXh0OiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuXyRoYW5kbGVyc1t0eXBlXSkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgIHZhciBhcmdMZW4gPSBhcmdzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGlmIChhcmdMZW4gPiA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcnJ5U2xpY2UuY2FsbChhcmdzLCAxLCBhcmdzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzW3R5cGVdO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBfaC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIGFkdmlzZSBmcm9tIGJhY2tib25lXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYXJnTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKGN0eCwgYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKGN0eCwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhdmUgbW9yZSB0aGFuIDIgZ2l2ZW4gYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5hcHBseShjdHgsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9oW2ldWydvbmUnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2guc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIOWvueixoeWPr+S7pemAmui/hyBvbnh4eHgg57uR5a6a5LqL5Lu2XG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uY2xpY2tcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNlb3ZlclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2VvdXRcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNlbW92ZVxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2V3aGVlbFxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2Vkb3duXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZXVwXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnc3RhcnRcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdlbmRcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdlbnRlclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ2xlYXZlXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnb3ZlclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJvcFxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG5cbiAgICByZXR1cm4gRXZlbnRmdWw7XG59KTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvenJlbmRlci9taXhpbi9FdmVudGZ1bC5qc1xuICoqIG1vZHVsZSBpZCA9IDM3XG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCIvKipcbiAqIOaPkOS+m+WPmOaNouaJqeWxlVxuICogQG1vZHVsZSB6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGVcbiAqIEBhdXRob3IgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBtYXRyaXggPSByZXF1aXJlKCcuLi9jb3JlL21hdHJpeCcpO1xuICAgIHZhciB2ZWN0b3IgPSByZXF1aXJlKCcuLi9jb3JlL3ZlY3RvcicpO1xuICAgIHZhciBtSWRlbnRpdHkgPSBtYXRyaXguaWRlbnRpdHk7XG5cbiAgICB2YXIgRVBTSUxPTiA9IDVlLTU7XG5cbiAgICBmdW5jdGlvbiBpc05vdEFyb3VuZFplcm8odmFsKSB7XG4gICAgICAgIHJldHVybiB2YWwgPiBFUFNJTE9OIHx8IHZhbCA8IC1FUFNJTE9OO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIFRyYW5zZm9ybWFibGUgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGdpdmVuIHBvc2l0aW9uLCByb3RhdGlvbiwgc2NhbGVcbiAgICAgICAgaWYgKCFvcHRzLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOW5s+enu1xuICAgICAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgICAgICogQGRlZmF1bHQgWzAsIDBdXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSBbMCwgMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMucm90YXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDml4vovaxcbiAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRzLnNjYWxlKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOe8qeaUvlxuICAgICAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgICAgICogQGRlZmF1bHQgWzEsIDFdXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuc2NhbGUgPSBbMSwgMV07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaXi+i9rOWSjOe8qeaUvueahOWOn+eCuVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3JpZ2luID0gdGhpcy5vcmlnaW4gfHwgbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIHRyYW5zZm9ybWFibGVQcm90byA9IFRyYW5zZm9ybWFibGUucHJvdG90eXBlO1xuICAgIHRyYW5zZm9ybWFibGVQcm90by50cmFuc2Zvcm0gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICog5Yik5pat5piv5ZCm6ZyA6KaB5pyJ5Z2Q5qCH5Y+Y5o2iXG4gICAgICog5aaC5p6c5pyJ5Z2Q5qCH5Y+Y5o2iLCDliJnku45wb3NpdGlvbiwgcm90YXRpb24sIHNjYWxl5Lul5Y+K54i26IqC54K555qEdHJhbnNmb3Jt6K6h566X5Ye66Ieq6Lqr55qEdHJhbnNmb3Jt55+p6Zi1XG4gICAgICovXG4gICAgdHJhbnNmb3JtYWJsZVByb3RvLm5lZWRMb2NhbFRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGlzTm90QXJvdW5kWmVybyh0aGlzLnJvdGF0aW9uKVxuICAgICAgICAgICAgfHwgaXNOb3RBcm91bmRaZXJvKHRoaXMucG9zaXRpb25bMF0pXG4gICAgICAgICAgICB8fCBpc05vdEFyb3VuZFplcm8odGhpcy5wb3NpdGlvblsxXSlcbiAgICAgICAgICAgIHx8IGlzTm90QXJvdW5kWmVybyh0aGlzLnNjYWxlWzBdIC0gMSlcbiAgICAgICAgICAgIHx8IGlzTm90QXJvdW5kWmVybyh0aGlzLnNjYWxlWzFdIC0gMSk7XG4gICAgfTtcblxuICAgIHRyYW5zZm9ybWFibGVQcm90by51cGRhdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgdmFyIHBhcmVudEhhc1RyYW5zZm9ybSA9IHBhcmVudCAmJiBwYXJlbnQudHJhbnNmb3JtO1xuICAgICAgICB2YXIgbmVlZExvY2FsVHJhbnNmb3JtID0gdGhpcy5uZWVkTG9jYWxUcmFuc2Zvcm0oKTtcblxuICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICBpZiAoIShuZWVkTG9jYWxUcmFuc2Zvcm0gfHwgcGFyZW50SGFzVHJhbnNmb3JtKSkge1xuICAgICAgICAgICAgbSAmJiBtSWRlbnRpdHkobSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBtID0gbSB8fCBtYXRyaXguY3JlYXRlKCk7XG5cbiAgICAgICAgaWYgKG5lZWRMb2NhbFRyYW5zZm9ybSkge1xuICAgICAgICAgICAgdGhpcy5nZXRMb2NhbFRyYW5zZm9ybShtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1JZGVudGl0eShtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOW6lOeUqOeItuiKgueCueWPmOaNolxuICAgICAgICBpZiAocGFyZW50SGFzVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBpZiAobmVlZExvY2FsVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgbWF0cml4Lm11bChtLCBwYXJlbnQudHJhbnNmb3JtLCBtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hdHJpeC5jb3B5KG0sIHBhcmVudC50cmFuc2Zvcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIOS/neWtmOi/meS4quWPmOaNouefqemYtVxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IG07XG5cbiAgICAgICAgdGhpcy5pbnZUcmFuc2Zvcm0gPSB0aGlzLmludlRyYW5zZm9ybSB8fCBtYXRyaXguY3JlYXRlKCk7XG4gICAgICAgIG1hdHJpeC5pbnZlcnQodGhpcy5pbnZUcmFuc2Zvcm0sIG0pO1xuICAgIH07XG5cbiAgICB0cmFuc2Zvcm1hYmxlUHJvdG8uZ2V0TG9jYWxUcmFuc2Zvcm0gPSBmdW5jdGlvbiAobSkge1xuICAgICAgICBtID0gbSB8fCBbXTtcbiAgICAgICAgbUlkZW50aXR5KG0pO1xuXG4gICAgICAgIHZhciBvcmlnaW4gPSB0aGlzLm9yaWdpbjtcblxuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgICAgICB2YXIgcm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICBpZiAob3JpZ2luKSB7XG4gICAgICAgICAgICAvLyBUcmFuc2xhdGUgdG8gb3JpZ2luXG4gICAgICAgICAgICBtWzRdIC09IG9yaWdpblswXTtcbiAgICAgICAgICAgIG1bNV0gLT0gb3JpZ2luWzFdO1xuICAgICAgICB9XG4gICAgICAgIG1hdHJpeC5zY2FsZShtLCBtLCBzY2FsZSk7XG4gICAgICAgIGlmIChyb3RhdGlvbikge1xuICAgICAgICAgICAgbWF0cml4LnJvdGF0ZShtLCBtLCByb3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yaWdpbikge1xuICAgICAgICAgICAgLy8gVHJhbnNsYXRlIGJhY2sgZnJvbSBvcmlnaW5cbiAgICAgICAgICAgIG1bNF0gKz0gb3JpZ2luWzBdO1xuICAgICAgICAgICAgbVs1XSArPSBvcmlnaW5bMV07XG4gICAgICAgIH1cblxuICAgICAgICBtWzRdICs9IHBvc2l0aW9uWzBdO1xuICAgICAgICBtWzVdICs9IHBvc2l0aW9uWzFdO1xuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH07XG4gICAgLyoqXG4gICAgICog5bCG6Ieq5bex55qEdHJhbnNmb3Jt5bqU55So5YiwY29udGV4dOS4ilxuICAgICAqIEBwYXJhbSB7Q29udGV4dDJEfSBjdHhcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1hYmxlUHJvdG8uc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICB2YXIgZHByID0gY3R4LmRwciB8fCAxO1xuICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgY3R4LnNldFRyYW5zZm9ybShkcHIgKiBtWzBdLCBkcHIgKiBtWzFdLCBkcHIgKiBtWzJdLCBkcHIgKiBtWzNdLCBkcHIgKiBtWzRdLCBkcHIgKiBtWzVdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oZHByLCAwLCAwLCBkcHIsIDAsIDApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRyYW5zZm9ybWFibGVQcm90by5yZXN0b3JlVHJhbnNmb3JtID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICB2YXIgZHByID0gY3R4LmRwciB8fCAxO1xuICAgICAgICBjdHguc2V0VHJhbnNmb3JtKGRwciwgMCwgMCwgZHByLCAwLCAwKTtcbiAgICB9XG5cbiAgICB2YXIgdG1wVHJhbnNmb3JtID0gW107XG5cbiAgICAvKipcbiAgICAgKiDliIbop6NgdHJhbnNmb3JtYOefqemYteWIsGBwb3NpdGlvbmAsIGByb3RhdGlvbmAsIGBzY2FsZWBcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1hYmxlUHJvdG8uZGVjb21wb3NlVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMudHJhbnNmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC50cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIC8vIEdldCBsb2NhbCB0cmFuc2Zvcm0gYW5kIGRlY29tcG9zZSB0aGVtIHRvIHBvc2l0aW9uLCBzY2FsZSwgcm90YXRpb25cbiAgICAgICAgICAgIG1hdHJpeC5tdWwodG1wVHJhbnNmb3JtLCBwYXJlbnQuaW52VHJhbnNmb3JtLCBtKTtcbiAgICAgICAgICAgIG0gPSB0bXBUcmFuc2Zvcm07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN4ID0gbVswXSAqIG1bMF0gKyBtWzFdICogbVsxXTtcbiAgICAgICAgdmFyIHN5ID0gbVsyXSAqIG1bMl0gKyBtWzNdICogbVszXTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICAgICAgaWYgKGlzTm90QXJvdW5kWmVybyhzeCAtIDEpKSB7XG4gICAgICAgICAgICBzeCA9IE1hdGguc3FydChzeCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTm90QXJvdW5kWmVybyhzeSAtIDEpKSB7XG4gICAgICAgICAgICBzeSA9IE1hdGguc3FydChzeSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1bMF0gPCAwKSB7XG4gICAgICAgICAgICBzeCA9IC1zeDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobVszXSA8IDApIHtcbiAgICAgICAgICAgIHN5ID0gLXN5O1xuICAgICAgICB9XG4gICAgICAgIHBvc2l0aW9uWzBdID0gbVs0XTtcbiAgICAgICAgcG9zaXRpb25bMV0gPSBtWzVdO1xuICAgICAgICBzY2FsZVswXSA9IHN4O1xuICAgICAgICBzY2FsZVsxXSA9IHN5O1xuICAgICAgICB0aGlzLnJvdGF0aW9uID0gTWF0aC5hdGFuMigtbVsxXSAvIHN5LCBtWzBdIC8gc3gpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZ2xvYmFsIHNjYWxlXG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICovXG4gICAgdHJhbnNmb3JtYWJsZVByb3RvLmdldEdsb2JhbFNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiBbMSwgMV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN4ID0gTWF0aC5zcXJ0KG1bMF0gKiBtWzBdICsgbVsxXSAqIG1bMV0pO1xuICAgICAgICB2YXIgc3kgPSBNYXRoLnNxcnQobVsyXSAqIG1bMl0gKyBtWzNdICogbVszXSk7XG4gICAgICAgIGlmIChtWzBdIDwgMCkge1xuICAgICAgICAgICAgc3ggPSAtc3g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1bM10gPCAwKSB7XG4gICAgICAgICAgICBzeSA9IC1zeTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3N4LCBzeV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiDlj5jmjaLlnZDmoIfkvY3nva7liLAgc2hhcGUg55qE5bGA6YOo5Z2Q5qCH56m66Ze0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1hYmxlUHJvdG8udHJhbnNmb3JtQ29vcmRUb0xvY2FsID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIHYyID0gW3gsIHldO1xuICAgICAgICB2YXIgaW52VHJhbnNmb3JtID0gdGhpcy5pbnZUcmFuc2Zvcm07XG4gICAgICAgIGlmIChpbnZUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHZlY3Rvci5hcHBseVRyYW5zZm9ybSh2MiwgdjIsIGludlRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHYyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiDlj5jmjaLlsYDpg6jlnZDmoIfkvY3nva7liLDlhajlsYDlnZDmoIfnqbrpl7RcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAqL1xuICAgIHRyYW5zZm9ybWFibGVQcm90by50cmFuc2Zvcm1Db29yZFRvR2xvYmFsID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIHYyID0gW3gsIHldO1xuICAgICAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHZlY3Rvci5hcHBseVRyYW5zZm9ybSh2MiwgdjIsIHRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHYyO1xuICAgIH07XG5cbiAgICByZXR1cm4gVHJhbnNmb3JtYWJsZTtcbn0pO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC96cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSAzOFxuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvbWl4aW4vQW5pbWF0YWJsZVxuICovXG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIEFuaW1hdG9yID0gcmVxdWlyZSgnLi4vYW5pbWF0aW9uL0FuaW1hdG9yJyk7XG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgaXNTdHJpbmcgPSB1dGlsLmlzU3RyaW5nO1xuICAgIHZhciBpc0Z1bmN0aW9uID0gdXRpbC5pc0Z1bmN0aW9uO1xuICAgIHZhciBpc09iamVjdCA9IHV0aWwuaXNPYmplY3Q7XG4gICAgdmFyIGxvZyA9IHJlcXVpcmUoJy4uL2NvcmUvbG9nJyk7XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWU6enJlbmRlci9taXhpbi9BbmltYXRhYmxlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGFibGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yPn1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFuaW1hdG9ycyA9IFtdO1xuICAgIH07XG5cbiAgICBBbmltYXRhYmxlLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogQW5pbWF0YWJsZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yqo55S7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIOmcgOimgea3u+WKoOWKqOeUu+eahOWxnuaAp+iOt+WPlui3r+W+hO+8jOWPr+S7pemAmui/h2EuYi5j5p2l6I635Y+W5rex5bGC55qE5bGe5oCnXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2xvb3BdIOWKqOeUu+aYr+WQpuW+queOr1xuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAgICAgICAqIEBleGFtcGxlOlxuICAgICAgICAgKiAgICAgZWwuYW5pbWF0ZSgnc3R5bGUnLCBmYWxzZSlcbiAgICAgICAgICogICAgICAgICAud2hlbigxMDAwLCB7eDogMTB9IClcbiAgICAgICAgICogICAgICAgICAuZG9uZShmdW5jdGlvbigpeyAvLyBBbmltYXRpb24gZG9uZSB9KVxuICAgICAgICAgKiAgICAgICAgIC5zdGFydCgpXG4gICAgICAgICAqL1xuICAgICAgICBhbmltYXRlOiBmdW5jdGlvbiAocGF0aCwgbG9vcCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldDtcbiAgICAgICAgICAgIHZhciBhbmltYXRpbmdTaGFwZSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGVsID0gdGhpcztcbiAgICAgICAgICAgIHZhciB6ciA9IHRoaXMuX196cjtcbiAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGhTcGxpdHRlZCA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcCA9IGVsO1xuICAgICAgICAgICAgICAgIC8vIElmIGFuaW1hdGluZyBzaGFwZVxuICAgICAgICAgICAgICAgIGFuaW1hdGluZ1NoYXBlID0gcGF0aFNwbGl0dGVkWzBdID09PSAnc2hhcGUnO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcGF0aFNwbGl0dGVkLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByb3AgPSBwcm9wW3BhdGhTcGxpdHRlZFtpXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHByb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gZWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgbG9nKFxuICAgICAgICAgICAgICAgICAgICAnUHJvcGVydHkgXCInXG4gICAgICAgICAgICAgICAgICAgICsgcGF0aFxuICAgICAgICAgICAgICAgICAgICArICdcIiBpcyBub3QgZXhpc3RlZCBpbiBlbGVtZW50ICdcbiAgICAgICAgICAgICAgICAgICAgKyBlbC5pZFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYW5pbWF0b3JzID0gZWwuYW5pbWF0b3JzO1xuXG4gICAgICAgICAgICB2YXIgYW5pbWF0b3IgPSBuZXcgQW5pbWF0b3IodGFyZ2V0LCBsb29wKTtcblxuICAgICAgICAgICAgYW5pbWF0b3IuZHVyaW5nKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBlbC5kaXJ0eShhbmltYXRpbmdTaGFwZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmRvbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FIEFuaW1hdG9yIHdpbGwgbm90IGJlIHJlbW92ZWQgaWYgdXNlIGBBbmltYXRvciNzdG9wYCB0byBzdG9wIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgIGFuaW1hdG9ycy5zcGxpY2UodXRpbC5pbmRleE9mKGFuaW1hdG9ycywgYW5pbWF0b3IpLCAxKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBhbmltYXRvcnMucHVzaChhbmltYXRvcik7XG5cbiAgICAgICAgICAgIC8vIElmIGFuaW1hdGUgYWZ0ZXIgYWRkZWQgdG8gdGhlIHpyZW5kZXJcbiAgICAgICAgICAgIGlmICh6cikge1xuICAgICAgICAgICAgICAgIHpyLmFuaW1hdGlvbi5hZGRBbmltYXRvcihhbmltYXRvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhbmltYXRvcjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5YGc5q2i5Yqo55S7XG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yd2FyZFRvTGFzdCBJZiBtb3ZlIHRvIGxhc3QgZnJhbWUgYmVmb3JlIHN0b3BcbiAgICAgICAgICovXG4gICAgICAgIHN0b3BBbmltYXRpb246IGZ1bmN0aW9uIChmb3J3YXJkVG9MYXN0KSB7XG4gICAgICAgICAgICB2YXIgYW5pbWF0b3JzID0gdGhpcy5hbmltYXRvcnM7XG4gICAgICAgICAgICB2YXIgbGVuID0gYW5pbWF0b3JzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhbmltYXRvcnNbaV0uc3RvcChmb3J3YXJkVG9MYXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuaW1hdG9ycy5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWU9NTAwXSBUaW1lIGluIG1zXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZWFzaW5nPSdsaW5lYXInXVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlbGF5PTBdXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja11cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogIC8vIEFuaW1hdGUgcG9zaXRpb25cbiAgICAgICAgICogIGVsLmFuaW1hdGVUbyh7XG4gICAgICAgICAqICAgICAgcG9zaXRpb246IFsxMCwgMTBdXG4gICAgICAgICAqICB9LCBmdW5jdGlvbiAoKSB7IC8vIGRvbmUgfSlcbiAgICAgICAgICpcbiAgICAgICAgICogIC8vIEFuaW1hdGUgc2hhcGUsIHN0eWxlIGFuZCBwb3NpdGlvbiBpbiAxMDBtcywgZGVsYXllZCAxMDBtcywgd2l0aCBjdWJpY091dCBlYXNpbmdcbiAgICAgICAgICogIGVsLmFuaW1hdGVUbyh7XG4gICAgICAgICAqICAgICAgc2hhcGU6IHtcbiAgICAgICAgICogICAgICAgICAgd2lkdGg6IDUwMFxuICAgICAgICAgKiAgICAgIH0sXG4gICAgICAgICAqICAgICAgc3R5bGU6IHtcbiAgICAgICAgICogICAgICAgICAgZmlsbDogJ3JlZCdcbiAgICAgICAgICogICAgICB9XG4gICAgICAgICAqICAgICAgcG9zaXRpb246IFsxMCwgMTBdXG4gICAgICAgICAqICB9LCAxMDAsIDEwMCwgJ2N1YmljT3V0JywgZnVuY3Rpb24gKCkgeyAvLyBkb25lIH0pXG4gICAgICAgICAqL1xuICAgICAgICAgLy8gVE9ETyBSZXR1cm4gYW5pbWF0aW9uIGtleVxuICAgICAgICBhbmltYXRlVG86IGZ1bmN0aW9uICh0YXJnZXQsIHRpbWUsIGRlbGF5LCBlYXNpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBhbmltYXRlVG8odGFyZ2V0LCB0aW1lLCBlYXNpbmcsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGlmIChpc1N0cmluZyhkZWxheSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGVhc2luZztcbiAgICAgICAgICAgICAgICBlYXNpbmcgPSBkZWxheTtcbiAgICAgICAgICAgICAgICBkZWxheSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhbmltYXRlVG8odGFyZ2V0LCB0aW1lLCBkZWxheSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihlYXNpbmcpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBlYXNpbmc7XG4gICAgICAgICAgICAgICAgZWFzaW5nID0gJ2xpbmVhcic7XG4gICAgICAgICAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYW5pbWF0ZVRvKHRhcmdldCwgdGltZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihkZWxheSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGRlbGF5O1xuICAgICAgICAgICAgICAgIGRlbGF5ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFuaW1hdGVUbyh0YXJnZXQsIGNhbGxiYWNrKVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aW1lKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gdGltZTtcbiAgICAgICAgICAgICAgICB0aW1lID0gNTAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYW5pbWF0ZVRvKHRhcmdldClcbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aW1lKSB7XG4gICAgICAgICAgICAgICAgdGltZSA9IDUwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0b3AgYWxsIHByZXZpb3VzIGFuaW1hdGlvbnNcbiAgICAgICAgICAgIHRoaXMuc3RvcEFuaW1hdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZVRvU2hhbGxvdygnJywgdGhpcywgdGFyZ2V0LCB0aW1lLCBkZWxheSwgZWFzaW5nLCBjYWxsYmFjayk7XG5cbiAgICAgICAgICAgIC8vIEFuaW1hdG9ycyBtYXkgYmUgcmVtb3ZlZCBpbW1lZGlhdGVseSBhZnRlciBzdGFydFxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm90aGluZyB0byBhbmltYXRlXG4gICAgICAgICAgICB2YXIgYW5pbWF0b3JzID0gdGhpcy5hbmltYXRvcnMuc2xpY2UoKTtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IGFuaW1hdG9ycy5sZW5ndGg7XG4gICAgICAgICAgICBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgICAgICAgICAgIGNvdW50LS07XG4gICAgICAgICAgICAgICAgaWYgKCFjb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTm8gYW5pbWF0b3JzLiBUaGlzIHNob3VsZCBiZSBjaGVja2VkIGJlZm9yZSBhbmltYXRvcnNbaV0uc3RhcnQoKSxcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgJ2RvbmUnIG1heSBiZSBleGVjdXRlZCBpbW1lZGlhdGVseSBpZiBubyBuZWVkIHRvIGFuaW1hdGUuXG4gICAgICAgICAgICBpZiAoIWNvdW50KSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0YXJ0IGFmdGVyIGFsbCBhbmltYXRvcnMgY3JlYXRlZFxuICAgICAgICAgICAgLy8gSW5jYXNlIGFueSBhbmltYXRvciBpcyBkb25lIGltbWVkaWF0ZWx5IHdoZW4gYWxsIGFuaW1hdGlvbiBwcm9wZXJ0aWVzIGFyZSBub3QgY2hhbmdlZFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmltYXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhbmltYXRvcnNbaV1cbiAgICAgICAgICAgICAgICAgICAgLmRvbmUoZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgLnN0YXJ0KGVhc2luZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoPScnXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2U9dGhpc1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZT01MDBdXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXk9MF1cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogIC8vIEFuaW1hdGUgcG9zaXRpb25cbiAgICAgICAgICogIGVsLl9hbmltYXRlVG9TaGFsbG93KHtcbiAgICAgICAgICogICAgICBwb3NpdGlvbjogWzEwLCAxMF1cbiAgICAgICAgICogIH0pXG4gICAgICAgICAqXG4gICAgICAgICAqICAvLyBBbmltYXRlIHNoYXBlLCBzdHlsZSBhbmQgcG9zaXRpb24gaW4gMTAwbXMsIGRlbGF5ZWQgMTAwbXNcbiAgICAgICAgICogIGVsLl9hbmltYXRlVG9TaGFsbG93KHtcbiAgICAgICAgICogICAgICBzaGFwZToge1xuICAgICAgICAgKiAgICAgICAgICB3aWR0aDogNTAwXG4gICAgICAgICAqICAgICAgfSxcbiAgICAgICAgICogICAgICBzdHlsZToge1xuICAgICAgICAgKiAgICAgICAgICBmaWxsOiAncmVkJ1xuICAgICAgICAgKiAgICAgIH1cbiAgICAgICAgICogICAgICBwb3NpdGlvbjogWzEwLCAxMF1cbiAgICAgICAgICogIH0sIDEwMCwgMTAwKVxuICAgICAgICAgKi9cbiAgICAgICAgX2FuaW1hdGVUb1NoYWxsb3c6IGZ1bmN0aW9uIChwYXRoLCBzb3VyY2UsIHRhcmdldCwgdGltZSwgZGVsYXkpIHtcbiAgICAgICAgICAgIHZhciBvYmpTaGFsbG93ID0ge307XG4gICAgICAgICAgICB2YXIgcHJvcGVydHlDb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRhcmdldCkge1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QodGFyZ2V0W25hbWVdKSAmJiAhdXRpbC5pc0FycmF5TGlrZSh0YXJnZXRbbmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRlVG9TaGFsbG93KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPyBwYXRoICsgJy4nICsgbmFtZSA6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlW25hbWVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqU2hhbGxvd1tuYW1lXSA9IHRhcmdldFtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5Q291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0YXJnZXRbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBdHRyIGRpcmVjdGx5IGlmIG5vdCBoYXMgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUsIGlmIHNvbWUgcHJvcGVydHkgbm90IG5lZWRlZCBmb3IgZWxlbWVudCA/XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyKG5hbWUsIHRhcmdldFtuYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7ICAvLyBTaGFwZSBvciBzdHlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wc1twYXRoXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNbcGF0aF1bbmFtZV0gPSB0YXJnZXRbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHIocHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHJvcGVydHlDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGUocGF0aCwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIC53aGVuKHRpbWUgPT0gbnVsbCA/IDUwMCA6IHRpbWUsIG9ialNoYWxsb3cpXG4gICAgICAgICAgICAgICAgICAgIC5kZWxheShkZWxheSB8fCAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIEFuaW1hdGFibGU7XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL3pyZW5kZXIvbWl4aW4vQW5pbWF0YWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDM5XG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCIvKipcbiAqIEBtb2R1bGUgZWNoYXJ0cy9hbmltYXRpb24vQW5pbWF0b3JcbiAqL1xuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cbiAgICB2YXIgQ2xpcCA9IHJlcXVpcmUoJy4vQ2xpcCcpO1xuICAgIHZhciBjb2xvciA9IHJlcXVpcmUoJy4uL3Rvb2wvY29sb3InKTtcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuICAgIHZhciBpc0FycmF5TGlrZSA9IHV0aWwuaXNBcnJheUxpa2U7XG5cbiAgICB2YXIgYXJyYXlTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRHZXR0ZXIodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldFtrZXldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRTZXR0ZXIodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50ZXJwb2xhdGVOdW1iZXIocDAsIHAxLCBwZXJjZW50KSB7XG4gICAgICAgIHJldHVybiAocDEgLSBwMCkgKiBwZXJjZW50ICsgcDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBwMFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50ZXJwb2xhdGVTdHJpbmcocDAsIHAxLCBwZXJjZW50KSB7XG4gICAgICAgIHJldHVybiBwZXJjZW50ID4gMC41ID8gcDEgOiBwMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcDBcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBhcnJEaW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnRlcnBvbGF0ZUFycmF5KHAwLCBwMSwgcGVyY2VudCwgb3V0LCBhcnJEaW0pIHtcbiAgICAgICAgdmFyIGxlbiA9IHAwLmxlbmd0aDtcbiAgICAgICAgaWYgKGFyckRpbSA9PSAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0W2ldID0gaW50ZXJwb2xhdGVOdW1iZXIocDBbaV0sIHAxW2ldLCBwZXJjZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsZW4yID0gcDBbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dFtpXVtqXSA9IGludGVycG9sYXRlTnVtYmVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgcDBbaV1bal0sIHAxW2ldW2pdLCBwZXJjZW50XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gYXJyMCBpcyBzb3VyY2UgYXJyYXksIGFycjEgaXMgdGFyZ2V0IGFycmF5LlxuICAgIC8vIERvIHNvbWUgcHJlcHJvY2VzcyB0byBhdm9pZCBlcnJvciBoYXBwZW5lZCB3aGVuIGludGVycG9sYXRpbmcgZnJvbSBhcnIwIHRvIGFycjFcbiAgICBmdW5jdGlvbiBmaWxsQXJyKGFycjAsIGFycjEsIGFyckRpbSkge1xuICAgICAgICB2YXIgYXJyMExlbiA9IGFycjAubGVuZ3RoO1xuICAgICAgICB2YXIgYXJyMUxlbiA9IGFycjEubGVuZ3RoO1xuICAgICAgICBpZiAoYXJyMExlbiAhPT0gYXJyMUxlbikge1xuICAgICAgICAgICAgLy8gRklYTUUgTm90IHdvcmsgZm9yIFR5cGVkQXJyYXlcbiAgICAgICAgICAgIHZhciBpc1ByZXZpb3VzTGFyZ2VyID0gYXJyMExlbiA+IGFycjFMZW47XG4gICAgICAgICAgICBpZiAoaXNQcmV2aW91c0xhcmdlcikge1xuICAgICAgICAgICAgICAgIC8vIEN1dCB0aGUgcHJldmlvdXNcbiAgICAgICAgICAgICAgICBhcnIwLmxlbmd0aCA9IGFycjFMZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGaWxsIHRoZSBwcmV2aW91c1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBhcnIwTGVuOyBpIDwgYXJyMUxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycjAucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyckRpbSA9PT0gMSA/IGFycjFbaV0gOiBhcnJheVNsaWNlLmNhbGwoYXJyMVtpXSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxpbmcgTmFOIHZhbHVlXG4gICAgICAgIHZhciBsZW4yID0gYXJyMFswXSAmJiBhcnIwWzBdLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYXJyRGltID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKGFycjBbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycjBbaV0gPSBhcnIxW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihhcnIwW2ldW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyMFtpXVtqXSA9IGFycjFbaV1bal07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gYXJyMFxuICAgICAqIEBwYXJhbSAge0FycmF5fSBhcnIxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBhcnJEaW1cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXlTYW1lKGFycjAsIGFycjEsIGFyckRpbSkge1xuICAgICAgICBpZiAoYXJyMCA9PT0gYXJyMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbiA9IGFycjAubGVuZ3RoO1xuICAgICAgICBpZiAobGVuICE9PSBhcnIxLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcnJEaW0gPT09IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJyMFtpXSAhPT0gYXJyMVtpXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxlbjIgPSBhcnIwWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJyMFtpXVtqXSAhPT0gYXJyMVtpXVtqXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhdG11bGwgUm9tIGludGVycG9sYXRlIGFycmF5XG4gICAgICogQHBhcmFtICB7QXJyYXl9IHAwXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHAxXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHAyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHAzXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0MlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gdDNcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBhcnJEaW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXRtdWxsUm9tSW50ZXJwb2xhdGVBcnJheShcbiAgICAgICAgcDAsIHAxLCBwMiwgcDMsIHQsIHQyLCB0Mywgb3V0LCBhcnJEaW1cbiAgICApIHtcbiAgICAgICAgdmFyIGxlbiA9IHAwLmxlbmd0aDtcbiAgICAgICAgaWYgKGFyckRpbSA9PSAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0W2ldID0gY2F0bXVsbFJvbUludGVycG9sYXRlKFxuICAgICAgICAgICAgICAgICAgICBwMFtpXSwgcDFbaV0sIHAyW2ldLCBwM1tpXSwgdCwgdDIsIHQzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsZW4yID0gcDBbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dFtpXVtqXSA9IGNhdG11bGxSb21JbnRlcnBvbGF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHAwW2ldW2pdLCBwMVtpXVtqXSwgcDJbaV1bal0sIHAzW2ldW2pdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdCwgdDIsIHQzXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2F0bXVsbCBSb20gaW50ZXJwb2xhdGUgbnVtYmVyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICAgICAqIEBwYXJhbSAge251bWJlcn0gdFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gdDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHQzXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhdG11bGxSb21JbnRlcnBvbGF0ZShwMCwgcDEsIHAyLCBwMywgdCwgdDIsIHQzKSB7XG4gICAgICAgIHZhciB2MCA9IChwMiAtIHAwKSAqIDAuNTtcbiAgICAgICAgdmFyIHYxID0gKHAzIC0gcDEpICogMC41O1xuICAgICAgICByZXR1cm4gKDIgKiAocDEgLSBwMikgKyB2MCArIHYxKSAqIHQzXG4gICAgICAgICAgICAgICAgKyAoLTMgKiAocDEgLSBwMikgLSAyICogdjAgLSB2MSkgKiB0MlxuICAgICAgICAgICAgICAgICsgdjAgKiB0ICsgcDE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlWzBdKSkge1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGFycmF5U2xpY2UuY2FsbCh2YWx1ZVtpXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYXJyYXlTbGljZS5jYWxsKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZ2JhMlN0cmluZyhyZ2JhKSB7XG4gICAgICAgIHJnYmFbMF0gPSBNYXRoLmZsb29yKHJnYmFbMF0pO1xuICAgICAgICByZ2JhWzFdID0gTWF0aC5mbG9vcihyZ2JhWzFdKTtcbiAgICAgICAgcmdiYVsyXSA9IE1hdGguZmxvb3IocmdiYVsyXSk7XG5cbiAgICAgICAgcmV0dXJuICdyZ2JhKCcgKyByZ2JhLmpvaW4oJywnKSArICcpJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVUcmFja0NsaXAgKGFuaW1hdG9yLCBlYXNpbmcsIG9uZVRyYWNrRG9uZSwga2V5ZnJhbWVzLCBwcm9wTmFtZSkge1xuICAgICAgICB2YXIgZ2V0dGVyID0gYW5pbWF0b3IuX2dldHRlcjtcbiAgICAgICAgdmFyIHNldHRlciA9IGFuaW1hdG9yLl9zZXR0ZXI7XG4gICAgICAgIHZhciB1c2VTcGxpbmUgPSBlYXNpbmcgPT09ICdzcGxpbmUnO1xuXG4gICAgICAgIHZhciB0cmFja0xlbiA9IGtleWZyYW1lcy5sZW5ndGg7XG4gICAgICAgIGlmICghdHJhY2tMZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBHdWVzcyBkYXRhIHR5cGVcbiAgICAgICAgdmFyIGZpcnN0VmFsID0ga2V5ZnJhbWVzWzBdLnZhbHVlO1xuICAgICAgICB2YXIgaXNWYWx1ZUFycmF5ID0gaXNBcnJheUxpa2UoZmlyc3RWYWwpO1xuICAgICAgICB2YXIgaXNWYWx1ZUNvbG9yID0gZmFsc2U7XG4gICAgICAgIHZhciBpc1ZhbHVlU3RyaW5nID0gZmFsc2U7XG5cbiAgICAgICAgLy8gRm9yIHZlcnRpY2VzIG1vcnBoaW5nXG4gICAgICAgIHZhciBhcnJEaW0gPSAoXG4gICAgICAgICAgICAgICAgaXNWYWx1ZUFycmF5XG4gICAgICAgICAgICAgICAgJiYgaXNBcnJheUxpa2UoZmlyc3RWYWxbMF0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgICA/IDIgOiAxO1xuICAgICAgICB2YXIgdHJhY2tNYXhUaW1lO1xuICAgICAgICAvLyBTb3J0IGtleWZyYW1lIGFzIGFzY2VuZGluZ1xuICAgICAgICBrZXlmcmFtZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS50aW1lIC0gYi50aW1lO1xuICAgICAgICB9KTtcblxuICAgICAgICB0cmFja01heFRpbWUgPSBrZXlmcmFtZXNbdHJhY2tMZW4gLSAxXS50aW1lO1xuICAgICAgICAvLyBQZXJjZW50cyBvZiBlYWNoIGtleWZyYW1lXG4gICAgICAgIHZhciBrZlBlcmNlbnRzID0gW107XG4gICAgICAgIC8vIFZhbHVlIG9mIGVhY2gga2V5ZnJhbWVcbiAgICAgICAgdmFyIGtmVmFsdWVzID0gW107XG4gICAgICAgIHZhciBwcmV2VmFsdWUgPSBrZXlmcmFtZXNbMF0udmFsdWU7XG4gICAgICAgIHZhciBpc0FsbFZhbHVlRXF1YWwgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrTGVuOyBpKyspIHtcbiAgICAgICAgICAgIGtmUGVyY2VudHMucHVzaChrZXlmcmFtZXNbaV0udGltZSAvIHRyYWNrTWF4VGltZSk7XG4gICAgICAgICAgICAvLyBBc3N1bWUgdmFsdWUgaXMgYSBjb2xvciB3aGVuIGl0IGlzIGEgc3RyaW5nXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBrZXlmcmFtZXNbaV0udmFsdWU7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHZhbHVlIGlzIGVxdWFsLCBkZWVwIGNoZWNrIGlmIHZhbHVlIGlzIGFycmF5XG4gICAgICAgICAgICBpZiAoISgoaXNWYWx1ZUFycmF5ICYmIGlzQXJyYXlTYW1lKHZhbHVlLCBwcmV2VmFsdWUsIGFyckRpbSkpXG4gICAgICAgICAgICAgICAgfHwgKCFpc1ZhbHVlQXJyYXkgJiYgdmFsdWUgPT09IHByZXZWYWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgaXNBbGxWYWx1ZUVxdWFsID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2VmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICAgICAgLy8gVHJ5IGNvbnZlcnRpbmcgYSBzdHJpbmcgdG8gYSBjb2xvciBhcnJheVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhciBjb2xvckFycmF5ID0gY29sb3IucGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChjb2xvckFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY29sb3JBcnJheTtcbiAgICAgICAgICAgICAgICAgICAgaXNWYWx1ZUNvbG9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlzVmFsdWVTdHJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtmVmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FsbFZhbHVlRXF1YWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYXN0VmFsdWUgPSBrZlZhbHVlc1t0cmFja0xlbiAtIDFdO1xuICAgICAgICAvLyBQb2x5ZmlsbCBhcnJheSBhbmQgTmFOIHZhbHVlXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tMZW4gLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbHVlQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBmaWxsQXJyKGtmVmFsdWVzW2ldLCBsYXN0VmFsdWUsIGFyckRpbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oa2ZWYWx1ZXNbaV0pICYmICFpc05hTihsYXN0VmFsdWUpICYmICFpc1ZhbHVlU3RyaW5nICYmICFpc1ZhbHVlQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAga2ZWYWx1ZXNbaV0gPSBsYXN0VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlzVmFsdWVBcnJheSAmJiBmaWxsQXJyKGdldHRlcihhbmltYXRvci5fdGFyZ2V0LCBwcm9wTmFtZSksIGxhc3RWYWx1ZSwgYXJyRGltKTtcblxuICAgICAgICAvLyBDYWNoZSB0aGUga2V5IG9mIGxhc3QgZnJhbWUgdG8gc3BlZWQgdXAgd2hlblxuICAgICAgICAvLyBhbmltYXRpb24gcGxheWJhY2sgaXMgc2VxdWVuY3lcbiAgICAgICAgdmFyIGxhc3RGcmFtZSA9IDA7XG4gICAgICAgIHZhciBsYXN0RnJhbWVQZXJjZW50ID0gMDtcbiAgICAgICAgdmFyIHN0YXJ0O1xuICAgICAgICB2YXIgdztcbiAgICAgICAgdmFyIHAwO1xuICAgICAgICB2YXIgcDE7XG4gICAgICAgIHZhciBwMjtcbiAgICAgICAgdmFyIHAzO1xuXG4gICAgICAgIGlmIChpc1ZhbHVlQ29sb3IpIHtcbiAgICAgICAgICAgIHZhciByZ2JhID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9uZnJhbWUgPSBmdW5jdGlvbiAodGFyZ2V0LCBwZXJjZW50KSB7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSByYW5nZSBrZXlmcmFtZXNcbiAgICAgICAgICAgIC8vIGtmMS0tLS0ta2YyLS0tLS0tLS0tY3VycmVudC0tLS0tLS0ta2YzXG4gICAgICAgICAgICAvLyBmaW5kIGtmMiBhbmQga2YzIGFuZCBkbyBpbnRlcnBvbGF0aW9uXG4gICAgICAgICAgICB2YXIgZnJhbWU7XG4gICAgICAgICAgICAvLyBJbiB0aGUgZWFzaW5nIGZ1bmN0aW9uIGxpa2UgZWxhc3RpY091dCwgcGVyY2VudCBtYXkgbGVzcyB0aGFuIDBcbiAgICAgICAgICAgIGlmIChwZXJjZW50IDwgMCkge1xuICAgICAgICAgICAgICAgIGZyYW1lID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBlcmNlbnQgPCBsYXN0RnJhbWVQZXJjZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgZnJvbSBuZXh0IGtleVxuICAgICAgICAgICAgICAgIC8vIFBFTkRJTkcgc3RhcnQgZnJvbSBsYXN0RnJhbWUgP1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5taW4obGFzdEZyYW1lICsgMSwgdHJhY2tMZW4gLSAxKTtcbiAgICAgICAgICAgICAgICBmb3IgKGZyYW1lID0gc3RhcnQ7IGZyYW1lID49IDA7IGZyYW1lLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtmUGVyY2VudHNbZnJhbWVdIDw9IHBlcmNlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBFTkRJTkcgcmVhbGx5IG5lZWQgdG8gZG8gdGhpcyA/XG4gICAgICAgICAgICAgICAgZnJhbWUgPSBNYXRoLm1pbihmcmFtZSwgdHJhY2tMZW4gLSAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoZnJhbWUgPSBsYXN0RnJhbWU7IGZyYW1lIDwgdHJhY2tMZW47IGZyYW1lKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtmUGVyY2VudHNbZnJhbWVdID4gcGVyY2VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnJhbWUgPSBNYXRoLm1pbihmcmFtZSAtIDEsIHRyYWNrTGVuIC0gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0RnJhbWUgPSBmcmFtZTtcbiAgICAgICAgICAgIGxhc3RGcmFtZVBlcmNlbnQgPSBwZXJjZW50O1xuXG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSAoa2ZQZXJjZW50c1tmcmFtZSArIDFdIC0ga2ZQZXJjZW50c1tmcmFtZV0pO1xuICAgICAgICAgICAgaWYgKHJhbmdlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdyA9IChwZXJjZW50IC0ga2ZQZXJjZW50c1tmcmFtZV0pIC8gcmFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXNlU3BsaW5lKSB7XG4gICAgICAgICAgICAgICAgcDEgPSBrZlZhbHVlc1tmcmFtZV07XG4gICAgICAgICAgICAgICAgcDAgPSBrZlZhbHVlc1tmcmFtZSA9PT0gMCA/IGZyYW1lIDogZnJhbWUgLSAxXTtcbiAgICAgICAgICAgICAgICBwMiA9IGtmVmFsdWVzW2ZyYW1lID4gdHJhY2tMZW4gLSAyID8gdHJhY2tMZW4gLSAxIDogZnJhbWUgKyAxXTtcbiAgICAgICAgICAgICAgICBwMyA9IGtmVmFsdWVzW2ZyYW1lID4gdHJhY2tMZW4gLSAzID8gdHJhY2tMZW4gLSAxIDogZnJhbWUgKyAyXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWx1ZUFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhdG11bGxSb21JbnRlcnBvbGF0ZUFycmF5KFxuICAgICAgICAgICAgICAgICAgICAgICAgcDAsIHAxLCBwMiwgcDMsIHcsIHcgKiB3LCB3ICogdyAqIHcsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXR0ZXIodGFyZ2V0LCBwcm9wTmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJEaW1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsdWVDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjYXRtdWxsUm9tSW50ZXJwb2xhdGVBcnJheShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwMCwgcDEsIHAyLCBwMywgdywgdyAqIHcsIHcgKiB3ICogdyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZ2JhLCAxXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZ2JhMlN0cmluZyhyZ2JhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1ZhbHVlU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdHJpbmcgaXMgc3RlcCgwLjUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVTdHJpbmcocDEsIHAyLCB3KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY2F0bXVsbFJvbUludGVycG9sYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAwLCBwMSwgcDIsIHAzLCB3LCB3ICogdywgdyAqIHcgKiB3XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldHRlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWx1ZUFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRlQXJyYXkoXG4gICAgICAgICAgICAgICAgICAgICAgICBrZlZhbHVlc1tmcmFtZV0sIGtmVmFsdWVzW2ZyYW1lICsgMV0sIHcsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXR0ZXIodGFyZ2V0LCBwcm9wTmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJEaW1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsdWVDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGVBcnJheShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZlZhbHVlc1tmcmFtZV0sIGtmVmFsdWVzW2ZyYW1lICsgMV0sIHcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmdiYSwgMVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmdiYTJTdHJpbmcocmdiYSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNWYWx1ZVN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RyaW5nIGlzIHN0ZXAoMC41KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludGVycG9sYXRlU3RyaW5nKGtmVmFsdWVzW2ZyYW1lXSwga2ZWYWx1ZXNbZnJhbWUgKyAxXSwgdyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGludGVycG9sYXRlTnVtYmVyKGtmVmFsdWVzW2ZyYW1lXSwga2ZWYWx1ZXNbZnJhbWUgKyAxXSwgdyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0dGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgY2xpcCA9IG5ldyBDbGlwKHtcbiAgICAgICAgICAgIHRhcmdldDogYW5pbWF0b3IuX3RhcmdldCxcbiAgICAgICAgICAgIGxpZmU6IHRyYWNrTWF4VGltZSxcbiAgICAgICAgICAgIGxvb3A6IGFuaW1hdG9yLl9sb29wLFxuICAgICAgICAgICAgZGVsYXk6IGFuaW1hdG9yLl9kZWxheSxcbiAgICAgICAgICAgIG9uZnJhbWU6IG9uZnJhbWUsXG4gICAgICAgICAgICBvbmRlc3Ryb3k6IG9uZVRyYWNrRG9uZVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZWFzaW5nICYmIGVhc2luZyAhPT0gJ3NwbGluZScpIHtcbiAgICAgICAgICAgIGNsaXAuZWFzaW5nID0gZWFzaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsaXA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvb3BcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXJcbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0b3IgPSBmdW5jdGlvbih0YXJnZXQsIGxvb3AsIGdldHRlciwgc2V0dGVyKSB7XG4gICAgICAgIHRoaXMuX3RyYWNrcyA9IHt9O1xuICAgICAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG5cbiAgICAgICAgdGhpcy5fbG9vcCA9IGxvb3AgfHwgZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fZ2V0dGVyID0gZ2V0dGVyIHx8IGRlZmF1bHRHZXR0ZXI7XG4gICAgICAgIHRoaXMuX3NldHRlciA9IHNldHRlciB8fCBkZWZhdWx0U2V0dGVyO1xuXG4gICAgICAgIHRoaXMuX2NsaXBDb3VudCA9IDA7XG5cbiAgICAgICAgdGhpcy5fZGVsYXkgPSAwO1xuXG4gICAgICAgIHRoaXMuX2RvbmVMaXN0ID0gW107XG5cbiAgICAgICAgdGhpcy5fb25mcmFtZUxpc3QgPSBbXTtcblxuICAgICAgICB0aGlzLl9jbGlwTGlzdCA9IFtdO1xuICAgIH07XG5cbiAgICBBbmltYXRvci5wcm90b3R5cGUgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorr7nva7liqjnlLvlhbPplK7luKdcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB0aW1lIOWFs+mUruW4p+aXtumXtO+8jOWNleS9jeaYr21zXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gcHJvcHMg5YWz6ZSu5bin55qE5bGe5oCn5YC877yMa2V5LXZhbHVl6KGo56S6XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICAgICAgICovXG4gICAgICAgIHdoZW46IGZ1bmN0aW9uKHRpbWUgLyogbXMgKi8sIHByb3BzKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2tzID0gdGhpcy5fdHJhY2tzO1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRyYWNrc1twcm9wTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tzW3Byb3BOYW1lXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2dldHRlcih0aGlzLl90YXJnZXQsIHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHpyTG9nKCdJbnZhbGlkIHByb3BlcnR5ICcgKyBwcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aW1lIGlzIDBcbiAgICAgICAgICAgICAgICAgICAgLy8gIFRoZW4gcHJvcHMgaXMgZ2l2ZW4gaW5pdGlhbGl6ZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAvLyBFbHNlXG4gICAgICAgICAgICAgICAgICAgIC8vICBJbml0aWFsaXplIHZhbHVlIGZyb20gY3VycmVudCBwcm9wIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFja3NbcHJvcE5hbWVdLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNsb25lVmFsdWUodmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmFja3NbcHJvcE5hbWVdLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0aW1lOiB0aW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcHJvcHNbcHJvcE5hbWVdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa3u+WKoOWKqOeUu+avj+S4gOW4p+eahOWbnuiwg+WHveaVsFxuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZHVyaW5nOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuX29uZnJhbWVMaXN0LnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RvbmVDYWxsYmFjazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gQ2xlYXIgYWxsIHRyYWNrc1xuICAgICAgICAgICAgdGhpcy5fdHJhY2tzID0ge307XG4gICAgICAgICAgICAvLyBDbGVhciBhbGwgY2xpcHNcbiAgICAgICAgICAgIHRoaXMuX2NsaXBMaXN0Lmxlbmd0aCA9IDA7XG5cbiAgICAgICAgICAgIHZhciBkb25lTGlzdCA9IHRoaXMuX2RvbmVMaXN0O1xuICAgICAgICAgICAgdmFyIGxlbiA9IGRvbmVMaXN0Lmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkb25lTGlzdFtpXS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5byA5aeL5omn6KGM5Yqo55S7XG4gICAgICAgICAqIEBwYXJhbSAge3N0cmluZ3xGdW5jdGlvbn0gZWFzaW5nXG4gICAgICAgICAqICAgICAgICAg5Yqo55S757yT5Yqo5Ye95pWw77yM6K+m6KeBe0BsaW5rIG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9lYXNpbmd9XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICAgICAgICovXG4gICAgICAgIHN0YXJ0OiBmdW5jdGlvbiAoZWFzaW5nKSB7XG5cbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBjbGlwQ291bnQgPSAwO1xuXG4gICAgICAgICAgICB2YXIgb25lVHJhY2tEb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY2xpcENvdW50LS07XG4gICAgICAgICAgICAgICAgaWYgKCFjbGlwQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZG9uZUNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGxhc3RDbGlwO1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gdGhpcy5fdHJhY2tzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsaXAgPSBjcmVhdGVUcmFja0NsaXAoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMsIGVhc2luZywgb25lVHJhY2tEb25lLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90cmFja3NbcHJvcE5hbWVdLCBwcm9wTmFtZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKGNsaXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xpcExpc3QucHVzaChjbGlwKTtcbiAgICAgICAgICAgICAgICAgICAgY2xpcENvdW50Kys7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgc3RhcnQgYWZ0ZXIgYWRkZWQgdG8gYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb24uYWRkQ2xpcChjbGlwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDbGlwID0gY2xpcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFkZCBkdXJpbmcgY2FsbGJhY2sgb24gdGhlIGxhc3QgY2xpcFxuICAgICAgICAgICAgaWYgKGxhc3RDbGlwKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZE9uRnJhbWUgPSBsYXN0Q2xpcC5vbmZyYW1lO1xuICAgICAgICAgICAgICAgIGxhc3RDbGlwLm9uZnJhbWUgPSBmdW5jdGlvbiAodGFyZ2V0LCBwZXJjZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZE9uRnJhbWUodGFyZ2V0LCBwZXJjZW50KTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuX29uZnJhbWVMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9vbmZyYW1lTGlzdFtpXSh0YXJnZXQsIHBlcmNlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFjbGlwQ291bnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kb25lQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5YGc5q2i5Yqo55S7XG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yd2FyZFRvTGFzdCBJZiBtb3ZlIHRvIGxhc3QgZnJhbWUgYmVmb3JlIHN0b3BcbiAgICAgICAgICovXG4gICAgICAgIHN0b3A6IGZ1bmN0aW9uIChmb3J3YXJkVG9MYXN0KSB7XG4gICAgICAgICAgICB2YXIgY2xpcExpc3QgPSB0aGlzLl9jbGlwTGlzdDtcbiAgICAgICAgICAgIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xpcCA9IGNsaXBMaXN0W2ldO1xuICAgICAgICAgICAgICAgIGlmIChmb3J3YXJkVG9MYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgdG8gbGFzdCBmcmFtZSBiZWZvcmUgc3RvcFxuICAgICAgICAgICAgICAgICAgICBjbGlwLm9uZnJhbWUodGhpcy5fdGFyZ2V0LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uICYmIGFuaW1hdGlvbi5yZW1vdmVDbGlwKGNsaXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xpcExpc3QubGVuZ3RoID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuvue9ruWKqOeUu+W7tui/n+W8gOWni+eahOaXtumXtFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRpbWUg5Y2V5L2NbXNcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZGVsYXk6IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWxheSA9IHRpbWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa3u+WKoOWKqOeUu+e7k+adn+eahOWbnuiwg1xuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZG9uZTogZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RvbmVMaXN0LnB1c2goY2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6enJlbmRlci9hbmltYXRpb24vQ2xpcD59XG4gICAgICAgICAqL1xuICAgICAgICBnZXRDbGlwczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NsaXBMaXN0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBBbmltYXRvcjtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvenJlbmRlci9hbmltYXRpb24vQW5pbWF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSA0MFxuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiLyoqXG4gKiDliqjnlLvkuLvmjqfliLblmahcbiAqIEBjb25maWcgdGFyZ2V0IOWKqOeUu+Wvueixoe+8jOWPr+S7peaYr+aVsOe7hO+8jOWmguaenOaYr+aVsOe7hOeahOivneS8muaJuemHj+WIhuWPkW9uZnJhbWXnrYnkuovku7ZcbiAqIEBjb25maWcgbGlmZSgxMDAwKSDliqjnlLvml7bplb9cbiAqIEBjb25maWcgZGVsYXkoMCkg5Yqo55S75bu26L+f5pe26Ze0XG4gKiBAY29uZmlnIGxvb3AodHJ1ZSlcbiAqIEBjb25maWcgZ2FwKDApIOW+queOr+eahOmXtOmalOaXtumXtFxuICogQGNvbmZpZyBvbmZyYW1lXG4gKiBAY29uZmlnIGVhc2luZyhvcHRpb25hbClcbiAqIEBjb25maWcgb25kZXN0cm95KG9wdGlvbmFsKVxuICogQGNvbmZpZyBvbnJlc3RhcnQob3B0aW9uYWwpXG4gKlxuICogVE9ETyBwYXVzZVxuICovXG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSkge1xuXG4gICAgdmFyIGVhc2luZ0Z1bmNzID0gcmVxdWlyZSgnLi9lYXNpbmcnKTtcblxuICAgIGZ1bmN0aW9uIENsaXAob3B0aW9ucykge1xuXG4gICAgICAgIHRoaXMuX3RhcmdldCA9IG9wdGlvbnMudGFyZ2V0O1xuXG4gICAgICAgIC8vIOeUn+WRveWRqOacn1xuICAgICAgICB0aGlzLl9saWZlID0gb3B0aW9ucy5saWZlIHx8IDEwMDA7XG4gICAgICAgIC8vIOW7tuaXtlxuICAgICAgICB0aGlzLl9kZWxheSA9IG9wdGlvbnMuZGVsYXkgfHwgMDtcbiAgICAgICAgLy8g5byA5aeL5pe26Ze0XG4gICAgICAgIC8vIHRoaXMuX3N0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgdGhpcy5fZGVsYXk7Ly8g5Y2V5L2N5q+r56eSXG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8g5piv5ZCm5b6q546vXG4gICAgICAgIHRoaXMubG9vcCA9IG9wdGlvbnMubG9vcCA9PSBudWxsID8gZmFsc2UgOiBvcHRpb25zLmxvb3A7XG5cbiAgICAgICAgdGhpcy5nYXAgPSBvcHRpb25zLmdhcCB8fCAwO1xuXG4gICAgICAgIHRoaXMuZWFzaW5nID0gb3B0aW9ucy5lYXNpbmcgfHwgJ0xpbmVhcic7XG5cbiAgICAgICAgdGhpcy5vbmZyYW1lID0gb3B0aW9ucy5vbmZyYW1lO1xuICAgICAgICB0aGlzLm9uZGVzdHJveSA9IG9wdGlvbnMub25kZXN0cm95O1xuICAgICAgICB0aGlzLm9ucmVzdGFydCA9IG9wdGlvbnMub25yZXN0YXJ0O1xuICAgIH1cblxuICAgIENsaXAucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBDbGlwLFxuXG4gICAgICAgIHN0ZXA6IGZ1bmN0aW9uIChnbG9iYWxUaW1lKSB7XG4gICAgICAgICAgICAvLyBTZXQgc3RhcnRUaW1lIG9uIGZpcnN0IHN0ZXAsIG9yIF9zdGFydFRpbWUgbWF5IGhhcyBtaWxsZXNlY29uZHMgZGlmZmVyZW50IGJldHdlZW4gY2xpcHNcbiAgICAgICAgICAgIC8vIFBFTkRJTkdcbiAgICAgICAgICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSBnbG9iYWxUaW1lICsgdGhpcy5fZGVsYXk7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGVyY2VudCA9IChnbG9iYWxUaW1lIC0gdGhpcy5fc3RhcnRUaW1lKSAvIHRoaXMuX2xpZmU7XG5cbiAgICAgICAgICAgIC8vIOi/mOayoeW8gOWni1xuICAgICAgICAgICAgaWYgKHBlcmNlbnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwZXJjZW50ID0gTWF0aC5taW4ocGVyY2VudCwgMSk7XG5cbiAgICAgICAgICAgIHZhciBlYXNpbmcgPSB0aGlzLmVhc2luZztcbiAgICAgICAgICAgIHZhciBlYXNpbmdGdW5jID0gdHlwZW9mIGVhc2luZyA9PSAnc3RyaW5nJyA/IGVhc2luZ0Z1bmNzW2Vhc2luZ10gOiBlYXNpbmc7XG4gICAgICAgICAgICB2YXIgc2NoZWR1bGUgPSB0eXBlb2YgZWFzaW5nRnVuYyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgID8gZWFzaW5nRnVuYyhwZXJjZW50KVxuICAgICAgICAgICAgICAgIDogcGVyY2VudDtcblxuICAgICAgICAgICAgdGhpcy5maXJlKCdmcmFtZScsIHNjaGVkdWxlKTtcblxuICAgICAgICAgICAgLy8g57uT5p2fXG4gICAgICAgICAgICBpZiAocGVyY2VudCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubG9vcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3RhcnQgKGdsb2JhbFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyDph43mlrDlvIDlp4vlkajmnJ9cbiAgICAgICAgICAgICAgICAgICAgLy8g5oqb5Ye66ICM5LiN5piv55u05o6l6LCD55So5LqL5Lu255u05YiwIHN0YWdlLnVwZGF0ZSDlkI7lho3nu5/kuIDosIPnlKjov5nkupvkuovku7ZcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdyZXN0YXJ0JztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyDliqjnlLvlrozmiJDlsIbov5nkuKrmjqfliLblmajmoIfor4bkuLrlvoXliKDpmaRcbiAgICAgICAgICAgICAgICAvLyDlnKhBbmltYXRpb24udXBkYXRl5Lit6L+b6KGM5om56YeP5Yig6ZmkXG4gICAgICAgICAgICAgICAgdGhpcy5fbmVlZHNSZW1vdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiAnZGVzdHJveSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlc3RhcnQ6IGZ1bmN0aW9uIChnbG9iYWxUaW1lKSB7XG4gICAgICAgICAgICB2YXIgcmVtYWluZGVyID0gKGdsb2JhbFRpbWUgLSB0aGlzLl9zdGFydFRpbWUpICUgdGhpcy5fbGlmZTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IGdsb2JhbFRpbWUgLSByZW1haW5kZXIgKyB0aGlzLmdhcDtcblxuICAgICAgICAgICAgdGhpcy5fbmVlZHNSZW1vdmUgPSBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBmaXJlOiBmdW5jdGlvbihldmVudFR5cGUsIGFyZykge1xuICAgICAgICAgICAgZXZlbnRUeXBlID0gJ29uJyArIGV2ZW50VHlwZTtcbiAgICAgICAgICAgIGlmICh0aGlzW2V2ZW50VHlwZV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzW2V2ZW50VHlwZV0odGhpcy5fdGFyZ2V0LCBhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBDbGlwO1xufSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL3pyZW5kZXIvYW5pbWF0aW9uL0NsaXAuanNcbiAqKiBtb2R1bGUgaWQgPSA0MVxuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiLyoqXG4gKiDnvJPliqjku6PnoIHmnaXoh6ogaHR0cHM6Ly9naXRodWIuY29tL3NvbGUvdHdlZW4uanMvYmxvYi9tYXN0ZXIvc3JjL1R3ZWVuLmpzXG4gKiBAc2VlIGh0dHA6Ly9zb2xlLmdpdGh1Yi5pby90d2Vlbi5qcy9leGFtcGxlcy8wM19ncmFwaHMuaHRtbFxuICogQGV4cG9ydHMgenJlbmRlci9hbmltYXRpb24vZWFzaW5nXG4gKi9cbmRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVhc2luZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGxpbmVhcjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBrO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBxdWFkcmF0aWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBrICogaztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHF1YWRyYXRpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBrICogKDIgLSBrKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHF1YWRyYXRpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiBrICogaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMC41ICogKC0tayAqIChrIC0gMikgLSAxKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDkuInmrKHmlrnnmoTnvJPliqjvvIh0XjPvvIlcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGN1YmljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gayAqIGsgKiBrO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgY3ViaWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gLS1rICogayAqIGsgKyAxO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgY3ViaWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiBrICsgMik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g5Zub5qyh5pa555qE57yT5Yqo77yIdF4077yJXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBxdWFydGljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gayAqIGsgKiBrICogaztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHF1YXJ0aWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gMSAtICgtLWsgKiBrICogayAqIGspO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgcXVhcnRpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiBrICogayAqIGsgKiBrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0wLjUgKiAoKGsgLT0gMikgKiBrICogayAqIGsgLSAyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDkupTmrKHmlrnnmoTnvJPliqjvvIh0XjXvvIlcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHF1aW50aWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBrICogayAqIGsgKiBrICogaztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHF1aW50aWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gLS1rICogayAqIGsgKiBrICogayArIDE7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBxdWludGljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogayAqIGsgKiBrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiBrICogayAqIGsgKyAyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDmraPlvKbmm7Lnur/nmoTnvJPliqjvvIhzaW4odCnvvIlcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHNpbnVzb2lkYWxJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiAxIC0gTWF0aC5jb3MoayAqIE1hdGguUEkgLyAyKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHNpbnVzb2lkYWxPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zaW4oayAqIE1hdGguUEkgLyAyKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHNpbnVzb2lkYWxJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoMSAtIE1hdGguY29zKE1hdGguUEkgKiBrKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g5oyH5pWw5puy57q/55qE57yT5Yqo77yIMl5077yJXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBleHBvbmVudGlhbEluOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIGsgPT09IDAgPyAwIDogTWF0aC5wb3coMTAyNCwgayAtIDEpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgZXhwb25lbnRpYWxPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gayA9PT0gMSA/IDEgOiAxIC0gTWF0aC5wb3coMiwgLTEwICogayk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBleHBvbmVudGlhbEluT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKGsgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIE1hdGgucG93KDEwMjQsIGsgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoLU1hdGgucG93KDIsIC0xMCAqIChrIC0gMSkpICsgMik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g5ZyG5b2i5puy57q/55qE57yT5Yqo77yIc3FydCgxLXReMinvvIlcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGNpcmN1bGFySW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gayAqIGspO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgY2lyY3VsYXJPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KDEgLSAoLS1rICogaykpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgY2lyY3VsYXJJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTAuNSAqIChNYXRoLnNxcnQoMSAtIGsgKiBrKSAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqIChNYXRoLnNxcnQoMSAtIChrIC09IDIpICogaykgKyAxKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDliJvlu7rnsbvkvLzkuo7lvLnnsKflnKjlgZzmraLliY3mnaXlm57mjK/ojaHnmoTliqjnlLtcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGVsYXN0aWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHZhciBzO1xuICAgICAgICAgICAgdmFyIGEgPSAwLjE7XG4gICAgICAgICAgICB2YXIgcCA9IDAuNDtcbiAgICAgICAgICAgIGlmIChrID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoayA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhIHx8IGEgPCAxKSB7XG4gICAgICAgICAgICAgICAgYSA9IDE7IHMgPSBwIC8gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHMgPSBwICogTWF0aC5hc2luKDEgLyBhKSAvICgyICogTWF0aC5QSSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLShhICogTWF0aC5wb3coMiwgMTAgKiAoayAtPSAxKSkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBlbGFzdGljT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgdmFyIHM7XG4gICAgICAgICAgICB2YXIgYSA9IDAuMTtcbiAgICAgICAgICAgIHZhciBwID0gMC40O1xuICAgICAgICAgICAgaWYgKGsgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWEgfHwgYSA8IDEpIHtcbiAgICAgICAgICAgICAgICBhID0gMTsgcyA9IHAgLyA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcyA9IHAgKiBNYXRoLmFzaW4oMSAvIGEpIC8gKDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoYSAqIE1hdGgucG93KDIsIC0xMCAqIGspICpcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSArIDEpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgZWxhc3RpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgdmFyIHM7XG4gICAgICAgICAgICB2YXIgYSA9IDAuMTtcbiAgICAgICAgICAgIHZhciBwID0gMC40O1xuICAgICAgICAgICAgaWYgKGsgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWEgfHwgYSA8IDEpIHtcbiAgICAgICAgICAgICAgICBhID0gMTsgcyA9IHAgLyA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcyA9IHAgKiBNYXRoLmFzaW4oMSAvIGEpIC8gKDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTAuNSAqIChhICogTWF0aC5wb3coMiwgMTAgKiAoayAtPSAxKSlcbiAgICAgICAgICAgICAgICAgICAgKiBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhICogTWF0aC5wb3coMiwgLTEwICogKGsgLT0gMSkpXG4gICAgICAgICAgICAgICAgICAgICogTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSAqIDAuNSArIDE7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvLyDlnKjmn5DkuIDliqjnlLvlvIDlp4vmsr/mjIfnpLrnmoTot6/lvoTov5vooYzliqjnlLvlpITnkIbliY3nqI3nqI3mlLblm57or6XliqjnlLvnmoTnp7vliqhcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGJhY2tJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgICAgICAgIHJldHVybiBrICogayAqICgocyArIDEpICogayAtIHMpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgYmFja091dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgICAgICAgIHJldHVybiAtLWsgKiBrICogKChzICsgMSkgKiBrICsgcykgKyAxO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgYmFja0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgdmFyIHMgPSAxLjcwMTU4ICogMS41MjU7XG4gICAgICAgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIChrICogayAqICgocyArIDEpICogayAtIHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogKChzICsgMSkgKiBrICsgcykgKyAyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDliJvlu7rlvLnot7PmlYjmnpxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGJvdW5jZUluOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIDEgLSBlYXNpbmcuYm91bmNlT3V0KDEgLSBrKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGJvdW5jZU91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmIChrIDwgKDEgLyAyLjc1KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiA3LjU2MjUgKiBrICogaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGsgPCAoMiAvIDIuNzUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC09ICgxLjUgLyAyLjc1KSkgKiBrICsgMC43NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGsgPCAoMi41IC8gMi43NSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNy41NjI1ICogKGsgLT0gKDIuMjUgLyAyLjc1KSkgKiBrICsgMC45Mzc1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC09ICgyLjYyNSAvIDIuNzUpKSAqIGsgKyAwLjk4NDM3NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGJvdW5jZUluT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKGsgPCAwLjUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWFzaW5nLmJvdW5jZUluKGsgKiAyKSAqIDAuNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlYXNpbmcuYm91bmNlT3V0KGsgKiAyIC0gMSkgKiAwLjUgKyAwLjU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGVhc2luZztcbn0pO1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL3pyZW5kZXIvYW5pbWF0aW9uL2Vhc2luZy5qc1xuICoqIG1vZHVsZSBpZCA9IDQyXG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCIvKipcbiAqIEBtb2R1bGUgenJlbmRlci90b29sL2NvbG9yXG4gKi9cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlKSB7XG5cbiAgICB2YXIga0NTU0NvbG9yVGFibGUgPSB7XG4gICAgICAgICd0cmFuc3BhcmVudCc6IFswLDAsMCwwXSwgJ2FsaWNlYmx1ZSc6IFsyNDAsMjQ4LDI1NSwxXSxcbiAgICAgICAgJ2FudGlxdWV3aGl0ZSc6IFsyNTAsMjM1LDIxNSwxXSwgJ2FxdWEnOiBbMCwyNTUsMjU1LDFdLFxuICAgICAgICAnYXF1YW1hcmluZSc6IFsxMjcsMjU1LDIxMiwxXSwgJ2F6dXJlJzogWzI0MCwyNTUsMjU1LDFdLFxuICAgICAgICAnYmVpZ2UnOiBbMjQ1LDI0NSwyMjAsMV0sICdiaXNxdWUnOiBbMjU1LDIyOCwxOTYsMV0sXG4gICAgICAgICdibGFjayc6IFswLDAsMCwxXSwgJ2JsYW5jaGVkYWxtb25kJzogWzI1NSwyMzUsMjA1LDFdLFxuICAgICAgICAnYmx1ZSc6IFswLDAsMjU1LDFdLCAnYmx1ZXZpb2xldCc6IFsxMzgsNDMsMjI2LDFdLFxuICAgICAgICAnYnJvd24nOiBbMTY1LDQyLDQyLDFdLCAnYnVybHl3b29kJzogWzIyMiwxODQsMTM1LDFdLFxuICAgICAgICAnY2FkZXRibHVlJzogWzk1LDE1OCwxNjAsMV0sICdjaGFydHJldXNlJzogWzEyNywyNTUsMCwxXSxcbiAgICAgICAgJ2Nob2NvbGF0ZSc6IFsyMTAsMTA1LDMwLDFdLCAnY29yYWwnOiBbMjU1LDEyNyw4MCwxXSxcbiAgICAgICAgJ2Nvcm5mbG93ZXJibHVlJzogWzEwMCwxNDksMjM3LDFdLCAnY29ybnNpbGsnOiBbMjU1LDI0OCwyMjAsMV0sXG4gICAgICAgICdjcmltc29uJzogWzIyMCwyMCw2MCwxXSwgJ2N5YW4nOiBbMCwyNTUsMjU1LDFdLFxuICAgICAgICAnZGFya2JsdWUnOiBbMCwwLDEzOSwxXSwgJ2RhcmtjeWFuJzogWzAsMTM5LDEzOSwxXSxcbiAgICAgICAgJ2Rhcmtnb2xkZW5yb2QnOiBbMTg0LDEzNCwxMSwxXSwgJ2RhcmtncmF5JzogWzE2OSwxNjksMTY5LDFdLFxuICAgICAgICAnZGFya2dyZWVuJzogWzAsMTAwLDAsMV0sICdkYXJrZ3JleSc6IFsxNjksMTY5LDE2OSwxXSxcbiAgICAgICAgJ2RhcmtraGFraSc6IFsxODksMTgzLDEwNywxXSwgJ2RhcmttYWdlbnRhJzogWzEzOSwwLDEzOSwxXSxcbiAgICAgICAgJ2RhcmtvbGl2ZWdyZWVuJzogWzg1LDEwNyw0NywxXSwgJ2RhcmtvcmFuZ2UnOiBbMjU1LDE0MCwwLDFdLFxuICAgICAgICAnZGFya29yY2hpZCc6IFsxNTMsNTAsMjA0LDFdLCAnZGFya3JlZCc6IFsxMzksMCwwLDFdLFxuICAgICAgICAnZGFya3NhbG1vbic6IFsyMzMsMTUwLDEyMiwxXSwgJ2RhcmtzZWFncmVlbic6IFsxNDMsMTg4LDE0MywxXSxcbiAgICAgICAgJ2RhcmtzbGF0ZWJsdWUnOiBbNzIsNjEsMTM5LDFdLCAnZGFya3NsYXRlZ3JheSc6IFs0Nyw3OSw3OSwxXSxcbiAgICAgICAgJ2RhcmtzbGF0ZWdyZXknOiBbNDcsNzksNzksMV0sICdkYXJrdHVycXVvaXNlJzogWzAsMjA2LDIwOSwxXSxcbiAgICAgICAgJ2Rhcmt2aW9sZXQnOiBbMTQ4LDAsMjExLDFdLCAnZGVlcHBpbmsnOiBbMjU1LDIwLDE0NywxXSxcbiAgICAgICAgJ2RlZXBza3libHVlJzogWzAsMTkxLDI1NSwxXSwgJ2RpbWdyYXknOiBbMTA1LDEwNSwxMDUsMV0sXG4gICAgICAgICdkaW1ncmV5JzogWzEwNSwxMDUsMTA1LDFdLCAnZG9kZ2VyYmx1ZSc6IFszMCwxNDQsMjU1LDFdLFxuICAgICAgICAnZmlyZWJyaWNrJzogWzE3OCwzNCwzNCwxXSwgJ2Zsb3JhbHdoaXRlJzogWzI1NSwyNTAsMjQwLDFdLFxuICAgICAgICAnZm9yZXN0Z3JlZW4nOiBbMzQsMTM5LDM0LDFdLCAnZnVjaHNpYSc6IFsyNTUsMCwyNTUsMV0sXG4gICAgICAgICdnYWluc2Jvcm8nOiBbMjIwLDIyMCwyMjAsMV0sICdnaG9zdHdoaXRlJzogWzI0OCwyNDgsMjU1LDFdLFxuICAgICAgICAnZ29sZCc6IFsyNTUsMjE1LDAsMV0sICdnb2xkZW5yb2QnOiBbMjE4LDE2NSwzMiwxXSxcbiAgICAgICAgJ2dyYXknOiBbMTI4LDEyOCwxMjgsMV0sICdncmVlbic6IFswLDEyOCwwLDFdLFxuICAgICAgICAnZ3JlZW55ZWxsb3cnOiBbMTczLDI1NSw0NywxXSwgJ2dyZXknOiBbMTI4LDEyOCwxMjgsMV0sXG4gICAgICAgICdob25leWRldyc6IFsyNDAsMjU1LDI0MCwxXSwgJ2hvdHBpbmsnOiBbMjU1LDEwNSwxODAsMV0sXG4gICAgICAgICdpbmRpYW5yZWQnOiBbMjA1LDkyLDkyLDFdLCAnaW5kaWdvJzogWzc1LDAsMTMwLDFdLFxuICAgICAgICAnaXZvcnknOiBbMjU1LDI1NSwyNDAsMV0sICdraGFraSc6IFsyNDAsMjMwLDE0MCwxXSxcbiAgICAgICAgJ2xhdmVuZGVyJzogWzIzMCwyMzAsMjUwLDFdLCAnbGF2ZW5kZXJibHVzaCc6IFsyNTUsMjQwLDI0NSwxXSxcbiAgICAgICAgJ2xhd25ncmVlbic6IFsxMjQsMjUyLDAsMV0sICdsZW1vbmNoaWZmb24nOiBbMjU1LDI1MCwyMDUsMV0sXG4gICAgICAgICdsaWdodGJsdWUnOiBbMTczLDIxNiwyMzAsMV0sICdsaWdodGNvcmFsJzogWzI0MCwxMjgsMTI4LDFdLFxuICAgICAgICAnbGlnaHRjeWFuJzogWzIyNCwyNTUsMjU1LDFdLCAnbGlnaHRnb2xkZW5yb2R5ZWxsb3cnOiBbMjUwLDI1MCwyMTAsMV0sXG4gICAgICAgICdsaWdodGdyYXknOiBbMjExLDIxMSwyMTEsMV0sICdsaWdodGdyZWVuJzogWzE0NCwyMzgsMTQ0LDFdLFxuICAgICAgICAnbGlnaHRncmV5JzogWzIxMSwyMTEsMjExLDFdLCAnbGlnaHRwaW5rJzogWzI1NSwxODIsMTkzLDFdLFxuICAgICAgICAnbGlnaHRzYWxtb24nOiBbMjU1LDE2MCwxMjIsMV0sICdsaWdodHNlYWdyZWVuJzogWzMyLDE3OCwxNzAsMV0sXG4gICAgICAgICdsaWdodHNreWJsdWUnOiBbMTM1LDIwNiwyNTAsMV0sICdsaWdodHNsYXRlZ3JheSc6IFsxMTksMTM2LDE1MywxXSxcbiAgICAgICAgJ2xpZ2h0c2xhdGVncmV5JzogWzExOSwxMzYsMTUzLDFdLCAnbGlnaHRzdGVlbGJsdWUnOiBbMTc2LDE5NiwyMjIsMV0sXG4gICAgICAgICdsaWdodHllbGxvdyc6IFsyNTUsMjU1LDIyNCwxXSwgJ2xpbWUnOiBbMCwyNTUsMCwxXSxcbiAgICAgICAgJ2xpbWVncmVlbic6IFs1MCwyMDUsNTAsMV0sICdsaW5lbic6IFsyNTAsMjQwLDIzMCwxXSxcbiAgICAgICAgJ21hZ2VudGEnOiBbMjU1LDAsMjU1LDFdLCAnbWFyb29uJzogWzEyOCwwLDAsMV0sXG4gICAgICAgICdtZWRpdW1hcXVhbWFyaW5lJzogWzEwMiwyMDUsMTcwLDFdLCAnbWVkaXVtYmx1ZSc6IFswLDAsMjA1LDFdLFxuICAgICAgICAnbWVkaXVtb3JjaGlkJzogWzE4Niw4NSwyMTEsMV0sICdtZWRpdW1wdXJwbGUnOiBbMTQ3LDExMiwyMTksMV0sXG4gICAgICAgICdtZWRpdW1zZWFncmVlbic6IFs2MCwxNzksMTEzLDFdLCAnbWVkaXVtc2xhdGVibHVlJzogWzEyMywxMDQsMjM4LDFdLFxuICAgICAgICAnbWVkaXVtc3ByaW5nZ3JlZW4nOiBbMCwyNTAsMTU0LDFdLCAnbWVkaXVtdHVycXVvaXNlJzogWzcyLDIwOSwyMDQsMV0sXG4gICAgICAgICdtZWRpdW12aW9sZXRyZWQnOiBbMTk5LDIxLDEzMywxXSwgJ21pZG5pZ2h0Ymx1ZSc6IFsyNSwyNSwxMTIsMV0sXG4gICAgICAgICdtaW50Y3JlYW0nOiBbMjQ1LDI1NSwyNTAsMV0sICdtaXN0eXJvc2UnOiBbMjU1LDIyOCwyMjUsMV0sXG4gICAgICAgICdtb2NjYXNpbic6IFsyNTUsMjI4LDE4MSwxXSwgJ25hdmFqb3doaXRlJzogWzI1NSwyMjIsMTczLDFdLFxuICAgICAgICAnbmF2eSc6IFswLDAsMTI4LDFdLCAnb2xkbGFjZSc6IFsyNTMsMjQ1LDIzMCwxXSxcbiAgICAgICAgJ29saXZlJzogWzEyOCwxMjgsMCwxXSwgJ29saXZlZHJhYic6IFsxMDcsMTQyLDM1LDFdLFxuICAgICAgICAnb3JhbmdlJzogWzI1NSwxNjUsMCwxXSwgJ29yYW5nZXJlZCc6IFsyNTUsNjksMCwxXSxcbiAgICAgICAgJ29yY2hpZCc6IFsyMTgsMTEyLDIxNCwxXSwgJ3BhbGVnb2xkZW5yb2QnOiBbMjM4LDIzMiwxNzAsMV0sXG4gICAgICAgICdwYWxlZ3JlZW4nOiBbMTUyLDI1MSwxNTIsMV0sICdwYWxldHVycXVvaXNlJzogWzE3NSwyMzgsMjM4LDFdLFxuICAgICAgICAncGFsZXZpb2xldHJlZCc6IFsyMTksMTEyLDE0NywxXSwgJ3BhcGF5YXdoaXAnOiBbMjU1LDIzOSwyMTMsMV0sXG4gICAgICAgICdwZWFjaHB1ZmYnOiBbMjU1LDIxOCwxODUsMV0sICdwZXJ1JzogWzIwNSwxMzMsNjMsMV0sXG4gICAgICAgICdwaW5rJzogWzI1NSwxOTIsMjAzLDFdLCAncGx1bSc6IFsyMjEsMTYwLDIyMSwxXSxcbiAgICAgICAgJ3Bvd2RlcmJsdWUnOiBbMTc2LDIyNCwyMzAsMV0sICdwdXJwbGUnOiBbMTI4LDAsMTI4LDFdLFxuICAgICAgICAncmVkJzogWzI1NSwwLDAsMV0sICdyb3N5YnJvd24nOiBbMTg4LDE0MywxNDMsMV0sXG4gICAgICAgICdyb3lhbGJsdWUnOiBbNjUsMTA1LDIyNSwxXSwgJ3NhZGRsZWJyb3duJzogWzEzOSw2OSwxOSwxXSxcbiAgICAgICAgJ3NhbG1vbic6IFsyNTAsMTI4LDExNCwxXSwgJ3NhbmR5YnJvd24nOiBbMjQ0LDE2NCw5NiwxXSxcbiAgICAgICAgJ3NlYWdyZWVuJzogWzQ2LDEzOSw4NywxXSwgJ3NlYXNoZWxsJzogWzI1NSwyNDUsMjM4LDFdLFxuICAgICAgICAnc2llbm5hJzogWzE2MCw4Miw0NSwxXSwgJ3NpbHZlcic6IFsxOTIsMTkyLDE5MiwxXSxcbiAgICAgICAgJ3NreWJsdWUnOiBbMTM1LDIwNiwyMzUsMV0sICdzbGF0ZWJsdWUnOiBbMTA2LDkwLDIwNSwxXSxcbiAgICAgICAgJ3NsYXRlZ3JheSc6IFsxMTIsMTI4LDE0NCwxXSwgJ3NsYXRlZ3JleSc6IFsxMTIsMTI4LDE0NCwxXSxcbiAgICAgICAgJ3Nub3cnOiBbMjU1LDI1MCwyNTAsMV0sICdzcHJpbmdncmVlbic6IFswLDI1NSwxMjcsMV0sXG4gICAgICAgICdzdGVlbGJsdWUnOiBbNzAsMTMwLDE4MCwxXSwgJ3Rhbic6IFsyMTAsMTgwLDE0MCwxXSxcbiAgICAgICAgJ3RlYWwnOiBbMCwxMjgsMTI4LDFdLCAndGhpc3RsZSc6IFsyMTYsMTkxLDIxNiwxXSxcbiAgICAgICAgJ3RvbWF0byc6IFsyNTUsOTksNzEsMV0sICd0dXJxdW9pc2UnOiBbNjQsMjI0LDIwOCwxXSxcbiAgICAgICAgJ3Zpb2xldCc6IFsyMzgsMTMwLDIzOCwxXSwgJ3doZWF0JzogWzI0NSwyMjIsMTc5LDFdLFxuICAgICAgICAnd2hpdGUnOiBbMjU1LDI1NSwyNTUsMV0sICd3aGl0ZXNtb2tlJzogWzI0NSwyNDUsMjQ1LDFdLFxuICAgICAgICAneWVsbG93JzogWzI1NSwyNTUsMCwxXSwgJ3llbGxvd2dyZWVuJzogWzE1NCwyMDUsNTAsMV1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2xhbXBDc3NCeXRlKGkpIHsgIC8vIENsYW1wIHRvIGludGVnZXIgMCAuLiAyNTUuXG4gICAgICAgIGkgPSBNYXRoLnJvdW5kKGkpOyAgLy8gU2VlbXMgdG8gYmUgd2hhdCBDaHJvbWUgZG9lcyAodnMgdHJ1bmNhdGlvbikuXG4gICAgICAgIHJldHVybiBpIDwgMCA/IDAgOiBpID4gMjU1ID8gMjU1IDogaTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGFtcENzc0FuZ2xlKGkpIHsgIC8vIENsYW1wIHRvIGludGVnZXIgMCAuLiAzNjAuXG4gICAgICAgIGkgPSBNYXRoLnJvdW5kKGkpOyAgLy8gU2VlbXMgdG8gYmUgd2hhdCBDaHJvbWUgZG9lcyAodnMgdHJ1bmNhdGlvbikuXG4gICAgICAgIHJldHVybiBpIDwgMCA/IDAgOiBpID4gMzYwID8gMzYwIDogaTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGFtcENzc0Zsb2F0KGYpIHsgIC8vIENsYW1wIHRvIGZsb2F0IDAuMCAuLiAxLjAuXG4gICAgICAgIHJldHVybiBmIDwgMCA/IDAgOiBmID4gMSA/IDEgOiBmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQ3NzSW50KHN0cikgeyAgLy8gaW50IG9yIHBlcmNlbnRhZ2UuXG4gICAgICAgIGlmIChzdHIubGVuZ3RoICYmIHN0ci5jaGFyQXQoc3RyLmxlbmd0aCAtIDEpID09PSAnJScpIHtcbiAgICAgICAgICAgIHJldHVybiBjbGFtcENzc0J5dGUocGFyc2VGbG9hdChzdHIpIC8gMTAwICogMjU1KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xhbXBDc3NCeXRlKHBhcnNlSW50KHN0ciwgMTApKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNzc0Zsb2F0KHN0cikgeyAgLy8gZmxvYXQgb3IgcGVyY2VudGFnZS5cbiAgICAgICAgaWYgKHN0ci5sZW5ndGggJiYgc3RyLmNoYXJBdChzdHIubGVuZ3RoIC0gMSkgPT09ICclJykge1xuICAgICAgICAgICAgcmV0dXJuIGNsYW1wQ3NzRmxvYXQocGFyc2VGbG9hdChzdHIpIC8gMTAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xhbXBDc3NGbG9hdChwYXJzZUZsb2F0KHN0cikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCkge1xuICAgICAgICBpZiAoaCA8IDApIHtcbiAgICAgICAgICAgIGggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoID4gMSkge1xuICAgICAgICAgICAgaCAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGggKiA2IDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogaCAqIDY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGggKiAyIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIG0yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoICogMyA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBtMSArIChtMiAtIG0xKSAqICgyLzMgLSBoKSAqIDY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0xO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxlcnAoYSwgYiwgcCkge1xuICAgICAgICByZXR1cm4gYSArIChiIC0gYSkgKiBwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclN0clxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2UoY29sb3JTdHIpIHtcbiAgICAgICAgaWYgKCFjb2xvclN0cikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbG9yU3RyIG1heSBiZSBub3Qgc3RyaW5nXG4gICAgICAgIGNvbG9yU3RyID0gY29sb3JTdHIgKyAnJztcbiAgICAgICAgLy8gUmVtb3ZlIGFsbCB3aGl0ZXNwYWNlLCBub3QgY29tcGxpYW50LCBidXQgc2hvdWxkIGp1c3QgYmUgbW9yZSBhY2NlcHRpbmcuXG4gICAgICAgIHZhciBzdHIgPSBjb2xvclN0ci5yZXBsYWNlKC8gL2csICcnKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIC8vIENvbG9yIGtleXdvcmRzIChhbmQgdHJhbnNwYXJlbnQpIGxvb2t1cC5cbiAgICAgICAgaWYgKHN0ciBpbiBrQ1NTQ29sb3JUYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGtDU1NDb2xvclRhYmxlW3N0cl0uc2xpY2UoKTsgIC8vIGR1cC5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vICNhYmMgYW5kICNhYmMxMjMgc3ludGF4LlxuICAgICAgICBpZiAoc3RyLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgICAgIHZhciBpdiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDE2KTsgIC8vIFRPRE8oZGVhbm0pOiBTdHJpY3RlciBwYXJzaW5nLlxuICAgICAgICAgICAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgIC8vIENvdmVycyBOYU4uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICgoaXYgJiAweGYwMCkgPj4gNCkgfCAoKGl2ICYgMHhmMDApID4+IDgpLFxuICAgICAgICAgICAgICAgICAgICAoaXYgJiAweGYwKSB8ICgoaXYgJiAweGYwKSA+PiA0KSxcbiAgICAgICAgICAgICAgICAgICAgKGl2ICYgMHhmKSB8ICgoaXYgJiAweGYpIDw8IDQpLFxuICAgICAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0ci5sZW5ndGggPT09IDcpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7ICAvLyBUT0RPKGRlYW5tKTogU3RyaWN0ZXIgcGFyc2luZy5cbiAgICAgICAgICAgICAgICBpZiAoIShpdiA+PSAwICYmIGl2IDw9IDB4ZmZmZmZmKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47ICAvLyBDb3ZlcnMgTmFOLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAoaXYgJiAweGZmMDAwMCkgPj4gMTYsXG4gICAgICAgICAgICAgICAgICAgIChpdiAmIDB4ZmYwMCkgPj4gOCxcbiAgICAgICAgICAgICAgICAgICAgaXYgJiAweGZmLFxuICAgICAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcCA9IHN0ci5pbmRleE9mKCcoJyksIGVwID0gc3RyLmluZGV4T2YoJyknKTtcbiAgICAgICAgaWYgKG9wICE9PSAtMSAmJiBlcCArIDEgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBmbmFtZSA9IHN0ci5zdWJzdHIoMCwgb3ApO1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHN0ci5zdWJzdHIob3AgKyAxLCBlcCAtIChvcCArIDEpKS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgdmFyIGFscGhhID0gMTsgIC8vIFRvIGFsbG93IGNhc2UgZmFsbHRocm91Z2guXG4gICAgICAgICAgICBzd2l0Y2ggKGZuYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAncmdiYSc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYWxwaGEgPSBwYXJzZUNzc0Zsb2F0KHBhcmFtcy5wb3AoKSk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICAgICAgICAgIC8vIEZhbGwgdGhyb3VnaC5cbiAgICAgICAgICAgICAgICBjYXNlICdyZ2InOlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUNzc0ludChwYXJhbXNbMF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VDc3NJbnQocGFyYW1zWzFdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlQ3NzSW50KHBhcmFtc1syXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hzbGEnOlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtc1szXSA9IHBhcnNlQ3NzRmxvYXQocGFyYW1zWzNdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhzbGEycmdiYShwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hzbCc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhzbGEycmdiYShwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBoc2xhXG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IHJnYmFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoc2xhMnJnYmEoaHNsYSkge1xuICAgICAgICB2YXIgaCA9ICgoKHBhcnNlRmxvYXQoaHNsYVswXSkgJSAzNjApICsgMzYwKSAlIDM2MCkgLyAzNjA7ICAvLyAwIC4uIDFcbiAgICAgICAgLy8gTk9URShkZWFubSk6IEFjY29yZGluZyB0byB0aGUgQ1NTIHNwZWMgcy9sIHNob3VsZCBvbmx5IGJlXG4gICAgICAgIC8vIHBlcmNlbnRhZ2VzLCBidXQgd2UgZG9uJ3QgYm90aGVyIGFuZCBsZXQgZmxvYXQgb3IgcGVyY2VudGFnZS5cbiAgICAgICAgdmFyIHMgPSBwYXJzZUNzc0Zsb2F0KGhzbGFbMV0pO1xuICAgICAgICB2YXIgbCA9IHBhcnNlQ3NzRmxvYXQoaHNsYVsyXSk7XG4gICAgICAgIHZhciBtMiA9IGwgPD0gMC41ID8gbCAqIChzICsgMSkgOiBsICsgcyAtIGwgKiBzO1xuICAgICAgICB2YXIgbTEgPSBsICogMiAtIG0yO1xuXG4gICAgICAgIHZhciByZ2JhID0gW1xuICAgICAgICAgICAgY2xhbXBDc3NCeXRlKGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCArIDEgLyAzKSAqIDI1NSksXG4gICAgICAgICAgICBjbGFtcENzc0J5dGUoY3NzSHVlVG9SZ2IobTEsIG0yLCBoKSAqIDI1NSksXG4gICAgICAgICAgICBjbGFtcENzc0J5dGUoY3NzSHVlVG9SZ2IobTEsIG0yLCBoIC0gMSAvIDMpICogMjU1KVxuICAgICAgICBdO1xuXG4gICAgICAgIGlmIChoc2xhLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgcmdiYVszXSA9IGhzbGFbM107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmdiYTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSByZ2JhXG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IGhzbGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZ2JhMmhzbGEocmdiYSkge1xuICAgICAgICBpZiAoIXJnYmEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJHQiBmcm9tIDAgdG8gMjU1XG4gICAgICAgIHZhciBSID0gcmdiYVswXSAvIDI1NTtcbiAgICAgICAgdmFyIEcgPSByZ2JhWzFdIC8gMjU1O1xuICAgICAgICB2YXIgQiA9IHJnYmFbMl0gLyAyNTU7XG5cbiAgICAgICAgdmFyIHZNaW4gPSBNYXRoLm1pbihSLCBHLCBCKTsgLy8gTWluLiB2YWx1ZSBvZiBSR0JcbiAgICAgICAgdmFyIHZNYXggPSBNYXRoLm1heChSLCBHLCBCKTsgLy8gTWF4LiB2YWx1ZSBvZiBSR0JcbiAgICAgICAgdmFyIGRlbHRhID0gdk1heCAtIHZNaW47IC8vIERlbHRhIFJHQiB2YWx1ZVxuXG4gICAgICAgIHZhciBMID0gKHZNYXggKyB2TWluKSAvIDI7XG4gICAgICAgIHZhciBIO1xuICAgICAgICB2YXIgUztcbiAgICAgICAgLy8gSFNMIHJlc3VsdHMgZnJvbSAwIHRvIDFcbiAgICAgICAgaWYgKGRlbHRhID09PSAwKSB7XG4gICAgICAgICAgICBIID0gMDtcbiAgICAgICAgICAgIFMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKEwgPCAwLjUpIHtcbiAgICAgICAgICAgICAgICBTID0gZGVsdGEgLyAodk1heCArIHZNaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgUyA9IGRlbHRhIC8gKDIgLSB2TWF4IC0gdk1pbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkZWx0YVIgPSAoKCh2TWF4IC0gUikgLyA2KSArIChkZWx0YSAvIDIpKSAvIGRlbHRhO1xuICAgICAgICAgICAgdmFyIGRlbHRhRyA9ICgoKHZNYXggLSBHKSAvIDYpICsgKGRlbHRhIC8gMikpIC8gZGVsdGE7XG4gICAgICAgICAgICB2YXIgZGVsdGFCID0gKCgodk1heCAtIEIpIC8gNikgKyAoZGVsdGEgLyAyKSkgLyBkZWx0YTtcblxuICAgICAgICAgICAgaWYgKFIgPT09IHZNYXgpIHtcbiAgICAgICAgICAgICAgICBIID0gZGVsdGFCIC0gZGVsdGFHO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoRyA9PT0gdk1heCkge1xuICAgICAgICAgICAgICAgIEggPSAoMSAvIDMpICsgZGVsdGFSIC0gZGVsdGFCO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQiA9PT0gdk1heCkge1xuICAgICAgICAgICAgICAgIEggPSAoMiAvIDMpICsgZGVsdGFHIC0gZGVsdGFSO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoSCA8IDApIHtcbiAgICAgICAgICAgICAgICBIICs9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChIID4gMSkge1xuICAgICAgICAgICAgICAgIEggLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoc2xhID0gW0ggKiAzNjAsIFMsIExdO1xuXG4gICAgICAgIGlmIChyZ2JhWzNdICE9IG51bGwpIHtcbiAgICAgICAgICAgIGhzbGEucHVzaChyZ2JhWzNdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoc2xhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbFxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpZnQoY29sb3IsIGxldmVsKSB7XG4gICAgICAgIHZhciBjb2xvckFyciA9IHBhcnNlKGNvbG9yKTtcbiAgICAgICAgaWYgKGNvbG9yQXJyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsZXZlbCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JBcnJbaV0gPSBjb2xvckFycltpXSAqICgxIC0gbGV2ZWwpIHwgMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yQXJyW2ldID0gKCgyNTUgLSBjb2xvckFycltpXSkgKiBsZXZlbCArIGNvbG9yQXJyW2ldKSB8IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShjb2xvckFyciwgY29sb3JBcnIubGVuZ3RoID09PSA0ID8gJ3JnYmEnIDogJ3JnYicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9IZXgoY29sb3IsIGxldmVsKSB7XG4gICAgICAgIHZhciBjb2xvckFyciA9IHBhcnNlKGNvbG9yKTtcbiAgICAgICAgaWYgKGNvbG9yQXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gKCgxIDw8IDI0KSArIChjb2xvckFyclswXSA8PCAxNikgKyAoY29sb3JBcnJbMV0gPDwgOCkgKyAoK2NvbG9yQXJyWzJdKSkudG9TdHJpbmcoMTYpLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFwIHZhbHVlIHRvIGNvbG9yLiBGYXN0ZXIgdGhhbiBtYXBUb0NvbG9yIG1ldGhvZHMgYmVjYXVzZSBjb2xvciBpcyByZXByZXNlbnRlZCBieSByZ2JhIGFycmF5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5vcm1hbGl6ZWRWYWx1ZSBBIGZsb2F0IGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IGNvbG9ycyBMaXN0IG9mIHJnYmEgY29sb3IgYXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBbb3V0XSBNYXBwZWQgZ2JhIGNvbG9yIGFycmF5XG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICovXG4gICAgZnVuY3Rpb24gZmFzdE1hcFRvQ29sb3Iobm9ybWFsaXplZFZhbHVlLCBjb2xvcnMsIG91dCkge1xuICAgICAgICBpZiAoIShjb2xvcnMgJiYgY29sb3JzLmxlbmd0aClcbiAgICAgICAgICAgIHx8ICEobm9ybWFsaXplZFZhbHVlID49IDAgJiYgbm9ybWFsaXplZFZhbHVlIDw9IDEpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG91dCA9IG91dCB8fCBbMCwgMCwgMCwgMF07XG4gICAgICAgIHZhciB2YWx1ZSA9IG5vcm1hbGl6ZWRWYWx1ZSAqIChjb2xvcnMubGVuZ3RoIC0gMSk7XG4gICAgICAgIHZhciBsZWZ0SW5kZXggPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgICAgICAgdmFyIHJpZ2h0SW5kZXggPSBNYXRoLmNlaWwodmFsdWUpO1xuICAgICAgICB2YXIgbGVmdENvbG9yID0gY29sb3JzW2xlZnRJbmRleF07XG4gICAgICAgIHZhciByaWdodENvbG9yID0gY29sb3JzW3JpZ2h0SW5kZXhdO1xuICAgICAgICB2YXIgZHYgPSB2YWx1ZSAtIGxlZnRJbmRleDtcbiAgICAgICAgb3V0WzBdID0gY2xhbXBDc3NCeXRlKGxlcnAobGVmdENvbG9yWzBdLCByaWdodENvbG9yWzBdLCBkdikpO1xuICAgICAgICBvdXRbMV0gPSBjbGFtcENzc0J5dGUobGVycChsZWZ0Q29sb3JbMV0sIHJpZ2h0Q29sb3JbMV0sIGR2KSk7XG4gICAgICAgIG91dFsyXSA9IGNsYW1wQ3NzQnl0ZShsZXJwKGxlZnRDb2xvclsyXSwgcmlnaHRDb2xvclsyXSwgZHYpKTtcbiAgICAgICAgb3V0WzNdID0gY2xhbXBDc3NCeXRlKGxlcnAobGVmdENvbG9yWzNdLCByaWdodENvbG9yWzNdLCBkdikpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbm9ybWFsaXplZFZhbHVlIEEgZmxvYXQgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGNvbG9ycyBDb2xvciBsaXN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGZ1bGxPdXRwdXQgRGVmYXVsdCBmYWxzZS5cbiAgICAgKiBAcmV0dXJuIHsoc3RyaW5nfE9iamVjdCl9IFJlc3VsdCBjb2xvci4gSWYgZnVsbE91dHB1dCxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7Y29sb3I6IC4uLiwgbGVmdEluZGV4OiAuLi4sIHJpZ2h0SW5kZXg6IC4uLiwgdmFsdWU6IC4uLn0sXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBUb0NvbG9yKG5vcm1hbGl6ZWRWYWx1ZSwgY29sb3JzLCBmdWxsT3V0cHV0KSB7XG4gICAgICAgIGlmICghKGNvbG9ycyAmJiBjb2xvcnMubGVuZ3RoKVxuICAgICAgICAgICAgfHwgIShub3JtYWxpemVkVmFsdWUgPj0gMCAmJiBub3JtYWxpemVkVmFsdWUgPD0gMSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsdWUgPSBub3JtYWxpemVkVmFsdWUgKiAoY29sb3JzLmxlbmd0aCAtIDEpO1xuICAgICAgICB2YXIgbGVmdEluZGV4ID0gTWF0aC5mbG9vcih2YWx1ZSk7XG4gICAgICAgIHZhciByaWdodEluZGV4ID0gTWF0aC5jZWlsKHZhbHVlKTtcbiAgICAgICAgdmFyIGxlZnRDb2xvciA9IHBhcnNlKGNvbG9yc1tsZWZ0SW5kZXhdKTtcbiAgICAgICAgdmFyIHJpZ2h0Q29sb3IgPSBwYXJzZShjb2xvcnNbcmlnaHRJbmRleF0pO1xuICAgICAgICB2YXIgZHYgPSB2YWx1ZSAtIGxlZnRJbmRleDtcblxuICAgICAgICB2YXIgY29sb3IgPSBzdHJpbmdpZnkoXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgY2xhbXBDc3NCeXRlKGxlcnAobGVmdENvbG9yWzBdLCByaWdodENvbG9yWzBdLCBkdikpLFxuICAgICAgICAgICAgICAgIGNsYW1wQ3NzQnl0ZShsZXJwKGxlZnRDb2xvclsxXSwgcmlnaHRDb2xvclsxXSwgZHYpKSxcbiAgICAgICAgICAgICAgICBjbGFtcENzc0J5dGUobGVycChsZWZ0Q29sb3JbMl0sIHJpZ2h0Q29sb3JbMl0sIGR2KSksXG4gICAgICAgICAgICAgICAgY2xhbXBDc3NGbG9hdChsZXJwKGxlZnRDb2xvclszXSwgcmlnaHRDb2xvclszXSwgZHYpKVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICdyZ2JhJ1xuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBmdWxsT3V0cHV0XG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgbGVmdEluZGV4OiBsZWZ0SW5kZXgsXG4gICAgICAgICAgICAgICAgcmlnaHRJbmRleDogcmlnaHRJbmRleCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogY29sb3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBoIDAgfiAzNjAsIGlnbm9yZSB3aGVuIG51bGwuXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBzIDAgfiAxLCBpZ25vcmUgd2hlbiBudWxsLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gbCAwIH4gMSwgaWdub3JlIHdoZW4gbnVsbC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvbG9yIHN0cmluZyBpbiByZ2JhIGZvcm1hdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1vZGlmeUhTTChjb2xvciwgaCwgcywgbCkge1xuICAgICAgICBjb2xvciA9IHBhcnNlKGNvbG9yKTtcblxuICAgICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgICAgIGNvbG9yID0gcmdiYTJoc2xhKGNvbG9yKTtcbiAgICAgICAgICAgIGggIT0gbnVsbCAmJiAoY29sb3JbMF0gPSBjbGFtcENzc0FuZ2xlKGgpKTtcbiAgICAgICAgICAgIHMgIT0gbnVsbCAmJiAoY29sb3JbMV0gPSBwYXJzZUNzc0Zsb2F0KHMpKTtcbiAgICAgICAgICAgIGwgIT0gbnVsbCAmJiAoY29sb3JbMl0gPSBwYXJzZUNzc0Zsb2F0KGwpKTtcblxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShoc2xhMnJnYmEoY29sb3IpLCAncmdiYScpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBhbHBoYSAwIH4gMVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gQ29sb3Igc3RyaW5nIGluIHJnYmEgZm9ybWF0LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gbW9kaWZ5QWxwaGEoY29sb3IsIGFscGhhKSB7XG4gICAgICAgIGNvbG9yID0gcGFyc2UoY29sb3IpO1xuXG4gICAgICAgIGlmIChjb2xvciAmJiBhbHBoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb2xvclszXSA9IGNsYW1wQ3NzRmxvYXQoYWxwaGEpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShjb2xvciwgJ3JnYmEnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGNvbG9ycyBDb2xvciBsaXN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlICdyZ2JhJywgJ2hzdmEnLCAuLi5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFJlc3VsdCBjb2xvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHJpbmdpZnkoYXJyQ29sb3IsIHR5cGUpIHtcbiAgICAgICAgdmFyIGNvbG9yU3RyID0gYXJyQ29sb3JbMF0gKyAnLCcgKyBhcnJDb2xvclsxXSArICcsJyArIGFyckNvbG9yWzJdO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3JnYmEnIHx8IHR5cGUgPT09ICdoc3ZhJyB8fCB0eXBlID09PSAnaHNsYScpIHtcbiAgICAgICAgICAgIGNvbG9yU3RyICs9ICcsJyArIGFyckNvbG9yWzNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlICsgJygnICsgY29sb3JTdHIgKyAnKSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGFyc2U6IHBhcnNlLFxuICAgICAgICBsaWZ0OiBsaWZ0LFxuICAgICAgICB0b0hleDogdG9IZXgsXG4gICAgICAgIGZhc3RNYXBUb0NvbG9yOiBmYXN0TWFwVG9Db2xvcixcbiAgICAgICAgbWFwVG9Db2xvcjogbWFwVG9Db2xvcixcbiAgICAgICAgbW9kaWZ5SFNMOiBtb2RpZnlIU0wsXG4gICAgICAgIG1vZGlmeUFscGhhOiBtb2RpZnlBbHBoYSxcbiAgICAgICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlcbiAgICB9O1xufSk7XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvenJlbmRlci90b29sL2NvbG9yLmpzXG4gKiogbW9kdWxlIGlkID0gNDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsImRlZmluZShcbiAgICBmdW5jdGlvbiAocmVxdWlyZSkge1xuICAgICAgICB2YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29uZmlnJyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBleHBvcnRzIHpyZW5kZXIvdG9vbC9sb2dcbiAgICAgICAgICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnLmRlYnVnTW9kZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZy5kZWJ1Z01vZGUgPT0gMSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgaW4gYXJndW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihhcmd1bWVudHNba10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZy5kZWJ1Z01vZGUgPiAxKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiBhcmd1bWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYXJndW1lbnRzW2tdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLyogZm9yIGRlYnVnXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihtZXMpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3cm9uZy1tZXNzYWdlJykuaW5uZXJIVE1MID1cbiAgICAgICAgICAgICAgICBtZXMgKyAnICcgKyAobmV3IERhdGUoKSAtIDApXG4gICAgICAgICAgICAgICAgKyAnPGJyLz4nIFxuICAgICAgICAgICAgICAgICsgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dyb25nLW1lc3NhZ2UnKS5pbm5lckhUTUw7XG4gICAgICAgIH07XG4gICAgICAgICovXG4gICAgfVxuKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvenJlbmRlci9jb3JlL2xvZy5qc1xuICoqIG1vZHVsZSBpZCA9IDQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCJkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgIHZhciBkcHIgPSAxO1xuICAgIC8vIElmIGluIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZHByID0gTWF0aC5tYXgod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSwgMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNvbmZpZ+m7mOiupOmFjee9rumhuVxuICAgICAqIEBleHBvcnRzIHpyZW5kZXIvY29uZmlnXG4gICAgICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gICAgICovXG4gICAgdmFyIGNvbmZpZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRlYnVn5pel5b+X6YCJ6aG577yaY2F0Y2hCcnVzaEV4Y2VwdGlvbuS4unRydWXkuIvmnInmlYhcbiAgICAgICAgICogMCA6IOS4jeeUn+aIkGRlYnVn5pWw5o2u77yM5Y+R5biD55SoXG4gICAgICAgICAqIDEgOiDlvILluLjmipvlh7rvvIzosIPor5XnlKhcbiAgICAgICAgICogMiA6IOaOp+WItuWPsOi+k+WHuu+8jOiwg+ivleeUqFxuICAgICAgICAgKi9cbiAgICAgICAgZGVidWdNb2RlOiAwLFxuXG4gICAgICAgIC8vIHJldGluYSDlsY/luZXkvJjljJZcbiAgICAgICAgZGV2aWNlUGl4ZWxSYXRpbzogZHByXG4gICAgfTtcbiAgICByZXR1cm4gY29uZmlnO1xufSk7XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvenJlbmRlci9jb25maWcuanNcbiAqKiBtb2R1bGUgaWQgPSA0NVxuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cbiAgICB2YXIgR3JvdXAgPSByZXF1aXJlKCd6cmVuZGVyL2NvbnRhaW5lci9Hcm91cCcpO1xuICAgIHZhciBjb21wb25lbnRVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9jb21wb25lbnQnKTtcbiAgICB2YXIgY2xhenpVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9jbGF6eicpO1xuXG4gICAgZnVuY3Rpb24gQ2hhcnQoKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb250YWluZXIvR3JvdXB9XG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ncm91cCA9IG5ldyBHcm91cCgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudWlkID0gY29tcG9uZW50VXRpbC5nZXRVSUQoJ3ZpZXdDaGFydCcpO1xuICAgIH1cblxuICAgIENoYXJ0LnByb3RvdHlwZSA9IHtcblxuICAgICAgICB0eXBlOiAnY2hhcnQnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0IHRoZSBjaGFydFxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAgICAgICAgICovXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIChlY01vZGVsLCBhcGkpIHt9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXIgdGhlIGNoYXJ0XG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc30gc2VyaWVzTW9kZWxcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gcGF5bG9hZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge30sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhpZ2hsaWdodCBzZXJpZXMgb3Igc3BlY2lmaWVkIGRhdGEgaXRlbVxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXN9IHNlcmllc01vZGVsXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHBheWxvYWRcbiAgICAgICAgICovXG4gICAgICAgIGhpZ2hsaWdodDogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICAgICAgICAgIHRvZ2dsZUhpZ2hsaWdodChzZXJpZXNNb2RlbC5nZXREYXRhKCksIHBheWxvYWQsICdlbXBoYXNpcycpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEb3ducGxheSBzZXJpZXMgb3Igc3BlY2lmaWVkIGRhdGEgaXRlbVxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9TZXJpZXN9IHNlcmllc01vZGVsXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHBheWxvYWRcbiAgICAgICAgICovXG4gICAgICAgIGRvd25wbGF5OiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgICAgICAgICAgdG9nZ2xlSGlnaGxpZ2h0KHNlcmllc01vZGVsLmdldERhdGEoKSwgcGF5bG9hZCwgJ25vcm1hbCcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgc2VsZlxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfSBhcGlcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcG9zZSBzZWxmXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL21vZGVsL0dsb2JhbH0gZWNNb2RlbFxuICAgICAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge31cbiAgICB9O1xuXG4gICAgdmFyIGNoYXJ0UHJvdG8gPSBDaGFydC5wcm90b3R5cGU7XG4gICAgY2hhcnRQcm90by51cGRhdGVWaWV3XG4gICAgICAgID0gY2hhcnRQcm90by51cGRhdGVMYXlvdXRcbiAgICAgICAgPSBjaGFydFByb3RvLnVwZGF0ZVZpc3VhbFxuICAgICAgICA9IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcihzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKTtcbiAgICAgICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCBzdGF0ZSBvZiBzaW5nbGUgZWxlbWVudFxuICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBzdGF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVsU2V0U3RhdGUoZWwsIHN0YXRlKSB7XG4gICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgZWwudHJpZ2dlcihzdGF0ZSk7XG4gICAgICAgICAgICBpZiAoZWwudHlwZSA9PT0gJ2dyb3VwJykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWwuY2hpbGRDb3VudCgpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZWxTZXRTdGF0ZShlbC5jaGlsZEF0KGkpLCBzdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gcGF5bG9hZFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gc3RhdGUgJ25vcm1hbCd8J2VtcGhhc2lzJ1xuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvZ2dsZUhpZ2hsaWdodChkYXRhLCBwYXlsb2FkLCBzdGF0ZSkge1xuICAgICAgICB2YXIgZGF0YUluZGV4ID0gcGF5bG9hZCAmJiBwYXlsb2FkLmRhdGFJbmRleDtcbiAgICAgICAgdmFyIG5hbWUgPSBwYXlsb2FkICYmIHBheWxvYWQubmFtZTtcblxuICAgICAgICBpZiAoZGF0YUluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBkYXRhSW5kaWNlcyA9IGRhdGFJbmRleCBpbnN0YW5jZW9mIEFycmF5ID8gZGF0YUluZGV4IDogW2RhdGFJbmRleF07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YUluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBlbFNldFN0YXRlKGRhdGEuZ2V0SXRlbUdyYXBoaWNFbChkYXRhSW5kaWNlc1tpXSksIHN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgbmFtZXMgPSBuYW1lIGluc3RhbmNlb2YgQXJyYXkgPyBuYW1lIDogW25hbWVdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFJbmRleCA9IGRhdGEuaW5kZXhPZk5hbWUobmFtZXNbaV0pO1xuICAgICAgICAgICAgICAgIGVsU2V0U3RhdGUoZGF0YS5nZXRJdGVtR3JhcGhpY0VsKGRhdGFJbmRleCksIHN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgZWxTZXRTdGF0ZShlbCwgc3RhdGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFbmFibGUgQ2hhcnQuZXh0ZW5kLlxuICAgIGNsYXp6VXRpbC5lbmFibGVDbGFzc0V4dGVuZChDaGFydCk7XG5cbiAgICAvLyBBZGQgY2FwYWJpbGl0eSBvZiByZWdpc3RlckNsYXNzLCBnZXRDbGFzcywgaGFzQ2xhc3MsIHJlZ2lzdGVyU3ViVHlwZURlZmF1bHRlciBhbmQgc28gb24uXG4gICAgY2xhenpVdGlsLmVuYWJsZUNsYXNzTWFuYWdlbWVudChDaGFydCwge3JlZ2lzdGVyV2hlbkV4dGVuZDogdHJ1ZX0pO1xuXG4gICAgcmV0dXJuIENoYXJ0O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC9lY2hhcnRzL3ZpZXcvQ2hhcnQuanNcbiAqKiBtb2R1bGUgaWQgPSA0NlxuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2NvcmUvdXRpbCcpO1xuXG4gICAgdmFyIHBhdGhUb29sID0gcmVxdWlyZSgnenJlbmRlci90b29sL3BhdGgnKTtcbiAgICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xuICAgIHZhciBQYXRoID0gcmVxdWlyZSgnenJlbmRlci9ncmFwaGljL1BhdGgnKTtcbiAgICB2YXIgY29sb3JUb29sID0gcmVxdWlyZSgnenJlbmRlci90b29sL2NvbG9yJyk7XG4gICAgdmFyIG1hdHJpeCA9IHJlcXVpcmUoJ3pyZW5kZXIvY29yZS9tYXRyaXgnKTtcbiAgICB2YXIgdmVjdG9yID0gcmVxdWlyZSgnenJlbmRlci9jb3JlL3ZlY3RvcicpO1xuICAgIHZhciBHcmFkaWVudCA9IHJlcXVpcmUoJ3pyZW5kZXIvZ3JhcGhpYy9HcmFkaWVudCcpO1xuXG4gICAgdmFyIGdyYXBoaWMgPSB7fTtcblxuICAgIGdyYXBoaWMuR3JvdXAgPSByZXF1aXJlKCd6cmVuZGVyL2NvbnRhaW5lci9Hcm91cCcpO1xuXG4gICAgZ3JhcGhpYy5JbWFnZSA9IHJlcXVpcmUoJ3pyZW5kZXIvZ3JhcGhpYy9JbWFnZScpO1xuXG4gICAgZ3JhcGhpYy5UZXh0ID0gcmVxdWlyZSgnenJlbmRlci9ncmFwaGljL1RleHQnKTtcblxuICAgIGdyYXBoaWMuQ2lyY2xlID0gcmVxdWlyZSgnenJlbmRlci9ncmFwaGljL3NoYXBlL0NpcmNsZScpO1xuXG4gICAgZ3JhcGhpYy5TZWN0b3IgPSByZXF1aXJlKCd6cmVuZGVyL2dyYXBoaWMvc2hhcGUvU2VjdG9yJyk7XG5cbiAgICBncmFwaGljLlJpbmcgPSByZXF1aXJlKCd6cmVuZGVyL2dyYXBoaWMvc2hhcGUvUmluZycpO1xuXG4gICAgZ3JhcGhpYy5Qb2x5Z29uID0gcmVxdWlyZSgnenJlbmRlci9ncmFwaGljL3NoYXBlL1BvbHlnb24nKTtcblxuICAgIGdyYXBoaWMuUG9seWxpbmUgPSByZXF1aXJlKCd6cmVuZGVyL2dyYXBoaWMvc2hhcGUvUG9seWxpbmUnKTtcblxuICAgIGdyYXBoaWMuUmVjdCA9IHJlcXVpcmUoJ3pyZW5kZXIvZ3JhcGhpYy9zaGFwZS9SZWN0Jyk7XG5cbiAgICBncmFwaGljLkxpbmUgPSByZXF1aXJlKCd6cmVuZGVyL2dyYXBoaWMvc2hhcGUvTGluZScpO1xuXG4gICAgZ3JhcGhpYy5CZXppZXJDdXJ2ZSA9IHJlcXVpcmUoJ3pyZW5kZXIvZ3JhcGhpYy9zaGFwZS9CZXppZXJDdXJ2ZScpO1xuXG4gICAgZ3JhcGhpYy5BcmMgPSByZXF1aXJlKCd6cmVuZGVyL2dyYXBoaWMvc2hhcGUvQXJjJyk7XG5cbiAgICBncmFwaGljLkNvbXBvdW5kUGF0aCA9IHJlcXVpcmUoJ3pyZW5kZXIvZ3JhcGhpYy9Db21wb3VuZFBhdGgnKTtcblxuICAgIGdyYXBoaWMuTGluZWFyR3JhZGllbnQgPSByZXF1aXJlKCd6cmVuZGVyL2dyYXBoaWMvTGluZWFyR3JhZGllbnQnKTtcblxuICAgIGdyYXBoaWMuUmFkaWFsR3JhZGllbnQgPSByZXF1aXJlKCd6cmVuZGVyL2dyYXBoaWMvUmFkaWFsR3JhZGllbnQnKTtcblxuICAgIGdyYXBoaWMuQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnenJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdCcpO1xuXG4gICAgLyoqXG4gICAgICogRXh0ZW5kIHNoYXBlIHdpdGggcGFyYW1ldGVyc1xuICAgICAqL1xuICAgIGdyYXBoaWMuZXh0ZW5kU2hhcGUgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICByZXR1cm4gUGF0aC5leHRlbmQob3B0cyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEV4dGVuZCBwYXRoXG4gICAgICovXG4gICAgZ3JhcGhpYy5leHRlbmRQYXRoID0gZnVuY3Rpb24gKHBhdGhEYXRhLCBvcHRzKSB7XG4gICAgICAgIHJldHVybiBwYXRoVG9vbC5leHRlbmRGcm9tU3RyaW5nKHBhdGhEYXRhLCBvcHRzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgcGF0aCBlbGVtZW50IGZyb20gcGF0aCBkYXRhIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoRGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH0gcmVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbGF5b3V0PWNvdmVyXSAnY2VudGVyJyBvciAnY292ZXInXG4gICAgICovXG4gICAgZ3JhcGhpYy5tYWtlUGF0aCA9IGZ1bmN0aW9uIChwYXRoRGF0YSwgb3B0cywgcmVjdCwgbGF5b3V0KSB7XG4gICAgICAgIHZhciBwYXRoID0gcGF0aFRvb2wuY3JlYXRlRnJvbVN0cmluZyhwYXRoRGF0YSwgb3B0cyk7XG4gICAgICAgIHZhciBib3VuZGluZ1JlY3QgPSBwYXRoLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICBpZiAocmVjdCkge1xuICAgICAgICAgICAgdmFyIGFzcGVjdCA9IGJvdW5kaW5nUmVjdC53aWR0aCAvIGJvdW5kaW5nUmVjdC5oZWlnaHQ7XG5cbiAgICAgICAgICAgIGlmIChsYXlvdXQgPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICAgICAgLy8gU2V0IHJlY3QgdG8gY2VudGVyLCBrZWVwIHdpZHRoIC8gaGVpZ2h0IHJhdGlvLlxuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IHJlY3QuaGVpZ2h0ICogYXNwZWN0O1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKHdpZHRoIDw9IHJlY3Qud2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IHdpZHRoIC8gYXNwZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY3ggPSByZWN0LnggKyByZWN0LndpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICB2YXIgY3kgPSByZWN0LnkgKyByZWN0LmhlaWdodCAvIDI7XG5cbiAgICAgICAgICAgICAgICByZWN0LnggPSBjeCAtIHdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICByZWN0LnkgPSBjeSAtIGhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgcmVjdC53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgIHJlY3QuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZVBhdGgocGF0aCwgcmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfTtcblxuICAgIGdyYXBoaWMubWVyZ2VQYXRoID0gcGF0aFRvb2wubWVyZ2VQYXRoLFxuXG4gICAgLyoqXG4gICAgICogUmVzaXplIGEgcGF0aCB0byBmaXQgdGhlIHJlY3RcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aH0gcGF0aFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0XG4gICAgICovXG4gICAgZ3JhcGhpYy5yZXNpemVQYXRoID0gZnVuY3Rpb24gKHBhdGgsIHJlY3QpIHtcbiAgICAgICAgaWYgKCFwYXRoLmFwcGx5VHJhbnNmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGF0aFJlY3QgPSBwYXRoLmdldEJvdW5kaW5nUmVjdCgpO1xuXG4gICAgICAgIHZhciBtID0gcGF0aFJlY3QuY2FsY3VsYXRlVHJhbnNmb3JtKHJlY3QpO1xuXG4gICAgICAgIHBhdGguYXBwbHlUcmFuc2Zvcm0obSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN1YiBwaXhlbCBvcHRpbWl6ZSBsaW5lIGZvciBjYW52YXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW0uc2hhcGVdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS54MV1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLnkxXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUueDJdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS55Ml1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtLnN0eWxlXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc3R5bGUubGluZVdpZHRoXVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gTW9kaWZpZWQgcGFyYW1cbiAgICAgKi9cbiAgICBncmFwaGljLnN1YlBpeGVsT3B0aW1pemVMaW5lID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgIHZhciBzdWJQaXhlbE9wdGltaXplID0gZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplO1xuICAgICAgICB2YXIgc2hhcGUgPSBwYXJhbS5zaGFwZTtcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHBhcmFtLnN0eWxlLmxpbmVXaWR0aDtcblxuICAgICAgICBpZiAocm91bmQoc2hhcGUueDEgKiAyKSA9PT0gcm91bmQoc2hhcGUueDIgKiAyKSkge1xuICAgICAgICAgICAgc2hhcGUueDEgPSBzaGFwZS54MiA9IHN1YlBpeGVsT3B0aW1pemUoc2hhcGUueDEsIGxpbmVXaWR0aCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvdW5kKHNoYXBlLnkxICogMikgPT09IHJvdW5kKHNoYXBlLnkyICogMikpIHtcbiAgICAgICAgICAgIHNoYXBlLnkxID0gc2hhcGUueTIgPSBzdWJQaXhlbE9wdGltaXplKHNoYXBlLnkxLCBsaW5lV2lkdGgsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3ViIHBpeGVsIG9wdGltaXplIHJlY3QgZm9yIGNhbnZhc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbS5zaGFwZV1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLnhdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS55XVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUud2lkdGhdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbS5zdHlsZV1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnN0eWxlLmxpbmVXaWR0aF1cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE1vZGlmaWVkIHBhcmFtXG4gICAgICovXG4gICAgZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplUmVjdCA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICB2YXIgc3ViUGl4ZWxPcHRpbWl6ZSA9IGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZTtcbiAgICAgICAgdmFyIHNoYXBlID0gcGFyYW0uc2hhcGU7XG4gICAgICAgIHZhciBsaW5lV2lkdGggPSBwYXJhbS5zdHlsZS5saW5lV2lkdGg7XG4gICAgICAgIHZhciBvcmlnaW5YID0gc2hhcGUueDtcbiAgICAgICAgdmFyIG9yaWdpblkgPSBzaGFwZS55O1xuICAgICAgICB2YXIgb3JpZ2luV2lkdGggPSBzaGFwZS53aWR0aDtcbiAgICAgICAgdmFyIG9yaWdpbkhlaWdodCA9IHNoYXBlLmhlaWdodDtcbiAgICAgICAgc2hhcGUueCA9IHN1YlBpeGVsT3B0aW1pemUoc2hhcGUueCwgbGluZVdpZHRoLCB0cnVlKTtcbiAgICAgICAgc2hhcGUueSA9IHN1YlBpeGVsT3B0aW1pemUoc2hhcGUueSwgbGluZVdpZHRoLCB0cnVlKTtcbiAgICAgICAgc2hhcGUud2lkdGggPSBNYXRoLm1heChcbiAgICAgICAgICAgIHN1YlBpeGVsT3B0aW1pemUob3JpZ2luWCArIG9yaWdpbldpZHRoLCBsaW5lV2lkdGgsIGZhbHNlKSAtIHNoYXBlLngsXG4gICAgICAgICAgICBvcmlnaW5XaWR0aCA9PT0gMCA/IDAgOiAxXG4gICAgICAgICk7XG4gICAgICAgIHNoYXBlLmhlaWdodCA9IE1hdGgubWF4KFxuICAgICAgICAgICAgc3ViUGl4ZWxPcHRpbWl6ZShvcmlnaW5ZICsgb3JpZ2luSGVpZ2h0LCBsaW5lV2lkdGgsIGZhbHNlKSAtIHNoYXBlLnksXG4gICAgICAgICAgICBvcmlnaW5IZWlnaHQgPT09IDAgPyAwIDogMVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gcGFyYW07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN1YiBwaXhlbCBvcHRpbWl6ZSBmb3IgY2FudmFzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24gQ29vcmRpbmF0ZSwgc3VjaCBhcyB4LCB5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVXaWR0aCBTaG91bGQgYmUgbm9ubmVnYXRpdmUgaW50ZWdlci5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBwb3NpdGl2ZU9yTmVnYXRpdmUgRGVmYXVsdCBmYWxzZSAobmVnYXRpdmUpLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gT3B0aW1pemVkIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZSA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgbGluZVdpZHRoLCBwb3NpdGl2ZU9yTmVnYXRpdmUpIHtcbiAgICAgICAgLy8gQXNzdXJlIHRoYXQgKHBvc2l0aW9uICsgbGluZVdpZHRoIC8gMikgaXMgbmVhciBpbnRlZ2VyIGVkZ2UsXG4gICAgICAgIC8vIG90aGVyd2lzZSBsaW5lIHdpbGwgYmUgZnV6enkgaW4gY2FudmFzLlxuICAgICAgICB2YXIgZG91YmxlZFBvc2l0aW9uID0gcm91bmQocG9zaXRpb24gKiAyKTtcbiAgICAgICAgcmV0dXJuIChkb3VibGVkUG9zaXRpb24gKyByb3VuZChsaW5lV2lkdGgpKSAlIDIgPT09IDBcbiAgICAgICAgICAgID8gZG91YmxlZFBvc2l0aW9uIC8gMlxuICAgICAgICAgICAgOiAoZG91YmxlZFBvc2l0aW9uICsgKHBvc2l0aXZlT3JOZWdhdGl2ZSA/IDEgOiAtMSkpIC8gMjtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaGFzRmlsbE9yU3Ryb2tlKGZpbGxPclN0cm9rZSkge1xuICAgICAgICByZXR1cm4gZmlsbE9yU3Ryb2tlICE9IG51bGwgJiYgZmlsbE9yU3Ryb2tlICE9ICdub25lJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWZ0Q29sb3IoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycgPyBjb2xvclRvb2wubGlmdChjb2xvciwgLTAuMSkgOiBjb2xvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhY2hlRWxlbWVudFN0bChlbCkge1xuICAgICAgICBpZiAoZWwuX19ob3ZlclN0bERpcnR5KSB7XG4gICAgICAgICAgICB2YXIgc3Ryb2tlID0gZWwuc3R5bGUuc3Ryb2tlO1xuICAgICAgICAgICAgdmFyIGZpbGwgPSBlbC5zdHlsZS5maWxsO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgaG92ZXJTdHlsZSBvbiBtb3VzZW92ZXJcbiAgICAgICAgICAgIHZhciBob3ZlclN0eWxlID0gZWwuX19ob3ZlclN0bDtcbiAgICAgICAgICAgIGhvdmVyU3R5bGUuZmlsbCA9IGhvdmVyU3R5bGUuZmlsbFxuICAgICAgICAgICAgICAgIHx8IChoYXNGaWxsT3JTdHJva2UoZmlsbCkgPyBsaWZ0Q29sb3IoZmlsbCkgOiBudWxsKTtcbiAgICAgICAgICAgIGhvdmVyU3R5bGUuc3Ryb2tlID0gaG92ZXJTdHlsZS5zdHJva2VcbiAgICAgICAgICAgICAgICB8fCAoaGFzRmlsbE9yU3Ryb2tlKHN0cm9rZSkgPyBsaWZ0Q29sb3Ioc3Ryb2tlKSA6IG51bGwpO1xuXG4gICAgICAgICAgICB2YXIgbm9ybWFsU3R5bGUgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gaG92ZXJTdHlsZSkge1xuICAgICAgICAgICAgICAgIGlmIChob3ZlclN0eWxlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbFN0eWxlW25hbWVdID0gZWwuc3R5bGVbbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbC5fX25vcm1hbFN0bCA9IG5vcm1hbFN0eWxlO1xuXG4gICAgICAgICAgICBlbC5fX2hvdmVyU3RsRGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZG9TaW5nbGVFbnRlckhvdmVyKGVsKSB7XG4gICAgICAgIGlmIChlbC5fX2lzSG92ZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhY2hlRWxlbWVudFN0bChlbCk7XG5cbiAgICAgICAgaWYgKGVsLnVzZUhvdmVyTGF5ZXIpIHtcbiAgICAgICAgICAgIGVsLl9fenIgJiYgZWwuX196ci5hZGRIb3ZlcihlbCwgZWwuX19ob3ZlclN0bCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbC5zZXRTdHlsZShlbC5fX2hvdmVyU3RsKTtcbiAgICAgICAgICAgIGVsLnoyICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBlbC5fX2lzSG92ZXIgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRvU2luZ2xlTGVhdmVIb3ZlcihlbCkge1xuICAgICAgICBpZiAoIWVsLl9faXNIb3Zlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vcm1hbFN0bCA9IGVsLl9fbm9ybWFsU3RsO1xuICAgICAgICBpZiAoZWwudXNlSG92ZXJMYXllcikge1xuICAgICAgICAgICAgZWwuX196ciAmJiBlbC5fX3pyLnJlbW92ZUhvdmVyKGVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vcm1hbFN0bCAmJiBlbC5zZXRTdHlsZShub3JtYWxTdGwpO1xuICAgICAgICAgICAgZWwuejIgLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsLl9faXNIb3ZlciA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRvRW50ZXJIb3ZlcihlbCkge1xuICAgICAgICBlbC50eXBlID09PSAnZ3JvdXAnXG4gICAgICAgICAgICA/IGVsLnRyYXZlcnNlKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlICE9PSAnZ3JvdXAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvU2luZ2xlRW50ZXJIb3ZlcihjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogZG9TaW5nbGVFbnRlckhvdmVyKGVsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkb0xlYXZlSG92ZXIoZWwpIHtcbiAgICAgICAgZWwudHlwZSA9PT0gJ2dyb3VwJ1xuICAgICAgICAgICAgPyBlbC50cmF2ZXJzZShmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPT0gJ2dyb3VwJykge1xuICAgICAgICAgICAgICAgICAgICBkb1NpbmdsZUxlYXZlSG92ZXIoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IGRvU2luZ2xlTGVhdmVIb3ZlcihlbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0RWxlbWVudEhvdmVyU3RsKGVsLCBob3ZlclN0bCkge1xuICAgICAgICAvLyBJZiBlbGVtZW50IGhhcyBzZXBjaWZpZWQgaG92ZXJTdHlsZSwgdGhlbiB1c2UgaXQgaW5zdGVhZCBvZiBnaXZlbiBob3ZlclN0eWxlXG4gICAgICAgIC8vIE9mdGVuIHVzZWQgd2hlbiBpdGVtIGdyb3VwIGhhcyBhIGxhYmVsIGVsZW1lbnQgYW5kIGl0J3MgaG92ZXJTdHlsZSBpcyBkaWZmZXJlbnRcbiAgICAgICAgZWwuX19ob3ZlclN0bCA9IGVsLmhvdmVyU3R5bGUgfHwgaG92ZXJTdGwgfHwge307XG4gICAgICAgIGVsLl9faG92ZXJTdGxEaXJ0eSA9IHRydWU7XG5cbiAgICAgICAgaWYgKGVsLl9faXNIb3Zlcikge1xuICAgICAgICAgICAgY2FjaGVFbGVtZW50U3RsKGVsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uRWxlbWVudE1vdXNlT3ZlcigpIHtcbiAgICAgICAgLy8gT25seSBpZiBlbGVtZW50IGlzIG5vdCBpbiBlbXBoYXNpcyBzdGF0dXNcbiAgICAgICAgIXRoaXMuX19pc0VtcGhhc2lzICYmIGRvRW50ZXJIb3Zlcih0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbkVsZW1lbnRNb3VzZU91dCgpIHtcbiAgICAgICAgLy8gT25seSBpZiBlbGVtZW50IGlzIG5vdCBpbiBlbXBoYXNpcyBzdGF0dXNcbiAgICAgICAgIXRoaXMuX19pc0VtcGhhc2lzICYmIGRvTGVhdmVIb3Zlcih0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbnRlckVtcGhhc2lzKCkge1xuICAgICAgICB0aGlzLl9faXNFbXBoYXNpcyA9IHRydWU7XG4gICAgICAgIGRvRW50ZXJIb3Zlcih0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsZWF2ZUVtcGhhc2lzKCkge1xuICAgICAgICB0aGlzLl9faXNFbXBoYXNpcyA9IGZhbHNlO1xuICAgICAgICBkb0xlYXZlSG92ZXIodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IGhvdmVyIHN0eWxlIG9mIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtob3ZlclN0eWxlXVxuICAgICAqL1xuICAgIGdyYXBoaWMuc2V0SG92ZXJTdHlsZSA9IGZ1bmN0aW9uIChlbCwgaG92ZXJTdHlsZSkge1xuICAgICAgICBlbC50eXBlID09PSAnZ3JvdXAnXG4gICAgICAgICAgICA/IGVsLnRyYXZlcnNlKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlICE9PSAnZ3JvdXAnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEVsZW1lbnRIb3ZlclN0bChjaGlsZCwgaG92ZXJTdHlsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogc2V0RWxlbWVudEhvdmVyU3RsKGVsLCBob3ZlclN0eWxlKTtcbiAgICAgICAgLy8gUmVtb3ZlIHByZXZpb3VzIGJvdW5kIGhhbmRsZXJzXG4gICAgICAgIGVsLm9uKCdtb3VzZW92ZXInLCBvbkVsZW1lbnRNb3VzZU92ZXIpXG4gICAgICAgICAgLm9uKCdtb3VzZW91dCcsIG9uRWxlbWVudE1vdXNlT3V0KTtcblxuICAgICAgICAvLyBFbXBoYXNpcywgbm9ybWFsIGNhbiBiZSB0cmlnZ2VyZWQgbWFudWFsbHlcbiAgICAgICAgZWwub24oJ2VtcGhhc2lzJywgZW50ZXJFbXBoYXNpcylcbiAgICAgICAgICAub24oJ25vcm1hbCcsIGxlYXZlRW1waGFzaXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGV4dCBvcHRpb24gaW4gdGhlIHN0eWxlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRleHRTdHlsZVxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IGxhYmVsTW9kZWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAgICAgKi9cbiAgICBncmFwaGljLnNldFRleHQgPSBmdW5jdGlvbiAodGV4dFN0eWxlLCBsYWJlbE1vZGVsLCBjb2xvcikge1xuICAgICAgICB2YXIgbGFiZWxQb3NpdGlvbiA9IGxhYmVsTW9kZWwuZ2V0U2hhbGxvdygncG9zaXRpb24nKSB8fCAnaW5zaWRlJztcbiAgICAgICAgdmFyIGxhYmVsQ29sb3IgPSBsYWJlbFBvc2l0aW9uLmluZGV4T2YoJ2luc2lkZScpID49IDAgPyAnd2hpdGUnIDogY29sb3I7XG4gICAgICAgIHZhciB0ZXh0U3R5bGVNb2RlbCA9IGxhYmVsTW9kZWwuZ2V0TW9kZWwoJ3RleHRTdHlsZScpO1xuICAgICAgICB6clV0aWwuZXh0ZW5kKHRleHRTdHlsZSwge1xuICAgICAgICAgICAgdGV4dERpc3RhbmNlOiBsYWJlbE1vZGVsLmdldFNoYWxsb3coJ2Rpc3RhbmNlJykgfHwgNSxcbiAgICAgICAgICAgIHRleHRGb250OiB0ZXh0U3R5bGVNb2RlbC5nZXRGb250KCksXG4gICAgICAgICAgICB0ZXh0UG9zaXRpb246IGxhYmVsUG9zaXRpb24sXG4gICAgICAgICAgICB0ZXh0RmlsbDogdGV4dFN0eWxlTW9kZWwuZ2V0VGV4dENvbG9yKCkgfHwgbGFiZWxDb2xvclxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gYW5pbWF0ZU9yU2V0UHJvcHMoaXNVcGRhdGUsIGVsLCBwcm9wcywgYW5pbWF0YWJsZU1vZGVsLCBkYXRhSW5kZXgsIGNiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YUluZGV4ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYiA9IGRhdGFJbmRleDtcbiAgICAgICAgICAgIGRhdGFJbmRleCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFuaW1hdGlvbkVuYWJsZWQgPSBhbmltYXRhYmxlTW9kZWxcbiAgICAgICAgICAgICYmIChcbiAgICAgICAgICAgICAgICBhbmltYXRhYmxlTW9kZWwuaWZFbmFibGVBbmltYXRpb25cbiAgICAgICAgICAgICAgICA/IGFuaW1hdGFibGVNb2RlbC5pZkVuYWJsZUFuaW1hdGlvbigpXG4gICAgICAgICAgICAgICAgLy8gRGlyZWN0bHkgdXNlIGFuaW1hdGlvbiBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIDogYW5pbWF0YWJsZU1vZGVsLmdldFNoYWxsb3coJ2FuaW1hdGlvbicpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgIGlmIChhbmltYXRpb25FbmFibGVkKSB7XG4gICAgICAgICAgICB2YXIgcG9zdGZpeCA9IGlzVXBkYXRlID8gJ1VwZGF0ZScgOiAnJztcbiAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IGFuaW1hdGFibGVNb2RlbFxuICAgICAgICAgICAgICAgICYmIGFuaW1hdGFibGVNb2RlbC5nZXRTaGFsbG93KCdhbmltYXRpb25EdXJhdGlvbicgKyBwb3N0Zml4KTtcbiAgICAgICAgICAgIHZhciBhbmltYXRpb25FYXNpbmcgPSBhbmltYXRhYmxlTW9kZWxcbiAgICAgICAgICAgICAgICAmJiBhbmltYXRhYmxlTW9kZWwuZ2V0U2hhbGxvdygnYW5pbWF0aW9uRWFzaW5nJyArIHBvc3RmaXgpO1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbkRlbGF5ID0gYW5pbWF0YWJsZU1vZGVsXG4gICAgICAgICAgICAgICAgJiYgYW5pbWF0YWJsZU1vZGVsLmdldFNoYWxsb3coJ2FuaW1hdGlvbkRlbGF5JyArIHBvc3RmaXgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhbmltYXRpb25EZWxheSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbkRlbGF5ID0gYW5pbWF0aW9uRGVsYXkoZGF0YUluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGR1cmF0aW9uID4gMFxuICAgICAgICAgICAgICAgID8gZWwuYW5pbWF0ZVRvKHByb3BzLCBkdXJhdGlvbiwgYW5pbWF0aW9uRGVsYXkgfHwgMCwgYW5pbWF0aW9uRWFzaW5nLCBjYilcbiAgICAgICAgICAgICAgICA6IChlbC5hdHRyKHByb3BzKSwgY2IgJiYgY2IoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbC5hdHRyKHByb3BzKTtcbiAgICAgICAgICAgIGNiICYmIGNiKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGdyYXBoaWMgZWxlbWVudCBwcm9wZXJ0aWVzIHdpdGggb3Igd2l0aG91dCBhbmltYXRpb24gYWNjb3JkaW5nIHRvIHRoZSBjb25maWd1cmF0aW9uIGluIHNlcmllc1xuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBbYW5pbWF0YWJsZU1vZGVsXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGF0YUluZGV4XVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICBncmFwaGljLnVwZGF0ZVByb3BzKGVsLCB7XG4gICAgICogICAgICAgICBwb3NpdGlvbjogWzEwMCwgMTAwXVxuICAgICAqICAgICB9LCBzZXJpZXNNb2RlbCwgZGF0YUluZGV4LCBmdW5jdGlvbiAoKSB7IGNvbnNvbGUubG9nKCdBbmltYXRpb24gZG9uZSEnKTsgfSk7XG4gICAgICogICAgIC8vIE9yXG4gICAgICogICAgIGdyYXBoaWMudXBkYXRlUHJvcHMoZWwsIHtcbiAgICAgKiAgICAgICAgIHBvc2l0aW9uOiBbMTAwLCAxMDBdXG4gICAgICogICAgIH0sIHNlcmllc01vZGVsLCBmdW5jdGlvbiAoKSB7IGNvbnNvbGUubG9nKCdBbmltYXRpb24gZG9uZSEnKTsgfSk7XG4gICAgICovXG4gICAgZ3JhcGhpYy51cGRhdGVQcm9wcyA9IGZ1bmN0aW9uIChlbCwgcHJvcHMsIGFuaW1hdGFibGVNb2RlbCwgZGF0YUluZGV4LCBjYikge1xuICAgICAgICBhbmltYXRlT3JTZXRQcm9wcyh0cnVlLCBlbCwgcHJvcHMsIGFuaW1hdGFibGVNb2RlbCwgZGF0YUluZGV4LCBjYik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEluaXQgZ3JhcGhpYyBlbGVtZW50IHByb3BlcnRpZXMgd2l0aCBvciB3aXRob3V0IGFuaW1hdGlvbiBhY2NvcmRpbmcgdG8gdGhlIGNvbmZpZ3VyYXRpb24gaW4gc2VyaWVzXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IFthbmltYXRhYmxlTW9kZWxdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkYXRhSW5kZXhdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgKi9cbiAgICBncmFwaGljLmluaXRQcm9wcyA9IGZ1bmN0aW9uIChlbCwgcHJvcHMsIGFuaW1hdGFibGVNb2RlbCwgZGF0YUluZGV4LCBjYikge1xuICAgICAgICBhbmltYXRlT3JTZXRQcm9wcyhmYWxzZSwgZWwsIHByb3BzLCBhbmltYXRhYmxlTW9kZWwsIGRhdGFJbmRleCwgY2IpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdHJhbnNmb3JtIG1hdHJpeCBvZiB0YXJnZXQgKHBhcmFtIHRhcmdldCksXG4gICAgICogaW4gY29vcmRpbmF0ZSBvZiBpdHMgYW5jZXN0b3IgKHBhcmFtIGFuY2VzdG9yKVxuICAgICAqXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlfSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGV9IFthbmNlc3Rvcl1cbiAgICAgKi9cbiAgICBncmFwaGljLmdldFRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0YXJnZXQsIGFuY2VzdG9yKSB7XG4gICAgICAgIHZhciBtYXQgPSBtYXRyaXguaWRlbnRpdHkoW10pO1xuXG4gICAgICAgIHdoaWxlICh0YXJnZXQgJiYgdGFyZ2V0ICE9PSBhbmNlc3Rvcikge1xuICAgICAgICAgICAgbWF0cml4Lm11bChtYXQsIHRhcmdldC5nZXRMb2NhbFRyYW5zZm9ybSgpLCBtYXQpO1xuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRyYW5zZm9ybSB0byBhbiB2ZXJ0ZXguXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdmVydGV4IFt4LCB5XVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHRyYW5zZm9ybSBUcmFuc2Zvcm0gbWF0cml4OiBsaWtlIFsxLCAwLCAwLCAxLCAwLCAwXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGludmVydCBXaGV0aGVyIHVzZSBpbnZlcnQgbWF0cml4LlxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBbeCwgeV1cbiAgICAgKi9cbiAgICBncmFwaGljLmFwcGx5VHJhbnNmb3JtID0gZnVuY3Rpb24gKHZlcnRleCwgdHJhbnNmb3JtLCBpbnZlcnQpIHtcbiAgICAgICAgaWYgKGludmVydCkge1xuICAgICAgICAgICAgdHJhbnNmb3JtID0gbWF0cml4LmludmVydChbXSwgdHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmVjdG9yLmFwcGx5VHJhbnNmb3JtKFtdLCB2ZXJ0ZXgsIHRyYW5zZm9ybSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaXJlY3Rpb24gJ2xlZnQnICdyaWdodCcgJ3RvcCcgJ2JvdHRvbSdcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0cmFuc2Zvcm0gVHJhbnNmb3JtIG1hdHJpeDogbGlrZSBbMSwgMCwgMCwgMSwgMCwgMF1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpbnZlcnQgV2hldGhlciB1c2UgaW52ZXJ0IG1hdHJpeC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRyYW5zZm9ybWVkIGRpcmVjdGlvbi4gJ2xlZnQnICdyaWdodCcgJ3RvcCcgJ2JvdHRvbSdcbiAgICAgKi9cbiAgICBncmFwaGljLnRyYW5zZm9ybURpcmVjdGlvbiA9IGZ1bmN0aW9uIChkaXJlY3Rpb24sIHRyYW5zZm9ybSwgaW52ZXJ0KSB7XG5cbiAgICAgICAgLy8gUGljayBhIGJhc2UsIGVuc3VyZSB0aGF0IHRyYW5zZm9ybSByZXN1bHQgd2lsbCBub3QgYmUgKDAsIDApLlxuICAgICAgICB2YXIgaEJhc2UgPSAodHJhbnNmb3JtWzRdID09PSAwIHx8IHRyYW5zZm9ybVs1XSA9PT0gMCB8fCB0cmFuc2Zvcm1bMF0gPT09IDApXG4gICAgICAgICAgICA/IDEgOiBNYXRoLmFicygyICogdHJhbnNmb3JtWzRdIC8gdHJhbnNmb3JtWzBdKTtcbiAgICAgICAgdmFyIHZCYXNlID0gKHRyYW5zZm9ybVs0XSA9PT0gMCB8fCB0cmFuc2Zvcm1bNV0gPT09IDAgfHwgdHJhbnNmb3JtWzJdID09PSAwKVxuICAgICAgICAgICAgPyAxIDogTWF0aC5hYnMoMiAqIHRyYW5zZm9ybVs0XSAvIHRyYW5zZm9ybVsyXSk7XG5cbiAgICAgICAgdmFyIHZlcnRleCA9IFtcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9PT0gJ2xlZnQnID8gLWhCYXNlIDogZGlyZWN0aW9uID09PSAncmlnaHQnID8gaEJhc2UgOiAwLFxuICAgICAgICAgICAgZGlyZWN0aW9uID09PSAndG9wJyA/IC12QmFzZSA6IGRpcmVjdGlvbiA9PT0gJ2JvdHRvbScgPyB2QmFzZSA6IDBcbiAgICAgICAgXTtcblxuICAgICAgICB2ZXJ0ZXggPSBncmFwaGljLmFwcGx5VHJhbnNmb3JtKHZlcnRleCwgdHJhbnNmb3JtLCBpbnZlcnQpO1xuXG4gICAgICAgIHJldHVybiBNYXRoLmFicyh2ZXJ0ZXhbMF0pID4gTWF0aC5hYnModmVydGV4WzFdKVxuICAgICAgICAgICAgPyAodmVydGV4WzBdID4gMCA/ICdyaWdodCcgOiAnbGVmdCcpXG4gICAgICAgICAgICA6ICh2ZXJ0ZXhbMV0gPiAwID8gJ2JvdHRvbScgOiAndG9wJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IGdyb3VwIHRyYW5zaXRpb24gYW5pbWF0aW9uIGZyb20gZzEgdG8gZzJcbiAgICAgKi9cbiAgICBncmFwaGljLmdyb3VwVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChnMSwgZzIsIGFuaW1hdGFibGVNb2RlbCwgY2IpIHtcbiAgICAgICAgaWYgKCFnMSB8fCAhZzIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldEVsTWFwKGcpIHtcbiAgICAgICAgICAgIHZhciBlbE1hcCA9IHt9O1xuICAgICAgICAgICAgZy50cmF2ZXJzZShmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVsLmlzR3JvdXAgJiYgZWwuYW5pZCkge1xuICAgICAgICAgICAgICAgICAgICBlbE1hcFtlbC5hbmlkXSA9IGVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGVsTWFwO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldEFuaW1hdGFibGVQcm9wcyhlbCkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogdmVjdG9yLmNsb25lKGVsLnBvc2l0aW9uKSxcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogZWwucm90YXRpb25cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZWwuc2hhcGUpIHtcbiAgICAgICAgICAgICAgICBvYmouc2hhcGUgPSB6clV0aWwuZXh0ZW5kKHt9LCBlbC5zaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbE1hcDEgPSBnZXRFbE1hcChnMSk7XG5cbiAgICAgICAgZzIudHJhdmVyc2UoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBpZiAoIWVsLmlzR3JvdXAgJiYgZWwuYW5pZCkge1xuICAgICAgICAgICAgICAgIHZhciBvbGRFbCA9IGVsTWFwMVtlbC5hbmlkXTtcbiAgICAgICAgICAgICAgICBpZiAob2xkRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1Byb3AgPSBnZXRBbmltYXRhYmxlUHJvcHMoZWwpO1xuICAgICAgICAgICAgICAgICAgICBlbC5hdHRyKGdldEFuaW1hdGFibGVQcm9wcyhvbGRFbCkpO1xuICAgICAgICAgICAgICAgICAgICBncmFwaGljLnVwZGF0ZVByb3BzKGVsLCBuZXdQcm9wLCBhbmltYXRhYmxlTW9kZWwsIGVsLmRhdGFJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vICAgICBpZiAoZWwucHJldmlvdXNQcm9wcykge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgZ3JhcGhpYy51cGRhdGVQcm9wc1xuICAgICAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGdyYXBoaWM7XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL2VjaGFydHMvdXRpbC9ncmFwaGljLmpzXG4gKiogbW9kdWxlIGlkID0gNDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsImRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG4gICAgdmFyIFBhdGggPSByZXF1aXJlKCcuLi9ncmFwaGljL1BhdGgnKTtcbiAgICB2YXIgUGF0aFByb3h5ID0gcmVxdWlyZSgnLi4vY29yZS9QYXRoUHJveHknKTtcbiAgICB2YXIgdHJhbnNmb3JtUGF0aCA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtUGF0aCcpO1xuICAgIHZhciBtYXRyaXggPSByZXF1aXJlKCcuLi9jb3JlL21hdHJpeCcpO1xuXG4gICAgLy8gY29tbWFuZCBjaGFyc1xuICAgIHZhciBjYyA9IFtcbiAgICAgICAgJ20nLCAnTScsICdsJywgJ0wnLCAndicsICdWJywgJ2gnLCAnSCcsICd6JywgJ1onLFxuICAgICAgICAnYycsICdDJywgJ3EnLCAnUScsICd0JywgJ1QnLCAncycsICdTJywgJ2EnLCAnQSdcbiAgICBdO1xuXG4gICAgdmFyIG1hdGhTcXJ0ID0gTWF0aC5zcXJ0O1xuICAgIHZhciBtYXRoU2luID0gTWF0aC5zaW47XG4gICAgdmFyIG1hdGhDb3MgPSBNYXRoLmNvcztcbiAgICB2YXIgUEkgPSBNYXRoLlBJO1xuXG4gICAgdmFyIHZNYWcgPSBmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQodlswXSAqIHZbMF0gKyB2WzFdICogdlsxXSk7XG4gICAgfTtcbiAgICB2YXIgdlJhdGlvID0gZnVuY3Rpb24odSwgdikge1xuICAgICAgICByZXR1cm4gKHVbMF0gKiB2WzBdICsgdVsxXSAqIHZbMV0pIC8gKHZNYWcodSkgKiB2TWFnKHYpKTtcbiAgICB9O1xuICAgIHZhciB2QW5nbGUgPSBmdW5jdGlvbih1LCB2KSB7XG4gICAgICAgIHJldHVybiAodVswXSAqIHZbMV0gPCB1WzFdICogdlswXSA/IC0xIDogMSlcbiAgICAgICAgICAgICAgICAqIE1hdGguYWNvcyh2UmF0aW8odSwgdikpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzQXJjKHgxLCB5MSwgeDIsIHkyLCBmYSwgZnMsIHJ4LCByeSwgcHNpRGVnLCBjbWQsIHBhdGgpIHtcbiAgICAgICAgdmFyIHBzaSA9IHBzaURlZyAqIChQSSAvIDE4MC4wKTtcbiAgICAgICAgdmFyIHhwID0gbWF0aENvcyhwc2kpICogKHgxIC0geDIpIC8gMi4wXG4gICAgICAgICAgICAgICAgICsgbWF0aFNpbihwc2kpICogKHkxIC0geTIpIC8gMi4wO1xuICAgICAgICB2YXIgeXAgPSAtMSAqIG1hdGhTaW4ocHNpKSAqICh4MSAtIHgyKSAvIDIuMFxuICAgICAgICAgICAgICAgICArIG1hdGhDb3MocHNpKSAqICh5MSAtIHkyKSAvIDIuMDtcblxuICAgICAgICB2YXIgbGFtYmRhID0gKHhwICogeHApIC8gKHJ4ICogcngpICsgKHlwICogeXApIC8gKHJ5ICogcnkpO1xuXG4gICAgICAgIGlmIChsYW1iZGEgPiAxKSB7XG4gICAgICAgICAgICByeCAqPSBtYXRoU3FydChsYW1iZGEpO1xuICAgICAgICAgICAgcnkgKj0gbWF0aFNxcnQobGFtYmRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmID0gKGZhID09PSBmcyA/IC0xIDogMSlcbiAgICAgICAgICAgICogbWF0aFNxcnQoKCgocnggKiByeCkgKiAocnkgKiByeSkpXG4gICAgICAgICAgICAgICAgICAgIC0gKChyeCAqIHJ4KSAqICh5cCAqIHlwKSlcbiAgICAgICAgICAgICAgICAgICAgLSAoKHJ5ICogcnkpICogKHhwICogeHApKSkgLyAoKHJ4ICogcngpICogKHlwICogeXApXG4gICAgICAgICAgICAgICAgICAgICsgKHJ5ICogcnkpICogKHhwICogeHApKVxuICAgICAgICAgICAgICAgICkgfHwgMDtcblxuICAgICAgICB2YXIgY3hwID0gZiAqIHJ4ICogeXAgLyByeTtcbiAgICAgICAgdmFyIGN5cCA9IGYgKiAtcnkgKiB4cCAvIHJ4O1xuXG4gICAgICAgIHZhciBjeCA9ICh4MSArIHgyKSAvIDIuMFxuICAgICAgICAgICAgICAgICArIG1hdGhDb3MocHNpKSAqIGN4cFxuICAgICAgICAgICAgICAgICAtIG1hdGhTaW4ocHNpKSAqIGN5cDtcbiAgICAgICAgdmFyIGN5ID0gKHkxICsgeTIpIC8gMi4wXG4gICAgICAgICAgICAgICAgKyBtYXRoU2luKHBzaSkgKiBjeHBcbiAgICAgICAgICAgICAgICArIG1hdGhDb3MocHNpKSAqIGN5cDtcblxuICAgICAgICB2YXIgdGhldGEgPSB2QW5nbGUoWyAxLCAwIF0sIFsgKHhwIC0gY3hwKSAvIHJ4LCAoeXAgLSBjeXApIC8gcnkgXSk7XG4gICAgICAgIHZhciB1ID0gWyAoeHAgLSBjeHApIC8gcngsICh5cCAtIGN5cCkgLyByeSBdO1xuICAgICAgICB2YXIgdiA9IFsgKC0xICogeHAgLSBjeHApIC8gcngsICgtMSAqIHlwIC0gY3lwKSAvIHJ5IF07XG4gICAgICAgIHZhciBkVGhldGEgPSB2QW5nbGUodSwgdik7XG5cbiAgICAgICAgaWYgKHZSYXRpbyh1LCB2KSA8PSAtMSkge1xuICAgICAgICAgICAgZFRoZXRhID0gUEk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZSYXRpbyh1LCB2KSA+PSAxKSB7XG4gICAgICAgICAgICBkVGhldGEgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcyA9PT0gMCAmJiBkVGhldGEgPiAwKSB7XG4gICAgICAgICAgICBkVGhldGEgPSBkVGhldGEgLSAyICogUEk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZzID09PSAxICYmIGRUaGV0YSA8IDApIHtcbiAgICAgICAgICAgIGRUaGV0YSA9IGRUaGV0YSArIDIgKiBQSTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGN4LCBjeSwgcngsIHJ5LCB0aGV0YSwgZFRoZXRhLCBwc2ksIGZzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXRoUHJveHlGcm9tU3RyaW5nKGRhdGEpIHtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb21tYW5kIHN0cmluZ1xuICAgICAgICB2YXIgY3MgPSBkYXRhLnJlcGxhY2UoLy0vZywgJyAtJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8gIC9nLCAnICcpXG4gICAgICAgICAgICAucmVwbGFjZSgvIC9nLCAnLCcpXG4gICAgICAgICAgICAucmVwbGFjZSgvLCwvZywgJywnKTtcblxuICAgICAgICB2YXIgbjtcbiAgICAgICAgLy8gY3JlYXRlIHBpcGVzIHNvIHRoYXQgd2UgY2FuIHNwbGl0IHRoZSBkYXRhXG4gICAgICAgIGZvciAobiA9IDA7IG4gPCBjYy5sZW5ndGg7IG4rKykge1xuICAgICAgICAgICAgY3MgPSBjcy5yZXBsYWNlKG5ldyBSZWdFeHAoY2Nbbl0sICdnJyksICd8JyArIGNjW25dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSBhcnJheVxuICAgICAgICB2YXIgYXJyID0gY3Muc3BsaXQoJ3wnKTtcbiAgICAgICAgLy8gaW5pdCBjb250ZXh0IHBvaW50XG4gICAgICAgIHZhciBjcHggPSAwO1xuICAgICAgICB2YXIgY3B5ID0gMDtcblxuICAgICAgICB2YXIgcGF0aCA9IG5ldyBQYXRoUHJveHkoKTtcbiAgICAgICAgdmFyIENNRCA9IFBhdGhQcm94eS5DTUQ7XG5cbiAgICAgICAgdmFyIHByZXZDbWQ7XG4gICAgICAgIGZvciAobiA9IDE7IG4gPCBhcnIubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgIHZhciBzdHIgPSBhcnJbbl07XG4gICAgICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoMCk7XG4gICAgICAgICAgICB2YXIgb2ZmID0gMDtcbiAgICAgICAgICAgIHZhciBwID0gc3RyLnNsaWNlKDEpLnJlcGxhY2UoL2UsLS9nLCAnZS0nKS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgdmFyIGNtZDtcblxuICAgICAgICAgICAgaWYgKHAubGVuZ3RoID4gMCAmJiBwWzBdID09PSAnJykge1xuICAgICAgICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcFtpXSA9IHBhcnNlRmxvYXQocFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAob2ZmIDwgcC5sZW5ndGggJiYgIWlzTmFOKHBbb2ZmXSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4ocFswXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjdGxQdHg7XG4gICAgICAgICAgICAgICAgdmFyIGN0bFB0eTtcblxuICAgICAgICAgICAgICAgIHZhciByeDtcbiAgICAgICAgICAgICAgICB2YXIgcnk7XG4gICAgICAgICAgICAgICAgdmFyIHBzaTtcbiAgICAgICAgICAgICAgICB2YXIgZmE7XG4gICAgICAgICAgICAgICAgdmFyIGZzO1xuXG4gICAgICAgICAgICAgICAgdmFyIHgxID0gY3B4O1xuICAgICAgICAgICAgICAgIHZhciB5MSA9IGNweTtcblxuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgbCwgSCwgaCwgViwgYW5kIHYgdG8gTFxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELk07XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gJ2wnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5NO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYyA9ICdMJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd2JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNtZCwgcFtvZmYrK10sIHBbb2ZmKytdLCBwW29mZisrXSwgcFtvZmYrK10sIHBbb2ZmKytdLCBwW29mZisrXVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHBbb2ZmIC0gMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwW29mZiAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkM7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY21kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBbb2ZmKytdICsgY3B4LCBwW29mZisrXSArIGNweSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwW29mZisrXSArIGNweCwgcFtvZmYrK10gKyBjcHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcFtvZmYrK10gKyBjcHgsIHBbb2ZmKytdICsgY3B5XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHBbb2ZmIC0gMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcFtvZmYgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSA9IGNweTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBwYXRoLmxlbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZDbWQgPT09IENNRC5DKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ICs9IGNweCAtIHBhdGhEYXRhW2xlbiAtIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSArPSBjcHkgLSBwYXRoRGF0YVtsZW4gLSAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3RsUHR4LCBjdGxQdHksIHgxLCB5MSwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aERhdGEgPSBwYXRoLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldkNtZCA9PT0gQ01ELkMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggKz0gY3B4IC0gcGF0aERhdGFbbGVuIC0gNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ICs9IGNweSAtIHBhdGhEYXRhW2xlbiAtIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkM7XG4gICAgICAgICAgICAgICAgICAgICAgICB4MSA9IGNweCArIHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTEgPSBjcHkgKyBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGN0bFB0eCwgY3RsUHR5LCB4MSwgeTEsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5MSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5RO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB4MSA9IHBbb2ZmKytdICsgY3B4O1xuICAgICAgICAgICAgICAgICAgICAgICAgeTEgPSBwW29mZisrXSArIGNweTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5RO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gcGF0aC5sZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGguZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2Q21kID09PSBDTUQuUSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCArPSBjcHggLSBwYXRoRGF0YVtsZW4gLSA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgKz0gY3B5IC0gcGF0aERhdGFbbGVuIC0gM107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aERhdGEgPSBwYXRoLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldkNtZCA9PT0gQ01ELlEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggKz0gY3B4IC0gcGF0aERhdGFbbGVuIC0gNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ICs9IGNweSAtIHBhdGhEYXRhW2xlbiAtIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcnggPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ5ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBwc2kgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBmcyA9IHBbb2ZmKytdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB4MSA9IGNweCwgeTEgPSBjcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkE7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzQXJjKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgxLCB5MSwgY3B4LCBjcHksIGZhLCBmcywgcngsIHJ5LCBwc2ksIGNtZCwgcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICByeSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHNpID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBmYSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnMgPSBwW29mZisrXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSBjcHgsIHkxID0gY3B5O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkE7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzQXJjKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgxLCB5MSwgY3B4LCBjcHksIGZhLCBmcywgcngsIHJ5LCBwc2ksIGNtZCwgcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGMgPT09ICd6JyB8fCBjID09PSAnWicpIHtcbiAgICAgICAgICAgICAgICBjbWQgPSBDTUQuWjtcbiAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJldkNtZCA9IGNtZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdGgudG9TdGF0aWMoKTtcblxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG5cbiAgICAvLyBUT0RPIE9wdGltaXplIGRvdWJsZSBtZW1vcnkgY29zdCBwcm9ibGVtXG4gICAgZnVuY3Rpb24gY3JlYXRlUGF0aE9wdGlvbnMoc3RyLCBvcHRzKSB7XG4gICAgICAgIHZhciBwYXRoUHJveHkgPSBjcmVhdGVQYXRoUHJveHlGcm9tU3RyaW5nKHN0cik7XG4gICAgICAgIHZhciB0cmFuc2Zvcm07XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICBvcHRzLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICBwYXRoLnNldERhdGEocGF0aFByb3h5LmRhdGEpO1xuICAgICAgICAgICAgdHJhbnNmb3JtICYmIHRyYW5zZm9ybVBhdGgocGF0aCwgdHJhbnNmb3JtKTtcbiAgICAgICAgICAgIC8vIFN2ZyBhbmQgdm1sIHJlbmRlcmVyIGRvbid0IGhhdmUgY29udGV4dFxuICAgICAgICAgICAgdmFyIGN0eCA9IHBhdGguZ2V0Q29udGV4dCgpO1xuICAgICAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgICAgIHBhdGgucmVidWlsZFBhdGgoY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBvcHRzLmFwcGx5VHJhbnNmb3JtID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIGlmICghdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtID0gbWF0cml4LmNyZWF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF0cml4Lm11bCh0cmFuc2Zvcm0sIG0sIHRyYW5zZm9ybSk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5KHRydWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBvcHRzO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBQYXRoIG9iamVjdCBmcm9tIHBhdGggc3RyaW5nIGRhdGFcbiAgICAgICAgICogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3BhdGhzLmh0bWwjUGF0aERhdGFcbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRzIE90aGVyIG9wdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZUZyb21TdHJpbmc6IGZ1bmN0aW9uIChzdHIsIG9wdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGF0aChjcmVhdGVQYXRoT3B0aW9ucyhzdHIsIG9wdHMpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgUGF0aCBjbGFzcyBmcm9tIHBhdGggc3RyaW5nIGRhdGFcbiAgICAgICAgICogQHBhcmFtICB7c3RyaW5nfSBzdHJcbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRzIE90aGVyIG9wdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIGV4dGVuZEZyb21TdHJpbmc6IGZ1bmN0aW9uIChzdHIsIG9wdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBQYXRoLmV4dGVuZChjcmVhdGVQYXRoT3B0aW9ucyhzdHIsIG9wdHMpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWVyZ2UgbXVsdGlwbGUgcGF0aHNcbiAgICAgICAgICovXG4gICAgICAgIC8vIFRPRE8gQXBwbHkgdHJhbnNmb3JtXG4gICAgICAgIC8vIFRPRE8gc3Ryb2tlIGRhc2hcbiAgICAgICAgLy8gVE9ETyBPcHRpbWl6ZSBkb3VibGUgbWVtb3J5IGNvc3QgcHJvYmxlbVxuICAgICAgICBtZXJnZVBhdGg6IGZ1bmN0aW9uIChwYXRoRWxzLCBvcHRzKSB7XG4gICAgICAgICAgICB2YXIgcGF0aExpc3QgPSBbXTtcbiAgICAgICAgICAgIHZhciBsZW4gPSBwYXRoRWxzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aEVsID0gcGF0aEVsc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGF0aEVsLl9fZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aEVsLmJ1aWxkUGF0aChwYXRoRWwucGF0aCwgcGF0aEVsLnNoYXBlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGF0aExpc3QucHVzaChwYXRoRWwucGF0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwYXRoQnVuZGxlID0gbmV3IFBhdGgob3B0cyk7XG4gICAgICAgICAgICBwYXRoQnVuZGxlLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgcGF0aC5hcHBlbmRQYXRoKHBhdGhMaXN0KTtcbiAgICAgICAgICAgICAgICAvLyBTdmcgYW5kIHZtbCByZW5kZXJlciBkb24ndCBoYXZlIGNvbnRleHRcbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gcGF0aC5nZXRDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnJlYnVpbGRQYXRoKGN0eCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIHBhdGhCdW5kbGU7XG4gICAgICAgIH1cbiAgICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC96cmVuZGVyL3Rvb2wvcGF0aC5qc1xuICoqIG1vZHVsZSBpZCA9IDQ4XG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCIvKipcbiAqIFBhdGggZWxlbWVudFxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvUGF0aFxuICovXG5cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG4gICAgdmFyIERpc3BsYXlhYmxlID0gcmVxdWlyZSgnLi9EaXNwbGF5YWJsZScpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgUGF0aFByb3h5ID0gcmVxdWlyZSgnLi4vY29yZS9QYXRoUHJveHknKTtcbiAgICB2YXIgcGF0aENvbnRhaW4gPSByZXF1aXJlKCcuLi9jb250YWluL3BhdGgnKTtcblxuICAgIHZhciBQYXR0ZXJuID0gcmVxdWlyZSgnLi9QYXR0ZXJuJyk7XG4gICAgdmFyIGdldENhbnZhc1BhdHRlcm4gPSBQYXR0ZXJuLnByb3RvdHlwZS5nZXRDYW52YXNQYXR0ZXJuO1xuXG4gICAgdmFyIGFicyA9IE1hdGguYWJzO1xuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aFxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBhdGgob3B0cykge1xuICAgICAgICBEaXNwbGF5YWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wYXRoID0gbmV3IFBhdGhQcm94eSgpO1xuICAgIH1cblxuICAgIFBhdGgucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBQYXRoLFxuXG4gICAgICAgIHR5cGU6ICdwYXRoJyxcblxuICAgICAgICBfX2RpcnR5UGF0aDogdHJ1ZSxcblxuICAgICAgICBzdHJva2VDb250YWluVGhyZXNob2xkOiA1LFxuXG4gICAgICAgIGJydXNoOiBmdW5jdGlvbiAoY3R4LCBwcmV2RWwpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgICAgIHZhciBoYXNTdHJva2UgPSBzdHlsZS5oYXNTdHJva2UoKTtcbiAgICAgICAgICAgIHZhciBoYXNGaWxsID0gc3R5bGUuaGFzRmlsbCgpO1xuICAgICAgICAgICAgdmFyIGZpbGwgPSBzdHlsZS5maWxsO1xuICAgICAgICAgICAgdmFyIHN0cm9rZSA9IHN0eWxlLnN0cm9rZTtcbiAgICAgICAgICAgIHZhciBoYXNGaWxsR3JhZGllbnQgPSBoYXNGaWxsICYmICEhKGZpbGwuY29sb3JTdG9wcyk7XG4gICAgICAgICAgICB2YXIgaGFzU3Ryb2tlR3JhZGllbnQgPSBoYXNTdHJva2UgJiYgISEoc3Ryb2tlLmNvbG9yU3RvcHMpO1xuICAgICAgICAgICAgdmFyIGhhc0ZpbGxQYXR0ZXJuID0gaGFzRmlsbCAmJiAhIShmaWxsLmltYWdlKTtcbiAgICAgICAgICAgIHZhciBoYXNTdHJva2VQYXR0ZXJuID0gaGFzU3Ryb2tlICYmICEhKHN0cm9rZS5pbWFnZSk7XG5cbiAgICAgICAgICAgIHN0eWxlLmJpbmQoY3R4LCB0aGlzLCBwcmV2RWwpO1xuICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oY3R4KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX19kaXJ0eSkge1xuICAgICAgICAgICAgICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgZ3JhZGllbnQgYmVjYXVzZSBib3VuZGluZyByZWN0IG1heSBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgaWYgKGhhc0ZpbGxHcmFkaWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9maWxsR3JhZGllbnQgPSBzdHlsZS5nZXRHcmFkaWVudChjdHgsIGZpbGwsIHJlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFzU3Ryb2tlR3JhZGllbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3Ryb2tlR3JhZGllbnQgPSBzdHlsZS5nZXRHcmFkaWVudChjdHgsIHN0cm9rZSwgcmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXNlIHRoZSBncmFkaWVudCBvciBwYXR0ZXJuXG4gICAgICAgICAgICBpZiAoaGFzRmlsbEdyYWRpZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gUEVORElORyBJZiBtYXkgaGF2ZSBhZmZlY3QgdGhlIHN0YXRlXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuX2ZpbGxHcmFkaWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc0ZpbGxQYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGdldENhbnZhc1BhdHRlcm4uY2FsbChmaWxsLCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc1N0cm9rZUdyYWRpZW50KSB7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5fc3Ryb2tlR3JhZGllbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYXNTdHJva2VQYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gZ2V0Q2FudmFzUGF0dGVybi5jYWxsKHN0cm9rZSwgY3R4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxpbmVEYXNoID0gc3R5bGUubGluZURhc2g7XG4gICAgICAgICAgICB2YXIgbGluZURhc2hPZmZzZXQgPSBzdHlsZS5saW5lRGFzaE9mZnNldDtcblxuICAgICAgICAgICAgdmFyIGN0eExpbmVEYXNoID0gISFjdHguc2V0TGluZURhc2g7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBwYXRoIHN4LCBzeVxuICAgICAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5nZXRHbG9iYWxTY2FsZSgpO1xuICAgICAgICAgICAgcGF0aC5zZXRTY2FsZShzY2FsZVswXSwgc2NhbGVbMV0pO1xuXG4gICAgICAgICAgICAvLyBQcm94eSBjb250ZXh0XG4gICAgICAgICAgICAvLyBSZWJ1aWxkIHBhdGggaW4gZm9sbG93aW5nIDIgY2FzZXNcbiAgICAgICAgICAgIC8vIDEuIFBhdGggaXMgZGlydHlcbiAgICAgICAgICAgIC8vIDIuIFBhdGggbmVlZHMgamF2YXNjcmlwdCBpbXBsZW1lbnRlZCBsaW5lRGFzaCBzdHJva2luZy5cbiAgICAgICAgICAgIC8vICAgIEluIHRoaXMgY2FzZSwgbGluZURhc2ggaW5mb3JtYXRpb24gd2lsbCBub3QgYmUgc2F2ZWQgaW4gUGF0aFByb3h5XG4gICAgICAgICAgICBpZiAodGhpcy5fX2RpcnR5UGF0aCB8fCAoXG4gICAgICAgICAgICAgICAgbGluZURhc2ggJiYgIWN0eExpbmVEYXNoICYmIGhhc1N0cm9rZVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgIHBhdGggPSB0aGlzLnBhdGguYmVnaW5QYXRoKGN0eCk7XG5cbiAgICAgICAgICAgICAgICAvLyBTZXR0aW5nIGxpbmUgZGFzaCBiZWZvcmUgYnVpbGQgcGF0aFxuICAgICAgICAgICAgICAgIGlmIChsaW5lRGFzaCAmJiAhY3R4TGluZURhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5zZXRMaW5lRGFzaChsaW5lRGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIHBhdGguc2V0TGluZURhc2hPZmZzZXQobGluZURhc2hPZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRQYXRoKHBhdGgsIHRoaXMuc2hhcGUsIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgIC8vIENsZWFyIHBhdGggZGlydHkgZmxhZ1xuICAgICAgICAgICAgICAgIHRoaXMuX19kaXJ0eVBhdGggPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFJlcGxheSBwYXRoIGJ1aWxkaW5nXG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucGF0aC5yZWJ1aWxkUGF0aChjdHgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoYXNGaWxsICYmIHBhdGguZmlsbChjdHgpO1xuXG4gICAgICAgICAgICBpZiAobGluZURhc2ggJiYgY3R4TGluZURhc2gpIHtcbiAgICAgICAgICAgICAgICBjdHguc2V0TGluZURhc2gobGluZURhc2gpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGxpbmVEYXNoT2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoYXNTdHJva2UgJiYgcGF0aC5zdHJva2UoY3R4KTtcblxuICAgICAgICAgICAgaWYgKGxpbmVEYXNoICYmIGN0eExpbmVEYXNoKSB7XG4gICAgICAgICAgICAgICAgLy8gUEVORElOR1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBsaW5lRGFzaFxuICAgICAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChbXSk7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgdGhpcy5yZXN0b3JlVHJhbnNmb3JtKGN0eCk7XG5cbiAgICAgICAgICAgIC8vIERyYXcgcmVjdCB0ZXh0XG4gICAgICAgICAgICBpZiAoc3R5bGUudGV4dCB8fCBzdHlsZS50ZXh0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd1JlY3RUZXh0KGN0eCwgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gV2hlbiBidW5kbGluZyBwYXRoLCBzb21lIHNoYXBlIG1heSBkZWNpZGUgaWYgdXNlIG1vdmVUbyB0byBiZWdpbiBhIG5ldyBzdWJwYXRoIG9yIGNsb3NlUGF0aFxuICAgICAgICAvLyBMaWtlIGluIGNpcmNsZVxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlQ2ZnLCBpbkJ1bmRsZSkge30sXG5cbiAgICAgICAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IHRoaXMuX3JlY3Q7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgICAgICAgICAgdmFyIG5lZWRzVXBkYXRlUmVjdCA9ICFyZWN0O1xuICAgICAgICAgICAgaWYgKG5lZWRzVXBkYXRlUmVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoID0gdGhpcy5wYXRoO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fZGlydHlQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRQYXRoKHBhdGgsIHRoaXMuc2hhcGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVjdCA9IHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yZWN0ID0gcmVjdDtcblxuICAgICAgICAgICAgaWYgKHN0eWxlLmhhc1N0cm9rZSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gTmVlZHMgdXBkYXRlIHJlY3Qgd2l0aCBzdHJva2UgbGluZVdpZHRoIHdoZW5cbiAgICAgICAgICAgICAgICAvLyAxLiBFbGVtZW50IGNoYW5nZXMgc2NhbGUgb3IgbGluZVdpZHRoXG4gICAgICAgICAgICAgICAgLy8gMi4gU2hhcGUgaXMgY2hhbmdlZFxuICAgICAgICAgICAgICAgIHZhciByZWN0V2l0aFN0cm9rZSA9IHRoaXMuX3JlY3RXaXRoU3Ryb2tlIHx8ICh0aGlzLl9yZWN0V2l0aFN0cm9rZSA9IHJlY3QuY2xvbmUoKSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19kaXJ0eSB8fCBuZWVkc1VwZGF0ZVJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdFdpdGhTdHJva2UuY29weShyZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgTXVzdCBhZnRlciB1cGRhdGVUcmFuc2Zvcm1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHcgPSBzdHlsZS5saW5lV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBFTkRJTkcsIE1pbiBsaW5lIHdpZHRoIGlzIG5lZWRlZCB3aGVuIGxpbmUgaXMgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbFxuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZVNjYWxlID0gc3R5bGUuc3Ryb2tlTm9TY2FsZSA/IHRoaXMuZ2V0TGluZVNjYWxlKCkgOiAxO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgYWRkIGV4dHJhIGhvdmVyIGxpbmVXaWR0aCB3aGVuIHRoZXJlIGFyZSBubyBmaWxsXG4gICAgICAgICAgICAgICAgICAgIGlmICghc3R5bGUuaGFzRmlsbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ID0gTWF0aC5tYXgodywgdGhpcy5zdHJva2VDb250YWluVGhyZXNob2xkIHx8IDQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnNpZGVyIGxpbmUgd2lkdGhcbiAgICAgICAgICAgICAgICAgICAgLy8gTGluZSBzY2FsZSBjYW4ndCBiZSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGluZVNjYWxlID4gMWUtMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RXaXRoU3Ryb2tlLndpZHRoICs9IHcgLyBsaW5lU2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0V2l0aFN0cm9rZS5oZWlnaHQgKz0gdyAvIGxpbmVTY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RXaXRoU3Ryb2tlLnggLT0gdyAvIGxpbmVTY2FsZSAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0V2l0aFN0cm9rZS55IC09IHcgLyBsaW5lU2NhbGUgLyAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIHJlY3Qgd2l0aCBzdHJva2VcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjdFdpdGhTdHJva2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbnRhaW46IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxQb3MgPSB0aGlzLnRyYW5zZm9ybUNvb3JkVG9Mb2NhbCh4LCB5KTtcbiAgICAgICAgICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICB4ID0gbG9jYWxQb3NbMF07XG4gICAgICAgICAgICB5ID0gbG9jYWxQb3NbMV07XG5cbiAgICAgICAgICAgIGlmIChyZWN0LmNvbnRhaW4oeCwgeSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aERhdGEgPSB0aGlzLnBhdGguZGF0YTtcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUuaGFzU3Ryb2tlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHN0eWxlLmxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVTY2FsZSA9IHN0eWxlLnN0cm9rZU5vU2NhbGUgPyB0aGlzLmdldExpbmVTY2FsZSgpIDogMTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTGluZSBzY2FsZSBjYW4ndCBiZSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGluZVNjYWxlID4gMWUtMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgYWRkIGV4dHJhIGhvdmVyIGxpbmVXaWR0aCB3aGVuIHRoZXJlIGFyZSBubyBmaWxsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0eWxlLmhhc0ZpbGwoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aCA9IE1hdGgubWF4KGxpbmVXaWR0aCwgdGhpcy5zdHJva2VDb250YWluVGhyZXNob2xkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXRoQ29udGFpbi5jb250YWluU3Ryb2tlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhEYXRhLCBsaW5lV2lkdGggLyBsaW5lU2NhbGUsIHgsIHlcbiAgICAgICAgICAgICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUuaGFzRmlsbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRoQ29udGFpbi5jb250YWluKHBhdGhEYXRhLCB4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IGRpcnR5UGF0aFxuICAgICAgICAgKi9cbiAgICAgICAgZGlydHk6IGZ1bmN0aW9uIChkaXJ0eVBhdGgpIHtcbiAgICAgICAgICAgIGlmIChkaXJ0eVBhdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRpcnR5UGF0aCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPbmx5IG1hcmsgZGlydHksIG5vdCBtYXJrIGNsZWFuXG4gICAgICAgICAgICBpZiAoZGlydHlQYXRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2RpcnR5UGF0aCA9IGRpcnR5UGF0aDtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fX2RpcnR5ID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7XG5cbiAgICAgICAgICAgIC8vIFVzZWQgYXMgYSBjbGlwcGluZyBwYXRoXG4gICAgICAgICAgICBpZiAodGhpcy5fX2NsaXBUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fY2xpcFRhcmdldC5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGlhcyBmb3IgYW5pbWF0ZSgnc2hhcGUnKVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvb3BcbiAgICAgICAgICovXG4gICAgICAgIGFuaW1hdGVTaGFwZTogZnVuY3Rpb24gKGxvb3ApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUoJ3NoYXBlJywgbG9vcCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gT3ZlcndyaXRlIGF0dHJLVlxuICAgICAgICBhdHRyS1Y6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3NoYXBlJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U2hhcGUodmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX19kaXJ0eVBhdGggPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlY3QgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgRGlzcGxheWFibGUucHJvdG90eXBlLmF0dHJLVi5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IGtleVxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICAgICAqL1xuICAgICAgICBzZXRTaGFwZTogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7XG4gICAgICAgICAgICAvLyBQYXRoIGZyb20gc3RyaW5nIG1heSBub3QgaGF2ZSBzaGFwZVxuICAgICAgICAgICAgaWYgKHNoYXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHpyVXRpbC5pc09iamVjdChrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFwZVtuYW1lXSA9IGtleVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhcGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5KHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0TGluZVNjYWxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBsaW5lIHNjYWxlLlxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5hbnQgb2YgYG1gIG1lYW5zIGhvdyBtdWNoIHRoZSBhcmVhIGlzIGVubGFyZ2VkIGJ5IHRoZVxuICAgICAgICAgICAgLy8gdHJhbnNmb3JtYXRpb24uIFNvIGl0cyBzcXVhcmUgcm9vdCBjYW4gYmUgdXNlZCBhcyBhIHNjYWxlIGZhY3RvclxuICAgICAgICAgICAgLy8gZm9yIHdpZHRoLlxuICAgICAgICAgICAgcmV0dXJuIG0gJiYgYWJzKG1bMF0gLSAxKSA+IDFlLTEwICYmIGFicyhtWzNdIC0gMSkgPiAxZS0xMFxuICAgICAgICAgICAgICAgID8gTWF0aC5zcXJ0KGFicyhtWzBdICogbVszXSAtIG1bMl0gKiBtWzFdKSlcbiAgICAgICAgICAgICAgICA6IDE7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICog5omp5bGV5LiA5LiqIFBhdGggZWxlbWVudCwg5q+U5aaC5pif5b2i77yM5ZyG562J44CCXG4gICAgICogRXh0ZW5kIGEgcGF0aCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BzLnR5cGUgUGF0aCB0eXBlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvcHMuaW5pdCBJbml0aWFsaXplXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvcHMuYnVpbGRQYXRoIE92ZXJ3cml0ZSBidWlsZFBhdGggbWV0aG9kXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5zdHlsZV0gRXh0ZW5kZWQgZGVmYXVsdCBzdHlsZSBjb25maWdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzLnNoYXBlXSBFeHRlbmRlZCBkZWZhdWx0IHNoYXBlIGNvbmZpZ1xuICAgICAqL1xuICAgIFBhdGguZXh0ZW5kID0gZnVuY3Rpb24gKGRlZmF1bHRzKSB7XG4gICAgICAgIHZhciBTdWIgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICAgICAgUGF0aC5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gICAgICAgICAgICBpZiAoZGVmYXVsdHMuc3R5bGUpIHtcbiAgICAgICAgICAgICAgICAvLyBFeHRlbmQgZGVmYXVsdCBzdHlsZVxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGUuZXh0ZW5kRnJvbShkZWZhdWx0cy5zdHlsZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFeHRlbmQgZGVmYXVsdCBzaGFwZVxuICAgICAgICAgICAgdmFyIGRlZmF1bHRTaGFwZSA9IGRlZmF1bHRzLnNoYXBlO1xuICAgICAgICAgICAgaWYgKGRlZmF1bHRTaGFwZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hhcGUgPSB0aGlzLnNoYXBlIHx8IHt9O1xuICAgICAgICAgICAgICAgIHZhciB0aGlzU2hhcGUgPSB0aGlzLnNoYXBlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gZGVmYXVsdFNoYXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICEgdGhpc1NoYXBlLmhhc093blByb3BlcnR5KG5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBkZWZhdWx0U2hhcGUuaGFzT3duUHJvcGVydHkobmFtZSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzU2hhcGVbbmFtZV0gPSBkZWZhdWx0U2hhcGVbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlZmF1bHRzLmluaXQgJiYgZGVmYXVsdHMuaW5pdC5jYWxsKHRoaXMsIG9wdHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHpyVXRpbC5pbmhlcml0cyhTdWIsIFBhdGgpO1xuXG4gICAgICAgIC8vIEZJWE1FIOS4jeiDvSBleHRlbmQgcG9zaXRpb24sIHJvdGF0aW9uIOetieW8leeUqOWvueixoVxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIGRlZmF1bHRzKSB7XG4gICAgICAgICAgICAvLyBFeHRlbmRpbmcgcHJvdG90eXBlIHZhbHVlcyBhbmQgbWV0aG9kc1xuICAgICAgICAgICAgaWYgKG5hbWUgIT09ICdzdHlsZScgJiYgbmFtZSAhPT0gJ3NoYXBlJykge1xuICAgICAgICAgICAgICAgIFN1Yi5wcm90b3R5cGVbbmFtZV0gPSBkZWZhdWx0c1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBTdWI7XG4gICAgfTtcblxuICAgIHpyVXRpbC5pbmhlcml0cyhQYXRoLCBEaXNwbGF5YWJsZSk7XG5cbiAgICByZXR1cm4gUGF0aDtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvenJlbmRlci9ncmFwaGljL1BhdGguanNcbiAqKiBtb2R1bGUgaWQgPSA0OVxuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiLyoqXG4gKiDlj6/nu5jliLbnmoTlm77lvaLln7rnsbtcbiAqIEJhc2UgY2xhc3Mgb2YgYWxsIGRpc3BsYXlhYmxlIGdyYXBoaWMgb2JqZWN0c1xuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGVcbiAqL1xuXG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcblxuICAgIHZhciBTdHlsZSA9IHJlcXVpcmUoJy4vU3R5bGUnKTtcblxuICAgIHZhciBFbGVtZW50ID0gcmVxdWlyZSgnLi4vRWxlbWVudCcpO1xuICAgIHZhciBSZWN0VGV4dCA9IHJlcXVpcmUoJy4vbWl4aW4vUmVjdFRleHQnKTtcbiAgICAvLyB2YXIgU3RhdGVmdWwgPSByZXF1aXJlKCcuL21peGluL1N0YXRlZnVsJyk7XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL0VsZW1lbnRcbiAgICAgKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL21peGluL1JlY3RUZXh0XG4gICAgICovXG4gICAgZnVuY3Rpb24gRGlzcGxheWFibGUob3B0cykge1xuXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgICAgIEVsZW1lbnQuY2FsbCh0aGlzLCBvcHRzKTtcblxuICAgICAgICAvLyBFeHRlbmQgcHJvcGVydGllc1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIG9wdHMpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBvcHRzLmhhc093blByb3BlcnR5KG5hbWUpICYmXG4gICAgICAgICAgICAgICAgbmFtZSAhPT0gJ3N0eWxlJ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tuYW1lXSA9IG9wdHNbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvU3R5bGV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0eWxlID0gbmV3IFN0eWxlKG9wdHMuc3R5bGUpO1xuXG4gICAgICAgIHRoaXMuX3JlY3QgPSBudWxsO1xuICAgICAgICAvLyBTaGFwZXMgZm9yIGNhc2NhZGUgY2xpcHBpbmcuXG4gICAgICAgIHRoaXMuX19jbGlwUGF0aHMgPSBbXTtcblxuICAgICAgICAvLyBGSVhNRSBTdGF0ZWZ1bCBtdXN0IGJlIG1peGluZWQgYWZ0ZXIgc3R5bGUgaXMgc2V0dGVkXG4gICAgICAgIC8vIFN0YXRlZnVsLmNhbGwodGhpcywgb3B0cyk7XG4gICAgfVxuXG4gICAgRGlzcGxheWFibGUucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBEaXNwbGF5YWJsZSxcblxuICAgICAgICB0eXBlOiAnZGlzcGxheWFibGUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5YWJsZSDmmK/lkKbkuLrohI/vvIxQYWludGVyIOS4reS8muagueaNruivpeagh+iusOWIpOaWreaYr+WQpumcgOimgeaYr+WQpumcgOimgemHjeaWsOe7mOWItlxuICAgICAgICAgKiBEaXJ0eSBmbGFnLiBGcm9tIHdoaWNoIHBhaW50ZXIgd2lsbCBkZXRlcm1pbmUgaWYgdGhpcyBkaXNwbGF5YWJsZSBvYmplY3QgbmVlZHMgYnJ1c2hcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNfX2RpcnR5XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgX19kaXJ0eTogdHJ1ZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Zu+5b2i5piv5ZCm5Y+v6KeB77yM5Li6dHJ1ZeaXtuS4jee7mOWItuWbvuW9ou+8jOS9huaYr+S7jeiDveinpuWPkem8oOagh+S6i+S7tlxuICAgICAgICAgKiBJZiBpZ25vcmUgZHJhd2luZyBvZiB0aGUgZGlzcGxheWFibGUgb2JqZWN0LiBNb3VzZSBldmVudCB3aWxsIHN0aWxsIGJlIHRyaWdnZXJlZFxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNpbnZpc2libGVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBpbnZpc2libGU6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSN6XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHo6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3pcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgejI6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHrlsYJsZXZlbO+8jOWGs+Wumue7mOeUu+WcqOWTquWxgmNhbnZhc+S4rVxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSN6bGV2ZWxcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgemxldmVsOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKblj6/mi5bmi71cbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjZHJhZ2dhYmxlXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ2dhYmxlOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5q2j5Zyo5ouW5ou9XG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI2RyYWdnYWJsZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdnaW5nOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm55u45bqU6byg5qCH5LqL5Lu2XG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3NpbGVudFxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHNpbGVudDogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGVuYWJsZSBjdWxsaW5nXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgY3VsbGluZzogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vdXNlIGN1cnNvciB3aGVuIGhvdmVyZWRcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjY3Vyc29yXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBjdXJzb3I6ICdwb2ludGVyJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgaG92ZXIgYXJlYSBpcyBib3VuZGluZyByZWN0XG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3JlY3RIb3ZlclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgcmVjdEhvdmVyOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVuZGVyIHRoZSBlbGVtZW50IHByb2dyZXNzaXZlbHkgd2hlbiB0aGUgdmFsdWUgPj0gMCxcbiAgICAgICAgICogdXNlZnVsbCBmb3IgbGFyZ2UgZGF0YS5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHByb2dyZXNzaXZlOiAtMSxcblxuICAgICAgICBiZWZvcmVCcnVzaDogZnVuY3Rpb24gKGN0eCkge30sXG5cbiAgICAgICAgYWZ0ZXJCcnVzaDogZnVuY3Rpb24gKGN0eCkge30sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWbvuW9oue7mOWItuaWueazlVxuICAgICAgICAgKiBAcGFyYW0ge0NhbnZhczJEUmVuZGVyaW5nQ29udGV4dH0gY3R4XG4gICAgICAgICAqL1xuICAgICAgICAvLyBJbnRlcmZhY2VcbiAgICAgICAgYnJ1c2g6IGZ1bmN0aW9uIChjdHgsIHByZXZFbCkge30sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPluacgOWwj+WMheWbtOebklxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICAgICAgICovXG4gICAgICAgIC8vIEludGVyZmFjZVxuICAgICAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHt9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliKTmlq3lnZDmoIcgeCwgeSDmmK/lkKblnKjlm77lvaLkuIpcbiAgICAgICAgICogSWYgZGlzcGxheWFibGUgZWxlbWVudCBjb250YWluIGNvb3JkIHgsIHlcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpbjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlY3RDb250YWluKHgsIHkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICogQHBhcmFtICB7fSAgIGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIHRyYXZlcnNlOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIpOaWreWdkOaghyB4LCB5IOaYr+WQpuWcqOWbvuW9oueahOWMheWbtOebkuS4ilxuICAgICAgICAgKiBJZiBib3VuZGluZyByZWN0IG9mIGVsZW1lbnQgY29udGFpbiBjb29yZCB4LCB5XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHJlY3RDb250YWluOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIGNvb3JkID0gdGhpcy50cmFuc2Zvcm1Db29yZFRvTG9jYWwoeCwgeSk7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgICAgICByZXR1cm4gcmVjdC5jb250YWluKGNvb3JkWzBdLCBjb29yZFsxXSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOagh+iusOWbvuW9ouWFg+e0oOS4uuiEj++8jOW5tuS4lOWcqOS4i+S4gOW4p+mHjee7mFxuICAgICAgICAgKiBNYXJrIGRpc3BsYXlhYmxlIGVsZW1lbnQgZGlydHkgYW5kIHJlZnJlc2ggbmV4dCBmcmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgZGlydHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX19kaXJ0eSA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuX3JlY3QgPSBudWxsO1xuXG4gICAgICAgICAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Zu+5b2i5piv5ZCm5Lya6Kem5Y+R5LqL5Lu2XG4gICAgICAgICAqIElmIGRpc3BsYXlhYmxlIG9iamVjdCBiaW5kZWQgYW55IGV2ZW50XG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICAvLyBUT0RPLCDpgJrov4cgYmluZCDnu5HlrprnmoTkuovku7ZcbiAgICAgICAgLy8gaXNTaWxlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gICAgIHJldHVybiAhKFxuICAgICAgICAvLyAgICAgICAgIHRoaXMuaG92ZXJhYmxlIHx8IHRoaXMuZHJhZ2dhYmxlXG4gICAgICAgIC8vICAgICAgICAgfHwgdGhpcy5vbm1vdXNlbW92ZSB8fCB0aGlzLm9ubW91c2VvdmVyIHx8IHRoaXMub25tb3VzZW91dFxuICAgICAgICAvLyAgICAgICAgIHx8IHRoaXMub25tb3VzZWRvd24gfHwgdGhpcy5vbm1vdXNldXAgfHwgdGhpcy5vbmNsaWNrXG4gICAgICAgIC8vICAgICAgICAgfHwgdGhpcy5vbmRyYWdlbnRlciB8fCB0aGlzLm9uZHJhZ292ZXIgfHwgdGhpcy5vbmRyYWdsZWF2ZVxuICAgICAgICAvLyAgICAgICAgIHx8IHRoaXMub25kcm9wXG4gICAgICAgIC8vICAgICApO1xuICAgICAgICAvLyB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQWxpYXMgZm9yIGFuaW1hdGUoJ3N0eWxlJylcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBsb29wXG4gICAgICAgICAqL1xuICAgICAgICBhbmltYXRlU3R5bGU6IGZ1bmN0aW9uIChsb29wKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRlKCdzdHlsZScsIGxvb3ApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGF0dHJLVjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChrZXkgIT09ICdzdHlsZScpIHtcbiAgICAgICAgICAgICAgICBFbGVtZW50LnByb3RvdHlwZS5hdHRyS1YuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGUuc2V0KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBrZXlcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0U3R5bGU6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZSBnaXZlbiBzdHlsZSBvYmplY3RcbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBvYmpcbiAgICAgICAgICovXG4gICAgICAgIHVzZVN0eWxlOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlID0gbmV3IFN0eWxlKG9iaik7XG4gICAgICAgICAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHpyVXRpbC5pbmhlcml0cyhEaXNwbGF5YWJsZSwgRWxlbWVudCk7XG5cbiAgICB6clV0aWwubWl4aW4oRGlzcGxheWFibGUsIFJlY3RUZXh0KTtcbiAgICAvLyB6clV0aWwubWl4aW4oRGlzcGxheWFibGUsIFN0YXRlZnVsKTtcblxuICAgIHJldHVybiBEaXNwbGF5YWJsZTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gNTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsIi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvU3R5bGVcbiAqL1xuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cbiAgICB2YXIgU1RZTEVfQ09NTU9OX1BST1BTID0gW1xuICAgICAgICBbJ3NoYWRvd0JsdXInLCAwXSwgWydzaGFkb3dPZmZzZXRYJywgMF0sIFsnc2hhZG93T2Zmc2V0WScsIDBdLCBbJ3NoYWRvd0NvbG9yJywgJyMwMDAnXSxcbiAgICAgICAgWydsaW5lQ2FwJywgJ2J1dHQnXSwgWydsaW5lSm9pbicsICdtaXRlciddLCBbJ21pdGVyTGltaXQnLCAxMF1cbiAgICBdO1xuXG4gICAgLy8gdmFyIFNIQURPV19QUk9QUyA9IFNUWUxFX0NPTU1PTl9QUk9QUy5zbGljZSgwLCA0KTtcbiAgICAvLyB2YXIgTElORV9QUk9QUyA9IFNUWUxFX0NPTU1PTl9QUk9QUy5zbGljZSg0KTtcblxuICAgIHZhciBTdHlsZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgIHRoaXMuZXh0ZW5kRnJvbShvcHRzKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlTGluZWFyR3JhZGllbnQoY3R4LCBvYmosIHJlY3QpIHtcbiAgICAgICAgLy8gdmFyIHNpemUgPVxuICAgICAgICB2YXIgeCA9IG9iai54O1xuICAgICAgICB2YXIgeDIgPSBvYmoueDI7XG4gICAgICAgIHZhciB5ID0gb2JqLnk7XG4gICAgICAgIHZhciB5MiA9IG9iai55MjtcblxuICAgICAgICBpZiAoIW9iai5nbG9iYWwpIHtcbiAgICAgICAgICAgIHggPSB4ICogcmVjdC53aWR0aCArIHJlY3QueDtcbiAgICAgICAgICAgIHgyID0geDIgKiByZWN0LndpZHRoICsgcmVjdC54O1xuICAgICAgICAgICAgeSA9IHkgKiByZWN0LmhlaWdodCArIHJlY3QueTtcbiAgICAgICAgICAgIHkyID0geTIgKiByZWN0LmhlaWdodCArIHJlY3QueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYW52YXNHcmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCh4LCB5LCB4MiwgeTIpO1xuXG4gICAgICAgIHJldHVybiBjYW52YXNHcmFkaWVudDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVSYWRpYWxHcmFkaWVudChjdHgsIG9iaiwgcmVjdCkge1xuICAgICAgICB2YXIgd2lkdGggPSByZWN0LndpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICB2YXIgeCA9IG9iai54O1xuICAgICAgICB2YXIgeSA9IG9iai55O1xuICAgICAgICB2YXIgciA9IG9iai5yO1xuICAgICAgICBpZiAoIW9iai5nbG9iYWwpIHtcbiAgICAgICAgICAgIHggPSB4ICogd2lkdGggKyByZWN0Lng7XG4gICAgICAgICAgICB5ID0geSAqIGhlaWdodCArIHJlY3QueTtcbiAgICAgICAgICAgIHIgPSByICogbWluO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNhbnZhc0dyYWRpZW50ID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHgsIHksIDAsIHgsIHksIHIpO1xuXG4gICAgICAgIHJldHVybiBjYW52YXNHcmFkaWVudDtcbiAgICB9XG5cblxuICAgIFN0eWxlLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogU3R5bGUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBmaWxsOiAnIzAwMDAwMCcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBzdHJva2U6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBvcGFjaXR5OiAxLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICBsaW5lRGFzaDogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpbmVEYXNoT2Zmc2V0OiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgc2hhZG93Qmx1cjogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHNoYWRvd09mZnNldFg6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBzaGFkb3dPZmZzZXRZOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgbGluZVdpZHRoOiAxLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzdHJva2UgaWdub3JlIHNjYWxlXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgc3Ryb2tlTm9TY2FsZTogZmFsc2UsXG5cbiAgICAgICAgLy8gQm91bmRpbmcgcmVjdCB0ZXh0IGNvbmZpZ3VyYXRpb25cbiAgICAgICAgLy8gTm90IGFmZmVjdGVkIGJ5IGVsZW1lbnQgdHJhbnNmb3JtXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dDogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRleHRGaWxsOiAnIzAwMCcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0U3Ryb2tlOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAnaW5zaWRlJywgJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbSdcbiAgICAgICAgICogW3gsIHldXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd8QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqIEBkZWZhdWx0ICdpbnNpZGUnXG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0UG9zaXRpb246ICdpbnNpZGUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dEJhc2VsaW5lOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dEFsaWduOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ246IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9ubHkgdXNlZnVsIGluIFBhdGggYW5kIEltYWdlIGVsZW1lbnRcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRleHREaXN0YW5jZTogNSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogT25seSB1c2VmdWwgaW4gUGF0aCBhbmQgSW1hZ2UgZWxlbWVudFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dFNoYWRvd0JsdXI6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9ubHkgdXNlZnVsIGluIFBhdGggYW5kIEltYWdlIGVsZW1lbnRcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRleHRTaGFkb3dPZmZzZXRYOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPbmx5IHVzZWZ1bCBpbiBQYXRoIGFuZCBJbWFnZSBlbGVtZW50XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0U2hhZG93T2Zmc2V0WTogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdHJhbnNmb3JtIHRleHRcbiAgICAgICAgICogT25seSB1c2VmdWwgaW4gUGF0aCBhbmQgSW1hZ2UgZWxlbWVudFxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRleHRUcmFuc2Zvcm06IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXh0IHJvdGF0ZSBhcm91bmQgcG9zaXRpb24gb2YgUGF0aCBvciBJbWFnZVxuICAgICAgICAgKiBPbmx5IHVzZWZ1bCBpbiBQYXRoIGFuZCBJbWFnZSBlbGVtZW50IGFuZCB0ZXh0VHJhbnNmb3JtIGlzIGZhbHNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dFJvdGF0aW9uOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2dsb2JhbENvbXBvc2l0ZU9wZXJhdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgYmxlbmQ6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgICAgICovXG4gICAgICAgIGJpbmQ6IGZ1bmN0aW9uIChjdHgsIGVsLCBwcmV2RWwpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgcHJldlN0eWxlID0gcHJldkVsICYmIHByZXZFbC5zdHlsZTtcbiAgICAgICAgICAgIHZhciBmaXJzdERyYXcgPSAhcHJldlN0eWxlO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFNUWUxFX0NPTU1PTl9QUk9QUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wID0gU1RZTEVfQ09NTU9OX1BST1BTW2ldO1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZU5hbWUgPSBwcm9wWzBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0RHJhdyB8fCBzdHlsZVtzdHlsZU5hbWVdICE9PSBwcmV2U3R5bGVbc3R5bGVOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBJbnZhbGlkIHByb3BlcnR5IHZhbHVlIHdpbGwgY2F1c2Ugc3R5bGUgbGVhayBmcm9tIHByZXZpb3VzIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIGN0eFtzdHlsZU5hbWVdID0gc3R5bGVbc3R5bGVOYW1lXSB8fCBwcm9wWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKChmaXJzdERyYXcgfHwgc3R5bGUuZmlsbCAhPT0gcHJldlN0eWxlLmZpbGwpKSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHN0eWxlLmZpbGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGZpcnN0RHJhdyB8fCBzdHlsZS5zdHJva2UgIT09IHByZXZTdHlsZS5zdHJva2UpKSB7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGUuc3Ryb2tlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChmaXJzdERyYXcgfHwgc3R5bGUub3BhY2l0eSAhPT0gcHJldlN0eWxlLm9wYWNpdHkpKSB7XG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gc3R5bGUub3BhY2l0eSA9PSBudWxsID8gMSA6IHN0eWxlLm9wYWNpdHk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgoZmlyc3REcmF3IHx8IHN0eWxlLmJsZW5kICE9PSBwcmV2U3R5bGUuYmxlbmQpKSB7XG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHN0eWxlLmJsZW5kIHx8ICdzb3VyY2Utb3Zlcic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNTdHJva2UoKSkge1xuICAgICAgICAgICAgICAgIHZhciBsaW5lV2lkdGggPSBzdHlsZS5saW5lV2lkdGg7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aCAvIChcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuc3Ryb2tlTm9TY2FsZSAmJiBlbCAmJiBlbC5nZXRMaW5lU2NhbGUpID8gZWwuZ2V0TGluZVNjYWxlKCkgOiAxXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBoYXNGaWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZmlsbCA9IHRoaXMuZmlsbDtcbiAgICAgICAgICAgIHJldHVybiBmaWxsICE9IG51bGwgJiYgZmlsbCAhPT0gJ25vbmUnO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhc1N0cm9rZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0cm9rZSA9IHRoaXMuc3Ryb2tlO1xuICAgICAgICAgICAgcmV0dXJuIHN0cm9rZSAhPSBudWxsICYmIHN0cm9rZSAhPT0gJ25vbmUnICYmIHRoaXMubGluZVdpZHRoID4gMDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXh0ZW5kIGZyb20gb3RoZXIgc3R5bGVcbiAgICAgICAgICogQHBhcmFtIHt6cmVuZGVyL2dyYXBoaWMvU3R5bGV9IG90aGVyU3R5bGVcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBvdmVyd3JpdGVcbiAgICAgICAgICovXG4gICAgICAgIGV4dGVuZEZyb206IGZ1bmN0aW9uIChvdGhlclN0eWxlLCBvdmVyd3JpdGUpIHtcbiAgICAgICAgICAgIGlmIChvdGhlclN0eWxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBvdGhlclN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdGhlclN0eWxlLmhhc093blByb3BlcnR5KG5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiAob3ZlcndyaXRlIHx8ICEgdGFyZ2V0Lmhhc093blByb3BlcnR5KG5hbWUpKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IG90aGVyU3R5bGVbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJhdGNoIHNldHRpbmcgc3R5bGUgd2l0aCBhIGdpdmVuIG9iamVjdFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IG9ialxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvYmpdXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChvYmosIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzW29ial0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZXh0ZW5kRnJvbShvYmosIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbG9uZVxuICAgICAgICAgKiBAcmV0dXJuIHt6cmVuZGVyL2dyYXBoaWMvU3R5bGV9IFtkZXNjcmlwdGlvbl1cbiAgICAgICAgICovXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbmV3U3R5bGUgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpO1xuICAgICAgICAgICAgbmV3U3R5bGUuZXh0ZW5kRnJvbSh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXdTdHlsZTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRHcmFkaWVudDogZnVuY3Rpb24gKGN0eCwgb2JqLCByZWN0KSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gb2JqLnR5cGUgPT09ICdyYWRpYWwnID8gY3JlYXRlUmFkaWFsR3JhZGllbnQgOiBjcmVhdGVMaW5lYXJHcmFkaWVudDtcbiAgICAgICAgICAgIHZhciBjYW52YXNHcmFkaWVudCA9IG1ldGhvZChjdHgsIG9iaiwgcmVjdCk7XG4gICAgICAgICAgICB2YXIgY29sb3JTdG9wcyA9IG9iai5jb2xvclN0b3BzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xvclN0b3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2FudmFzR3JhZGllbnQuYWRkQ29sb3JTdG9wKFxuICAgICAgICAgICAgICAgICAgICBjb2xvclN0b3BzW2ldLm9mZnNldCwgY29sb3JTdG9wc1tpXS5jb2xvclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FudmFzR3JhZGllbnQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHN0eWxlUHJvdG8gPSBTdHlsZS5wcm90b3R5cGU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBTVFlMRV9DT01NT05fUFJPUFMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3AgPSBTVFlMRV9DT01NT05fUFJPUFNbaV07XG4gICAgICAgIGlmICghKHByb3BbMF0gaW4gc3R5bGVQcm90bykpIHtcbiAgICAgICAgICAgIHN0eWxlUHJvdG9bcHJvcFswXV0gPSBwcm9wWzFdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHJvdmlkZSBmb3Igb3RoZXJzXG4gICAgU3R5bGUuZ2V0R3JhZGllbnQgPSBzdHlsZVByb3RvLmdldEdyYWRpZW50O1xuXG4gICAgcmV0dXJuIFN0eWxlO1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC96cmVuZGVyL2dyYXBoaWMvU3R5bGUuanNcbiAqKiBtb2R1bGUgaWQgPSA1MVxuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiLyoqXG4gKiBNaXhpbiBmb3IgZHJhd2luZyB0ZXh0IGluIGEgZWxlbWVudCBib3VuZGluZyByZWN0XG4gKiBAbW9kdWxlIHpyZW5kZXIvbWl4aW4vUmVjdFRleHRcbiAqL1xuXG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuICAgIHZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoJy4uLy4uL2NvbnRhaW4vdGV4dCcpO1xuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCcuLi8uLi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xuXG4gICAgdmFyIHRtcFJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KCk7XG5cbiAgICB2YXIgUmVjdFRleHQgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlUGVyY2VudCh2YWx1ZSwgbWF4VmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sYXN0SW5kZXhPZignJScpID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkgLyAxMDAgKiBtYXhWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgUmVjdFRleHQucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBSZWN0VGV4dCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRHJhdyB0ZXh0IGluIGEgcmVjdCB3aXRoIHNwZWNpZmllZCBwb3NpdGlvbi5cbiAgICAgICAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dH0gY3R4XG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gcmVjdCBEaXNwbGF5YWJsZSByZWN0XG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gdGV4dFJlY3QgQWx0ZXJuYXRpdmUgcHJlY2FsY3VsYXRlZCB0ZXh0IGJvdW5kaW5nIHJlY3RcbiAgICAgICAgICovXG4gICAgICAgIGRyYXdSZWN0VGV4dDogZnVuY3Rpb24gKGN0eCwgcmVjdCwgdGV4dFJlY3QpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IHN0eWxlLnRleHQ7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRvIHN0cmluZ1xuICAgICAgICAgICAgdGV4dCAhPSBudWxsICYmICh0ZXh0ICs9ICcnKTtcbiAgICAgICAgICAgIGlmICghdGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgICAgICAgIHZhciB4O1xuICAgICAgICAgICAgdmFyIHk7XG4gICAgICAgICAgICB2YXIgdGV4dFBvc2l0aW9uID0gc3R5bGUudGV4dFBvc2l0aW9uO1xuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gc3R5bGUudGV4dERpc3RhbmNlO1xuICAgICAgICAgICAgdmFyIGFsaWduID0gc3R5bGUudGV4dEFsaWduO1xuICAgICAgICAgICAgdmFyIGZvbnQgPSBzdHlsZS50ZXh0Rm9udCB8fCBzdHlsZS5mb250O1xuICAgICAgICAgICAgdmFyIGJhc2VsaW5lID0gc3R5bGUudGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgdmFyIHZlcnRpY2FsQWxpZ24gPSBzdHlsZS50ZXh0VmVydGljYWxBbGlnbjtcblxuICAgICAgICAgICAgdGV4dFJlY3QgPSB0ZXh0UmVjdCB8fCB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QodGV4dCwgZm9udCwgYWxpZ24sIGJhc2VsaW5lKTtcblxuICAgICAgICAgICAgLy8gVHJhbnNmb3JtIHJlY3QgdG8gdmlldyBzcGFjZVxuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICAgICAgaWYgKCFzdHlsZS50ZXh0VHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICB0bXBSZWN0LmNvcHkocmVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHRtcFJlY3QuYXBwbHlUcmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgcmVjdCA9IHRtcFJlY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oY3R4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGV4dCBwb3NpdGlvbiByZXByZXNlbnRlZCBieSBjb29yZFxuICAgICAgICAgICAgaWYgKHRleHRQb3NpdGlvbiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgLy8gUGVyY2VudFxuICAgICAgICAgICAgICAgIHggPSByZWN0LnggKyBwYXJzZVBlcmNlbnQodGV4dFBvc2l0aW9uWzBdLCByZWN0LndpZHRoKTtcbiAgICAgICAgICAgICAgICB5ID0gcmVjdC55ICsgcGFyc2VQZXJjZW50KHRleHRQb3NpdGlvblsxXSwgcmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGFsaWduID0gYWxpZ24gfHwgJ2xlZnQnO1xuICAgICAgICAgICAgICAgIGJhc2VsaW5lID0gYmFzZWxpbmUgfHwgJ3RvcCc7XG5cbiAgICAgICAgICAgICAgICBpZiAodmVydGljYWxBbGlnbikge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHZlcnRpY2FsQWxpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSAtPSB0ZXh0UmVjdC5oZWlnaHQgLyAyIC0gdGV4dFJlY3QubGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgLT0gdGV4dFJlY3QuaGVpZ2h0IC0gdGV4dFJlY3QubGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gdGV4dFJlY3QubGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yY2UgYnNlbGluZSB0byBiZSBtaWRkbGVcbiAgICAgICAgICAgICAgICAgICAgYmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gdGV4dENvbnRhaW4uYWRqdXN0VGV4dFBvc2l0aW9uT25SZWN0KFxuICAgICAgICAgICAgICAgICAgICB0ZXh0UG9zaXRpb24sIHJlY3QsIHRleHRSZWN0LCBkaXN0YW5jZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgeCA9IHJlcy54O1xuICAgICAgICAgICAgICAgIHkgPSByZXMueTtcbiAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IGFsaWduIGFuZCBiYXNlbGluZSB3aGVuIGhhcyB0ZXh0UG9zaXRpb25cbiAgICAgICAgICAgICAgICBhbGlnbiA9IGFsaWduIHx8IHJlcy50ZXh0QWxpZ247XG4gICAgICAgICAgICAgICAgYmFzZWxpbmUgPSBiYXNlbGluZSB8fCByZXMudGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVc2UgY2FudmFzIGRlZmF1bHQgbGVmdCB0ZXh0QWxpZ24uIEdpdmluZyBpbnZhbGlkIHZhbHVlIHdpbGwgY2F1c2Ugc3RhdGUgbm90IGNoYW5nZVxuICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IGFsaWduIHx8ICdsZWZ0JztcbiAgICAgICAgICAgIC8vIFVzZSBjYW52YXMgZGVmYXVsdCBhbHBoYWJldGljIGJhc2VsaW5lXG4gICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gYmFzZWxpbmUgfHwgJ2FscGhhYmV0aWMnO1xuXG4gICAgICAgICAgICB2YXIgdGV4dEZpbGwgPSBzdHlsZS50ZXh0RmlsbDtcbiAgICAgICAgICAgIHZhciB0ZXh0U3Ryb2tlID0gc3R5bGUudGV4dFN0cm9rZTtcbiAgICAgICAgICAgIHRleHRGaWxsICYmIChjdHguZmlsbFN0eWxlID0gdGV4dEZpbGwpO1xuICAgICAgICAgICAgdGV4dFN0cm9rZSAmJiAoY3R4LnN0cm9rZVN0eWxlID0gdGV4dFN0cm9rZSk7XG5cbiAgICAgICAgICAgIC8vIFRPRE8gSW52YWxpZCBmb250XG4gICAgICAgICAgICBjdHguZm9udCA9IGZvbnQgfHwgJzEycHggc2Fucy1zZXJpZic7XG5cbiAgICAgICAgICAgIC8vIFRleHQgc2hhZG93XG4gICAgICAgICAgICAvLyBBbHdheXMgc2V0IHNoYWRvd0JsdXIgYW5kIHNoYWRvd09mZnNldCB0byBhdm9pZCBsZWFrIGZyb20gZGlzcGxheWFibGVcbiAgICAgICAgICAgIGN0eC5zaGFkb3dCbHVyID0gc3R5bGUudGV4dFNoYWRvd0JsdXI7XG4gICAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBzdHlsZS50ZXh0U2hhZG93Q29sb3IgfHwgJ3RyYW5zcGFyZW50JztcbiAgICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gc3R5bGUudGV4dFNoYWRvd09mZnNldFg7XG4gICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IHN0eWxlLnRleHRTaGFkb3dPZmZzZXRZO1xuXG4gICAgICAgICAgICB2YXIgdGV4dExpbmVzID0gdGV4dC5zcGxpdCgnXFxuJyk7XG5cbiAgICAgICAgICAgIGlmIChzdHlsZS50ZXh0Um90YXRpb24pIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0gJiYgY3R4LnRyYW5zbGF0ZSh0cmFuc2Zvcm1bNF0sIHRyYW5zZm9ybVs1XSk7XG4gICAgICAgICAgICAgICAgY3R4LnJvdGF0ZShzdHlsZS50ZXh0Um90YXRpb24pO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybSAmJiBjdHgudHJhbnNsYXRlKC10cmFuc2Zvcm1bNF0sIC10cmFuc2Zvcm1bNV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRleHRGaWxsICYmIGN0eC5maWxsVGV4dCh0ZXh0TGluZXNbaV0sIHgsIHkpO1xuICAgICAgICAgICAgICAgIHRleHRTdHJva2UgJiYgY3R4LnN0cm9rZVRleHQodGV4dExpbmVzW2ldLCB4LCB5KTtcbiAgICAgICAgICAgICAgICB5ICs9IHRleHRSZWN0LmxpbmVIZWlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFJlY3RUZXh0O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC96cmVuZGVyL2dyYXBoaWMvbWl4aW4vUmVjdFRleHQuanNcbiAqKiBtb2R1bGUgaWQgPSA1MlxuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiLyoqXG4gKiBQYXRoIOS7o+eQhu+8jOWPr+S7peWcqGBidWlsZFBhdGhg5Lit55So5LqO5pu/5LujYGN0eGAsIOS8muS/neWtmOavj+S4qnBhdGjmk43kvZznmoTlkb3ku6TliLBwYXRoQ29tbWFuZHPlsZ7mgKfkuK1cbiAqIOWPr+S7peeUqOS6jiBpc0luc2lkZVBhdGgg5Yik5pat5Lul5Y+K6I635Y+WYm91bmRpbmdSZWN0XG4gKlxuICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvUGF0aFByb3h5XG4gKiBAYXV0aG9yIFlpIFNoZW4gKGh0dHA6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG5cbiAvLyBUT0RPIGdldFRvdGFsTGVuZ3RoLCBnZXRQb2ludEF0TGVuZ3RoXG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgY3VydmUgPSByZXF1aXJlKCcuL2N1cnZlJyk7XG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuL3ZlY3RvcicpO1xuICAgIHZhciBiYm94ID0gcmVxdWlyZSgnLi9iYm94Jyk7XG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJy4vQm91bmRpbmdSZWN0Jyk7XG4gICAgdmFyIGRwciA9IHJlcXVpcmUoJy4uL2NvbmZpZycpLmRldmljZVBpeGVsUmF0aW87XG5cbiAgICB2YXIgQ01EID0ge1xuICAgICAgICBNOiAxLFxuICAgICAgICBMOiAyLFxuICAgICAgICBDOiAzLFxuICAgICAgICBROiA0LFxuICAgICAgICBBOiA1LFxuICAgICAgICBaOiA2LFxuICAgICAgICAvLyBSZWN0XG4gICAgICAgIFI6IDdcbiAgICB9O1xuXG4gICAgdmFyIG1pbiA9IFtdO1xuICAgIHZhciBtYXggPSBbXTtcbiAgICB2YXIgbWluMiA9IFtdO1xuICAgIHZhciBtYXgyID0gW107XG4gICAgdmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbiAgICB2YXIgbWF0aE1heCA9IE1hdGgubWF4O1xuICAgIHZhciBtYXRoQ29zID0gTWF0aC5jb3M7XG4gICAgdmFyIG1hdGhTaW4gPSBNYXRoLnNpbjtcbiAgICB2YXIgbWF0aFNxcnQgPSBNYXRoLnNxcnQ7XG4gICAgdmFyIG1hdGhBYnMgPSBNYXRoLmFicztcblxuICAgIHZhciBoYXNUeXBlZEFycmF5ID0gdHlwZW9mIEZsb2F0MzJBcnJheSAhPSAndW5kZWZpbmVkJztcblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBQYXRoUHJveHkgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhdGggZGF0YS4gU3RvcmVkIGFzIGZsYXQgYXJyYXlcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhID0gW107XG5cbiAgICAgICAgdGhpcy5fbGVuID0gMDtcblxuICAgICAgICB0aGlzLl9jdHggPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3hpID0gMDtcbiAgICAgICAgdGhpcy5feWkgPSAwO1xuXG4gICAgICAgIHRoaXMuX3gwID0gMDtcbiAgICAgICAgdGhpcy5feTAgPSAwO1xuXG4gICAgICAgIC8vIFVuaXQgeCwgVW5pdCB5LiBQcm92aWRlIGZvciBhdm9pZGluZyBkcmF3aW5nIHRoYXQgdG9vIHNob3J0IGxpbmUgc2VnbWVudFxuICAgICAgICB0aGlzLl91eCA9IDA7XG4gICAgICAgIHRoaXMuX3V5ID0gMDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICog5b+r6YCf6K6h566XUGF0aOWMheWbtOebku+8iOW5tuS4jeaYr+acgOWwj+WMheWbtOebku+8iVxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICBQYXRoUHJveHkucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBQYXRoUHJveHksXG5cbiAgICAgICAgX2xpbmVEYXNoOiBudWxsLFxuXG4gICAgICAgIF9kYXNoT2Zmc2V0OiAwLFxuXG4gICAgICAgIF9kYXNoSWR4OiAwLFxuXG4gICAgICAgIF9kYXNoU3VtOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHNldFNjYWxlOiBmdW5jdGlvbiAoc3gsIHN5KSB7XG4gICAgICAgICAgICB0aGlzLl91eCA9IG1hdGhBYnMoMSAvIGRwciAvIHN4KSB8fCAwO1xuICAgICAgICAgICAgdGhpcy5fdXkgPSBtYXRoQWJzKDEgLyBkcHIgLyBzeSkgfHwgMDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3R4O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIGJlZ2luUGF0aDogZnVuY3Rpb24gKGN0eCkge1xuXG4gICAgICAgICAgICB0aGlzLl9jdHggPSBjdHg7XG5cbiAgICAgICAgICAgIGN0eCAmJiBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgICAgIGN0eCAmJiAodGhpcy5kcHIgPSBjdHguZHByKTtcblxuICAgICAgICAgICAgLy8gUmVzZXRcbiAgICAgICAgICAgIHRoaXMuX2xlbiA9IDA7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9saW5lRGFzaCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmVEYXNoID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2Rhc2hPZmZzZXQgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIG1vdmVUbzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGF0YShDTUQuTSwgeCwgeSk7XG4gICAgICAgICAgICB0aGlzLl9jdHggJiYgdGhpcy5fY3R4Lm1vdmVUbyh4LCB5KTtcblxuICAgICAgICAgICAgLy8geDAsIHkwLCB4aSwgeWkg5piv6K6w5b2V5ZyoIF9kYXNoZWRYWFhYVG8g5pa55rOV5Lit5L2/55SoXG4gICAgICAgICAgICAvLyB4aSwgeWkg6K6w5b2V5b2T5YmN54K5LCB4MCwgeTAg5ZyoIGNsb3NlUGF0aCDnmoTml7blgJnlm57liLDotbflp4vngrnjgIJcbiAgICAgICAgICAgIC8vIOacieWPr+iDveWcqCBiZWdpblBhdGgg5LmL5ZCO55u05o6l6LCD55SoIGxpbmVUb++8jOi/meaXtuWAmSB4MCwgeTAg6ZyA6KaBXG4gICAgICAgICAgICAvLyDlnKggbGluZVRvIOaWueazleS4reiusOW9le+8jOi/memHjOWFiOS4jeiAg+iZkei/meenjeaDheWGte+8jGRhc2hlZCBsaW5lIOS5n+WPquWcqCBJRTEwLSDkuK3kuI3mlK/mjIFcbiAgICAgICAgICAgIHRoaXMuX3gwID0geDtcbiAgICAgICAgICAgIHRoaXMuX3kwID0geTtcblxuICAgICAgICAgICAgdGhpcy5feGkgPSB4O1xuICAgICAgICAgICAgdGhpcy5feWkgPSB5O1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIGxpbmVUbzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBleGNlZWRVbml0ID0gbWF0aEFicyh4IC0gdGhpcy5feGkpID4gdGhpcy5fdXhcbiAgICAgICAgICAgICAgICB8fCBtYXRoQWJzKHkgLSB0aGlzLl95aSkgPiB0aGlzLl91eVxuICAgICAgICAgICAgICAgIC8vIEZvcmNlIGRyYXcgdGhlIGZpcnN0IHNlZ21lbnRcbiAgICAgICAgICAgICAgICB8fCB0aGlzLl9sZW4gPCA1O1xuXG4gICAgICAgICAgICB0aGlzLmFkZERhdGEoQ01ELkwsIHgsIHkpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fY3R4ICYmIGV4Y2VlZFVuaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZWVkc0Rhc2goKSA/IHRoaXMuX2Rhc2hlZExpbmVUbyh4LCB5KVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX2N0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhjZWVkVW5pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3hpID0geDtcbiAgICAgICAgICAgICAgICB0aGlzLl95aSA9IHk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geTFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4MlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geDNcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB5M1xuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIGJlemllckN1cnZlVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZERhdGEoQ01ELkMsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2N0eCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25lZWRzRGFzaCgpID8gdGhpcy5fZGFzaGVkQmV6aWVyVG8oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MylcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9jdHguYmV6aWVyQ3VydmVUbyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3hpID0geDM7XG4gICAgICAgICAgICB0aGlzLl95aSA9IHkzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geDFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB5MVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geTJcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGF0YShDTUQuUSwgeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2N0eCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25lZWRzRGFzaCgpID8gdGhpcy5fZGFzaGVkUXVhZHJhdGljVG8oeDEsIHkxLCB4MiwgeTIpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5fY3R4LnF1YWRyYXRpY0N1cnZlVG8oeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5feGkgPSB4MjtcbiAgICAgICAgICAgIHRoaXMuX3lpID0geTI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBjeFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGN5XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gclxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHN0YXJ0QW5nbGVcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBlbmRBbmdsZVxuICAgICAgICAgKiBAcGFyYW0gIHtib29sZWFufSBhbnRpY2xvY2t3aXNlXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgYXJjOiBmdW5jdGlvbiAoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgdGhpcy5hZGREYXRhKFxuICAgICAgICAgICAgICAgIENNRC5BLCBjeCwgY3ksIHIsIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSwgMCwgYW50aWNsb2Nrd2lzZSA/IDAgOiAxXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5fY3R4ICYmIHRoaXMuX2N0eC5hcmMoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSk7XG5cbiAgICAgICAgICAgIHRoaXMuX3hpID0gbWF0aENvcyhlbmRBbmdsZSkgKiByICsgY3g7XG4gICAgICAgICAgICB0aGlzLl94aSA9IG1hdGhTaW4oZW5kQW5nbGUpICogciArIGN4O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICBhcmNUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdHgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdHguYXJjVG8oeDEsIHkxLCB4MiwgeTIsIHJhZGl1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIHJlY3Q6IGZ1bmN0aW9uICh4LCB5LCB3LCBoKSB7XG4gICAgICAgICAgICB0aGlzLl9jdHggJiYgdGhpcy5fY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgICAgICB0aGlzLmFkZERhdGEoQ01ELlIsIHgsIHksIHcsIGgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgY2xvc2VQYXRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmFkZERhdGEoQ01ELlopO1xuXG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgICAgdmFyIHgwID0gdGhpcy5feDA7XG4gICAgICAgICAgICB2YXIgeTAgPSB0aGlzLl95MDtcbiAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZWVkc0Rhc2goKSAmJiB0aGlzLl9kYXNoZWRMaW5lVG8oeDAsIHkwKTtcbiAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3hpID0geDA7XG4gICAgICAgICAgICB0aGlzLl95aSA9IHkwO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnRleHQg5LuO5aSW6YOo5Lyg5YWl77yM5Zug5Li65pyJ5Y+v6IO95pivIHJlYnVpbGRQYXRoIOWujOS5i+WQjuWGjSBmaWxs44CCXG4gICAgICAgICAqIHN0cm9rZSDlkIzmoLdcbiAgICAgICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIGZpbGw6IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIGN0eCAmJiBjdHguZmlsbCgpO1xuICAgICAgICAgICAgdGhpcy50b1N0YXRpYygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgc3Ryb2tlOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICBjdHggJiYgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgdGhpcy50b1N0YXRpYygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlv4XpobvlnKjlhbblroPnu5jliLblkb3ku6TliY3osIPnlKhcbiAgICAgICAgICogTXVzdCBiZSBpbnZva2VkIGJlZm9yZSBhbGwgb3RoZXIgcGF0aCBkcmF3aW5nIG1ldGhvZHNcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBzZXRMaW5lRGFzaDogZnVuY3Rpb24gKGxpbmVEYXNoKSB7XG4gICAgICAgICAgICBpZiAobGluZURhc2ggaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmVEYXNoID0gbGluZURhc2g7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9kYXNoSWR4ID0gMDtcblxuICAgICAgICAgICAgICAgIHZhciBsaW5lRGFzaFN1bSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lRGFzaC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsaW5lRGFzaFN1bSArPSBsaW5lRGFzaFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZGFzaFN1bSA9IGxpbmVEYXNoU3VtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW/hemhu+WcqOWFtuWug+e7mOWItuWRveS7pOWJjeiwg+eUqFxuICAgICAgICAgKiBNdXN0IGJlIGludm9rZWQgYmVmb3JlIGFsbCBvdGhlciBwYXRoIGRyYXdpbmcgbWV0aG9kc1xuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIHNldExpbmVEYXNoT2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBsZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZW47XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOebtOaOpeiuvue9riBQYXRoIOaVsOaNrlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0RGF0YTogZnVuY3Rpb24gKGRhdGEpIHtcblxuICAgICAgICAgICAgdmFyIGxlbiA9IGRhdGEubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAoISAodGhpcy5kYXRhICYmIHRoaXMuZGF0YS5sZW5ndGggPT0gbGVuKSAmJiBoYXNUeXBlZEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShsZW4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhW2ldID0gZGF0YVtpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fbGVuID0gbGVuO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqDlrZDot6/lvoRcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eXxBcnJheS48bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHk+fSBwYXRoXG4gICAgICAgICAqL1xuICAgICAgICBhcHBlbmRQYXRoOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgICAgaWYgKCEocGF0aCBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgICAgIHBhdGggPSBbcGF0aF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGVuID0gcGF0aC5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgYXBwZW5kU2l6ZSA9IDA7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fbGVuO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGFwcGVuZFNpemUgKz0gcGF0aFtpXS5sZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNUeXBlZEFycmF5ICYmICh0aGlzLmRhdGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShvZmZzZXQgKyBhcHBlbmRTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYXBwZW5kUGF0aERhdGEgPSBwYXRoW2ldLmRhdGE7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBhcHBlbmRQYXRoRGF0YS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFbb2Zmc2V0KytdID0gYXBwZW5kUGF0aERhdGFba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbGVuID0gb2Zmc2V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDloavlhYUgUGF0aCDmlbDmja7jgIJcbiAgICAgICAgICog5bC96YeP5aSN55So6ICM5LiN55Sz5piO5paw55qE5pWw57uE44CC5aSn6YOo5YiG5Zu+5b2i6YeN57uY55qE5oyH5Luk5pWw5o2u6ZW/5bqm6YO95piv5LiN5Y+Y55qE44CCXG4gICAgICAgICAqL1xuICAgICAgICBhZGREYXRhOiBmdW5jdGlvbiAoY21kKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9sZW4gKyBhcmd1bWVudHMubGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyDlm6DkuLrkuYvliY3nmoTmlbDnu4Tlt7Lnu4/ovazmjaLmiJDpnZnmgIHnmoQgRmxvYXQzMkFycmF5XG4gICAgICAgICAgICAgICAgLy8g5omA5Lul5LiN5aSf55So5pe26ZyA6KaB5omp5bGV5LiA5Liq5paw55qE5Yqo5oCB5pWw57uEXG4gICAgICAgICAgICAgICAgdGhpcy5fZXhwYW5kRGF0YSgpO1xuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGRhdGFbdGhpcy5fbGVuKytdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9wcmV2Q21kID0gY21kO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9leHBhbmREYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBPbmx5IGlmIGRhdGEgaXMgRmxvYXQzMkFycmF5XG4gICAgICAgICAgICBpZiAoISh0aGlzLmRhdGEgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3RGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0YVtpXSA9IHRoaXMuZGF0YVtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3RGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgbmVlZHMganMgaW1wbGVtZW50ZWQgZGFzaGVkIGxpbmVcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9uZWVkc0Rhc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9saW5lRGFzaDtcbiAgICAgICAgfSxcblxuICAgICAgICBfZGFzaGVkTGluZVRvOiBmdW5jdGlvbiAoeDEsIHkxKSB7XG4gICAgICAgICAgICB2YXIgZGFzaFN1bSA9IHRoaXMuX2Rhc2hTdW07XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fZGFzaE9mZnNldDtcbiAgICAgICAgICAgIHZhciBsaW5lRGFzaCA9IHRoaXMuX2xpbmVEYXNoO1xuICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcblxuICAgICAgICAgICAgdmFyIHgwID0gdGhpcy5feGk7XG4gICAgICAgICAgICB2YXIgeTAgPSB0aGlzLl95aTtcbiAgICAgICAgICAgIHZhciBkeCA9IHgxIC0geDA7XG4gICAgICAgICAgICB2YXIgZHkgPSB5MSAtIHkwO1xuICAgICAgICAgICAgdmFyIGRpc3QgPSBtYXRoU3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgICAgICB2YXIgeCA9IHgwO1xuICAgICAgICAgICAgdmFyIHkgPSB5MDtcbiAgICAgICAgICAgIHZhciBkYXNoO1xuICAgICAgICAgICAgdmFyIG5EYXNoID0gbGluZURhc2gubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGlkeDtcbiAgICAgICAgICAgIGR4IC89IGRpc3Q7XG4gICAgICAgICAgICBkeSAvPSBkaXN0O1xuXG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gcG9zaXRpdmUgb2Zmc2V0XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gZGFzaFN1bSArIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCAlPSBkYXNoU3VtO1xuICAgICAgICAgICAgeCAtPSBvZmZzZXQgKiBkeDtcbiAgICAgICAgICAgIHkgLT0gb2Zmc2V0ICogZHk7XG5cbiAgICAgICAgICAgIHdoaWxlICgoZHggPiAwICYmIHggPD0geDEpIHx8IChkeCA8IDAgJiYgeCA+PSB4MSlcbiAgICAgICAgICAgIHx8IChkeCA9PSAwICYmICgoZHkgPiAwICYmIHkgPD0geTEpIHx8IChkeSA8IDAgJiYgeSA+PSB5MSkpKSkge1xuICAgICAgICAgICAgICAgIGlkeCA9IHRoaXMuX2Rhc2hJZHg7XG4gICAgICAgICAgICAgICAgZGFzaCA9IGxpbmVEYXNoW2lkeF07XG4gICAgICAgICAgICAgICAgeCArPSBkeCAqIGRhc2g7XG4gICAgICAgICAgICAgICAgeSArPSBkeSAqIGRhc2g7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGFzaElkeCA9IChpZHggKyAxKSAlIG5EYXNoO1xuICAgICAgICAgICAgICAgIC8vIFNraXAgcG9zaXRpdmUgb2Zmc2V0XG4gICAgICAgICAgICAgICAgaWYgKChkeCA+IDAgJiYgeCA8IHgwKSB8fCAoZHggPCAwICYmIHggPiB4MCkgfHwgKGR5ID4gMCAmJiB5IDwgeTApIHx8IChkeSA8IDAgJiYgeSA+IHkwKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4W2lkeCAlIDIgPyAnbW92ZVRvJyA6ICdsaW5lVG8nXShcbiAgICAgICAgICAgICAgICAgICAgZHggPj0gMCA/IG1hdGhNaW4oeCwgeDEpIDogbWF0aE1heCh4LCB4MSksXG4gICAgICAgICAgICAgICAgICAgIGR5ID49IDAgPyBtYXRoTWluKHksIHkxKSA6IG1hdGhNYXgoeSwgeTEpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9mZnNldCBmb3IgbmV4dCBsaW5lVG9cbiAgICAgICAgICAgIGR4ID0geCAtIHgxO1xuICAgICAgICAgICAgZHkgPSB5IC0geTE7XG4gICAgICAgICAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gLW1hdGhTcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBOb3QgYWNjdXJhdGUgZGFzaGVkIGxpbmUgdG9cbiAgICAgICAgX2Rhc2hlZEJlemllclRvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgICAgICAgdmFyIGRhc2hTdW0gPSB0aGlzLl9kYXNoU3VtO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX2Rhc2hPZmZzZXQ7XG4gICAgICAgICAgICB2YXIgbGluZURhc2ggPSB0aGlzLl9saW5lRGFzaDtcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG5cbiAgICAgICAgICAgIHZhciB4MCA9IHRoaXMuX3hpO1xuICAgICAgICAgICAgdmFyIHkwID0gdGhpcy5feWk7XG4gICAgICAgICAgICB2YXIgdDtcbiAgICAgICAgICAgIHZhciBkeDtcbiAgICAgICAgICAgIHZhciBkeTtcbiAgICAgICAgICAgIHZhciBjdWJpY0F0ID0gY3VydmUuY3ViaWNBdDtcbiAgICAgICAgICAgIHZhciBiZXppZXJMZW4gPSAwO1xuICAgICAgICAgICAgdmFyIGlkeCA9IHRoaXMuX2Rhc2hJZHg7XG4gICAgICAgICAgICB2YXIgbkRhc2ggPSBsaW5lRGFzaC5sZW5ndGg7XG5cbiAgICAgICAgICAgIHZhciB4O1xuICAgICAgICAgICAgdmFyIHk7XG5cbiAgICAgICAgICAgIHZhciB0bXBMZW4gPSAwO1xuXG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gcG9zaXRpdmUgb2Zmc2V0XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gZGFzaFN1bSArIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCAlPSBkYXNoU3VtO1xuICAgICAgICAgICAgLy8gQmV6aWVyIGFwcHJveCBsZW5ndGhcbiAgICAgICAgICAgIGZvciAodCA9IDA7IHQgPCAxOyB0ICs9IDAuMSkge1xuICAgICAgICAgICAgICAgIGR4ID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCArIDAuMSlcbiAgICAgICAgICAgICAgICAgICAgLSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB0KTtcbiAgICAgICAgICAgICAgICBkeSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHQgKyAwLjEpXG4gICAgICAgICAgICAgICAgICAgIC0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgdCk7XG4gICAgICAgICAgICAgICAgYmV6aWVyTGVuICs9IG1hdGhTcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmluZCBpZHggYWZ0ZXIgYWRkIG9mZnNldFxuICAgICAgICAgICAgZm9yICg7IGlkeCA8IG5EYXNoOyBpZHgrKykge1xuICAgICAgICAgICAgICAgIHRtcExlbiArPSBsaW5lRGFzaFtpZHhdO1xuICAgICAgICAgICAgICAgIGlmICh0bXBMZW4gPiBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdCA9ICh0bXBMZW4gLSBvZmZzZXQpIC8gYmV6aWVyTGVuO1xuXG4gICAgICAgICAgICB3aGlsZSAodCA8PSAxKSB7XG5cbiAgICAgICAgICAgICAgICB4ID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG4gICAgICAgICAgICAgICAgeSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIHQpO1xuXG4gICAgICAgICAgICAgICAgLy8gVXNlIGxpbmUgdG8gYXBwcm94aW1hdGUgZGFzaGVkIGJlemllclxuICAgICAgICAgICAgICAgIC8vIEJhZCByZXN1bHQgaWYgZGFzaCBpcyBsb25nXG4gICAgICAgICAgICAgICAgaWR4ICUgMiA/IGN0eC5tb3ZlVG8oeCwgeSlcbiAgICAgICAgICAgICAgICAgICAgOiBjdHgubGluZVRvKHgsIHkpO1xuXG4gICAgICAgICAgICAgICAgdCArPSBsaW5lRGFzaFtpZHhdIC8gYmV6aWVyTGVuO1xuXG4gICAgICAgICAgICAgICAgaWR4ID0gKGlkeCArIDEpICUgbkRhc2g7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpbmlzaCB0aGUgbGFzdCBzZWdtZW50IGFuZCBjYWxjdWxhdGUgdGhlIG5ldyBvZmZzZXRcbiAgICAgICAgICAgIChpZHggJSAyICE9PSAwKSAmJiBjdHgubGluZVRvKHgzLCB5Myk7XG4gICAgICAgICAgICBkeCA9IHgzIC0geDtcbiAgICAgICAgICAgIGR5ID0geTMgLSB5O1xuICAgICAgICAgICAgdGhpcy5fZGFzaE9mZnNldCA9IC1tYXRoU3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2Rhc2hlZFF1YWRyYXRpY1RvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgcXVhZHJhdGljIHRvIGN1YmljIHVzaW5nIGRlZ3JlZSBlbGV2YXRpb25cbiAgICAgICAgICAgIHZhciB4MyA9IHgyO1xuICAgICAgICAgICAgdmFyIHkzID0geTI7XG4gICAgICAgICAgICB4MiA9ICh4MiArIDIgKiB4MSkgLyAzO1xuICAgICAgICAgICAgeTIgPSAoeTIgKyAyICogeTEpIC8gMztcbiAgICAgICAgICAgIHgxID0gKHRoaXMuX3hpICsgMiAqIHgxKSAvIDM7XG4gICAgICAgICAgICB5MSA9ICh0aGlzLl95aSArIDIgKiB5MSkgLyAzO1xuXG4gICAgICAgICAgICB0aGlzLl9kYXNoZWRCZXppZXJUbyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6L2s5oiQ6Z2Z5oCB55qEIEZsb2F0MzJBcnJheSDlh4/lsJHloIblhoXlrZjljaDnlKhcbiAgICAgICAgICogQ29udmVydCBkeW5hbWljIGFycmF5IHRvIHN0YXRpYyBGbG9hdDMyQXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIHRvU3RhdGljOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmxlbmd0aCA9IHRoaXMuX2xlbjtcbiAgICAgICAgICAgICAgICBpZiAoaGFzVHlwZWRBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG1pblswXSA9IG1pblsxXSA9IG1pbjJbMF0gPSBtaW4yWzFdID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgIG1heFswXSA9IG1heFsxXSA9IG1heDJbMF0gPSBtYXgyWzFdID0gLU51bWJlci5NQVhfVkFMVUU7XG5cbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgdmFyIHhpID0gMDtcbiAgICAgICAgICAgIHZhciB5aSA9IDA7XG4gICAgICAgICAgICB2YXIgeDAgPSAwO1xuICAgICAgICAgICAgdmFyIHkwID0gMDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICB2YXIgY21kID0gZGF0YVtpKytdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyDlpoLmnpznrKzkuIDkuKrlkb3ku6TmmK8gTCwgQywgUVxuICAgICAgICAgICAgICAgICAgICAvLyDliJkgcHJldmlvdXMgcG9pbnQg5ZCM57uY5Yi25ZG95Luk55qE56ys5LiA5LiqIHBvaW50XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIOesrOS4gOS4quWRveS7pOS4uiBBcmMg55qE5oOF5Ya15LiL5Lya5Zyo5ZCO6Z2i54m55q6K5aSE55CGXG4gICAgICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpXTtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSBkYXRhW2kgKyAxXTtcblxuICAgICAgICAgICAgICAgICAgICB4MCA9IHhpO1xuICAgICAgICAgICAgICAgICAgICB5MCA9IHlpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELk06XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlVG8g5ZG95Luk6YeN5paw5Yib5bu65LiA5Liq5paw55qEIHN1YnBhdGgsIOW5tuS4lOabtOaWsOaWsOeahOi1t+eCuVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5ZyoIGNsb3NlUGF0aCDnmoTml7blgJnkvb/nlKhcbiAgICAgICAgICAgICAgICAgICAgICAgIHgwID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTAgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IHgwO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbjJbMF0gPSB4MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbjJbMV0gPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heDJbMF0gPSB4MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heDJbMV0gPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5MOlxuICAgICAgICAgICAgICAgICAgICAgICAgYmJveC5mcm9tTGluZSh4aSwgeWksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBtaW4yLCBtYXgyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuQzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJib3guZnJvbUN1YmljKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhpLCB5aSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW4yLCBtYXgyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5ROlxuICAgICAgICAgICAgICAgICAgICAgICAgYmJveC5mcm9tUXVhZHJhdGljKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhpLCB5aSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbjIsIG1heDJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELkE6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIEFyYyDliKTmlq3nmoTlvIDplIDmr5TovoPlpKdcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFydEFuZ2xlID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZEFuZ2xlID0gZGF0YVtpKytdICsgc3RhcnRBbmdsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gQXJjIOaXi+i9rFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBzaSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbnRpY2xvY2t3aXNlID0gMSAtIGRhdGFbaSsrXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOebtOaOpeS9v+eUqCBhcmMg5ZG95LukXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk6LW354K56L+Y5pyq5a6a5LmJXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDAgPSBtYXRoQ29zKHN0YXJ0QW5nbGUpICogcnggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MCA9IG1hdGhTaW4oc3RhcnRBbmdsZSkgKiByeSArIGN5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBiYm94LmZyb21BcmMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3gsIGN5LCByeCwgcnksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFudGljbG9ja3dpc2UsIG1pbjIsIG1heDJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0gbWF0aENvcyhlbmRBbmdsZSkgKiByeCArIGN4O1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSBtYXRoU2luKGVuZEFuZ2xlKSAqIHJ5ICsgY3k7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuUjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHgwID0geGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5MCA9IHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBmcm9tTGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgYmJveC5mcm9tTGluZSh4MCwgeTAsIHgwICsgd2lkdGgsIHkwICsgaGVpZ2h0LCBtaW4yLCBtYXgyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5aOlxuICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0geTA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBVbmlvblxuICAgICAgICAgICAgICAgIHZlYzIubWluKG1pbiwgbWluLCBtaW4yKTtcbiAgICAgICAgICAgICAgICB2ZWMyLm1heChtYXgsIG1heCwgbWF4Mik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE5vIGRhdGFcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbWluWzBdID0gbWluWzFdID0gbWF4WzBdID0gbWF4WzFdID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ1JlY3QoXG4gICAgICAgICAgICAgICAgbWluWzBdLCBtaW5bMV0sIG1heFswXSAtIG1pblswXSwgbWF4WzFdIC0gbWluWzFdXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWJ1aWxkIHBhdGggZnJvbSBjdXJyZW50IGRhdGFcbiAgICAgICAgICogUmVidWlsZCBwYXRoIHdpbGwgbm90IGNvbnNpZGVyIGphdmFzY3JpcHQgaW1wbGVtZW50ZWQgbGluZSBkYXNoLlxuICAgICAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHR9IGN0eFxuICAgICAgICAgKi9cbiAgICAgICAgcmVidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIHZhciBkID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgdmFyIHgwLCB5MDtcbiAgICAgICAgICAgIHZhciB4aSwgeWk7XG4gICAgICAgICAgICB2YXIgeCwgeTtcbiAgICAgICAgICAgIHZhciB1eCA9IHRoaXMuX3V4O1xuICAgICAgICAgICAgdmFyIHV5ID0gdGhpcy5fdXk7XG4gICAgICAgICAgICB2YXIgbGVuID0gdGhpcy5fbGVuO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNtZCA9IGRbaSsrXTtcblxuICAgICAgICAgICAgICAgIGlmIChpID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6c56ys5LiA5Liq5ZG95Luk5pivIEwsIEMsIFFcbiAgICAgICAgICAgICAgICAgICAgLy8g5YiZIHByZXZpb3VzIHBvaW50IOWQjOe7mOWItuWRveS7pOeahOesrOS4gOS4qiBwb2ludFxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6TkuLogQXJjIOeahOaDheWGteS4i+S8muWcqOWQjumdoueJueauiuWkhOeQhlxuICAgICAgICAgICAgICAgICAgICB4aSA9IGRbaV07XG4gICAgICAgICAgICAgICAgICAgIHlpID0gZFtpICsgMV07XG5cbiAgICAgICAgICAgICAgICAgICAgeDAgPSB4aTtcbiAgICAgICAgICAgICAgICAgICAgeTAgPSB5aTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuTTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHgwID0geGkgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5MCA9IHlpID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh4aSwgeWkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELkw6XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCBkcmF3IHRvbyBzbWFsbCBzZWcgYmV0d2VlblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGhBYnMoeCAtIHhpKSA+IHV4IHx8IG1hdGhBYnMoeSAtIHlpKSA+IHV5IHx8IGkgPT09IGxlbiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhpID0geDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aSA9IHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuQzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdLCBkW2krK11cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IGRbaSAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSBkW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5ROlxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0gZFtpIC0gMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB5aSA9IGRbaSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELkE6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3ggPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3kgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnggPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnkgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhldGEgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZFRoZXRhID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBzaSA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcyA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gKHJ4ID4gcnkpID8gcnggOiByeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZVggPSAocnggPiByeSkgPyAxIDogcnggLyByeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZVkgPSAocnggPiByeSkgPyByeSAvIHJ4IDogMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0VsbGlwc2UgPSBNYXRoLmFicyhyeCAtIHJ5KSA+IDFlLTM7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kQW5nbGUgPSB0aGV0YSArIGRUaGV0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0VsbGlwc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKGN4LCBjeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJvdGF0ZShwc2kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFyYygwLCAwLCByLCB0aGV0YSwgZW5kQW5nbGUsIDEgLSBmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnNjYWxlKDEgLyBzY2FsZVgsIDEgLyBzY2FsZVkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoLXBzaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtY3gsIC1jeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguYXJjKGN4LCBjeSwgciwgdGhldGEsIGVuZEFuZ2xlLCAxIC0gZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g55u05o6l5L2/55SoIGFyYyDlkb3ku6RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6Totbfngrnov5jmnKrlrprkuYlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MCA9IG1hdGhDb3ModGhldGEpICogcnggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MCA9IG1hdGhTaW4odGhldGEpICogcnkgKyBjeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0gbWF0aENvcyhlbmRBbmdsZSkgKiByeCArIGN4O1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSBtYXRoU2luKGVuZEFuZ2xlKSAqIHJ5ICsgY3k7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuUjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHgwID0geGkgPSBkW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTAgPSB5aSA9IGRbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3QoZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5aOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0geTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIFBhdGhQcm94eS5DTUQgPSBDTUQ7XG5cbiAgICByZXR1cm4gUGF0aFByb3h5O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC96cmVuZGVyL2NvcmUvUGF0aFByb3h5LmpzXG4gKiogbW9kdWxlIGlkID0gNTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsIi8qKlxuICog5puy57q/6L6F5Yqp5qih5Z2XXG4gKiBAbW9kdWxlIHpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQGF1dGhvciBwaXNzYW5nKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnLi92ZWN0b3InKTtcbiAgICB2YXIgdjJDcmVhdGUgPSB2ZWMyLmNyZWF0ZTtcbiAgICB2YXIgdjJEaXN0U3F1YXJlID0gdmVjMi5kaXN0U3F1YXJlO1xuICAgIHZhciBtYXRoUG93ID0gTWF0aC5wb3c7XG4gICAgdmFyIG1hdGhTcXJ0ID0gTWF0aC5zcXJ0O1xuXG4gICAgdmFyIEVQU0lMT04gPSAxZS04O1xuICAgIHZhciBFUFNJTE9OX05VTUVSSUMgPSAxZS00O1xuXG4gICAgdmFyIFRIUkVFX1NRUlQgPSBtYXRoU3FydCgzKTtcbiAgICB2YXIgT05FX1RISVJEID0gMSAvIDM7XG5cbiAgICAvLyDkuLTml7blj5jph49cbiAgICB2YXIgX3YwID0gdjJDcmVhdGUoKTtcbiAgICB2YXIgX3YxID0gdjJDcmVhdGUoKTtcbiAgICB2YXIgX3YyID0gdjJDcmVhdGUoKTtcbiAgICAvLyB2YXIgX3YzID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIGZ1bmN0aW9uIGlzQXJvdW5kWmVybyh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbCA+IC1FUFNJTE9OICYmIHZhbCA8IEVQU0lMT047XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzTm90QXJvdW5kWmVybyh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbCA+IEVQU0lMT04gfHwgdmFsIDwgLUVQU0lMT047XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOiuoeeul+S4ieasoei0neWhnuWwlOWAvFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICAgICAqIEBwYXJhbSAge251bWJlcn0gdFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdWJpY0F0KHAwLCBwMSwgcDIsIHAzLCB0KSB7XG4gICAgICAgIHZhciBvbmV0ID0gMSAtIHQ7XG4gICAgICAgIHJldHVybiBvbmV0ICogb25ldCAqIChvbmV0ICogcDAgKyAzICogdCAqIHAxKVxuICAgICAgICAgICAgICsgdCAqIHQgKiAodCAqIHAzICsgMyAqIG9uZXQgKiBwMik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6K6h566X5LiJ5qyh6LSd5aGe5bCU5a+85pWw5YC8XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1YmljRGVyaXZhdGl2ZUF0KHAwLCBwMSwgcDIsIHAzLCB0KSB7XG4gICAgICAgIHZhciBvbmV0ID0gMSAtIHQ7XG4gICAgICAgIHJldHVybiAzICogKFxuICAgICAgICAgICAgKChwMSAtIHAwKSAqIG9uZXQgKyAyICogKHAyIC0gcDEpICogdCkgKiBvbmV0XG4gICAgICAgICAgICArIChwMyAtIHAyKSAqIHQgKiB0XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6K6h566X5LiJ5qyh6LSd5aGe5bCU5pa556iL5qC577yM5L2/55So55ub6YeR5YWs5byPXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB2YWxcbiAgICAgKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gcm9vdHNcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IOacieaViOagueaVsOebrlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1YmljUm9vdEF0KHAwLCBwMSwgcDIsIHAzLCB2YWwsIHJvb3RzKSB7XG4gICAgICAgIC8vIEV2YWx1YXRlIHJvb3RzIG9mIGN1YmljIGZ1bmN0aW9uc1xuICAgICAgICB2YXIgYSA9IHAzICsgMyAqIChwMSAtIHAyKSAtIHAwO1xuICAgICAgICB2YXIgYiA9IDMgKiAocDIgLSBwMSAqIDIgKyBwMCk7XG4gICAgICAgIHZhciBjID0gMyAqIChwMSAgLSBwMCk7XG4gICAgICAgIHZhciBkID0gcDAgLSB2YWw7XG5cbiAgICAgICAgdmFyIEEgPSBiICogYiAtIDMgKiBhICogYztcbiAgICAgICAgdmFyIEIgPSBiICogYyAtIDkgKiBhICogZDtcbiAgICAgICAgdmFyIEMgPSBjICogYyAtIDMgKiBiICogZDtcblxuICAgICAgICB2YXIgbiA9IDA7XG5cbiAgICAgICAgaWYgKGlzQXJvdW5kWmVybyhBKSAmJiBpc0Fyb3VuZFplcm8oQikpIHtcbiAgICAgICAgICAgIGlmIChpc0Fyb3VuZFplcm8oYikpIHtcbiAgICAgICAgICAgICAgICByb290c1swXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdDEgPSAtYyAvIGI7ICAvL3QxLCB0MiwgdDMsIGIgaXMgbm90IHplcm9cbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGlzYyA9IEIgKiBCIC0gNCAqIEEgKiBDO1xuXG4gICAgICAgICAgICBpZiAoaXNBcm91bmRaZXJvKGRpc2MpKSB7XG4gICAgICAgICAgICAgICAgdmFyIEsgPSBCIC8gQTtcbiAgICAgICAgICAgICAgICB2YXIgdDEgPSAtYiAvIGEgKyBLOyAgLy8gdDEsIGEgaXMgbm90IHplcm9cbiAgICAgICAgICAgICAgICB2YXIgdDIgPSAtSyAvIDI7ICAvLyB0MiwgdDNcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGlzYyA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlzY1NxcnQgPSBtYXRoU3FydChkaXNjKTtcbiAgICAgICAgICAgICAgICB2YXIgWTEgPSBBICogYiArIDEuNSAqIGEgKiAoLUIgKyBkaXNjU3FydCk7XG4gICAgICAgICAgICAgICAgdmFyIFkyID0gQSAqIGIgKyAxLjUgKiBhICogKC1CIC0gZGlzY1NxcnQpO1xuICAgICAgICAgICAgICAgIGlmIChZMSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgWTEgPSAtbWF0aFBvdygtWTEsIE9ORV9USElSRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBZMSA9IG1hdGhQb3coWTEsIE9ORV9USElSRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChZMiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgWTIgPSAtbWF0aFBvdygtWTIsIE9ORV9USElSRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBZMiA9IG1hdGhQb3coWTIsIE9ORV9USElSRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB0MSA9ICgtYiAtIChZMSArIFkyKSkgLyAoMyAqIGEpO1xuICAgICAgICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBUID0gKDIgKiBBICogYiAtIDMgKiBhICogQikgLyAoMiAqIG1hdGhTcXJ0KEEgKiBBICogQSkpO1xuICAgICAgICAgICAgICAgIHZhciB0aGV0YSA9IE1hdGguYWNvcyhUKSAvIDM7XG4gICAgICAgICAgICAgICAgdmFyIEFTcXJ0ID0gbWF0aFNxcnQoQSk7XG4gICAgICAgICAgICAgICAgdmFyIHRtcCA9IE1hdGguY29zKHRoZXRhKTtcblxuICAgICAgICAgICAgICAgIHZhciB0MSA9ICgtYiAtIDIgKiBBU3FydCAqIHRtcCkgLyAoMyAqIGEpO1xuICAgICAgICAgICAgICAgIHZhciB0MiA9ICgtYiArIEFTcXJ0ICogKHRtcCArIFRIUkVFX1NRUlQgKiBNYXRoLnNpbih0aGV0YSkpKSAvICgzICogYSk7XG4gICAgICAgICAgICAgICAgdmFyIHQzID0gKC1iICsgQVNxcnQgKiAodG1wIC0gVEhSRUVfU1FSVCAqIE1hdGguc2luKHRoZXRhKSkpIC8gKDMgKiBhKTtcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0MyA+PSAwICYmIHQzIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorqHnrpfkuInmrKHotJ3loZ7lsJTmlrnnqIvmnoHpmZDlgLznmoTkvY3nva5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAgICAgKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gZXh0cmVtYVxuICAgICAqIEByZXR1cm4ge251bWJlcn0g5pyJ5pWI5pWw55uuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3ViaWNFeHRyZW1hKHAwLCBwMSwgcDIsIHAzLCBleHRyZW1hKSB7XG4gICAgICAgIHZhciBiID0gNiAqIHAyIC0gMTIgKiBwMSArIDYgKiBwMDtcbiAgICAgICAgdmFyIGEgPSA5ICogcDEgKyAzICogcDMgLSAzICogcDAgLSA5ICogcDI7XG4gICAgICAgIHZhciBjID0gMyAqIHAxIC0gMyAqIHAwO1xuXG4gICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgaWYgKGlzQXJvdW5kWmVybyhhKSkge1xuICAgICAgICAgICAgaWYgKGlzTm90QXJvdW5kWmVybyhiKSkge1xuICAgICAgICAgICAgICAgIHZhciB0MSA9IC1jIC8gYjtcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PTEpIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmVtYVtuKytdID0gdDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRpc2MgPSBiICogYiAtIDQgKiBhICogYztcbiAgICAgICAgICAgIGlmIChpc0Fyb3VuZFplcm8oZGlzYykpIHtcbiAgICAgICAgICAgICAgICBleHRyZW1hWzBdID0gLWIgLyAoMiAqIGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGlzYyA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlzY1NxcnQgPSBtYXRoU3FydChkaXNjKTtcbiAgICAgICAgICAgICAgICB2YXIgdDEgPSAoLWIgKyBkaXNjU3FydCkgLyAoMiAqIGEpO1xuICAgICAgICAgICAgICAgIHZhciB0MiA9ICgtYiAtIGRpc2NTcXJ0KSAvICgyICogYSk7XG4gICAgICAgICAgICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICBleHRyZW1hW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICBleHRyZW1hW24rK10gPSB0MjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog57uG5YiG5LiJ5qyh6LSd5aGe5bCU5puy57q/XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IG91dFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1YmljU3ViZGl2aWRlKHAwLCBwMSwgcDIsIHAzLCB0LCBvdXQpIHtcbiAgICAgICAgdmFyIHAwMSA9IChwMSAtIHAwKSAqIHQgKyBwMDtcbiAgICAgICAgdmFyIHAxMiA9IChwMiAtIHAxKSAqIHQgKyBwMTtcbiAgICAgICAgdmFyIHAyMyA9IChwMyAtIHAyKSAqIHQgKyBwMjtcblxuICAgICAgICB2YXIgcDAxMiA9IChwMTIgLSBwMDEpICogdCArIHAwMTtcbiAgICAgICAgdmFyIHAxMjMgPSAocDIzIC0gcDEyKSAqIHQgKyBwMTI7XG5cbiAgICAgICAgdmFyIHAwMTIzID0gKHAxMjMgLSBwMDEyKSAqIHQgKyBwMDEyO1xuICAgICAgICAvLyBTZWcwXG4gICAgICAgIG91dFswXSA9IHAwO1xuICAgICAgICBvdXRbMV0gPSBwMDE7XG4gICAgICAgIG91dFsyXSA9IHAwMTI7XG4gICAgICAgIG91dFszXSA9IHAwMTIzO1xuICAgICAgICAvLyBTZWcxXG4gICAgICAgIG91dFs0XSA9IHAwMTIzO1xuICAgICAgICBvdXRbNV0gPSBwMTIzO1xuICAgICAgICBvdXRbNl0gPSBwMjM7XG4gICAgICAgIG91dFs3XSA9IHAzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaKleWwhOeCueWIsOS4ieasoei0neWhnuWwlOabsue6v+S4iu+8jOi/lOWbnuaKleWwhOi3neemu+OAglxuICAgICAqIOaKleWwhOeCueacieWPr+iDveS8muacieS4gOS4quaIluiAheWkmuS4qu+8jOi/memHjOWPqui/lOWbnuWFtuS4rei3neemu+acgOefreeahOS4gOS4quOAglxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4M1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5M1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBbb3V0XSDmipXlsITngrlcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3ViaWNQcm9qZWN0UG9pbnQoXG4gICAgICAgIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MyxcbiAgICAgICAgeCwgeSwgb3V0XG4gICAgKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9wb21heC5naXRodWIuaW8vYmV6aWVyaW5mby8jcHJvamVjdGlvbnNcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgIHZhciBpbnRlcnZhbCA9IDAuMDA1O1xuICAgICAgICB2YXIgZCA9IEluZmluaXR5O1xuICAgICAgICB2YXIgcHJldjtcbiAgICAgICAgdmFyIG5leHQ7XG4gICAgICAgIHZhciBkMTtcbiAgICAgICAgdmFyIGQyO1xuXG4gICAgICAgIF92MFswXSA9IHg7XG4gICAgICAgIF92MFsxXSA9IHk7XG5cbiAgICAgICAgLy8g5YWI57KX55Wl5Lyw6K6h5LiA5LiL5Y+v6IO955qE5pyA5bCP6Led56a755qEIHQg5YC8XG4gICAgICAgIC8vIFBFTkRJTkdcbiAgICAgICAgZm9yICh2YXIgX3QgPSAwOyBfdCA8IDE7IF90ICs9IDAuMDUpIHtcbiAgICAgICAgICAgIF92MVswXSA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIF90KTtcbiAgICAgICAgICAgIF92MVsxXSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIF90KTtcbiAgICAgICAgICAgIGQxID0gdjJEaXN0U3F1YXJlKF92MCwgX3YxKTtcbiAgICAgICAgICAgIGlmIChkMSA8IGQpIHtcbiAgICAgICAgICAgICAgICB0ID0gX3Q7XG4gICAgICAgICAgICAgICAgZCA9IGQxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGQgPSBJbmZpbml0eTtcblxuICAgICAgICAvLyBBdCBtb3N0IDMyIGl0ZXJhdGlvblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpbnRlcnZhbCA8IEVQU0lMT05fTlVNRVJJQykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldiA9IHQgLSBpbnRlcnZhbDtcbiAgICAgICAgICAgIG5leHQgPSB0ICsgaW50ZXJ2YWw7XG4gICAgICAgICAgICAvLyB0IC0gaW50ZXJ2YWxcbiAgICAgICAgICAgIF92MVswXSA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHByZXYpO1xuICAgICAgICAgICAgX3YxWzFdID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgcHJldik7XG5cbiAgICAgICAgICAgIGQxID0gdjJEaXN0U3F1YXJlKF92MSwgX3YwKTtcblxuICAgICAgICAgICAgaWYgKHByZXYgPj0gMCAmJiBkMSA8IGQpIHtcbiAgICAgICAgICAgICAgICB0ID0gcHJldjtcbiAgICAgICAgICAgICAgICBkID0gZDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0ICsgaW50ZXJ2YWxcbiAgICAgICAgICAgICAgICBfdjJbMF0gPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCBuZXh0KTtcbiAgICAgICAgICAgICAgICBfdjJbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBuZXh0KTtcbiAgICAgICAgICAgICAgICBkMiA9IHYyRGlzdFNxdWFyZShfdjIsIF92MCk7XG5cbiAgICAgICAgICAgICAgICBpZiAobmV4dCA8PSAxICYmIGQyIDwgZCkge1xuICAgICAgICAgICAgICAgICAgICB0ID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgZCA9IGQyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwgKj0gMC41O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0XG4gICAgICAgIGlmIChvdXQpIHtcbiAgICAgICAgICAgIG91dFswXSA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHQpO1xuICAgICAgICAgICAgb3V0WzFdID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc29sZS5sb2coaW50ZXJ2YWwsIGkpO1xuICAgICAgICByZXR1cm4gbWF0aFNxcnQoZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6K6h566X5LqM5qyh5pa56LSd5aGe5bCU5YC8XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YWRyYXRpY0F0KHAwLCBwMSwgcDIsIHQpIHtcbiAgICAgICAgdmFyIG9uZXQgPSAxIC0gdDtcbiAgICAgICAgcmV0dXJuIG9uZXQgKiAob25ldCAqIHAwICsgMiAqIHQgKiBwMSkgKyB0ICogdCAqIHAyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiuoeeul+S6jOasoeaWuei0neWhnuWwlOWvvOaVsOWAvFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gdFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBxdWFkcmF0aWNEZXJpdmF0aXZlQXQocDAsIHAxLCBwMiwgdCkge1xuICAgICAgICByZXR1cm4gMiAqICgoMSAtIHQpICogKHAxIC0gcDApICsgdCAqIChwMiAtIHAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6K6h566X5LqM5qyh5pa56LSd5aGe5bCU5pa556iL5qC5XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IHJvb3RzXG4gICAgICogQHJldHVybiB7bnVtYmVyfSDmnInmlYjmoLnmlbDnm65cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBxdWFkcmF0aWNSb290QXQocDAsIHAxLCBwMiwgdmFsLCByb290cykge1xuICAgICAgICB2YXIgYSA9IHAwIC0gMiAqIHAxICsgcDI7XG4gICAgICAgIHZhciBiID0gMiAqIChwMSAtIHAwKTtcbiAgICAgICAgdmFyIGMgPSBwMCAtIHZhbDtcblxuICAgICAgICB2YXIgbiA9IDA7XG4gICAgICAgIGlmIChpc0Fyb3VuZFplcm8oYSkpIHtcbiAgICAgICAgICAgIGlmIChpc05vdEFyb3VuZFplcm8oYikpIHtcbiAgICAgICAgICAgICAgICB2YXIgdDEgPSAtYyAvIGI7XG4gICAgICAgICAgICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRpc2MgPSBiICogYiAtIDQgKiBhICogYztcbiAgICAgICAgICAgIGlmIChpc0Fyb3VuZFplcm8oZGlzYykpIHtcbiAgICAgICAgICAgICAgICB2YXIgdDEgPSAtYiAvICgyICogYSk7XG4gICAgICAgICAgICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGlzYyA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlzY1NxcnQgPSBtYXRoU3FydChkaXNjKTtcbiAgICAgICAgICAgICAgICB2YXIgdDEgPSAoLWIgKyBkaXNjU3FydCkgLyAoMiAqIGEpO1xuICAgICAgICAgICAgICAgIHZhciB0MiA9ICgtYiAtIGRpc2NTcXJ0KSAvICgyICogYSk7XG4gICAgICAgICAgICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorqHnrpfkuozmrKHotJ3loZ7lsJTmlrnnqIvmnoHpmZDlgLxcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBxdWFkcmF0aWNFeHRyZW11bShwMCwgcDEsIHAyKSB7XG4gICAgICAgIHZhciBkaXZpZGVyID0gcDAgKyBwMiAtIDIgKiBwMTtcbiAgICAgICAgaWYgKGRpdmlkZXIgPT09IDApIHtcbiAgICAgICAgICAgIC8vIHAxIGlzIGNlbnRlciBvZiBwMCBhbmQgcDJcbiAgICAgICAgICAgIHJldHVybiAwLjU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKHAwIC0gcDEpIC8gZGl2aWRlcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOe7huWIhuS6jOasoei0neWhnuWwlOabsue6v1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IG91dFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YWRyYXRpY1N1YmRpdmlkZShwMCwgcDEsIHAyLCB0LCBvdXQpIHtcbiAgICAgICAgdmFyIHAwMSA9IChwMSAtIHAwKSAqIHQgKyBwMDtcbiAgICAgICAgdmFyIHAxMiA9IChwMiAtIHAxKSAqIHQgKyBwMTtcbiAgICAgICAgdmFyIHAwMTIgPSAocDEyIC0gcDAxKSAqIHQgKyBwMDE7XG5cbiAgICAgICAgLy8gU2VnMFxuICAgICAgICBvdXRbMF0gPSBwMDtcbiAgICAgICAgb3V0WzFdID0gcDAxO1xuICAgICAgICBvdXRbMl0gPSBwMDEyO1xuXG4gICAgICAgIC8vIFNlZzFcbiAgICAgICAgb3V0WzNdID0gcDAxMjtcbiAgICAgICAgb3V0WzRdID0gcDEyO1xuICAgICAgICBvdXRbNV0gPSBwMjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmipXlsITngrnliLDkuozmrKHotJ3loZ7lsJTmm7Lnur/kuIrvvIzov5Tlm57mipXlsITot53nprvjgIJcbiAgICAgKiDmipXlsITngrnmnInlj6/og73kvJrmnInkuIDkuKrmiJbogIXlpJrkuKrvvIzov5nph4zlj6rov5Tlm57lhbbkuK3ot53nprvmnIDnn63nmoTkuIDkuKrjgIJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gb3V0IOaKleWwhOeCuVxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBxdWFkcmF0aWNQcm9qZWN0UG9pbnQoXG4gICAgICAgIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsXG4gICAgICAgIHgsIHksIG91dFxuICAgICkge1xuICAgICAgICAvLyBodHRwOi8vcG9tYXguZ2l0aHViLmlvL2JlemllcmluZm8vI3Byb2plY3Rpb25zXG4gICAgICAgIHZhciB0O1xuICAgICAgICB2YXIgaW50ZXJ2YWwgPSAwLjAwNTtcbiAgICAgICAgdmFyIGQgPSBJbmZpbml0eTtcblxuICAgICAgICBfdjBbMF0gPSB4O1xuICAgICAgICBfdjBbMV0gPSB5O1xuXG4gICAgICAgIC8vIOWFiOeyl+eVpeS8sOiuoeS4gOS4i+WPr+iDveeahOacgOWwj+i3neemu+eahCB0IOWAvFxuICAgICAgICAvLyBQRU5ESU5HXG4gICAgICAgIGZvciAodmFyIF90ID0gMDsgX3QgPCAxOyBfdCArPSAwLjA1KSB7XG4gICAgICAgICAgICBfdjFbMF0gPSBxdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCBfdCk7XG4gICAgICAgICAgICBfdjFbMV0gPSBxdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCBfdCk7XG4gICAgICAgICAgICB2YXIgZDEgPSB2MkRpc3RTcXVhcmUoX3YwLCBfdjEpO1xuICAgICAgICAgICAgaWYgKGQxIDwgZCkge1xuICAgICAgICAgICAgICAgIHQgPSBfdDtcbiAgICAgICAgICAgICAgICBkID0gZDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZCA9IEluZmluaXR5O1xuXG4gICAgICAgIC8vIEF0IG1vc3QgMzIgaXRlcmF0aW9uXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgICAgICAgICAgaWYgKGludGVydmFsIDwgRVBTSUxPTl9OVU1FUklDKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJldiA9IHQgLSBpbnRlcnZhbDtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gdCArIGludGVydmFsO1xuICAgICAgICAgICAgLy8gdCAtIGludGVydmFsXG4gICAgICAgICAgICBfdjFbMF0gPSBxdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCBwcmV2KTtcbiAgICAgICAgICAgIF92MVsxXSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIHByZXYpO1xuXG4gICAgICAgICAgICB2YXIgZDEgPSB2MkRpc3RTcXVhcmUoX3YxLCBfdjApO1xuXG4gICAgICAgICAgICBpZiAocHJldiA+PSAwICYmIGQxIDwgZCkge1xuICAgICAgICAgICAgICAgIHQgPSBwcmV2O1xuICAgICAgICAgICAgICAgIGQgPSBkMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHQgKyBpbnRlcnZhbFxuICAgICAgICAgICAgICAgIF92MlswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIG5leHQpO1xuICAgICAgICAgICAgICAgIF92MlsxXSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIG5leHQpO1xuICAgICAgICAgICAgICAgIHZhciBkMiA9IHYyRGlzdFNxdWFyZShfdjIsIF92MCk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgPD0gMSAmJiBkMiA8IGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdCA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGQgPSBkMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVydmFsICo9IDAuNTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdFxuICAgICAgICBpZiAob3V0KSB7XG4gICAgICAgICAgICBvdXRbMF0gPSBxdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCB0KTtcbiAgICAgICAgICAgIG91dFsxXSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIHQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGludGVydmFsLCBpKTtcbiAgICAgICAgcmV0dXJuIG1hdGhTcXJ0KGQpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG5cbiAgICAgICAgY3ViaWNBdDogY3ViaWNBdCxcblxuICAgICAgICBjdWJpY0Rlcml2YXRpdmVBdDogY3ViaWNEZXJpdmF0aXZlQXQsXG5cbiAgICAgICAgY3ViaWNSb290QXQ6IGN1YmljUm9vdEF0LFxuXG4gICAgICAgIGN1YmljRXh0cmVtYTogY3ViaWNFeHRyZW1hLFxuXG4gICAgICAgIGN1YmljU3ViZGl2aWRlOiBjdWJpY1N1YmRpdmlkZSxcblxuICAgICAgICBjdWJpY1Byb2plY3RQb2ludDogY3ViaWNQcm9qZWN0UG9pbnQsXG5cbiAgICAgICAgcXVhZHJhdGljQXQ6IHF1YWRyYXRpY0F0LFxuXG4gICAgICAgIHF1YWRyYXRpY0Rlcml2YXRpdmVBdDogcXVhZHJhdGljRGVyaXZhdGl2ZUF0LFxuXG4gICAgICAgIHF1YWRyYXRpY1Jvb3RBdDogcXVhZHJhdGljUm9vdEF0LFxuXG4gICAgICAgIHF1YWRyYXRpY0V4dHJlbXVtOiBxdWFkcmF0aWNFeHRyZW11bSxcblxuICAgICAgICBxdWFkcmF0aWNTdWJkaXZpZGU6IHF1YWRyYXRpY1N1YmRpdmlkZSxcblxuICAgICAgICBxdWFkcmF0aWNQcm9qZWN0UG9pbnQ6IHF1YWRyYXRpY1Byb2plY3RQb2ludFxuICAgIH07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL3pyZW5kZXIvY29yZS9jdXJ2ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDU0XG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCIvKipcbiAqIEBhdXRob3IgWWkgU2hlbihodHRwczovL2dpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJy4vdmVjdG9yJyk7XG4gICAgdmFyIGN1cnZlID0gcmVxdWlyZSgnLi9jdXJ2ZScpO1xuXG4gICAgdmFyIGJib3ggPSB7fTtcbiAgICB2YXIgbWF0aE1pbiA9IE1hdGgubWluO1xuICAgIHZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG4gICAgdmFyIG1hdGhTaW4gPSBNYXRoLnNpbjtcbiAgICB2YXIgbWF0aENvcyA9IE1hdGguY29zO1xuXG4gICAgdmFyIHN0YXJ0ID0gdmVjMi5jcmVhdGUoKTtcbiAgICB2YXIgZW5kID0gdmVjMi5jcmVhdGUoKTtcbiAgICB2YXIgZXh0cmVtaXR5ID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIHZhciBQSTIgPSBNYXRoLlBJICogMjtcbiAgICAvKipcbiAgICAgKiDku47pobbngrnmlbDnu4TkuK3orqHnrpflh7rmnIDlsI/ljIXlm7Tnm5LvvIzlhpnlhaVgbWluYOWSjGBtYXhg5LitXG4gICAgICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvYmJveFxuICAgICAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gcG9pbnRzIOmhtueCueaVsOe7hFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gICAgICovXG4gICAgYmJveC5mcm9tUG9pbnRzID0gZnVuY3Rpb24ocG9pbnRzLCBtaW4sIG1heCkge1xuICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwID0gcG9pbnRzWzBdO1xuICAgICAgICB2YXIgbGVmdCA9IHBbMF07XG4gICAgICAgIHZhciByaWdodCA9IHBbMF07XG4gICAgICAgIHZhciB0b3AgPSBwWzFdO1xuICAgICAgICB2YXIgYm90dG9tID0gcFsxXTtcbiAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgZm9yIChpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgIGxlZnQgPSBtYXRoTWluKGxlZnQsIHBbMF0pO1xuICAgICAgICAgICAgcmlnaHQgPSBtYXRoTWF4KHJpZ2h0LCBwWzBdKTtcbiAgICAgICAgICAgIHRvcCA9IG1hdGhNaW4odG9wLCBwWzFdKTtcbiAgICAgICAgICAgIGJvdHRvbSA9IG1hdGhNYXgoYm90dG9tLCBwWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1pblswXSA9IGxlZnQ7XG4gICAgICAgIG1pblsxXSA9IHRvcDtcbiAgICAgICAgbWF4WzBdID0gcmlnaHQ7XG4gICAgICAgIG1heFsxXSA9IGJvdHRvbTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvYmJveFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1pblxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1heFxuICAgICAqL1xuICAgIGJib3guZnJvbUxpbmUgPSBmdW5jdGlvbiAoeDAsIHkwLCB4MSwgeTEsIG1pbiwgbWF4KSB7XG4gICAgICAgIG1pblswXSA9IG1hdGhNaW4oeDAsIHgxKTtcbiAgICAgICAgbWluWzFdID0gbWF0aE1pbih5MCwgeTEpO1xuICAgICAgICBtYXhbMF0gPSBtYXRoTWF4KHgwLCB4MSk7XG4gICAgICAgIG1heFsxXSA9IG1hdGhNYXgoeTAsIHkxKTtcbiAgICB9O1xuXG4gICAgdmFyIHhEaW0gPSBbXTtcbiAgICB2YXIgeURpbSA9IFtdO1xuICAgIC8qKlxuICAgICAqIOS7juS4iemYtui0neWhnuWwlOabsue6vyhwMCwgcDEsIHAyLCBwMynkuK3orqHnrpflh7rmnIDlsI/ljIXlm7Tnm5LvvIzlhpnlhaVgbWluYOWSjGBtYXhg5LitXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvYmJveFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4M1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5M1xuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1pblxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1heFxuICAgICAqL1xuICAgIGJib3guZnJvbUN1YmljID0gZnVuY3Rpb24oXG4gICAgICAgIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgbWluLCBtYXhcbiAgICApIHtcbiAgICAgICAgdmFyIGN1YmljRXh0cmVtYSA9IGN1cnZlLmN1YmljRXh0cmVtYTtcbiAgICAgICAgdmFyIGN1YmljQXQgPSBjdXJ2ZS5jdWJpY0F0O1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIG4gPSBjdWJpY0V4dHJlbWEoeDAsIHgxLCB4MiwgeDMsIHhEaW0pO1xuICAgICAgICBtaW5bMF0gPSBJbmZpbml0eTtcbiAgICAgICAgbWluWzFdID0gSW5maW5pdHk7XG4gICAgICAgIG1heFswXSA9IC1JbmZpbml0eTtcbiAgICAgICAgbWF4WzFdID0gLUluZmluaXR5O1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB4ID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgeERpbVtpXSk7XG4gICAgICAgICAgICBtaW5bMF0gPSBtYXRoTWluKHgsIG1pblswXSk7XG4gICAgICAgICAgICBtYXhbMF0gPSBtYXRoTWF4KHgsIG1heFswXSk7XG4gICAgICAgIH1cbiAgICAgICAgbiA9IGN1YmljRXh0cmVtYSh5MCwgeTEsIHkyLCB5MywgeURpbSk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB5ID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgeURpbVtpXSk7XG4gICAgICAgICAgICBtaW5bMV0gPSBtYXRoTWluKHksIG1pblsxXSk7XG4gICAgICAgICAgICBtYXhbMV0gPSBtYXRoTWF4KHksIG1heFsxXSk7XG4gICAgICAgIH1cblxuICAgICAgICBtaW5bMF0gPSBtYXRoTWluKHgwLCBtaW5bMF0pO1xuICAgICAgICBtYXhbMF0gPSBtYXRoTWF4KHgwLCBtYXhbMF0pO1xuICAgICAgICBtaW5bMF0gPSBtYXRoTWluKHgzLCBtaW5bMF0pO1xuICAgICAgICBtYXhbMF0gPSBtYXRoTWF4KHgzLCBtYXhbMF0pO1xuXG4gICAgICAgIG1pblsxXSA9IG1hdGhNaW4oeTAsIG1pblsxXSk7XG4gICAgICAgIG1heFsxXSA9IG1hdGhNYXgoeTAsIG1heFsxXSk7XG4gICAgICAgIG1pblsxXSA9IG1hdGhNaW4oeTMsIG1pblsxXSk7XG4gICAgICAgIG1heFsxXSA9IG1hdGhNYXgoeTMsIG1heFsxXSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIOS7juS6jOmYtui0neWhnuWwlOabsue6vyhwMCwgcDEsIHAyKeS4reiuoeeul+WHuuacgOWwj+WMheWbtOebku+8jOWGmeWFpWBtaW5g5ZKMYG1heGDkuK1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9iYm94XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWluXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF4XG4gICAgICovXG4gICAgYmJveC5mcm9tUXVhZHJhdGljID0gZnVuY3Rpb24oeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgbWluLCBtYXgpIHtcbiAgICAgICAgdmFyIHF1YWRyYXRpY0V4dHJlbXVtID0gY3VydmUucXVhZHJhdGljRXh0cmVtdW07XG4gICAgICAgIHZhciBxdWFkcmF0aWNBdCA9IGN1cnZlLnF1YWRyYXRpY0F0O1xuICAgICAgICAvLyBGaW5kIGV4dHJlbWl0aWVzLCB3aGVyZSBkZXJpdmF0aXZlIGluIHggZGltIG9yIHkgZGltIGlzIHplcm9cbiAgICAgICAgdmFyIHR4ID1cbiAgICAgICAgICAgIG1hdGhNYXgoXG4gICAgICAgICAgICAgICAgbWF0aE1pbihxdWFkcmF0aWNFeHRyZW11bSh4MCwgeDEsIHgyKSwgMSksIDBcbiAgICAgICAgICAgICk7XG4gICAgICAgIHZhciB0eSA9XG4gICAgICAgICAgICBtYXRoTWF4KFxuICAgICAgICAgICAgICAgIG1hdGhNaW4ocXVhZHJhdGljRXh0cmVtdW0oeTAsIHkxLCB5MiksIDEpLCAwXG4gICAgICAgICAgICApO1xuXG4gICAgICAgIHZhciB4ID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgdHgpO1xuICAgICAgICB2YXIgeSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIHR5KTtcblxuICAgICAgICBtaW5bMF0gPSBtYXRoTWluKHgwLCB4MiwgeCk7XG4gICAgICAgIG1pblsxXSA9IG1hdGhNaW4oeTAsIHkyLCB5KTtcbiAgICAgICAgbWF4WzBdID0gbWF0aE1heCh4MCwgeDIsIHgpO1xuICAgICAgICBtYXhbMV0gPSBtYXRoTWF4KHkwLCB5MiwgeSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIOS7juWchuW8p+S4reiuoeeul+WHuuacgOWwj+WMheWbtOebku+8jOWGmeWFpWBtaW5g5ZKMYG1heGDkuK1cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvYmJveFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcnhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcnlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRBbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRBbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbnRpY2xvY2t3aXNlXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWluXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF4XG4gICAgICovXG4gICAgYmJveC5mcm9tQXJjID0gZnVuY3Rpb24gKFxuICAgICAgICB4LCB5LCByeCwgcnksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlLCBtaW4sIG1heFxuICAgICkge1xuICAgICAgICB2YXIgdmVjMk1pbiA9IHZlYzIubWluO1xuICAgICAgICB2YXIgdmVjMk1heCA9IHZlYzIubWF4O1xuXG4gICAgICAgIHZhciBkaWZmID0gTWF0aC5hYnMoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKTtcblxuXG4gICAgICAgIGlmIChkaWZmICUgUEkyIDwgMWUtNCAmJiBkaWZmID4gMWUtNCkge1xuICAgICAgICAgICAgLy8gSXMgYSBjaXJjbGVcbiAgICAgICAgICAgIG1pblswXSA9IHggLSByeDtcbiAgICAgICAgICAgIG1pblsxXSA9IHkgLSByeTtcbiAgICAgICAgICAgIG1heFswXSA9IHggKyByeDtcbiAgICAgICAgICAgIG1heFsxXSA9IHkgKyByeTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0WzBdID0gbWF0aENvcyhzdGFydEFuZ2xlKSAqIHJ4ICsgeDtcbiAgICAgICAgc3RhcnRbMV0gPSBtYXRoU2luKHN0YXJ0QW5nbGUpICogcnkgKyB5O1xuXG4gICAgICAgIGVuZFswXSA9IG1hdGhDb3MoZW5kQW5nbGUpICogcnggKyB4O1xuICAgICAgICBlbmRbMV0gPSBtYXRoU2luKGVuZEFuZ2xlKSAqIHJ5ICsgeTtcblxuICAgICAgICB2ZWMyTWluKG1pbiwgc3RhcnQsIGVuZCk7XG4gICAgICAgIHZlYzJNYXgobWF4LCBzdGFydCwgZW5kKTtcblxuICAgICAgICAvLyBUaHJlc2ggdG8gWzAsIE1hdGguUEkgKiAyXVxuICAgICAgICBzdGFydEFuZ2xlID0gc3RhcnRBbmdsZSAlIChQSTIpO1xuICAgICAgICBpZiAoc3RhcnRBbmdsZSA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBzdGFydEFuZ2xlICsgUEkyO1xuICAgICAgICB9XG4gICAgICAgIGVuZEFuZ2xlID0gZW5kQW5nbGUgJSAoUEkyKTtcbiAgICAgICAgaWYgKGVuZEFuZ2xlIDwgMCkge1xuICAgICAgICAgICAgZW5kQW5nbGUgPSBlbmRBbmdsZSArIFBJMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFydEFuZ2xlID4gZW5kQW5nbGUgJiYgIWFudGljbG9ja3dpc2UpIHtcbiAgICAgICAgICAgIGVuZEFuZ2xlICs9IFBJMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGFydEFuZ2xlIDwgZW5kQW5nbGUgJiYgYW50aWNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgc3RhcnRBbmdsZSArPSBQSTI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFudGljbG9ja3dpc2UpIHtcbiAgICAgICAgICAgIHZhciB0bXAgPSBlbmRBbmdsZTtcbiAgICAgICAgICAgIGVuZEFuZ2xlID0gc3RhcnRBbmdsZTtcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSB0bXA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YXIgbnVtYmVyID0gMDtcbiAgICAgICAgLy8gdmFyIHN0ZXAgPSAoYW50aWNsb2Nrd2lzZSA/IC1NYXRoLlBJIDogTWF0aC5QSSkgLyAyO1xuICAgICAgICBmb3IgKHZhciBhbmdsZSA9IDA7IGFuZ2xlIDwgZW5kQW5nbGU7IGFuZ2xlICs9IE1hdGguUEkgLyAyKSB7XG4gICAgICAgICAgICBpZiAoYW5nbGUgPiBzdGFydEFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgZXh0cmVtaXR5WzBdID0gbWF0aENvcyhhbmdsZSkgKiByeCArIHg7XG4gICAgICAgICAgICAgICAgZXh0cmVtaXR5WzFdID0gbWF0aFNpbihhbmdsZSkgKiByeSArIHk7XG5cbiAgICAgICAgICAgICAgICB2ZWMyTWluKG1pbiwgZXh0cmVtaXR5LCBtaW4pO1xuICAgICAgICAgICAgICAgIHZlYzJNYXgobWF4LCBleHRyZW1pdHksIG1heCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGJib3g7XG59KTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvenJlbmRlci9jb3JlL2Jib3guanNcbiAqKiBtb2R1bGUgaWQgPSA1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgQ01EID0gcmVxdWlyZSgnLi4vY29yZS9QYXRoUHJveHknKS5DTUQ7XG4gICAgdmFyIGxpbmUgPSByZXF1aXJlKCcuL2xpbmUnKTtcbiAgICB2YXIgY3ViaWMgPSByZXF1aXJlKCcuL2N1YmljJyk7XG4gICAgdmFyIHF1YWRyYXRpYyA9IHJlcXVpcmUoJy4vcXVhZHJhdGljJyk7XG4gICAgdmFyIGFyYyA9IHJlcXVpcmUoJy4vYXJjJyk7XG4gICAgdmFyIG5vcm1hbGl6ZVJhZGlhbiA9IHJlcXVpcmUoJy4vdXRpbCcpLm5vcm1hbGl6ZVJhZGlhbjtcbiAgICB2YXIgY3VydmUgPSByZXF1aXJlKCcuLi9jb3JlL2N1cnZlJyk7XG5cbiAgICB2YXIgd2luZGluZ0xpbmUgPSByZXF1aXJlKCcuL3dpbmRpbmdMaW5lJyk7XG5cbiAgICB2YXIgY29udGFpblN0cm9rZSA9IGxpbmUuY29udGFpblN0cm9rZTtcblxuICAgIHZhciBQSTIgPSBNYXRoLlBJICogMjtcblxuICAgIHZhciBFUFNJTE9OID0gMWUtNDtcblxuICAgIGZ1bmN0aW9uIGlzQXJvdW5kRXF1YWwoYSwgYikge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDwgRVBTSUxPTjtcbiAgICB9XG5cbiAgICAvLyDkuLTml7bmlbDnu4RcbiAgICB2YXIgcm9vdHMgPSBbLTEsIC0xLCAtMV07XG4gICAgdmFyIGV4dHJlbWEgPSBbLTEsIC0xXTtcblxuICAgIGZ1bmN0aW9uIHN3YXBFeHRyZW1hKCkge1xuICAgICAgICB2YXIgdG1wID0gZXh0cmVtYVswXTtcbiAgICAgICAgZXh0cmVtYVswXSA9IGV4dHJlbWFbMV07XG4gICAgICAgIGV4dHJlbWFbMV0gPSB0bXA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2luZGluZ0N1YmljKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeCwgeSkge1xuICAgICAgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHkgPiB5MCAmJiB5ID4geTEgJiYgeSA+IHkyICYmIHkgPiB5MylcbiAgICAgICAgICAgIHx8ICh5IDwgeTAgJiYgeSA8IHkxICYmIHkgPCB5MiAmJiB5IDwgeTMpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5Sb290cyA9IGN1cnZlLmN1YmljUm9vdEF0KHkwLCB5MSwgeTIsIHkzLCB5LCByb290cyk7XG4gICAgICAgIGlmIChuUm9vdHMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHcgPSAwO1xuICAgICAgICAgICAgdmFyIG5FeHRyZW1hID0gLTE7XG4gICAgICAgICAgICB2YXIgeTBfLCB5MV87XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5Sb290czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSByb290c1tpXTtcblxuICAgICAgICAgICAgICAgIC8vIEF2b2lkIHdpbmRpbmcgZXJyb3Igd2hlbiBpbnRlcnNlY3Rpb24gcG9pbnQgaXMgdGhlIGNvbm5lY3QgcG9pbnQgb2YgdHdvIGxpbmUgb2YgcG9seWdvblxuICAgICAgICAgICAgICAgIHZhciB1bml0ID0gKHQgPT09IDAgfHwgdCA9PT0gMSkgPyAwLjUgOiAxO1xuXG4gICAgICAgICAgICAgICAgdmFyIHhfID0gY3VydmUuY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG4gICAgICAgICAgICAgICAgaWYgKHhfIDwgeCkgeyAvLyBRdWljayByZWplY3RcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuRXh0cmVtYSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbkV4dHJlbWEgPSBjdXJ2ZS5jdWJpY0V4dHJlbWEoeTAsIHkxLCB5MiwgeTMsIGV4dHJlbWEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXh0cmVtYVsxXSA8IGV4dHJlbWFbMF0gJiYgbkV4dHJlbWEgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2FwRXh0cmVtYSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHkwXyA9IGN1cnZlLmN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIGV4dHJlbWFbMF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobkV4dHJlbWEgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5MV8gPSBjdXJ2ZS5jdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBleHRyZW1hWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobkV4dHJlbWEgPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyDliIbmiJDkuInmrrXljZXosIPlh73mlbBcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgPCBleHRyZW1hWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHkwXyA8IHkwID8gdW5pdCA6IC11bml0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHQgPCBleHRyZW1hWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHkxXyA8IHkwXyA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0geTMgPCB5MV8gPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWIhuaIkOS4pOauteWNleiwg+WHveaVsFxuICAgICAgICAgICAgICAgICAgICBpZiAodCA8IGV4dHJlbWFbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0geTBfIDwgeTAgPyB1bml0IDogLXVuaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHkzIDwgeTBfID8gdW5pdCA6IC11bml0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3aW5kaW5nUXVhZHJhdGljKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgsIHkpIHtcbiAgICAgICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICh5ID4geTAgJiYgeSA+IHkxICYmIHkgPiB5MilcbiAgICAgICAgICAgIHx8ICh5IDwgeTAgJiYgeSA8IHkxICYmIHkgPCB5MilcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgblJvb3RzID0gY3VydmUucXVhZHJhdGljUm9vdEF0KHkwLCB5MSwgeTIsIHksIHJvb3RzKTtcbiAgICAgICAgaWYgKG5Sb290cyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdCA9IGN1cnZlLnF1YWRyYXRpY0V4dHJlbXVtKHkwLCB5MSwgeTIpO1xuICAgICAgICAgICAgaWYgKHQgPj0gMCAmJiB0IDw9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgdyA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIHlfID0gY3VydmUucXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgdCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUm9vdHM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgb25lIGVuZHBvaW50LlxuICAgICAgICAgICAgICAgICAgICB2YXIgdW5pdCA9IChyb290c1tpXSA9PT0gMCB8fCByb290c1tpXSA9PT0gMSkgPyAwLjUgOiAxO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB4XyA9IGN1cnZlLnF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHJvb3RzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhfIDwgeCkgeyAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvb3RzW2ldIDwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB5XyA8IHkwID8gdW5pdCA6IC11bml0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB5MiA8IHlfID8gdW5pdCA6IC11bml0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIG9uZSBlbmRwb2ludC5cbiAgICAgICAgICAgICAgICB2YXIgdW5pdCA9IChyb290c1swXSA9PT0gMCB8fCByb290c1swXSA9PT0gMSkgPyAwLjUgOiAxO1xuXG4gICAgICAgICAgICAgICAgdmFyIHhfID0gY3VydmUucXVhZHJhdGljQXQoeDAsIHgxLCB4Miwgcm9vdHNbMF0pO1xuICAgICAgICAgICAgICAgIGlmICh4XyA8IHgpIHsgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB5MiA8IHkwID8gdW5pdCA6IC11bml0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ET1xuICAgIC8vIEFyYyDml4vovaxcbiAgICBmdW5jdGlvbiB3aW5kaW5nQXJjKFxuICAgICAgICBjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlLCB4LCB5XG4gICAgKSB7XG4gICAgICAgIHkgLT0gY3k7XG4gICAgICAgIGlmICh5ID4gciB8fCB5IDwgLXIpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0bXAgPSBNYXRoLnNxcnQociAqIHIgLSB5ICogeSk7XG4gICAgICAgIHJvb3RzWzBdID0gLXRtcDtcbiAgICAgICAgcm9vdHNbMV0gPSB0bXA7XG5cbiAgICAgICAgdmFyIGRpZmYgPSBNYXRoLmFicyhzdGFydEFuZ2xlIC0gZW5kQW5nbGUpO1xuICAgICAgICBpZiAoZGlmZiA8IDFlLTQpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaWZmICUgUEkyIDwgMWUtNCkge1xuICAgICAgICAgICAgLy8gSXMgYSBjaXJjbGVcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSAwO1xuICAgICAgICAgICAgZW5kQW5nbGUgPSBQSTI7XG4gICAgICAgICAgICB2YXIgZGlyID0gYW50aWNsb2Nrd2lzZSA/IDEgOiAtMTtcbiAgICAgICAgICAgIGlmICh4ID49IHJvb3RzWzBdICsgY3ggJiYgeCA8PSByb290c1sxXSArIGN4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYW50aWNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgdmFyIHRtcCA9IHN0YXJ0QW5nbGU7XG4gICAgICAgICAgICBzdGFydEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKGVuZEFuZ2xlKTtcbiAgICAgICAgICAgIGVuZEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKHRtcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKHN0YXJ0QW5nbGUpO1xuICAgICAgICAgICAgZW5kQW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydEFuZ2xlID4gZW5kQW5nbGUpIHtcbiAgICAgICAgICAgIGVuZEFuZ2xlICs9IFBJMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB4XyA9IHJvb3RzW2ldO1xuICAgICAgICAgICAgaWYgKHhfICsgY3ggPiB4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMih5LCB4Xyk7XG4gICAgICAgICAgICAgICAgdmFyIGRpciA9IGFudGljbG9ja3dpc2UgPyAxIDogLTE7XG4gICAgICAgICAgICAgICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBhbmdsZSA9IFBJMiArIGFuZ2xlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIChhbmdsZSA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlIDw9IGVuZEFuZ2xlKVxuICAgICAgICAgICAgICAgICAgICB8fCAoYW5nbGUgKyBQSTIgPj0gc3RhcnRBbmdsZSAmJiBhbmdsZSArIFBJMiA8PSBlbmRBbmdsZSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFuZ2xlID4gTWF0aC5QSSAvIDIgJiYgYW5nbGUgPCBNYXRoLlBJICogMS41KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXIgPSAtZGlyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHcgKz0gZGlyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb250YWluUGF0aChkYXRhLCBsaW5lV2lkdGgsIGlzU3Ryb2tlLCB4LCB5KSB7XG4gICAgICAgIHZhciB3ID0gMDtcbiAgICAgICAgdmFyIHhpID0gMDtcbiAgICAgICAgdmFyIHlpID0gMDtcbiAgICAgICAgdmFyIHgwID0gMDtcbiAgICAgICAgdmFyIHkwID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOykge1xuICAgICAgICAgICAgdmFyIGNtZCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgIC8vIEJlZ2luIGEgbmV3IHN1YnBhdGhcbiAgICAgICAgICAgIGlmIChjbWQgPT09IENNRC5NICYmIGkgPiAxKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2xvc2UgcHJldmlvdXMgc3VicGF0aFxuICAgICAgICAgICAgICAgIGlmICghaXNTdHJva2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdyArPSB3aW5kaW5nTGluZSh4aSwgeWksIHgwLCB5MCwgeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIOWmguaenOiiq+S7u+S9leS4gOS4qiBzdWJwYXRoIOWMheWQq1xuICAgICAgICAgICAgICAgIC8vIGlmICh3ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGkgPT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIOWmguaenOesrOS4gOS4quWRveS7pOaYryBMLCBDLCBRXG4gICAgICAgICAgICAgICAgLy8g5YiZIHByZXZpb3VzIHBvaW50IOWQjOe7mOWItuWRveS7pOeahOesrOS4gOS4qiBwb2ludFxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk5Li6IEFyYyDnmoTmg4XlhrXkuIvkvJrlnKjlkI7pnaLnibnmrorlpITnkIZcbiAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaV07XG4gICAgICAgICAgICAgICAgeWkgPSBkYXRhW2kgKyAxXTtcblxuICAgICAgICAgICAgICAgIHgwID0geGk7XG4gICAgICAgICAgICAgICAgeTAgPSB5aTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIENNRC5NOlxuICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlVG8g5ZG95Luk6YeN5paw5Yib5bu65LiA5Liq5paw55qEIHN1YnBhdGgsIOW5tuS4lOabtOaWsOaWsOeahOi1t+eCuVxuICAgICAgICAgICAgICAgICAgICAvLyDlnKggY2xvc2VQYXRoIOeahOaXtuWAmeS9v+eUqFxuICAgICAgICAgICAgICAgICAgICB4MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgeTAgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHhpID0geDA7XG4gICAgICAgICAgICAgICAgICAgIHlpID0geTA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELkw6XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5TdHJva2UoeGksIHlpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGluZVdpZHRoLCB4LCB5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URSDlnKjnrKzkuIDkuKrlkb3ku6TkuLogTCwgQywgUSDnmoTml7blgJnkvJrorqHnrpflh7ogTmFOXG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIHgsIHkpIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENNRC5DOlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdWJpYy5jb250YWluU3Ryb2tlKHhpLCB5aSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aCwgeCwgeVxuICAgICAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB3aW5kaW5nQ3ViaWMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGksIHlpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCwgeVxuICAgICAgICAgICAgICAgICAgICAgICAgKSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDTUQuUTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocXVhZHJhdGljLmNvbnRhaW5TdHJva2UoeGksIHlpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGgsIHgsIHlcbiAgICAgICAgICAgICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ1F1YWRyYXRpYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aSwgeWksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgsIHlcbiAgICAgICAgICAgICAgICAgICAgICAgICkgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELkE6XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gQXJjIOWIpOaWreeahOW8gOmUgOavlOi+g+Wkp1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3ggPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciBjeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJ4ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcnkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aGV0YSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRUaGV0YSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBBcmMg5peL6L2sXG4gICAgICAgICAgICAgICAgICAgIHZhciBwc2kgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbnRpY2xvY2t3aXNlID0gMSAtIGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHgxID0gTWF0aC5jb3ModGhldGEpICogcnggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkxID0gTWF0aC5zaW4odGhldGEpICogcnkgKyBjeTtcbiAgICAgICAgICAgICAgICAgICAgLy8g5LiN5piv55u05o6l5L2/55SoIGFyYyDlkb3ku6RcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDEsIHkxLCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOesrOS4gOS4quWRveS7pOi1t+eCuei/mOacquWumuS5iVxuICAgICAgICAgICAgICAgICAgICAgICAgeDAgPSB4MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkwID0geTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8genIg5L2/55Soc2NhbGXmnaXmqKHmi5/mpK3lnIYsIOi/memHjOS5n+WvuXjlgZrkuIDlrprnmoTnvKnmlL5cbiAgICAgICAgICAgICAgICAgICAgdmFyIF94ID0gKHggLSBjeCkgKiByeSAvIHJ4ICsgY3g7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyYy5jb250YWluU3Ryb2tlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4LCBjeSwgcnksIHRoZXRhLCB0aGV0YSArIGRUaGV0YSwgYW50aWNsb2Nrd2lzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGgsIF94LCB5XG4gICAgICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdBcmMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3gsIGN5LCByeSwgdGhldGEsIHRoZXRhICsgZFRoZXRhLCBhbnRpY2xvY2t3aXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF94LCB5XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHhpID0gTWF0aC5jb3ModGhldGEgKyBkVGhldGEpICogcnggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSBNYXRoLnNpbih0aGV0YSArIGRUaGV0YSkgKiByeSArIGN5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENNRC5SOlxuICAgICAgICAgICAgICAgICAgICB4MCA9IHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB5MCA9IHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciB4MSA9IHgwICsgd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5MSA9IHkwICsgaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250YWluU3Ryb2tlKHgwLCB5MCwgeDEsIHkwLCBsaW5lV2lkdGgsIHgsIHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGNvbnRhaW5TdHJva2UoeDEsIHkwLCB4MSwgeTEsIGxpbmVXaWR0aCwgeCwgeSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgY29udGFpblN0cm9rZSh4MSwgeTEsIHgwLCB5MSwgbGluZVdpZHRoLCB4LCB5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBjb250YWluU3Ryb2tlKHgwLCB5MSwgeDAsIHkwLCBsaW5lV2lkdGgsIHgsIHkpXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIENsb2Nrd2lzZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHgxLCB5MCwgeDEsIHkxLCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeDAsIHkxLCB4MCwgeTAsIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELlo6XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5TdHJva2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGksIHlpLCB4MCwgeTAsIGxpbmVXaWR0aCwgeCwgeVxuICAgICAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xvc2UgYSBzdWJwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDAsIHkwLCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOiiq+S7u+S9leS4gOS4qiBzdWJwYXRoIOWMheWQq1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgc3VicGF0aHMgbWF5IG92ZXJsYXBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmICh3ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1N0cm9rZSAmJiAhaXNBcm91bmRFcXVhbCh5aSwgeTApKSB7XG4gICAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDAsIHkwLCB4LCB5KSB8fCAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3ICE9PSAwO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRhaW46IGZ1bmN0aW9uIChwYXRoRGF0YSwgeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5QYXRoKHBhdGhEYXRhLCAwLCBmYWxzZSwgeCwgeSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29udGFpblN0cm9rZTogZnVuY3Rpb24gKHBhdGhEYXRhLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250YWluUGF0aChwYXRoRGF0YSwgbGluZVdpZHRoLCB0cnVlLCB4LCB5KTtcbiAgICAgICAgfVxuICAgIH07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL3pyZW5kZXIvY29udGFpbi9wYXRoLmpzXG4gKiogbW9kdWxlIGlkID0gNTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsImRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOe6v+auteWMheWQq+WIpOaWrVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4MFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5MFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4MVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5MVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICBsaW5lV2lkdGhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5XG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluU3Ryb2tlOiBmdW5jdGlvbiAoeDAsIHkwLCB4MSwgeTEsIGxpbmVXaWR0aCwgeCwgeSkge1xuICAgICAgICAgICAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfbCA9IGxpbmVXaWR0aDtcbiAgICAgICAgICAgIHZhciBfYSA9IDA7XG4gICAgICAgICAgICB2YXIgX2IgPSB4MDtcbiAgICAgICAgICAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICh5ID4geTAgKyBfbCAmJiB5ID4geTEgKyBfbClcbiAgICAgICAgICAgICAgICB8fCAoeSA8IHkwIC0gX2wgJiYgeSA8IHkxIC0gX2wpXG4gICAgICAgICAgICAgICAgfHwgKHggPiB4MCArIF9sICYmIHggPiB4MSArIF9sKVxuICAgICAgICAgICAgICAgIHx8ICh4IDwgeDAgLSBfbCAmJiB4IDwgeDEgLSBfbClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHgwICE9PSB4MSkge1xuICAgICAgICAgICAgICAgIF9hID0gKHkwIC0geTEpIC8gKHgwIC0geDEpO1xuICAgICAgICAgICAgICAgIF9iID0gKHgwICogeTEgLSB4MSAqIHkwKSAvICh4MCAtIHgxKSA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMoeCAtIHgwKSA8PSBfbCAvIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdG1wID0gX2EgKiB4IC0geSArIF9iO1xuICAgICAgICAgICAgdmFyIF9zID0gdG1wICogdG1wIC8gKF9hICogX2EgKyAxKTtcbiAgICAgICAgICAgIHJldHVybiBfcyA8PSBfbCAvIDIgKiBfbCAvIDI7XG4gICAgICAgIH1cbiAgICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC96cmVuZGVyL2NvbnRhaW4vbGluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDU3XG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCJkZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuICAgIHZhciBjdXJ2ZSA9IHJlcXVpcmUoJy4uL2NvcmUvY3VydmUnKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDkuInmrKHotJ3loZ7lsJTmm7Lnur/mj4/ovrnljIXlkKvliKTmlq1cbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDBcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTBcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDNcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTNcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgbGluZVdpZHRoXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeVxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpblN0cm9rZTogZnVuY3Rpb24oeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgICAgICAgICAgIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2wgPSBsaW5lV2lkdGg7XG4gICAgICAgICAgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoeSA+IHkwICsgX2wgJiYgeSA+IHkxICsgX2wgJiYgeSA+IHkyICsgX2wgJiYgeSA+IHkzICsgX2wpXG4gICAgICAgICAgICAgICAgfHwgKHkgPCB5MCAtIF9sICYmIHkgPCB5MSAtIF9sICYmIHkgPCB5MiAtIF9sICYmIHkgPCB5MyAtIF9sKVxuICAgICAgICAgICAgICAgIHx8ICh4ID4geDAgKyBfbCAmJiB4ID4geDEgKyBfbCAmJiB4ID4geDIgKyBfbCAmJiB4ID4geDMgKyBfbClcbiAgICAgICAgICAgICAgICB8fCAoeCA8IHgwIC0gX2wgJiYgeCA8IHgxIC0gX2wgJiYgeCA8IHgyIC0gX2wgJiYgeCA8IHgzIC0gX2wpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZCA9IGN1cnZlLmN1YmljUHJvamVjdFBvaW50KFxuICAgICAgICAgICAgICAgIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MyxcbiAgICAgICAgICAgICAgICB4LCB5LCBudWxsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGQgPD0gX2wgLyAyO1xuICAgICAgICB9XG4gICAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvenJlbmRlci9jb250YWluL2N1YmljLmpzXG4gKiogbW9kdWxlIGlkID0gNThcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsImRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG4gICAgdmFyIGN1cnZlID0gcmVxdWlyZSgnLi4vY29yZS9jdXJ2ZScpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOS6jOasoei0neWhnuWwlOabsue6v+aPj+i+ueWMheWQq+WIpOaWrVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4MFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5MFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4MVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5MVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4MlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5MlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICBsaW5lV2lkdGhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5XG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluU3Ryb2tlOiBmdW5jdGlvbiAoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgbGluZVdpZHRoLCB4LCB5KSB7XG4gICAgICAgICAgICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9sID0gbGluZVdpZHRoO1xuICAgICAgICAgICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKHkgPiB5MCArIF9sICYmIHkgPiB5MSArIF9sICYmIHkgPiB5MiArIF9sKVxuICAgICAgICAgICAgICAgIHx8ICh5IDwgeTAgLSBfbCAmJiB5IDwgeTEgLSBfbCAmJiB5IDwgeTIgLSBfbClcbiAgICAgICAgICAgICAgICB8fCAoeCA+IHgwICsgX2wgJiYgeCA+IHgxICsgX2wgJiYgeCA+IHgyICsgX2wpXG4gICAgICAgICAgICAgICAgfHwgKHggPCB4MCAtIF9sICYmIHggPCB4MSAtIF9sICYmIHggPCB4MiAtIF9sKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGQgPSBjdXJ2ZS5xdWFkcmF0aWNQcm9qZWN0UG9pbnQoXG4gICAgICAgICAgICAgICAgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MixcbiAgICAgICAgICAgICAgICB4LCB5LCBudWxsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGQgPD0gX2wgLyAyO1xuICAgICAgICB9XG4gICAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvenJlbmRlci9jb250YWluL3F1YWRyYXRpYy5qc1xuICoqIG1vZHVsZSBpZCA9IDU5XG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCJkZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuICAgIHZhciBub3JtYWxpemVSYWRpYW4gPSByZXF1aXJlKCcuL3V0aWwnKS5ub3JtYWxpemVSYWRpYW47XG4gICAgdmFyIFBJMiA9IE1hdGguUEkgKiAyO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWchuW8p+aPj+i+ueWMheWQq+WIpOaWrVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICBjeFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICBjeVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICByXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHN0YXJ0QW5nbGVcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgZW5kQW5nbGVcbiAgICAgICAgICogQHBhcmFtICB7Ym9vbGVhbn0gIGFudGljbG9ja3dpc2VcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBsaW5lV2lkdGhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5XG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluU3Ryb2tlOiBmdW5jdGlvbiAoXG4gICAgICAgICAgICBjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlLFxuICAgICAgICAgICAgbGluZVdpZHRoLCB4LCB5XG4gICAgICAgICkge1xuXG4gICAgICAgICAgICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9sID0gbGluZVdpZHRoO1xuXG4gICAgICAgICAgICB4IC09IGN4O1xuICAgICAgICAgICAgeSAtPSBjeTtcbiAgICAgICAgICAgIHZhciBkID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXG4gICAgICAgICAgICBpZiAoKGQgLSBfbCA+IHIpIHx8IChkICsgX2wgPCByKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhzdGFydEFuZ2xlIC0gZW5kQW5nbGUpICUgUEkyIDwgMWUtNCkge1xuICAgICAgICAgICAgICAgIC8vIElzIGEgY2lyY2xlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYW50aWNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgICAgIHZhciB0bXAgPSBzdGFydEFuZ2xlO1xuICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICAgICAgICAgICAgICAgIGVuZEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKHRtcCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oc3RhcnRBbmdsZSk7XG4gICAgICAgICAgICAgICAgZW5kQW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXJ0QW5nbGUgPiBlbmRBbmdsZSkge1xuICAgICAgICAgICAgICAgIGVuZEFuZ2xlICs9IFBJMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMih5LCB4KTtcbiAgICAgICAgICAgIGlmIChhbmdsZSA8IDApIHtcbiAgICAgICAgICAgICAgICBhbmdsZSArPSBQSTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKGFuZ2xlID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgPD0gZW5kQW5nbGUpXG4gICAgICAgICAgICAgICAgfHwgKGFuZ2xlICsgUEkyID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgKyBQSTIgPD0gZW5kQW5nbGUpO1xuICAgICAgICB9XG4gICAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvenJlbmRlci9jb250YWluL2FyYy5qc1xuICoqIG1vZHVsZSBpZCA9IDYwXG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCJkZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuICAgIHZhciBQSTIgPSBNYXRoLlBJICogMjtcbiAgICByZXR1cm4ge1xuICAgICAgICBub3JtYWxpemVSYWRpYW46IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgICAgICAgICBhbmdsZSAlPSBQSTI7XG4gICAgICAgICAgICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICAgICAgICAgICAgYW5nbGUgKz0gUEkyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFuZ2xlO1xuICAgICAgICB9XG4gICAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvenJlbmRlci9jb250YWluL3V0aWwuanNcbiAqKiBtb2R1bGUgaWQgPSA2MVxuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gd2luZGluZ0xpbmUoeDAsIHkwLCB4MSwgeTEsIHgsIHkpIHtcbiAgICAgICAgaWYgKCh5ID4geTAgJiYgeSA+IHkxKSB8fCAoeSA8IHkwICYmIHkgPCB5MSkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIElnbm9yZSBob3Jpem9udGFsIGxpbmVcbiAgICAgICAgaWYgKHkxID09PSB5MCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpciA9IHkxIDwgeTAgPyAxIDogLTE7XG4gICAgICAgIHZhciB0ID0gKHkgLSB5MCkgLyAoeTEgLSB5MCk7XG5cbiAgICAgICAgLy8gQXZvaWQgd2luZGluZyBlcnJvciB3aGVuIGludGVyc2VjdGlvbiBwb2ludCBpcyB0aGUgY29ubmVjdCBwb2ludCBvZiB0d28gbGluZSBvZiBwb2x5Z29uXG4gICAgICAgIGlmICh0ID09PSAxIHx8IHQgPT09IDApIHtcbiAgICAgICAgICAgIGRpciA9IHkxIDwgeTAgPyAwLjUgOiAtMC41O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHhfID0gdCAqICh4MSAtIHgwKSArIHgwO1xuXG4gICAgICAgIHJldHVybiB4XyA+IHggPyBkaXIgOiAwO1xuICAgIH07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL3pyZW5kZXIvY29udGFpbi93aW5kaW5nTGluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDYyXG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCJkZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuICAgIHZhciBQYXR0ZXJuID0gZnVuY3Rpb24gKGltYWdlLCByZXBlYXQpIHtcbiAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICAgICAgICB0aGlzLnJlcGVhdCA9IHJlcGVhdDtcblxuICAgICAgICAvLyBDYW4gYmUgY2xvbmVkXG4gICAgICAgIHRoaXMudHlwZSA9ICdwYXR0ZXJuJztcbiAgICB9O1xuXG4gICAgUGF0dGVybi5wcm90b3R5cGUuZ2V0Q2FudmFzUGF0dGVybiA9IGZ1bmN0aW9uIChjdHgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fY2FudmFzUGF0dGVyblxuICAgICAgICAgICAgfHwgKHRoaXMuX2NhbnZhc1BhdHRlcm4gPSBjdHguY3JlYXRlUGF0dGVybih0aGlzLmltYWdlLCB0aGlzLnJlcGVhdCkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gUGF0dGVybjtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvenJlbmRlci9ncmFwaGljL1BhdHRlcm4uanNcbiAqKiBtb2R1bGUgaWQgPSA2M1xuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cbiAgICB2YXIgQ01EID0gcmVxdWlyZSgnLi4vY29yZS9QYXRoUHJveHknKS5DTUQ7XG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuLi9jb3JlL3ZlY3RvcicpO1xuICAgIHZhciB2MkFwcGx5VHJhbnNmb3JtID0gdmVjMi5hcHBseVRyYW5zZm9ybTtcblxuICAgIHZhciBwb2ludHMgPSBbW10sIFtdLCBbXV07XG4gICAgdmFyIG1hdGhTcXJ0ID0gTWF0aC5zcXJ0O1xuICAgIHZhciBtYXRoQXRhbjIgPSBNYXRoLmF0YW4yO1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybVBhdGgocGF0aCwgbSkge1xuICAgICAgICB2YXIgZGF0YSA9IHBhdGguZGF0YTtcbiAgICAgICAgdmFyIGNtZDtcbiAgICAgICAgdmFyIG5Qb2ludDtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBqO1xuICAgICAgICB2YXIgaztcbiAgICAgICAgdmFyIHA7XG5cbiAgICAgICAgdmFyIE0gPSBDTUQuTTtcbiAgICAgICAgdmFyIEMgPSBDTUQuQztcbiAgICAgICAgdmFyIEwgPSBDTUQuTDtcbiAgICAgICAgdmFyIFIgPSBDTUQuUjtcbiAgICAgICAgdmFyIEEgPSBDTUQuQTtcbiAgICAgICAgdmFyIFEgPSBDTUQuUTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGRhdGEubGVuZ3RoOykge1xuICAgICAgICAgICAgY21kID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgaiA9IGk7XG4gICAgICAgICAgICBuUG9pbnQgPSAwO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgTTpcbiAgICAgICAgICAgICAgICAgICAgblBvaW50ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBMOlxuICAgICAgICAgICAgICAgICAgICBuUG9pbnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEM6XG4gICAgICAgICAgICAgICAgICAgIG5Qb2ludCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUTpcbiAgICAgICAgICAgICAgICAgICAgblBvaW50ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBBOlxuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IG1bNF07XG4gICAgICAgICAgICAgICAgICAgIHZhciB5ID0gbVs1XTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN4ID0gbWF0aFNxcnQobVswXSAqIG1bMF0gKyBtWzFdICogbVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzeSA9IG1hdGhTcXJ0KG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM10pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW5nbGUgPSBtYXRoQXRhbjIoLW1bMV0gLyBzeSwgbVswXSAvIHN4KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY3hcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdICs9IHg7XG4gICAgICAgICAgICAgICAgICAgIC8vIGN5XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSArPSB5O1xuICAgICAgICAgICAgICAgICAgICAvLyBTY2FsZSByeCBhbmQgcnlcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgQXNzdW1lIHBzaSBpcyAwIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdICo9IHN4O1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2krK10gKj0gc3k7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgYW5nbGVcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdICs9IGFuZ2xlO1xuICAgICAgICAgICAgICAgICAgICAvLyBlbmQgYW5nbGVcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdICs9IGFuZ2xlO1xuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBwc2lcbiAgICAgICAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgICAgICAgICBqID0gaTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBSOlxuICAgICAgICAgICAgICAgICAgICAvLyB4MCwgeTBcbiAgICAgICAgICAgICAgICAgICAgcFswXSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgcFsxXSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdjJBcHBseVRyYW5zZm9ybShwLCBwLCBtKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtqKytdID0gcFswXTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtqKytdID0gcFsxXTtcbiAgICAgICAgICAgICAgICAgICAgLy8geDEsIHkxXG4gICAgICAgICAgICAgICAgICAgIHBbMF0gKz0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICBwWzFdICs9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdjJBcHBseVRyYW5zZm9ybShwLCBwLCBtKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtqKytdID0gcFswXTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtqKytdID0gcFsxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IG5Qb2ludDsgaysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBwb2ludHNba107XG4gICAgICAgICAgICAgICAgcFswXSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICBwWzFdID0gZGF0YVtpKytdO1xuXG4gICAgICAgICAgICAgICAgdjJBcHBseVRyYW5zZm9ybShwLCBwLCBtKTtcbiAgICAgICAgICAgICAgICAvLyBXcml0ZSBiYWNrXG4gICAgICAgICAgICAgICAgZGF0YVtqKytdID0gcFswXTtcbiAgICAgICAgICAgICAgICBkYXRhW2orK10gPSBwWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRyYW5zZm9ybVBhdGg7XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL3pyZW5kZXIvdG9vbC90cmFuc2Zvcm1QYXRoLmpzXG4gKiogbW9kdWxlIGlkID0gNjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsImRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gY29sb3JTdG9wc1xuICAgICAqL1xuICAgIHZhciBHcmFkaWVudCA9IGZ1bmN0aW9uIChjb2xvclN0b3BzKSB7XG5cbiAgICAgICAgdGhpcy5jb2xvclN0b3BzID0gY29sb3JTdG9wcyB8fCBbXTtcbiAgICB9O1xuXG4gICAgR3JhZGllbnQucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBHcmFkaWVudCxcblxuICAgICAgICBhZGRDb2xvclN0b3A6IGZ1bmN0aW9uIChvZmZzZXQsIGNvbG9yKSB7XG4gICAgICAgICAgICB0aGlzLmNvbG9yU3RvcHMucHVzaCh7XG5cbiAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcblxuICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIEdyYWRpZW50O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC96cmVuZGVyL2dyYXBoaWMvR3JhZGllbnQuanNcbiAqKiBtb2R1bGUgaWQgPSA2NVxuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiLyoqXG4gKiBJbWFnZSBlbGVtZW50XG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9JbWFnZVxuICovXG5cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG4gICAgdmFyIERpc3BsYXlhYmxlID0gcmVxdWlyZSgnLi9EaXNwbGF5YWJsZScpO1xuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCcuLi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcblxuICAgIHZhciBMUlUgPSByZXF1aXJlKCcuLi9jb3JlL0xSVScpO1xuICAgIHZhciBnbG9iYWxJbWFnZUNhY2hlID0gbmV3IExSVSg1MCk7XG4gICAgLyoqXG4gICAgICogQGFsaWFzIHpyZW5kZXIvZ3JhcGhpYy9JbWFnZVxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFpJbWFnZShvcHRzKSB7XG4gICAgICAgIERpc3BsYXlhYmxlLmNhbGwodGhpcywgb3B0cyk7XG4gICAgfVxuXG4gICAgWkltYWdlLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogWkltYWdlLFxuXG4gICAgICAgIHR5cGU6ICdpbWFnZScsXG5cbiAgICAgICAgYnJ1c2g6IGZ1bmN0aW9uIChjdHgsIHByZXZFbCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgIHZhciBzcmMgPSBzdHlsZS5pbWFnZTtcbiAgICAgICAgICAgIHZhciBpbWFnZTtcblxuICAgICAgICAgICAgLy8gTXVzdCBiaW5kIGVhY2ggdGltZVxuICAgICAgICAgICAgc3R5bGUuYmluZChjdHgsIHRoaXMsIHByZXZFbCk7XG4gICAgICAgICAgICAvLyBzdHlsZS5pbWFnZSBpcyBhIHVybCBzdHJpbmdcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3JjID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGltYWdlID0gdGhpcy5faW1hZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzdHlsZS5pbWFnZSBpcyBhbiBIVE1MSW1hZ2VFbGVtZW50IG9yIEhUTUxDYW52YXNFbGVtZW50IG9yIENhbnZhc1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW1hZ2UgPSBzcmM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGSVhNRSBDYXNlIGNyZWF0ZSBtYW55IGltYWdlcyB3aXRoIHNyY1xuICAgICAgICAgICAgaWYgKCFpbWFnZSAmJiBzcmMpIHtcbiAgICAgICAgICAgICAgICAvLyBUcnkgZ2V0IGZyb20gZ2xvYmFsIGltYWdlIGNhY2hlXG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlZEltZ09iaiA9IGdsb2JhbEltYWdlQ2FjaGUuZ2V0KHNyYyk7XG4gICAgICAgICAgICAgICAgaWYgKCFjYWNoZWRJbWdPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGltYWdlXG4gICAgICAgICAgICAgICAgICAgIGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLm9ubG9hZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhY2hlZEltZ09iai5wZW5kaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkSW1nT2JqLnBlbmRpbmdbaV0uZGlydHkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkSW1nT2JqID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IGltYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZzogW3RoaXNdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGltYWdlLnNyYyA9IHNyYztcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsSW1hZ2VDYWNoZS5wdXQoc3JjLCBjYWNoZWRJbWdPYmopO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbWFnZSA9IGltYWdlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZSA9IGNhY2hlZEltZ09iai5pbWFnZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW1hZ2UgaXMgbm90IGNvbXBsZXRlIGZpbmlzaCwgYWRkIHRvIHBlbmRpbmcgbGlzdFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWltYWdlLndpZHRoIHx8ICFpbWFnZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZEltZ09iai5wZW5kaW5nLnB1c2godGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbWFnZSkge1xuICAgICAgICAgICAgICAgIC8vIOWbvueJh+W3sue7j+WKoOi9veWujOaIkFxuICAgICAgICAgICAgICAgIC8vIGlmIChpbWFnZS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09ICdJTUcnKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgIGlmICghaW1hZ2UuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAvLyBFbHNlIGlzIGNhbnZhc1xuXG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gc3R5bGUud2lkdGggfHwgaW1hZ2Uud2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IHN0eWxlLmhlaWdodCB8fCBpbWFnZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgdmFyIHggPSBzdHlsZS54IHx8IDA7XG4gICAgICAgICAgICAgICAgdmFyIHkgPSBzdHlsZS55IHx8IDA7XG4gICAgICAgICAgICAgICAgLy8g5Zu+54mH5Yqg6L295aSx6LSlXG4gICAgICAgICAgICAgICAgaWYgKCFpbWFnZS53aWR0aCB8fCAhaW1hZ2UuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyDorr7nva50cmFuc2Zvcm1cbiAgICAgICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybShjdHgpO1xuXG5cbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUuc1dpZHRoICYmIHN0eWxlLnNIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN4ID0gc3R5bGUuc3ggfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5ID0gc3R5bGUuc3kgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3gsIHN5LCBzdHlsZS5zV2lkdGgsIHN0eWxlLnNIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB4LCB5LCB3aWR0aCwgaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0eWxlLnN4ICYmIHN0eWxlLnN5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzeCA9IHN0eWxlLnN4O1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3kgPSBzdHlsZS5zeTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNXaWR0aCA9IHdpZHRoIC0gc3g7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzSGVpZ2h0ID0gaGVpZ2h0IC0gc3k7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN4LCBzeSwgc1dpZHRoLCBzSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeCwgeSwgd2lkdGgsIGhlaWdodFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8g5aaC5p6c5rKh6K6+572u5a695ZKM6auY55qE6K+d6Ieq5Yqo5qC55o2u5Zu+54mH5a696auY6K6+572uXG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLndpZHRoID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLmhlaWdodCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJlc3RvcmVUcmFuc2Zvcm0oY3R4KTtcblxuICAgICAgICAgICAgICAgIC8vIERyYXcgcmVjdCB0ZXh0XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLnRleHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdSZWN0VGV4dChjdHgsIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgIGlmICghIHRoaXMuX3JlY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWN0ID0gbmV3IEJvdW5kaW5nUmVjdChcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUueCB8fCAwLCBzdHlsZS55IHx8IDAsIHN0eWxlLndpZHRoIHx8IDAsIHN0eWxlLmhlaWdodCB8fCAwXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWN0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHpyVXRpbC5pbmhlcml0cyhaSW1hZ2UsIERpc3BsYXlhYmxlKTtcblxuICAgIHJldHVybiBaSW1hZ2U7XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL3pyZW5kZXIvZ3JhcGhpYy9JbWFnZS5qc1xuICoqIG1vZHVsZSBpZCA9IDY2XG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCIvLyBTaW1wbGUgTFJVIGNhY2hlIHVzZSBkb3VibHkgbGlua2VkIGxpc3Rcbi8vIEBtb2R1bGUgenJlbmRlci9jb3JlL0xSVVxuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUpIHtcblxuICAgIC8qKlxuICAgICAqIFNpbXBsZSBkb3VibGUgbGlua2VkIGxpc3QuIENvbXBhcmVkIHdpdGggYXJyYXksIGl0IGhhcyBPKDEpIHJlbW92ZSBvcGVyYXRpb24uXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIExpbmtlZExpc3QgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oZWFkID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50YWlsID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9sZW4gPSAwO1xuICAgIH07XG5cbiAgICB2YXIgbGlua2VkTGlzdFByb3RvID0gTGlua2VkTGlzdC5wcm90b3R5cGU7XG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGEgbmV3IHZhbHVlIGF0IHRoZSB0YWlsXG4gICAgICogQHBhcmFtICB7fSB2YWxcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAgICAgKi9cbiAgICBsaW5rZWRMaXN0UHJvdG8uaW5zZXJ0ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IG5ldyBFbnRyeSh2YWwpO1xuICAgICAgICB0aGlzLmluc2VydEVudHJ5KGVudHJ5KTtcbiAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnQgYW4gZW50cnkgYXQgdGhlIHRhaWxcbiAgICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX0gZW50cnlcbiAgICAgKi9cbiAgICBsaW5rZWRMaXN0UHJvdG8uaW5zZXJ0RW50cnkgPSBmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICBpZiAoIXRoaXMuaGVhZCkge1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gZW50cnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O1xuICAgICAgICAgICAgZW50cnkucHJldiA9IHRoaXMudGFpbDtcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xlbisrO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgZW50cnkuXG4gICAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9IGVudHJ5XG4gICAgICovXG4gICAgbGlua2VkTGlzdFByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgIHZhciBwcmV2ID0gZW50cnkucHJldjtcbiAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uZXh0O1xuICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgcHJldi5uZXh0ID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElzIGhlYWRcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgIG5leHQucHJldiA9IHByZXY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJcyB0YWlsXG4gICAgICAgICAgICB0aGlzLnRhaWwgPSBwcmV2O1xuICAgICAgICB9XG4gICAgICAgIGVudHJ5Lm5leHQgPSBlbnRyeS5wcmV2ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGVuLS07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBsaW5rZWRMaXN0UHJvdG8ubGVuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZW47XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7fSB2YWxcbiAgICAgKi9cbiAgICB2YXIgRW50cnkgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHt9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5leHQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJldjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTFJVIENhY2hlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2NvcmUvTFJVXG4gICAgICovXG4gICAgdmFyIExSVSA9IGZ1bmN0aW9uKG1heFNpemUpIHtcblxuICAgICAgICB0aGlzLl9saXN0ID0gbmV3IExpbmtlZExpc3QoKTtcblxuICAgICAgICB0aGlzLl9tYXAgPSB7fTtcblxuICAgICAgICB0aGlzLl9tYXhTaXplID0gbWF4U2l6ZSB8fCAxMDtcbiAgICB9O1xuXG4gICAgdmFyIExSVVByb3RvID0gTFJVLnByb3RvdHlwZTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtICB7fSB2YWx1ZVxuICAgICAqL1xuICAgIExSVVByb3RvLnB1dCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLl9saXN0O1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuICAgICAgICBpZiAobWFwW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGxlbiA9IGxpc3QubGVuKCk7XG4gICAgICAgICAgICBpZiAobGVuID49IHRoaXMuX21heFNpemUgJiYgbGVuID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbGVhc3QgcmVjZW50bHkgdXNlZFxuICAgICAgICAgICAgICAgIHZhciBsZWFzdFVzZWRFbnRyeSA9IGxpc3QuaGVhZDtcbiAgICAgICAgICAgICAgICBsaXN0LnJlbW92ZShsZWFzdFVzZWRFbnRyeSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG1hcFtsZWFzdFVzZWRFbnRyeS5rZXldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZW50cnkgPSBsaXN0Lmluc2VydCh2YWx1ZSk7XG4gICAgICAgICAgICBlbnRyeS5rZXkgPSBrZXk7XG4gICAgICAgICAgICBtYXBba2V5XSA9IGVudHJ5O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30ga2V5XG4gICAgICogQHJldHVybiB7fVxuICAgICAqL1xuICAgIExSVVByb3RvLmdldCA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLl9tYXBba2V5XTtcbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLl9saXN0O1xuICAgICAgICBpZiAoZW50cnkgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gUHV0IHRoZSBsYXRlc3QgdXNlZCBlbnRyeSBpbiB0aGUgdGFpbFxuICAgICAgICAgICAgaWYgKGVudHJ5ICE9PSBsaXN0LnRhaWwpIHtcbiAgICAgICAgICAgICAgICBsaXN0LnJlbW92ZShlbnRyeSk7XG4gICAgICAgICAgICAgICAgbGlzdC5pbnNlcnRFbnRyeShlbnRyeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlbnRyeS52YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUgY2FjaGVcbiAgICAgKi9cbiAgICBMUlVQcm90by5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9saXN0LmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX21hcCA9IHt9O1xuICAgIH07XG5cbiAgICByZXR1cm4gTFJVO1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC96cmVuZGVyL2NvcmUvTFJVLmpzXG4gKiogbW9kdWxlIGlkID0gNjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsIi8qKlxuICogVGV4dCBlbGVtZW50XG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9UZXh0XG4gKlxuICogVE9ETyBXcmFwcGluZ1xuICpcbiAqIFRleHQgbm90IHN1cHBvcnQgZ3JhZGllbnRcbiAqL1xuXG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuICAgIHZhciBEaXNwbGF5YWJsZSA9IHJlcXVpcmUoJy4vRGlzcGxheWFibGUnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG4gICAgdmFyIHRleHRDb250YWluID0gcmVxdWlyZSgnLi4vY29udGFpbi90ZXh0Jyk7XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgenJlbmRlci9ncmFwaGljL1RleHRcbiAgICAgKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKi9cbiAgICB2YXIgVGV4dCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgIERpc3BsYXlhYmxlLmNhbGwodGhpcywgb3B0cyk7XG4gICAgfTtcblxuICAgIFRleHQucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBUZXh0LFxuXG4gICAgICAgIHR5cGU6ICd0ZXh0JyxcblxuICAgICAgICBicnVzaDogZnVuY3Rpb24gKGN0eCwgcHJldkVsKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgICAgICAgICAgdmFyIHggPSBzdHlsZS54IHx8IDA7XG4gICAgICAgICAgICB2YXIgeSA9IHN0eWxlLnkgfHwgMDtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gc3RyaW5nXG4gICAgICAgICAgICB2YXIgdGV4dCA9IHN0eWxlLnRleHQ7XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gc3RyaW5nXG4gICAgICAgICAgICB0ZXh0ICE9IG51bGwgJiYgKHRleHQgKz0gJycpO1xuXG4gICAgICAgICAgICAvLyBBbHdheXMgYmluZCBzdHlsZVxuICAgICAgICAgICAgc3R5bGUuYmluZChjdHgsIHRoaXMsIHByZXZFbCk7XG5cbiAgICAgICAgICAgIGlmICh0ZXh0KSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybShjdHgpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHRleHRCYXNlbGluZTtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dEFsaWduID0gc3R5bGUudGV4dEFsaWduO1xuICAgICAgICAgICAgICAgIHZhciBmb250ID0gc3R5bGUudGV4dEZvbnQgfHwgc3R5bGUuZm9udDtcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUudGV4dFZlcnRpY2FsQWxpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QoXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LCBmb250LCBzdHlsZS50ZXh0QWxpZ24sICd0b3AnXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSB0ZXh0QmFzZWxpbmVcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3R5bGUudGV4dFZlcnRpY2FsQWxpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSAtPSByZWN0LmhlaWdodCAvIDIgLSByZWN0LmxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5IC09IHJlY3QuaGVpZ2h0IC0gcmVjdC5saW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSArPSByZWN0LmxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmUgPSBzdHlsZS50ZXh0QmFzZWxpbmU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBJbnZhbGlkIGZvbnRcbiAgICAgICAgICAgICAgICBjdHguZm9udCA9IGZvbnQgfHwgJzEycHggc2Fucy1zZXJpZic7XG4gICAgICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IHRleHRBbGlnbiB8fCAnbGVmdCc7XG4gICAgICAgICAgICAgICAgLy8gVXNlIGNhbnZhcyBkZWZhdWx0IGxlZnQgdGV4dEFsaWduLiBHaXZpbmcgaW52YWxpZCB2YWx1ZSB3aWxsIGNhdXNlIHN0YXRlIG5vdCBjaGFuZ2VcbiAgICAgICAgICAgICAgICBpZiAoY3R4LnRleHRBbGlnbiAhPT0gdGV4dEFsaWduKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSB0ZXh0QmFzZWxpbmUgfHwgJ2FscGhhYmV0aWMnO1xuICAgICAgICAgICAgICAgIC8vIFVzZSBjYW52YXMgZGVmYXVsdCBhbHBoYWJldGljIGJhc2VsaW5lXG4gICAgICAgICAgICAgICAgaWYgKGN0eC50ZXh0QmFzZWxpbmUgIT09IHRleHRCYXNlbGluZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ2FscGhhYmV0aWMnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBsaW5lSGVpZ2h0ID0gdGV4dENvbnRhaW4ubWVhc3VyZVRleHQoJ+WbvScsIGN0eC5mb250KS53aWR0aDtcblxuICAgICAgICAgICAgICAgIHZhciB0ZXh0TGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS5oYXNGaWxsKCkgJiYgY3R4LmZpbGxUZXh0KHRleHRMaW5lc1tpXSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLmhhc1N0cm9rZSgpICYmIGN0eC5zdHJva2VUZXh0KHRleHRMaW5lc1tpXSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJlc3RvcmVUcmFuc2Zvcm0oY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcmVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICAgICAgdmFyIHRleHRWZXJ0aWNhbEFsaWduID0gc3R5bGUudGV4dFZlcnRpY2FsQWxpZ247XG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QoXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLnRleHQgKyAnJywgc3R5bGUudGV4dEZvbnQgfHwgc3R5bGUuZm9udCwgc3R5bGUudGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbiA/ICd0b3AnIDogc3R5bGUudGV4dEJhc2VsaW5lXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRleHRWZXJ0aWNhbEFsaWduKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0LnkgLT0gcmVjdC5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0LnkgLT0gcmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVjdC54ICs9IHN0eWxlLnggfHwgMDtcbiAgICAgICAgICAgICAgICByZWN0LnkgKz0gc3R5bGUueSB8fCAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlY3QgPSByZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlY3Q7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgenJVdGlsLmluaGVyaXRzKFRleHQsIERpc3BsYXlhYmxlKTtcblxuICAgIHJldHVybiBUZXh0O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC96cmVuZGVyL2dyYXBoaWMvVGV4dC5qc1xuICoqIG1vZHVsZSBpZCA9IDY4XG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCIvKipcbiAqIOWchuW9olxuICogQG1vZHVsZSB6cmVuZGVyL3NoYXBlL0NpcmNsZVxuICovXG5cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHJldHVybiByZXF1aXJlKCcuLi9QYXRoJykuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnY2lyY2xlJyxcblxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgY3g6IDAsXG4gICAgICAgICAgICBjeTogMCxcbiAgICAgICAgICAgIHI6IDBcbiAgICAgICAgfSxcblxuXG4gICAgICAgIGJ1aWxkUGF0aCA6IGZ1bmN0aW9uIChjdHgsIHNoYXBlLCBpbkJ1bmRsZSkge1xuICAgICAgICAgICAgLy8gQmV0dGVyIHN0cm9raW5nIGluIFNoYXBlQnVuZGxlXG4gICAgICAgICAgICAvLyBBbHdheXMgZG8gaXQgbWF5IGhhdmUgcGVyZm9ybWVuY2UgaXNzdWUgKCBmaWxsIG1heSBiZSAyeCBtb3JlIGNvc3QpXG4gICAgICAgICAgICBpZiAoaW5CdW5kbGUpIHtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHNoYXBlLmN4ICsgc2hhcGUuciwgc2hhcGUuY3kpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQmV0dGVyIHN0cm9raW5nIGluIFNoYXBlQnVuZGxlXG4gICAgICAgICAgICAvLyBjdHgubW92ZVRvKHNoYXBlLmN4ICsgc2hhcGUuciwgc2hhcGUuY3kpO1xuICAgICAgICAgICAgY3R4LmFyYyhzaGFwZS5jeCwgc2hhcGUuY3ksIHNoYXBlLnIsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL3pyZW5kZXIvZ3JhcGhpYy9zaGFwZS9DaXJjbGUuanNcbiAqKiBtb2R1bGUgaWQgPSA2OVxuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiLyoqXG4gKiDmiYflvaJcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL1NlY3RvclxuICovXG5cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG4gICAgcmV0dXJuIHJlcXVpcmUoJy4uL1BhdGgnKS5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdzZWN0b3InLFxuXG4gICAgICAgIHNoYXBlOiB7XG5cbiAgICAgICAgICAgIGN4OiAwLFxuXG4gICAgICAgICAgICBjeTogMCxcblxuICAgICAgICAgICAgcjA6IDAsXG5cbiAgICAgICAgICAgIHI6IDAsXG5cbiAgICAgICAgICAgIHN0YXJ0QW5nbGU6IDAsXG5cbiAgICAgICAgICAgIGVuZEFuZ2xlOiBNYXRoLlBJICogMixcblxuICAgICAgICAgICAgY2xvY2t3aXNlOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuXG4gICAgICAgICAgICB2YXIgeCA9IHNoYXBlLmN4O1xuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS5jeTtcbiAgICAgICAgICAgIHZhciByMCA9IE1hdGgubWF4KHNoYXBlLnIwIHx8IDAsIDApO1xuICAgICAgICAgICAgdmFyIHIgPSBNYXRoLm1heChzaGFwZS5yLCAwKTtcbiAgICAgICAgICAgIHZhciBzdGFydEFuZ2xlID0gc2hhcGUuc3RhcnRBbmdsZTtcbiAgICAgICAgICAgIHZhciBlbmRBbmdsZSA9IHNoYXBlLmVuZEFuZ2xlO1xuICAgICAgICAgICAgdmFyIGNsb2Nrd2lzZSA9IHNoYXBlLmNsb2Nrd2lzZTtcblxuICAgICAgICAgICAgdmFyIHVuaXRYID0gTWF0aC5jb3Moc3RhcnRBbmdsZSk7XG4gICAgICAgICAgICB2YXIgdW5pdFkgPSBNYXRoLnNpbihzdGFydEFuZ2xlKTtcblxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh1bml0WCAqIHIwICsgeCwgdW5pdFkgKiByMCArIHkpO1xuXG4gICAgICAgICAgICBjdHgubGluZVRvKHVuaXRYICogciArIHgsIHVuaXRZICogciArIHkpO1xuXG4gICAgICAgICAgICBjdHguYXJjKHgsIHksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCAhY2xvY2t3aXNlKTtcblxuICAgICAgICAgICAgY3R4LmxpbmVUbyhcbiAgICAgICAgICAgICAgICBNYXRoLmNvcyhlbmRBbmdsZSkgKiByMCArIHgsXG4gICAgICAgICAgICAgICAgTWF0aC5zaW4oZW5kQW5nbGUpICogcjAgKyB5XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAocjAgIT09IDApIHtcbiAgICAgICAgICAgICAgICBjdHguYXJjKHgsIHksIHIwLCBlbmRBbmdsZSwgc3RhcnRBbmdsZSwgY2xvY2t3aXNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgfSk7XG59KTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvenJlbmRlci9ncmFwaGljL3NoYXBlL1NlY3Rvci5qc1xuICoqIG1vZHVsZSBpZCA9IDcwXG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCIvKipcbiAqIOWchueOr1xuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvUmluZ1xuICovXG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuICAgIHJldHVybiByZXF1aXJlKCcuLi9QYXRoJykuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAncmluZycsXG5cbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIGN4OiAwLFxuICAgICAgICAgICAgY3k6IDAsXG4gICAgICAgICAgICByOiAwLFxuICAgICAgICAgICAgcjA6IDBcbiAgICAgICAgfSxcblxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHNoYXBlLmN4O1xuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS5jeTtcbiAgICAgICAgICAgIHZhciBQSTIgPSBNYXRoLlBJICogMjtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCArIHNoYXBlLnIsIHkpO1xuICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCBzaGFwZS5yLCAwLCBQSTIsIGZhbHNlKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCArIHNoYXBlLnIwLCB5KTtcbiAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgc2hhcGUucjAsIDAsIFBJMiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn0pO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC96cmVuZGVyL2dyYXBoaWMvc2hhcGUvUmluZy5qc1xuICoqIG1vZHVsZSBpZCA9IDcxXG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCIvKipcbiAqIOWkmui+ueW9olxuICogQG1vZHVsZSB6cmVuZGVyL3NoYXBlL1BvbHlnb25cbiAqL1xuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cbiAgICB2YXIgcG9seUhlbHBlciA9IHJlcXVpcmUoJy4uL2hlbHBlci9wb2x5Jyk7XG5cbiAgICByZXR1cm4gcmVxdWlyZSgnLi4vUGF0aCcpLmV4dGVuZCh7XG4gICAgICAgIFxuICAgICAgICB0eXBlOiAncG9seWdvbicsXG5cbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIHBvaW50czogbnVsbCxcblxuICAgICAgICAgICAgc21vb3RoOiBmYWxzZSxcblxuICAgICAgICAgICAgc21vb3RoQ29uc3RyYWludDogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHBvbHlIZWxwZXIuYnVpbGRQYXRoKGN0eCwgc2hhcGUsIHRydWUpO1xuICAgICAgICB9XG4gICAgfSk7XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL3pyZW5kZXIvZ3JhcGhpYy9zaGFwZS9Qb2x5Z29uLmpzXG4gKiogbW9kdWxlIGlkID0gNzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsImRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG4gICAgdmFyIHNtb290aFNwbGluZSA9IHJlcXVpcmUoJy4vc21vb3RoU3BsaW5lJyk7XG4gICAgdmFyIHNtb290aEJlemllciA9IHJlcXVpcmUoJy4vc21vb3RoQmV6aWVyJyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlLCBjbG9zZVBhdGgpIHtcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSBzaGFwZS5wb2ludHM7XG4gICAgICAgICAgICB2YXIgc21vb3RoID0gc2hhcGUuc21vb3RoO1xuICAgICAgICAgICAgaWYgKHBvaW50cyAmJiBwb2ludHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc21vb3RoICYmIHNtb290aCAhPT0gJ3NwbGluZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xQb2ludHMgPSBzbW9vdGhCZXppZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMsIHNtb290aCwgY2xvc2VQYXRoLCBzaGFwZS5zbW9vdGhDb25zdHJhaW50XG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhwb2ludHNbMF1bMF0sIHBvaW50c1swXVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IChjbG9zZVBhdGggPyBsZW4gOiBsZW4gLSAxKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3AxID0gY29udHJvbFBvaW50c1tpICogMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3AyID0gY29udHJvbFBvaW50c1tpICogMiArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBwb2ludHNbKGkgKyAxKSAlIGxlbl07XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcDFbMF0sIGNwMVsxXSwgY3AyWzBdLCBjcDJbMV0sIHBbMF0sIHBbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzbW9vdGggPT09ICdzcGxpbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMgPSBzbW9vdGhTcGxpbmUocG9pbnRzLCBjbG9zZVBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhwb2ludHNbMF1bMF0sIHBvaW50c1swXVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhwb2ludHNbaV1bMF0sIHBvaW50c1tpXVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjbG9zZVBhdGggJiYgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvenJlbmRlci9ncmFwaGljL2hlbHBlci9wb2x5LmpzXG4gKiogbW9kdWxlIGlkID0gNzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsIi8qKlxuICogQ2F0bXVsbC1Sb20gc3BsaW5lIOaPkuWAvOaKmOe6v1xuICogQG1vZHVsZSB6cmVuZGVyL3NoYXBlL3V0aWwvc21vb3RoU3BsaW5lXG4gKiBAYXV0aG9yIHBpc3NhbmcgKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqICAgICAgICAgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdmVjdG9yJyk7XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnRlcnBvbGF0ZShwMCwgcDEsIHAyLCBwMywgdCwgdDIsIHQzKSB7XG4gICAgICAgIHZhciB2MCA9IChwMiAtIHAwKSAqIDAuNTtcbiAgICAgICAgdmFyIHYxID0gKHAzIC0gcDEpICogMC41O1xuICAgICAgICByZXR1cm4gKDIgKiAocDEgLSBwMikgKyB2MCArIHYxKSAqIHQzXG4gICAgICAgICAgICAgICAgKyAoLTMgKiAocDEgLSBwMikgLSAyICogdjAgLSB2MSkgKiB0MlxuICAgICAgICAgICAgICAgICsgdjAgKiB0ICsgcDE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL3NoYXBlL3V0aWwvc21vb3RoU3BsaW5lXG4gICAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIOe6v+autemhtueCueaVsOe7hFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMb29wXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwb2ludHMsIGlzTG9vcCkge1xuICAgICAgICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgdmFyIHJldCA9IFtdO1xuXG4gICAgICAgIHZhciBkaXN0YW5jZSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGRpc3RhbmNlICs9IHZlYzIuZGlzdGFuY2UocG9pbnRzW2kgLSAxXSwgcG9pbnRzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWdzID0gZGlzdGFuY2UgLyAyO1xuICAgICAgICBzZWdzID0gc2VncyA8IGxlbiA/IGxlbiA6IHNlZ3M7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnczsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gaSAvIChzZWdzIC0gMSkgKiAoaXNMb29wID8gbGVuIDogbGVuIC0gMSk7XG4gICAgICAgICAgICB2YXIgaWR4ID0gTWF0aC5mbG9vcihwb3MpO1xuXG4gICAgICAgICAgICB2YXIgdyA9IHBvcyAtIGlkeDtcblxuICAgICAgICAgICAgdmFyIHAwO1xuICAgICAgICAgICAgdmFyIHAxID0gcG9pbnRzW2lkeCAlIGxlbl07XG4gICAgICAgICAgICB2YXIgcDI7XG4gICAgICAgICAgICB2YXIgcDM7XG4gICAgICAgICAgICBpZiAoIWlzTG9vcCkge1xuICAgICAgICAgICAgICAgIHAwID0gcG9pbnRzW2lkeCA9PT0gMCA/IGlkeCA6IGlkeCAtIDFdO1xuICAgICAgICAgICAgICAgIHAyID0gcG9pbnRzW2lkeCA+IGxlbiAtIDIgPyBsZW4gLSAxIDogaWR4ICsgMV07XG4gICAgICAgICAgICAgICAgcDMgPSBwb2ludHNbaWR4ID4gbGVuIC0gMyA/IGxlbiAtIDEgOiBpZHggKyAyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHAwID0gcG9pbnRzWyhpZHggLSAxICsgbGVuKSAlIGxlbl07XG4gICAgICAgICAgICAgICAgcDIgPSBwb2ludHNbKGlkeCArIDEpICUgbGVuXTtcbiAgICAgICAgICAgICAgICBwMyA9IHBvaW50c1soaWR4ICsgMikgJSBsZW5dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdzIgPSB3ICogdztcbiAgICAgICAgICAgIHZhciB3MyA9IHcgKiB3MjtcblxuICAgICAgICAgICAgcmV0LnB1c2goW1xuICAgICAgICAgICAgICAgIGludGVycG9sYXRlKHAwWzBdLCBwMVswXSwgcDJbMF0sIHAzWzBdLCB3LCB3MiwgdzMpLFxuICAgICAgICAgICAgICAgIGludGVycG9sYXRlKHAwWzFdLCBwMVsxXSwgcDJbMV0sIHAzWzFdLCB3LCB3MiwgdzMpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG59KTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvenJlbmRlci9ncmFwaGljL2hlbHBlci9zbW9vdGhTcGxpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSA3NFxuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiLyoqXG4gKiDotJ3loZ7lsJTlubPmu5Hmm7Lnur9cbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS91dGlsL3Ntb290aEJlemllclxuICogQGF1dGhvciBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKiAgICAgICAgIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqICAgICAgICAgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdmVjdG9yJyk7XG4gICAgdmFyIHYyTWluID0gdmVjMi5taW47XG4gICAgdmFyIHYyTWF4ID0gdmVjMi5tYXg7XG4gICAgdmFyIHYyU2NhbGUgPSB2ZWMyLnNjYWxlO1xuICAgIHZhciB2MkRpc3RhbmNlID0gdmVjMi5kaXN0YW5jZTtcbiAgICB2YXIgdjJBZGQgPSB2ZWMyLmFkZDtcblxuICAgIC8qKlxuICAgICAqIOi0neWhnuWwlOW5s+a7keabsue6v1xuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9zaGFwZS91dGlsL3Ntb290aEJlemllclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyDnur/mrrXpobbngrnmlbDnu4RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc21vb3RoIOW5s+a7keetiee6pywgMC0xXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0xvb3BcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb25zdHJhaW50IOWwhuiuoeeul+WHuuadpeeahOaOp+WItueCuee6puadn+WcqOS4gOS4quWMheWbtOebkuWGhVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAg5q+U5aaCIFtbMCwgMF0sIFsxMDAsIDEwMF1dLCDov5nkuKrljIXlm7Tnm5LkvJrkuI5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIOaVtOS4quaKmOe6v+eahOWMheWbtOebkuWBmuS4gOS4quW5tumbhueUqOadpee6puadn+aOp+WItueCueOAglxuICAgICAqIEBwYXJhbSB7QXJyYXl9IOiuoeeul+WHuuadpeeahOaOp+WItueCueaVsOe7hFxuICAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbiAocG9pbnRzLCBzbW9vdGgsIGlzTG9vcCwgY29uc3RyYWludCkge1xuICAgICAgICB2YXIgY3BzID0gW107XG5cbiAgICAgICAgdmFyIHYgPSBbXTtcbiAgICAgICAgdmFyIHYxID0gW107XG4gICAgICAgIHZhciB2MiA9IFtdO1xuICAgICAgICB2YXIgcHJldlBvaW50O1xuICAgICAgICB2YXIgbmV4dFBvaW50O1xuXG4gICAgICAgIHZhciBtaW4sIG1heDtcbiAgICAgICAgaWYgKGNvbnN0cmFpbnQpIHtcbiAgICAgICAgICAgIG1pbiA9IFtJbmZpbml0eSwgSW5maW5pdHldO1xuICAgICAgICAgICAgbWF4ID0gWy1JbmZpbml0eSwgLUluZmluaXR5XTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2Mk1pbihtaW4sIG1pbiwgcG9pbnRzW2ldKTtcbiAgICAgICAgICAgICAgICB2Mk1heChtYXgsIG1heCwgcG9pbnRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIOS4juaMh+WumueahOWMheWbtOebkuWBmuW5tumbhlxuICAgICAgICAgICAgdjJNaW4obWluLCBtaW4sIGNvbnN0cmFpbnRbMF0pO1xuICAgICAgICAgICAgdjJNYXgobWF4LCBtYXgsIGNvbnN0cmFpbnRbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gcG9pbnRzW2ldO1xuXG4gICAgICAgICAgICBpZiAoaXNMb29wKSB7XG4gICAgICAgICAgICAgICAgcHJldlBvaW50ID0gcG9pbnRzW2kgPyBpIC0gMSA6IGxlbiAtIDFdO1xuICAgICAgICAgICAgICAgIG5leHRQb2ludCA9IHBvaW50c1soaSArIDEpICUgbGVuXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAwIHx8IGkgPT09IGxlbiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY3BzLnB1c2godmVjMi5jbG9uZShwb2ludHNbaV0pKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmV2UG9pbnQgPSBwb2ludHNbaSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBuZXh0UG9pbnQgPSBwb2ludHNbaSArIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmVjMi5zdWIodiwgbmV4dFBvaW50LCBwcmV2UG9pbnQpO1xuXG4gICAgICAgICAgICAvLyB1c2UgZGVncmVlIHRvIHNjYWxlIHRoZSBoYW5kbGUgbGVuZ3RoXG4gICAgICAgICAgICB2MlNjYWxlKHYsIHYsIHNtb290aCk7XG5cbiAgICAgICAgICAgIHZhciBkMCA9IHYyRGlzdGFuY2UocG9pbnQsIHByZXZQb2ludCk7XG4gICAgICAgICAgICB2YXIgZDEgPSB2MkRpc3RhbmNlKHBvaW50LCBuZXh0UG9pbnQpO1xuICAgICAgICAgICAgdmFyIHN1bSA9IGQwICsgZDE7XG4gICAgICAgICAgICBpZiAoc3VtICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgZDAgLz0gc3VtO1xuICAgICAgICAgICAgICAgIGQxIC89IHN1bTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdjJTY2FsZSh2MSwgdiwgLWQwKTtcbiAgICAgICAgICAgIHYyU2NhbGUodjIsIHYsIGQxKTtcbiAgICAgICAgICAgIHZhciBjcDAgPSB2MkFkZChbXSwgcG9pbnQsIHYxKTtcbiAgICAgICAgICAgIHZhciBjcDEgPSB2MkFkZChbXSwgcG9pbnQsIHYyKTtcbiAgICAgICAgICAgIGlmIChjb25zdHJhaW50KSB7XG4gICAgICAgICAgICAgICAgdjJNYXgoY3AwLCBjcDAsIG1pbik7XG4gICAgICAgICAgICAgICAgdjJNaW4oY3AwLCBjcDAsIG1heCk7XG4gICAgICAgICAgICAgICAgdjJNYXgoY3AxLCBjcDEsIG1pbik7XG4gICAgICAgICAgICAgICAgdjJNaW4oY3AxLCBjcDEsIG1heCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjcHMucHVzaChjcDApO1xuICAgICAgICAgICAgY3BzLnB1c2goY3AxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0xvb3ApIHtcbiAgICAgICAgICAgIGNwcy5wdXNoKGNwcy5zaGlmdCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjcHM7XG4gICAgfTtcbn0pO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC96cmVuZGVyL2dyYXBoaWMvaGVscGVyL3Ntb290aEJlemllci5qc1xuICoqIG1vZHVsZSBpZCA9IDc1XG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCIvKipcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL1BvbHlsaW5lXG4gKi9cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG4gICAgdmFyIHBvbHlIZWxwZXIgPSByZXF1aXJlKCcuLi9oZWxwZXIvcG9seScpO1xuXG4gICAgcmV0dXJuIHJlcXVpcmUoJy4uL1BhdGgnKS5leHRlbmQoe1xuICAgICAgICBcbiAgICAgICAgdHlwZTogJ3BvbHlsaW5lJyxcblxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgcG9pbnRzOiBudWxsLFxuXG4gICAgICAgICAgICBzbW9vdGg6IGZhbHNlLFxuXG4gICAgICAgICAgICBzbW9vdGhDb25zdHJhaW50OiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHN0cm9rZTogJyMwMDAnLFxuXG4gICAgICAgICAgICBmaWxsOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgICAgICAgICAgcG9seUhlbHBlci5idWlsZFBhdGgoY3R4LCBzaGFwZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfSk7XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL3pyZW5kZXIvZ3JhcGhpYy9zaGFwZS9Qb2x5bGluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDc2XG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCIvKipcbiAqIOefqeW9olxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvUmVjdFxuICovXG5cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuICAgIHZhciByb3VuZFJlY3RIZWxwZXIgPSByZXF1aXJlKCcuLi9oZWxwZXIvcm91bmRSZWN0Jyk7XG5cbiAgICByZXR1cm4gcmVxdWlyZSgnLi4vUGF0aCcpLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ3JlY3QnLFxuXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAvLyDlt6bkuIrjgIHlj7PkuIrjgIHlj7PkuIvjgIHlt6bkuIvop5LnmoTljYrlvoTkvp3mrKHkuLpyMeOAgXIy44CBcjPjgIFyNFxuICAgICAgICAgICAgLy8gcue8qeWGmeS4ujEgICAgICAgICDnm7jlvZPkuo4gWzEsIDEsIDEsIDFdXG4gICAgICAgICAgICAvLyBy57yp5YaZ5Li6WzFdICAgICAgIOebuOW9k+S6jiBbMSwgMSwgMSwgMV1cbiAgICAgICAgICAgIC8vIHLnvKnlhpnkuLpbMSwgMl0gICAg55u45b2T5LqOIFsxLCAyLCAxLCAyXVxuICAgICAgICAgICAgLy8gcue8qeWGmeS4ulsxLCAyLCAzXSDnm7jlvZPkuo4gWzEsIDIsIDMsIDJdXG4gICAgICAgICAgICByOiAwLFxuXG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgICAgICAgICAgdmFyIHggPSBzaGFwZS54O1xuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS55O1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc2hhcGUuaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKCFzaGFwZS5yKSB7XG4gICAgICAgICAgICAgICAgY3R4LnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByb3VuZFJlY3RIZWxwZXIuYnVpbGRQYXRoKGN0eCwgc2hhcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfSk7XG59KTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvenJlbmRlci9ncmFwaGljL3NoYXBlL1JlY3QuanNcbiAqKiBtb2R1bGUgaWQgPSA3N1xuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHNoYXBlLng7XG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLnk7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgciA9IHNoYXBlLnI7XG4gICAgICAgICAgICB2YXIgcjE7XG4gICAgICAgICAgICB2YXIgcjI7XG4gICAgICAgICAgICB2YXIgcjM7XG4gICAgICAgICAgICB2YXIgcjQ7XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnQgd2lkdGggYW5kIGhlaWdodCB0byBwb3NpdGl2ZSBmb3IgYmV0dGVyIGJvcmRlclJhZGl1c1xuICAgICAgICAgICAgaWYgKHdpZHRoIDwgMCkge1xuICAgICAgICAgICAgICAgIHggPSB4ICsgd2lkdGg7XG4gICAgICAgICAgICAgICAgd2lkdGggPSAtd2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgICAgIHkgPSB5ICsgaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IC1oZWlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByMSA9IHIyID0gcjMgPSByNCA9IHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcjEgPSByMiA9IHIzID0gcjQgPSByWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICByMSA9IHIzID0gclswXTtcbiAgICAgICAgICAgICAgICAgICAgcjIgPSByNCA9IHJbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHIubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHIxID0gclswXTtcbiAgICAgICAgICAgICAgICAgICAgcjIgPSByNCA9IHJbMV07XG4gICAgICAgICAgICAgICAgICAgIHIzID0gclsyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHIxID0gclswXTtcbiAgICAgICAgICAgICAgICAgICAgcjIgPSByWzFdO1xuICAgICAgICAgICAgICAgICAgICByMyA9IHJbMl07XG4gICAgICAgICAgICAgICAgICAgIHI0ID0gclszXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByMSA9IHIyID0gcjMgPSByNCA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0b3RhbDtcbiAgICAgICAgICAgIGlmIChyMSArIHIyID4gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0b3RhbCA9IHIxICsgcjI7XG4gICAgICAgICAgICAgICAgcjEgKj0gd2lkdGggLyB0b3RhbDtcbiAgICAgICAgICAgICAgICByMiAqPSB3aWR0aCAvIHRvdGFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHIzICsgcjQgPiB3aWR0aCkge1xuICAgICAgICAgICAgICAgIHRvdGFsID0gcjMgKyByNDtcbiAgICAgICAgICAgICAgICByMyAqPSB3aWR0aCAvIHRvdGFsO1xuICAgICAgICAgICAgICAgIHI0ICo9IHdpZHRoIC8gdG90YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocjIgKyByMyA+IGhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRvdGFsID0gcjIgKyByMztcbiAgICAgICAgICAgICAgICByMiAqPSBoZWlnaHQgLyB0b3RhbDtcbiAgICAgICAgICAgICAgICByMyAqPSBoZWlnaHQgLyB0b3RhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyMSArIHI0ID4gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdG90YWwgPSByMSArIHI0O1xuICAgICAgICAgICAgICAgIHIxICo9IGhlaWdodCAvIHRvdGFsO1xuICAgICAgICAgICAgICAgIHI0ICo9IGhlaWdodCAvIHRvdGFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgcjEsIHkpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGggLSByMiwgeSk7XG4gICAgICAgICAgICByMiAhPT0gMCAmJiBjdHgucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICAgICAgICB4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIHIyXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByMyk7XG4gICAgICAgICAgICByMyAhPT0gMCAmJiBjdHgucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICAgICAgICB4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIHIzLCB5ICsgaGVpZ2h0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgcjQsIHkgKyBoZWlnaHQpO1xuICAgICAgICAgICAgcjQgIT09IDAgJiYgY3R4LnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgICAgICAgeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIHI0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgcjEpO1xuICAgICAgICAgICAgcjEgIT09IDAgJiYgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHIxLCB5KTtcbiAgICAgICAgfVxuICAgIH07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL3pyZW5kZXIvZ3JhcGhpYy9oZWxwZXIvcm91bmRSZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gNzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsIi8qKlxuICog55u057q/XG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9MaW5lXG4gKi9cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuICAgIHJldHVybiByZXF1aXJlKCcuLi9QYXRoJykuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnbGluZScsXG5cbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIC8vIFN0YXJ0IHBvaW50XG4gICAgICAgICAgICB4MTogMCxcbiAgICAgICAgICAgIHkxOiAwLFxuICAgICAgICAgICAgLy8gRW5kIHBvaW50XG4gICAgICAgICAgICB4MjogMCxcbiAgICAgICAgICAgIHkyOiAwLFxuXG4gICAgICAgICAgICBwZXJjZW50OiAxXG4gICAgICAgIH0sXG5cbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHN0cm9rZTogJyMwMDAnLFxuICAgICAgICAgICAgZmlsbDogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciB4MSA9IHNoYXBlLngxO1xuICAgICAgICAgICAgdmFyIHkxID0gc2hhcGUueTE7XG4gICAgICAgICAgICB2YXIgeDIgPSBzaGFwZS54MjtcbiAgICAgICAgICAgIHZhciB5MiA9IHNoYXBlLnkyO1xuICAgICAgICAgICAgdmFyIHBlcmNlbnQgPSBzaGFwZS5wZXJjZW50O1xuXG4gICAgICAgICAgICBpZiAocGVyY2VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuXG4gICAgICAgICAgICBpZiAocGVyY2VudCA8IDEpIHtcbiAgICAgICAgICAgICAgICB4MiA9IHgxICogKDEgLSBwZXJjZW50KSArIHgyICogcGVyY2VudDtcbiAgICAgICAgICAgICAgICB5MiA9IHkxICogKDEgLSBwZXJjZW50KSArIHkyICogcGVyY2VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHBvaW50IGF0IHBlcmNlbnRcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBwZXJjZW50XG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgcG9pbnRBdDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHNoYXBlLngxICogKDEgLSBwKSArIHNoYXBlLngyICogcCxcbiAgICAgICAgICAgICAgICBzaGFwZS55MSAqICgxIC0gcCkgKyBzaGFwZS55MiAqIHBcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC96cmVuZGVyL2dyYXBoaWMvc2hhcGUvTGluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDc5XG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCIvKipcbiAqIOi0neWhnuWwlOabsue6v1xuICogQG1vZHVsZSB6cmVuZGVyL3NoYXBlL0JlemllckN1cnZlXG4gKi9cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBjdXJ2ZVRvb2wgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2N1cnZlJyk7XG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3ZlY3RvcicpO1xuICAgIHZhciBxdWFkcmF0aWNTdWJkaXZpZGUgPSBjdXJ2ZVRvb2wucXVhZHJhdGljU3ViZGl2aWRlO1xuICAgIHZhciBjdWJpY1N1YmRpdmlkZSA9IGN1cnZlVG9vbC5jdWJpY1N1YmRpdmlkZTtcbiAgICB2YXIgcXVhZHJhdGljQXQgPSBjdXJ2ZVRvb2wucXVhZHJhdGljQXQ7XG4gICAgdmFyIGN1YmljQXQgPSBjdXJ2ZVRvb2wuY3ViaWNBdDtcbiAgICB2YXIgcXVhZHJhdGljRGVyaXZhdGl2ZUF0ID0gY3VydmVUb29sLnF1YWRyYXRpY0Rlcml2YXRpdmVBdDtcbiAgICB2YXIgY3ViaWNEZXJpdmF0aXZlQXQgPSBjdXJ2ZVRvb2wuY3ViaWNEZXJpdmF0aXZlQXQ7XG5cbiAgICB2YXIgb3V0ID0gW107XG5cbiAgICBmdW5jdGlvbiBzb21lVmVjdG9yQXQoc2hhcGUsIHQsIGlzVGFuZ2VudCkge1xuICAgICAgICB2YXIgY3B4MiA9IHNoYXBlLmNweDI7XG4gICAgICAgIHZhciBjcHkyID0gc2hhcGUuY3B5MjtcbiAgICAgICAgaWYgKGNweDIgPT09IG51bGwgfHwgY3B5MiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAoaXNUYW5nZW50ID8gY3ViaWNEZXJpdmF0aXZlQXQgOiBjdWJpY0F0KShzaGFwZS54MSwgc2hhcGUuY3B4MSwgc2hhcGUuY3B4Miwgc2hhcGUueDIsIHQpLFxuICAgICAgICAgICAgICAgIChpc1RhbmdlbnQgPyBjdWJpY0Rlcml2YXRpdmVBdCA6IGN1YmljQXQpKHNoYXBlLnkxLCBzaGFwZS5jcHkxLCBzaGFwZS5jcHkyLCBzaGFwZS55MiwgdClcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIChpc1RhbmdlbnQgPyBxdWFkcmF0aWNEZXJpdmF0aXZlQXQgOiBxdWFkcmF0aWNBdCkoc2hhcGUueDEsIHNoYXBlLmNweDEsIHNoYXBlLngyLCB0KSxcbiAgICAgICAgICAgICAgICAoaXNUYW5nZW50ID8gcXVhZHJhdGljRGVyaXZhdGl2ZUF0IDogcXVhZHJhdGljQXQpKHNoYXBlLnkxLCBzaGFwZS5jcHkxLCBzaGFwZS55MiwgdClcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcXVpcmUoJy4uL1BhdGgnKS5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdiZXppZXItY3VydmUnLFxuXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICB4MTogMCxcbiAgICAgICAgICAgIHkxOiAwLFxuICAgICAgICAgICAgeDI6IDAsXG4gICAgICAgICAgICB5MjogMCxcbiAgICAgICAgICAgIGNweDE6IDAsXG4gICAgICAgICAgICBjcHkxOiAwLFxuICAgICAgICAgICAgLy8gY3B4MjogMCxcbiAgICAgICAgICAgIC8vIGNweTI6IDBcblxuICAgICAgICAgICAgLy8gQ3VydmUgc2hvdyBwZXJjZW50LCBmb3IgYW5pbWF0aW5nXG4gICAgICAgICAgICBwZXJjZW50OiAxXG4gICAgICAgIH0sXG5cbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHN0cm9rZTogJyMwMDAnLFxuICAgICAgICAgICAgZmlsbDogbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciB4MSA9IHNoYXBlLngxO1xuICAgICAgICAgICAgdmFyIHkxID0gc2hhcGUueTE7XG4gICAgICAgICAgICB2YXIgeDIgPSBzaGFwZS54MjtcbiAgICAgICAgICAgIHZhciB5MiA9IHNoYXBlLnkyO1xuICAgICAgICAgICAgdmFyIGNweDEgPSBzaGFwZS5jcHgxO1xuICAgICAgICAgICAgdmFyIGNweTEgPSBzaGFwZS5jcHkxO1xuICAgICAgICAgICAgdmFyIGNweDIgPSBzaGFwZS5jcHgyO1xuICAgICAgICAgICAgdmFyIGNweTIgPSBzaGFwZS5jcHkyO1xuICAgICAgICAgICAgdmFyIHBlcmNlbnQgPSBzaGFwZS5wZXJjZW50O1xuICAgICAgICAgICAgaWYgKHBlcmNlbnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcblxuICAgICAgICAgICAgaWYgKGNweDIgPT0gbnVsbCB8fCBjcHkyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAocGVyY2VudCA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVhZHJhdGljU3ViZGl2aWRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgeDEsIGNweDEsIHgyLCBwZXJjZW50LCBvdXRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY3B4MSA9IG91dFsxXTtcbiAgICAgICAgICAgICAgICAgICAgeDIgPSBvdXRbMl07XG4gICAgICAgICAgICAgICAgICAgIHF1YWRyYXRpY1N1YmRpdmlkZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxLCBjcHkxLCB5MiwgcGVyY2VudCwgb3V0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGNweTEgPSBvdXRbMV07XG4gICAgICAgICAgICAgICAgICAgIHkyID0gb3V0WzJdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgICAgICBjcHgxLCBjcHkxLFxuICAgICAgICAgICAgICAgICAgICB4MiwgeTJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHBlcmNlbnQgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1YmljU3ViZGl2aWRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgeDEsIGNweDEsIGNweDIsIHgyLCBwZXJjZW50LCBvdXRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY3B4MSA9IG91dFsxXTtcbiAgICAgICAgICAgICAgICAgICAgY3B4MiA9IG91dFsyXTtcbiAgICAgICAgICAgICAgICAgICAgeDIgPSBvdXRbM107XG4gICAgICAgICAgICAgICAgICAgIGN1YmljU3ViZGl2aWRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgeTEsIGNweTEsIGNweTIsIHkyLCBwZXJjZW50LCBvdXRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY3B5MSA9IG91dFsxXTtcbiAgICAgICAgICAgICAgICAgICAgY3B5MiA9IG91dFsyXTtcbiAgICAgICAgICAgICAgICAgICAgeTIgPSBvdXRbM107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgICAgICBjcHgxLCBjcHkxLFxuICAgICAgICAgICAgICAgICAgICBjcHgyLCBjcHkyLFxuICAgICAgICAgICAgICAgICAgICB4MiwgeTJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgcG9pbnQgYXQgcGVyY2VudFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICBwb2ludEF0OiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHNvbWVWZWN0b3JBdCh0aGlzLnNoYXBlLCB0LCBmYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0YW5nZW50IGF0IHBlcmNlbnRcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGFuZ2VudEF0OiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdmFyIHAgPSBzb21lVmVjdG9yQXQodGhpcy5zaGFwZSwgdCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmVjMi5ub3JtYWxpemUocCwgcCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn0pO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC96cmVuZGVyL2dyYXBoaWMvc2hhcGUvQmV6aWVyQ3VydmUuanNcbiAqKiBtb2R1bGUgaWQgPSA4MFxuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiLyoqXG4gKiDlnIblvKdcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL0FyY1xuICovXG4gZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cbiAgICByZXR1cm4gcmVxdWlyZSgnLi4vUGF0aCcpLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ2FyYycsXG5cbiAgICAgICAgc2hhcGU6IHtcblxuICAgICAgICAgICAgY3g6IDAsXG5cbiAgICAgICAgICAgIGN5OiAwLFxuXG4gICAgICAgICAgICByOiAwLFxuXG4gICAgICAgICAgICBzdGFydEFuZ2xlOiAwLFxuXG4gICAgICAgICAgICBlbmRBbmdsZTogTWF0aC5QSSAqIDIsXG5cbiAgICAgICAgICAgIGNsb2Nrd2lzZTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIHN0eWxlOiB7XG5cbiAgICAgICAgICAgIHN0cm9rZTogJyMwMDAnLFxuXG4gICAgICAgICAgICBmaWxsOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuXG4gICAgICAgICAgICB2YXIgeCA9IHNoYXBlLmN4O1xuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS5jeTtcbiAgICAgICAgICAgIHZhciByID0gTWF0aC5tYXgoc2hhcGUuciwgMCk7XG4gICAgICAgICAgICB2YXIgc3RhcnRBbmdsZSA9IHNoYXBlLnN0YXJ0QW5nbGU7XG4gICAgICAgICAgICB2YXIgZW5kQW5nbGUgPSBzaGFwZS5lbmRBbmdsZTtcbiAgICAgICAgICAgIHZhciBjbG9ja3dpc2UgPSBzaGFwZS5jbG9ja3dpc2U7XG5cbiAgICAgICAgICAgIHZhciB1bml0WCA9IE1hdGguY29zKHN0YXJ0QW5nbGUpO1xuICAgICAgICAgICAgdmFyIHVuaXRZID0gTWF0aC5zaW4oc3RhcnRBbmdsZSk7XG5cbiAgICAgICAgICAgIGN0eC5tb3ZlVG8odW5pdFggKiByICsgeCwgdW5pdFkgKiByICsgeSk7XG4gICAgICAgICAgICBjdHguYXJjKHgsIHksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCAhY2xvY2t3aXNlKTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC96cmVuZGVyL2dyYXBoaWMvc2hhcGUvQXJjLmpzXG4gKiogbW9kdWxlIGlkID0gODFcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsIi8vIENvbXBvdW5kUGF0aCB0byBpbXByb3ZlIHBlcmZvcm1hbmNlXG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuICAgIHZhciBQYXRoID0gcmVxdWlyZSgnLi9QYXRoJyk7XG4gICAgcmV0dXJuIFBhdGguZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnY29tcG91bmQnLFxuXG4gICAgICAgIHNoYXBlOiB7XG5cbiAgICAgICAgICAgIHBhdGhzOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgX3VwZGF0ZVBhdGhEaXJ0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRpcnR5UGF0aCA9IHRoaXMuX19kaXJ0eVBhdGg7XG4gICAgICAgICAgICB2YXIgcGF0aHMgPSB0aGlzLnNoYXBlLnBhdGhzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIE1hcmsgYXMgZGlydHkgaWYgYW55IHN1YnBhdGggaXMgZGlydHlcbiAgICAgICAgICAgICAgICBkaXJ0eVBhdGggPSBkaXJ0eVBhdGggfHwgcGF0aHNbaV0uX19kaXJ0eVBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9fZGlydHlQYXRoID0gZGlydHlQYXRoO1xuICAgICAgICAgICAgdGhpcy5fX2RpcnR5ID0gdGhpcy5fX2RpcnR5IHx8IGRpcnR5UGF0aDtcbiAgICAgICAgfSxcblxuICAgICAgICBiZWZvcmVCcnVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlUGF0aERpcnR5KCk7XG4gICAgICAgICAgICB2YXIgcGF0aHMgPSB0aGlzLnNoYXBlLnBhdGhzIHx8IFtdO1xuICAgICAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5nZXRHbG9iYWxTY2FsZSgpO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHBhdGggc2NhbGVcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwYXRoc1tpXS5wYXRoLnNldFNjYWxlKHNjYWxlWzBdLCBzY2FsZVsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgICAgICAgICAgdmFyIHBhdGhzID0gc2hhcGUucGF0aHMgfHwgW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGF0aHNbaV0uYnVpbGRQYXRoKGN0eCwgcGF0aHNbaV0uc2hhcGUsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyQnJ1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwYXRocyA9IHRoaXMuc2hhcGUucGF0aHM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGF0aHNbaV0uX19kaXJ0eVBhdGggPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVBhdGhEaXJ0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFBhdGgucHJvdG90eXBlLmdldEJvdW5kaW5nUmVjdC5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfSk7XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL3pyZW5kZXIvZ3JhcGhpYy9Db21wb3VuZFBhdGguanNcbiAqKiBtb2R1bGUgaWQgPSA4MlxuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG5cbiAgICB2YXIgR3JhZGllbnQgPSByZXF1aXJlKCcuL0dyYWRpZW50Jyk7XG5cbiAgICAvKipcbiAgICAgKiB4LCB5LCB4MiwgeTIgYXJlIGFsbCBwZXJjZW50IGZyb20gMCB0byAxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt4Mj0xXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeTI9MF1cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBjb2xvclN0b3BzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZ2xvYmFsQ29vcmQ9ZmFsc2VdXG4gICAgICovXG4gICAgdmFyIExpbmVhckdyYWRpZW50ID0gZnVuY3Rpb24gKHgsIHksIHgyLCB5MiwgY29sb3JTdG9wcywgZ2xvYmFsQ29vcmQpIHtcbiAgICAgICAgdGhpcy54ID0geCA9PSBudWxsID8gMCA6IHg7XG5cbiAgICAgICAgdGhpcy55ID0geSA9PSBudWxsID8gMCA6IHk7XG5cbiAgICAgICAgdGhpcy54MiA9IHgyID09IG51bGwgPyAxIDogeDI7XG5cbiAgICAgICAgdGhpcy55MiA9IHkyID09IG51bGwgPyAwIDogeTI7XG5cbiAgICAgICAgLy8gQ2FuIGJlIGNsb25lZFxuICAgICAgICB0aGlzLnR5cGUgPSAnbGluZWFyJztcblxuICAgICAgICAvLyBJZiB1c2UgZ2xvYmFsIGNvb3JkXG4gICAgICAgIHRoaXMuZ2xvYmFsID0gZ2xvYmFsQ29vcmQgfHwgZmFsc2U7XG5cbiAgICAgICAgR3JhZGllbnQuY2FsbCh0aGlzLCBjb2xvclN0b3BzKTtcbiAgICB9O1xuXG4gICAgTGluZWFyR3JhZGllbnQucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBMaW5lYXJHcmFkaWVudFxuICAgIH07XG5cbiAgICB6clV0aWwuaW5oZXJpdHMoTGluZWFyR3JhZGllbnQsIEdyYWRpZW50KTtcblxuICAgIHJldHVybiBMaW5lYXJHcmFkaWVudDtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvenJlbmRlci9ncmFwaGljL0xpbmVhckdyYWRpZW50LmpzXG4gKiogbW9kdWxlIGlkID0gODNcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsImRlZmluZShmdW5jdGlvbihyZXF1aXJlKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuXG4gICAgdmFyIEdyYWRpZW50ID0gcmVxdWlyZSgnLi9HcmFkaWVudCcpO1xuXG4gICAgLyoqXG4gICAgICogeCwgeSwgciBhcmUgYWxsIHBlcmNlbnQgZnJvbSAwIHRvIDFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MC41XVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wLjVdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyPTAuNV1cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBbY29sb3JTdG9wc11cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtnbG9iYWxDb29yZD1mYWxzZV1cbiAgICAgKi9cbiAgICB2YXIgUmFkaWFsR3JhZGllbnQgPSBmdW5jdGlvbiAoeCwgeSwgciwgY29sb3JTdG9wcywgZ2xvYmFsQ29vcmQpIHtcbiAgICAgICAgdGhpcy54ID0geCA9PSBudWxsID8gMC41IDogeDtcblxuICAgICAgICB0aGlzLnkgPSB5ID09IG51bGwgPyAwLjUgOiB5O1xuXG4gICAgICAgIHRoaXMuciA9IHIgPT0gbnVsbCA/IDAuNSA6IHI7XG5cbiAgICAgICAgLy8gQ2FuIGJlIGNsb25lZFxuICAgICAgICB0aGlzLnR5cGUgPSAncmFkaWFsJztcblxuICAgICAgICAvLyBJZiB1c2UgZ2xvYmFsIGNvb3JkXG4gICAgICAgIHRoaXMuZ2xvYmFsID0gZ2xvYmFsQ29vcmQgfHwgZmFsc2U7XG5cbiAgICAgICAgR3JhZGllbnQuY2FsbCh0aGlzLCBjb2xvclN0b3BzKTtcbiAgICB9O1xuXG4gICAgUmFkaWFsR3JhZGllbnQucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBSYWRpYWxHcmFkaWVudFxuICAgIH07XG5cbiAgICB6clV0aWwuaW5oZXJpdHMoUmFkaWFsR3JhZGllbnQsIEdyYWRpZW50KTtcblxuICAgIHJldHVybiBSYWRpYWxHcmFkaWVudDtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvenJlbmRlci9ncmFwaGljL1JhZGlhbEdyYWRpZW50LmpzXG4gKiogbW9kdWxlIGlkID0gODRcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsIi8qIVxuICogWlJlbmRlciwgYSBoaWdoIHBlcmZvcm1hbmNlIDJkIGRyYXdpbmcgbGlicmFyeS5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJhaWR1IEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTElDRU5TRVxuICogaHR0cHM6Ly9naXRodWIuY29tL2Vjb21mZS96cmVuZGVyL2Jsb2IvbWFzdGVyL0xJQ0VOU0UudHh0XG4gKi9cbi8vIEdsb2JhbCBkZWZpbmVzXG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSkge1xuICAgIHZhciBndWlkID0gcmVxdWlyZSgnLi9jb3JlL2d1aWQnKTtcbiAgICB2YXIgZW52ID0gcmVxdWlyZSgnLi9jb3JlL2VudicpO1xuXG4gICAgdmFyIEhhbmRsZXIgPSByZXF1aXJlKCcuL0hhbmRsZXInKTtcbiAgICB2YXIgU3RvcmFnZSA9IHJlcXVpcmUoJy4vU3RvcmFnZScpO1xuICAgIHZhciBBbmltYXRpb24gPSByZXF1aXJlKCcuL2FuaW1hdGlvbi9BbmltYXRpb24nKTtcbiAgICB2YXIgSGFuZGxlclByb3h5ID0gcmVxdWlyZSgnLi9kb20vSGFuZGxlclByb3h5Jyk7XG5cbiAgICB2YXIgdXNlVk1MID0gIWVudi5jYW52YXNTdXBwb3J0ZWQ7XG5cbiAgICB2YXIgcGFpbnRlckN0b3JzID0ge1xuICAgICAgICBjYW52YXM6IHJlcXVpcmUoJy4vUGFpbnRlcicpXG4gICAgfTtcblxuICAgIHZhciBpbnN0YW5jZXMgPSB7fTsgICAgLy8gWlJlbmRlcuWunuS+i21hcOe0ouW8lVxuXG4gICAgdmFyIHpyZW5kZXIgPSB7fTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHpyZW5kZXIudmVyc2lvbiA9ICczLjEuMyc7XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXppbmcgYSB6cmVuZGVyIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZG9tXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucmVuZGVyZXI9J2NhbnZhcyddICdjYW52YXMnIG9yICdzdmcnXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmRldmljZVBpeGVsUmF0aW9dXG4gICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn1cbiAgICAgKi9cbiAgICB6cmVuZGVyLmluaXQgPSBmdW5jdGlvbihkb20sIG9wdHMpIHtcbiAgICAgICAgdmFyIHpyID0gbmV3IFpSZW5kZXIoZ3VpZCgpLCBkb20sIG9wdHMpO1xuICAgICAgICBpbnN0YW5jZXNbenIuaWRdID0genI7XG4gICAgICAgIHJldHVybiB6cjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGlzcG9zZSB6cmVuZGVyIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfSB6clxuICAgICAqL1xuICAgIHpyZW5kZXIuZGlzcG9zZSA9IGZ1bmN0aW9uICh6cikge1xuICAgICAgICBpZiAoenIpIHtcbiAgICAgICAgICAgIHpyLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBpbnN0YW5jZXMpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZXNba2V5XS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnN0YW5jZXMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB6cmVuZGVyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgenJlbmRlciBpbnN0YW5jZSBieSBpZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCB6cmVuZGVyIGluc3RhbmNlIGlkXG4gICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn1cbiAgICAgKi9cbiAgICB6cmVuZGVyLmdldEluc3RhbmNlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZXNbaWRdO1xuICAgIH07XG5cbiAgICB6cmVuZGVyLnJlZ2lzdGVyUGFpbnRlciA9IGZ1bmN0aW9uIChuYW1lLCBDdG9yKSB7XG4gICAgICAgIHBhaW50ZXJDdG9yc1tuYW1lXSA9IEN0b3I7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGRlbEluc3RhbmNlKGlkKSB7XG4gICAgICAgIGRlbGV0ZSBpbnN0YW5jZXNbaWRdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtb2R1bGUgenJlbmRlci9aUmVuZGVyXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL1pSZW5kZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKiBAcGFyYW0ge0hUTUxEb21FbGVtZW50fSBkb21cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5yZW5kZXJlcj0nY2FudmFzJ10gJ2NhbnZhcycgb3IgJ3N2ZydcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMuZGV2aWNlUGl4ZWxSYXRpb11cbiAgICAgKi9cbiAgICB2YXIgWlJlbmRlciA9IGZ1bmN0aW9uKGlkLCBkb20sIG9wdHMpIHtcblxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0hUTUxEb21FbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kb20gPSBkb207XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc3RvcmFnZSA9IG5ldyBTdG9yYWdlKCk7XG5cbiAgICAgICAgdmFyIHJlbmRlcmVyVHlwZSA9IG9wdHMucmVuZGVyZXI7XG4gICAgICAgIGlmICh1c2VWTUwpIHtcbiAgICAgICAgICAgIGlmICghcGFpbnRlckN0b3JzLnZtbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG5lZWQgdG8gcmVxdWlyZSBcXCd6cmVuZGVyL3ZtbC92bWxcXCcgdG8gc3VwcG9ydCBJRTgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbmRlcmVyVHlwZSA9ICd2bWwnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFyZW5kZXJlclR5cGUgfHwgIXBhaW50ZXJDdG9yc1tyZW5kZXJlclR5cGVdKSB7XG4gICAgICAgICAgICByZW5kZXJlclR5cGUgPSAnY2FudmFzJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFpbnRlciA9IG5ldyBwYWludGVyQ3RvcnNbcmVuZGVyZXJUeXBlXShkb20sIHN0b3JhZ2UsIG9wdHMpO1xuXG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gICAgICAgIHRoaXMucGFpbnRlciA9IHBhaW50ZXI7XG5cbiAgICAgICAgdmFyIGhhbmRlclByb3h5ID0gIWVudi5ub2RlID8gbmV3IEhhbmRsZXJQcm94eShwYWludGVyLmdldFZpZXdwb3J0Um9vdCgpKSA6IG51bGw7XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IG5ldyBIYW5kbGVyKHN0b3JhZ2UsIHBhaW50ZXIsIGhhbmRlclByb3h5KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRpb259XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oe1xuICAgICAgICAgICAgc3RhZ2U6IHtcbiAgICAgICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX25lZWRzUmVmcmVzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZWZyZXNoSW1tZWRpYXRlbHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fbmVlZHNSZWZyZXNoSG92ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVmcmVzaEhvdmVySW1tZWRpYXRlbHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uLnN0YXJ0KCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoO1xuXG4gICAgICAgIC8vIOS/ruaUuSBzdG9yYWdlLmRlbEZyb21NYXAsIOavj+asoeWIoOmZpOWFg+e0oOS5i+WJjeWIoOmZpOWKqOeUu1xuICAgICAgICAvLyBGSVhNRSDmnInngrl1Z2x5XG4gICAgICAgIHZhciBvbGREZWxGcm9tTWFwID0gc3RvcmFnZS5kZWxGcm9tTWFwO1xuICAgICAgICB2YXIgb2xkQWRkVG9NYXAgPSBzdG9yYWdlLmFkZFRvTWFwO1xuXG4gICAgICAgIHN0b3JhZ2UuZGVsRnJvbU1hcCA9IGZ1bmN0aW9uIChlbElkKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSBzdG9yYWdlLmdldChlbElkKTtcblxuICAgICAgICAgICAgb2xkRGVsRnJvbU1hcC5jYWxsKHN0b3JhZ2UsIGVsSWQpO1xuXG4gICAgICAgICAgICBlbCAmJiBlbC5yZW1vdmVTZWxmRnJvbVpyKHNlbGYpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHN0b3JhZ2UuYWRkVG9NYXAgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIG9sZEFkZFRvTWFwLmNhbGwoc3RvcmFnZSwgZWwpO1xuXG4gICAgICAgICAgICBlbC5hZGRTZWxmVG9acihzZWxmKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgWlJlbmRlci5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFpSZW5kZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDojrflj5blrp7kvovllK/kuIDmoIfor4ZcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlkO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqDlhYPntKBcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICAgICAgICovXG4gICAgICAgIGFkZDogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UuYWRkUm9vdChlbCk7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliKDpmaTlhYPntKBcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UuZGVsUm9vdChlbCk7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGFuZ2UgY29uZmlndXJhdGlvbiBvZiBsYXllclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gekxldmVsXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcuY2xlYXJDb2xvcj0wXSBDbGVhciBjb2xvclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5tb3Rpb25CbHVyPWZhbHNlXSBJZiBlbmFibGUgbW90aW9uIGJsdXJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcubGFzdEZyYW1lQWxwaGE9MC43XSBNb3Rpb24gYmx1ciBmYWN0b3IuIExhcmdlciB2YWx1ZSBjYXVzZSBsb25nZXIgdHJhaWxlclxuICAgICAgICAqL1xuICAgICAgICBjb25maWdMYXllcjogZnVuY3Rpb24gKHpMZXZlbCwgY29uZmlnKSB7XG4gICAgICAgICAgICB0aGlzLnBhaW50ZXIuY29uZmlnTGF5ZXIoekxldmVsLCBjb25maWcpO1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVwYWludCB0aGUgY2FudmFzIGltbWVkaWF0ZWx5XG4gICAgICAgICAqL1xuICAgICAgICByZWZyZXNoSW1tZWRpYXRlbHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIENsZWFyIG5lZWRzUmVmcmVzaCBhaGVhZCB0byBhdm9pZCBzb21ldGhpbmcgd3JvbmcgaGFwcGVucyBpbiByZWZyZXNoXG4gICAgICAgICAgICAvLyBPciBpdCB3aWxsIGNhdXNlIHpyZW5kZXIgcmVmcmVzaGVzIGFnYWluIGFuZCBhZ2Fpbi5cbiAgICAgICAgICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5wYWludGVyLnJlZnJlc2goKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXZvaWQgdHJpZ2dlciB6ci5yZWZyZXNoIGluIEVsZW1lbnQjYmVmb3JlVXBkYXRlIGhvb2tcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcmsgYW5kIHJlcGFpbnQgdGhlIGNhbnZhcyBpbiB0aGUgbmV4dCBmcmFtZSBvZiBicm93c2VyXG4gICAgICAgICAqL1xuICAgICAgICByZWZyZXNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBlbGVtZW50IHRvIGhvdmVyIGxheWVyXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZVxuICAgICAgICAgKi9cbiAgICAgICAgYWRkSG92ZXI6IGZ1bmN0aW9uIChlbCwgc3R5bGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhaW50ZXIuYWRkSG92ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhaW50ZXIuYWRkSG92ZXIoZWwsIHN0eWxlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hIb3ZlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgZWxlbWVudCBmcm9tIGhvdmVyIGxheWVyXG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVIb3ZlcjogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYWludGVyLnJlbW92ZUhvdmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYWludGVyLnJlbW92ZUhvdmVyKGVsKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hIb3ZlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhciBhbGwgaG92ZXIgZWxlbWVudHMgaW4gaG92ZXIgbGF5ZXJcbiAgICAgICAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFySG92ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhaW50ZXIuY2xlYXJIb3Zlcikge1xuICAgICAgICAgICAgICAgIHRoaXMucGFpbnRlci5jbGVhckhvdmVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoSG92ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVmcmVzaCBob3ZlciBpbiBuZXh0IGZyYW1lXG4gICAgICAgICAqL1xuICAgICAgICByZWZyZXNoSG92ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX25lZWRzUmVmcmVzaEhvdmVyID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVmcmVzaCBob3ZlciBpbW1lZGlhdGVseVxuICAgICAgICAgKi9cbiAgICAgICAgcmVmcmVzaEhvdmVySW1tZWRpYXRlbHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX25lZWRzUmVmcmVzaEhvdmVyID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnBhaW50ZXIucmVmcmVzaEhvdmVyICYmIHRoaXMucGFpbnRlci5yZWZyZXNoSG92ZXIoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVzaXplIHRoZSBjYW52YXMuXG4gICAgICAgICAqIFNob3VsZCBiZSBpbnZva2VkIHdoZW4gY29udGFpbmVyIHNpemUgaXMgY2hhbmdlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmVzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMucGFpbnRlci5yZXNpemUoKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlci5yZXNpemUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcCBhbmQgY2xlYXIgYWxsIGFuaW1hdGlvbiBpbW1lZGlhdGVseVxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXJBbmltYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uLmNsZWFyKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBjb250YWluZXIgd2lkdGhcbiAgICAgICAgICovXG4gICAgICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhaW50ZXIuZ2V0V2lkdGgoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGNvbnRhaW5lciBoZWlnaHRcbiAgICAgICAgICovXG4gICAgICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYWludGVyLmdldEhlaWdodCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHBvcnQgdGhlIGNhbnZhcyBhcyBCYXNlNjQgVVJMXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYmFja2dyb3VuZENvbG9yPScjZmZmJ11cbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBCYXNlNjQgVVJMXG4gICAgICAgICAqL1xuICAgICAgICAvLyB0b0RhdGFVUkw6IGZ1bmN0aW9uKHR5cGUsIGJhY2tncm91bmRDb2xvcikge1xuICAgICAgICAvLyAgICAgcmV0dXJuIHRoaXMucGFpbnRlci5nZXRSZW5kZXJlZENhbnZhcyh7XG4gICAgICAgIC8vICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBiYWNrZ3JvdW5kQ29sb3JcbiAgICAgICAgLy8gICAgIH0pLnRvRGF0YVVSTCh0eXBlKTtcbiAgICAgICAgLy8gfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydGluZyBhIHBhdGggdG8gaW1hZ2UuXG4gICAgICAgICAqIEl0IGhhcyBtdWNoIGJldHRlciBwZXJmb3JtYW5jZSBvZiBkcmF3aW5nIGltYWdlIHJhdGhlciB0aGFuIGRyYXdpbmcgYSB2ZWN0b3IgcGF0aC5cbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGh9IGVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAgICAgICAgICovXG4gICAgICAgIHBhdGhUb0ltYWdlOiBmdW5jdGlvbihlLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBndWlkKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYWludGVyLnBhdGhUb0ltYWdlKGlkLCBlLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGRlZmF1bHQgY3Vyc29yXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yU3R5bGU9J2RlZmF1bHQnXSDkvovlpoIgY3Jvc3NoYWlyXG4gICAgICAgICAqL1xuICAgICAgICBzZXRDdXJzb3JTdHlsZTogZnVuY3Rpb24gKGN1cnNvclN0eWxlKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIuc2V0Q3Vyc29yU3R5bGUoY3Vyc29yU3R5bGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCaW5kIGV2ZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudEhhbmRsZXIgSGFuZGxlciBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIENvbnRleHQgb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBvbjogZnVuY3Rpb24oZXZlbnROYW1lLCBldmVudEhhbmRsZXIsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlci5vbihldmVudE5hbWUsIGV2ZW50SGFuZGxlciwgY29udGV4dCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVuYmluZCBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIEV2ZW50IG5hbWVcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2V2ZW50SGFuZGxlcl0gSGFuZGxlciBmdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgb2ZmOiBmdW5jdGlvbihldmVudE5hbWUsIGV2ZW50SGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyLm9mZihldmVudE5hbWUsIGV2ZW50SGFuZGxlcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyaWdnZXIgZXZlbnQgbWFudWFsbHlcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBFdmVudCBuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7ZXZlbnQ9fSBldmVudCBFdmVudCBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50KTtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhciBhbGwgb2JqZWN0cyBhbmQgdGhlIGNhbnZhcy5cbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UuZGVsUm9vdCgpO1xuICAgICAgICAgICAgdGhpcy5wYWludGVyLmNsZWFyKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3Bvc2Ugc2VsZi5cbiAgICAgICAgICovXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uLnN0b3AoKTtcblxuICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMucGFpbnRlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIuZGlzcG9zZSgpO1xuXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbiA9XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UgPVxuICAgICAgICAgICAgdGhpcy5wYWludGVyID1cbiAgICAgICAgICAgIHRoaXMuaGFuZGxlciA9IG51bGw7XG5cbiAgICAgICAgICAgIGRlbEluc3RhbmNlKHRoaXMuaWQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiB6cmVuZGVyO1xufSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL3pyZW5kZXIvenJlbmRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDg1XG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCIvKipcbiAqIEhhbmRsZXJcbiAqIEBtb2R1bGUgenJlbmRlci9IYW5kbGVyXG4gKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqICAgICAgICAgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqICAgICAgICAgcGlzc2FuZyAoc2hlbnlpLjkxNEBnbWFpbC5jb20pXG4gKi9cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL2NvcmUvdXRpbCcpO1xuICAgIHZhciBEcmFnZ2FibGUgPSByZXF1aXJlKCcuL21peGluL0RyYWdnYWJsZScpO1xuXG4gICAgdmFyIEV2ZW50ZnVsID0gcmVxdWlyZSgnLi9taXhpbi9FdmVudGZ1bCcpO1xuXG4gICAgZnVuY3Rpb24gbWFrZUV2ZW50UGFja2V0KGV2ZVR5cGUsIHRhcmdldCwgZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IGV2ZVR5cGUsXG4gICAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgIGNhbmNlbEJ1YmJsZTogZmFsc2UsXG4gICAgICAgICAgICBvZmZzZXRYOiBldmVudC56clgsXG4gICAgICAgICAgICBvZmZzZXRZOiBldmVudC56clksXG4gICAgICAgICAgICBnZXN0dXJlRXZlbnQ6IGV2ZW50Lmdlc3R1cmVFdmVudCxcbiAgICAgICAgICAgIHBpbmNoWDogZXZlbnQucGluY2hYLFxuICAgICAgICAgICAgcGluY2hZOiBldmVudC5waW5jaFksXG4gICAgICAgICAgICBwaW5jaFNjYWxlOiBldmVudC5waW5jaFNjYWxlLFxuICAgICAgICAgICAgd2hlZWxEZWx0YTogZXZlbnQuenJEZWx0YVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEVtcHR5UHJveHkgKCkge31cbiAgICBFbXB0eVByb3h5LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge307XG5cbiAgICB2YXIgaGFuZGxlck5hbWVzID0gW1xuICAgICAgICAnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2V3aGVlbCcsICdtb3VzZW91dCcsXG4gICAgICAgICdtb3VzZXVwJywgJ21vdXNlZG93bicsICdtb3VzZW1vdmUnXG4gICAgXTtcbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvSGFuZGxlclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcm9vdCBNYWluIEhUTUwgZWxlbWVudCBmb3IgcGFpbnRpbmcuXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9TdG9yYWdlfSBzdG9yYWdlIFN0b3JhZ2UgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9QYWludGVyfSBwYWludGVyIFBhaW50ZXIgaW5zdGFuY2UuXG4gICAgICovXG4gICAgdmFyIEhhbmRsZXIgPSBmdW5jdGlvbihzdG9yYWdlLCBwYWludGVyLCBwcm94eSkge1xuICAgICAgICBFdmVudGZ1bC5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG5cbiAgICAgICAgdGhpcy5wYWludGVyID0gcGFpbnRlcjtcblxuICAgICAgICBwcm94eSA9IHByb3h5IHx8IG5ldyBFbXB0eVByb3h5KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm94eSBvZiBldmVudC4gY2FuIGJlIERvbSwgV2ViR0xTdXJmYWNlLCBldGMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb3h5ID0gcHJveHk7XG5cbiAgICAgICAgLy8gQXR0YWNoIGhhbmRsZXJcbiAgICAgICAgcHJveHkuaGFuZGxlciA9IHRoaXM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faG92ZXJlZDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge0RhdGV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sYXN0VG91Y2hNb21lbnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sYXN0WDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xhc3RZO1xuXG5cbiAgICAgICAgRHJhZ2dhYmxlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdXRpbC5lYWNoKGhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHByb3h5Lm9uICYmIHByb3h5Lm9uKG5hbWUsIHRoaXNbbmFtZV0sIHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9O1xuXG4gICAgSGFuZGxlci5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IEhhbmRsZXIsXG5cbiAgICAgICAgbW91c2Vtb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciB4ID0gZXZlbnQuenJYO1xuICAgICAgICAgICAgdmFyIHkgPSBldmVudC56clk7XG5cbiAgICAgICAgICAgIHZhciBob3ZlcmVkID0gdGhpcy5maW5kSG92ZXIoeCwgeSwgbnVsbCk7XG4gICAgICAgICAgICB2YXIgbGFzdEhvdmVyZWQgPSB0aGlzLl9ob3ZlcmVkO1xuICAgICAgICAgICAgdmFyIHByb3h5ID0gdGhpcy5wcm94eTtcblxuICAgICAgICAgICAgdGhpcy5faG92ZXJlZCA9IGhvdmVyZWQ7XG5cbiAgICAgICAgICAgIHByb3h5LnNldEN1cnNvciAmJiBwcm94eS5zZXRDdXJzb3IoaG92ZXJlZCA/IGhvdmVyZWQuY3Vyc29yIDogJ2RlZmF1bHQnKTtcblxuICAgICAgICAgICAgLy8gTW91c2Ugb3V0IG9uIHByZXZpb3VzIGhvdmVyZWQgZWxlbWVudFxuICAgICAgICAgICAgaWYgKGxhc3RIb3ZlcmVkICYmIGhvdmVyZWQgIT09IGxhc3RIb3ZlcmVkICYmIGxhc3RIb3ZlcmVkLl9fenIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGxhc3RIb3ZlcmVkLCAnbW91c2VvdXQnLCBldmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1vdXNlIG1vdmluZyBvbiBvbmUgZWxlbWVudFxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChob3ZlcmVkLCAnbW91c2Vtb3ZlJywgZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyBNb3VzZSBvdmVyIG9uIGEgbmV3IGVsZW1lbnRcbiAgICAgICAgICAgIGlmIChob3ZlcmVkICYmIGhvdmVyZWQgIT09IGxhc3RIb3ZlcmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChob3ZlcmVkLCAnbW91c2VvdmVyJywgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1vdXNlb3V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQodGhpcy5faG92ZXJlZCwgJ21vdXNlb3V0JywgZXZlbnQpO1xuXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2dsb2JhbG91dCcsIHtcbiAgICAgICAgICAgICAgICBldmVudDogZXZlbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNpemVcbiAgICAgICAgICovXG4gICAgICAgIHJlc2l6ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9ob3ZlcmVkID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGF0Y2ggZXZlbnRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICAgICAgICAgKiBAcGFyYW0ge2V2ZW50PX0gZXZlbnRBcmdzXG4gICAgICAgICAqL1xuICAgICAgICBkaXNwYXRjaDogZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnRBcmdzKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXNbZXZlbnROYW1lXTtcbiAgICAgICAgICAgIGhhbmRsZXIgJiYgaGFuZGxlci5jYWxsKHRoaXMsIGV2ZW50QXJncyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3Bvc2VcbiAgICAgICAgICovXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgdGhpcy5wcm94eS5kaXNwb3NlKCk7XG5cbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZSA9XG4gICAgICAgICAgICB0aGlzLnByb3h5ID1cbiAgICAgICAgICAgIHRoaXMucGFpbnRlciA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuvue9rum7mOiupOeahGN1cnNvciBzdHlsZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvclN0eWxlPSdkZWZhdWx0J10g5L6L5aaCIGNyb3NzaGFpclxuICAgICAgICAgKi9cbiAgICAgICAgc2V0Q3Vyc29yU3R5bGU6IGZ1bmN0aW9uIChjdXJzb3JTdHlsZSkge1xuICAgICAgICAgICAgdmFyIHByb3h5ID0gdGhpcy5wcm94eTtcbiAgICAgICAgICAgIHByb3h5LnNldEN1cnNvciAmJiBwcm94eS5zZXRDdXJzb3IoY3Vyc29yU3R5bGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDkuovku7bliIblj5Hku6PnkIZcbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldEVsIOebruagh+WbvuW9ouWFg+e0oFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIOS6i+S7tuWQjeensFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQg5LqL5Lu25a+56LGhXG4gICAgICAgICAqL1xuICAgICAgICBkaXNwYXRjaFRvRWxlbWVudDogZnVuY3Rpb24gKHRhcmdldEVsLCBldmVudE5hbWUsIGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRIYW5kbGVyID0gJ29uJyArIGV2ZW50TmFtZTtcbiAgICAgICAgICAgIHZhciBldmVudFBhY2tldCA9IG1ha2VFdmVudFBhY2tldChldmVudE5hbWUsIHRhcmdldEVsLCBldmVudCk7XG5cbiAgICAgICAgICAgIHZhciBlbCA9IHRhcmdldEVsO1xuXG4gICAgICAgICAgICB3aGlsZSAoZWwpIHtcbiAgICAgICAgICAgICAgICBlbFtldmVudEhhbmRsZXJdXG4gICAgICAgICAgICAgICAgICAgICYmIChldmVudFBhY2tldC5jYW5jZWxCdWJibGUgPSBlbFtldmVudEhhbmRsZXJdLmNhbGwoZWwsIGV2ZW50UGFja2V0KSk7XG5cbiAgICAgICAgICAgICAgICBlbC50cmlnZ2VyKGV2ZW50TmFtZSwgZXZlbnRQYWNrZXQpO1xuXG4gICAgICAgICAgICAgICAgZWwgPSBlbC5wYXJlbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRQYWNrZXQuY2FuY2VsQnViYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFldmVudFBhY2tldC5jYW5jZWxCdWJibGUpIHtcbiAgICAgICAgICAgICAgICAvLyDlhpLms6HliLDpobbnuqcgenJlbmRlciDlr7nosaFcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoZXZlbnROYW1lLCBldmVudFBhY2tldCk7XG4gICAgICAgICAgICAgICAgLy8g5YiG5Y+R5LqL5Lu25Yiw55So5oi36Ieq5a6a5LmJ5bGCXG4gICAgICAgICAgICAgICAgLy8g55So5oi35pyJ5Y+v6IO95Zyo5YWo5bGAIGNsaWNrIOS6i+S7tuS4rSBkaXNwb3Nl77yM5omA5Lul6ZyA6KaB5Yik5pat5LiLIHBhaW50ZXIg5piv5ZCm5a2Y5ZyoXG4gICAgICAgICAgICAgICAgdGhpcy5wYWludGVyICYmIHRoaXMucGFpbnRlci5lYWNoT3RoZXJMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZihsYXllcltldmVudEhhbmRsZXJdKSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllcltldmVudEhhbmRsZXJdLmNhbGwobGF5ZXIsIGV2ZW50UGFja2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobGF5ZXIudHJpZ2dlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXIudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50UGFja2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGV9IGV4Y2x1ZGVcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKi9cbiAgICAgICAgZmluZEhvdmVyOiBmdW5jdGlvbih4LCB5LCBleGNsdWRlKSB7XG4gICAgICAgICAgICB2YXIgbGlzdCA9IHRoaXMuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwIDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsaXN0W2ldLnNpbGVudFxuICAgICAgICAgICAgICAgICAmJiBsaXN0W2ldICE9PSBleGNsdWRlXG4gICAgICAgICAgICAgICAgIC8vIGdldERpc3BsYXlMaXN0IG1heSBpbmNsdWRlIGlnbm9yZWQgaXRlbSBpbiBWTUwgbW9kZVxuICAgICAgICAgICAgICAgICAmJiAhbGlzdFtpXS5pZ25vcmVcbiAgICAgICAgICAgICAgICAgJiYgaXNIb3ZlcihsaXN0W2ldLCB4LCB5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGlzdFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQ29tbW9uIGhhbmRsZXJzXG4gICAgdXRpbC5lYWNoKFsnY2xpY2snLCAnbW91c2Vkb3duJywgJ21vdXNldXAnLCAnbW91c2V3aGVlbCcsICdkYmxjbGljayddLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBIYW5kbGVyLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgLy8gRmluZCBob3ZlciBhZ2FpbiB0byBhdm9pZCBjbGljayBldmVudCBpcyBkaXNwYXRjaGVkIG1hbnVhbGx5LiBPciBjbGljayBpcyB0cmlnZ2VyZWQgd2l0aG91dCBtb3VzZW92ZXJcbiAgICAgICAgICAgIHZhciBob3ZlcmVkID0gdGhpcy5maW5kSG92ZXIoZXZlbnQuenJYLCBldmVudC56clksIG51bGwpO1xuXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ21vdXNlZG93bicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kb3duZWwgPSBob3ZlcmVkO1xuICAgICAgICAgICAgICAgIC8vIEluIGNhc2UgY2xpY2sgdHJpZ2dlcmVkIGJlZm9yZSBtb3VzZXVwXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBlbCA9IGhvdmVyZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnbW9zdWV1cCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGVsID0gaG92ZXJlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdjbGljaycpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZG93bmVsICE9PSB0aGlzLl91cGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQoaG92ZXJlZCwgbmFtZSwgZXZlbnQpO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gaXNIb3ZlcihkaXNwbGF5YWJsZSwgeCwgeSkge1xuICAgICAgICBpZiAoZGlzcGxheWFibGVbZGlzcGxheWFibGUucmVjdEhvdmVyID8gJ3JlY3RDb250YWluJyA6ICdjb250YWluJ10oeCwgeSkpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IGRpc3BsYXlhYmxlO1xuICAgICAgICAgICAgd2hpbGUgKGVsKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYW5jZXN0b3IgaXMgc2lsZW50IG9yIGNsaXBwZWQgYnkgYW5jZXN0b3JcbiAgICAgICAgICAgICAgICBpZiAoZWwuc2lsZW50IHx8IChlbC5jbGlwUGF0aCAmJiAhZWwuY2xpcFBhdGguY29udGFpbih4LCB5KSkpICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWwgPSBlbC5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB1dGlsLm1peGluKEhhbmRsZXIsIEV2ZW50ZnVsKTtcbiAgICB1dGlsLm1peGluKEhhbmRsZXIsIERyYWdnYWJsZSk7XG5cbiAgICByZXR1cm4gSGFuZGxlcjtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvenJlbmRlci9IYW5kbGVyLmpzXG4gKiogbW9kdWxlIGlkID0gODZcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsIi8vIFRPRE8gRHJhZ2dhYmxlIGZvciBncm91cFxuLy8gRklYTUUgRHJhZ2dhYmxlIG9uIGVsZW1lbnQgd2hpY2ggaGFzIHBhcmVudCByb3RhdGlvbiBvciBzY2FsZVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG4gICAgZnVuY3Rpb24gRHJhZ2dhYmxlKCkge1xuXG4gICAgICAgIHRoaXMub24oJ21vdXNlZG93bicsIHRoaXMuX2RyYWdTdGFydCwgdGhpcyk7XG4gICAgICAgIHRoaXMub24oJ21vdXNlbW92ZScsIHRoaXMuX2RyYWcsIHRoaXMpO1xuICAgICAgICB0aGlzLm9uKCdtb3VzZXVwJywgdGhpcy5fZHJhZ0VuZCwgdGhpcyk7XG4gICAgICAgIHRoaXMub24oJ2dsb2JhbG91dCcsIHRoaXMuX2RyYWdFbmQsIHRoaXMpO1xuICAgICAgICAvLyB0aGlzLl9kcm9wVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgLy8gdGhpcy5fZHJhZ2dpbmdUYXJnZXQgPSBudWxsO1xuXG4gICAgICAgIC8vIHRoaXMuX3ggPSAwO1xuICAgICAgICAvLyB0aGlzLl95ID0gMDtcbiAgICB9XG5cbiAgICBEcmFnZ2FibGUucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBEcmFnZ2FibGUsXG5cbiAgICAgICAgX2RyYWdTdGFydDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBkcmFnZ2luZ1RhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGRyYWdnaW5nVGFyZ2V0ICYmIGRyYWdnaW5nVGFyZ2V0LmRyYWdnYWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdnaW5nVGFyZ2V0ID0gZHJhZ2dpbmdUYXJnZXQ7XG4gICAgICAgICAgICAgICAgZHJhZ2dpbmdUYXJnZXQuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ggPSBlLm9mZnNldFg7XG4gICAgICAgICAgICAgICAgdGhpcy5feSA9IGUub2Zmc2V0WTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQoZHJhZ2dpbmdUYXJnZXQsICdkcmFnc3RhcnQnLCBlLmV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfZHJhZzogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBkcmFnZ2luZ1RhcmdldCA9IHRoaXMuX2RyYWdnaW5nVGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGRyYWdnaW5nVGFyZ2V0KSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgeCA9IGUub2Zmc2V0WDtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IGUub2Zmc2V0WTtcblxuICAgICAgICAgICAgICAgIHZhciBkeCA9IHggLSB0aGlzLl94O1xuICAgICAgICAgICAgICAgIHZhciBkeSA9IHkgLSB0aGlzLl95O1xuICAgICAgICAgICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSB5O1xuXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmdUYXJnZXQuZHJpZnQoZHgsIGR5LCBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGRyYWdnaW5nVGFyZ2V0LCAnZHJhZycsIGUuZXZlbnQpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRyb3BUYXJnZXQgPSB0aGlzLmZpbmRIb3Zlcih4LCB5LCBkcmFnZ2luZ1RhcmdldCk7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3REcm9wVGFyZ2V0ID0gdGhpcy5fZHJvcFRhcmdldDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcm9wVGFyZ2V0ID0gZHJvcFRhcmdldDtcblxuICAgICAgICAgICAgICAgIGlmIChkcmFnZ2luZ1RhcmdldCAhPT0gZHJvcFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdERyb3BUYXJnZXQgJiYgZHJvcFRhcmdldCAhPT0gbGFzdERyb3BUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQobGFzdERyb3BUYXJnZXQsICdkcmFnbGVhdmUnLCBlLmV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZHJvcFRhcmdldCAmJiBkcm9wVGFyZ2V0ICE9PSBsYXN0RHJvcFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChkcm9wVGFyZ2V0LCAnZHJhZ2VudGVyJywgZS5ldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgZHJhZ2dpbmdUYXJnZXQgPSB0aGlzLl9kcmFnZ2luZ1RhcmdldDtcblxuICAgICAgICAgICAgaWYgKGRyYWdnaW5nVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgZHJhZ2dpbmdUYXJnZXQuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChkcmFnZ2luZ1RhcmdldCwgJ2RyYWdlbmQnLCBlLmV2ZW50KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2Ryb3BUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHRoaXMuX2Ryb3BUYXJnZXQsICdkcm9wJywgZS5ldmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2RyYWdnaW5nVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2Ryb3BUYXJnZXQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgcmV0dXJuIERyYWdnYWJsZTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvenJlbmRlci9taXhpbi9EcmFnZ2FibGUuanNcbiAqKiBtb2R1bGUgaWQgPSA4N1xuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiLyoqXG4gKiBTdG9yYWdl5YaF5a655LuT5bqT5qih5Z2XXG4gKiBAbW9kdWxlIHpyZW5kZXIvU3RvcmFnZVxuICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiBAYXV0aG9yIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKiBAYXV0aG9yIHBpc3NhbmcgKGh0dHBzOi8vZ2l0aHViLmNvbS9waXNzYW5nLylcbiAqL1xuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vY29yZS91dGlsJyk7XG4gICAgdmFyIGVudiA9IHJlcXVpcmUoJy4vY29yZS9lbnYnKTtcblxuICAgIHZhciBHcm91cCA9IHJlcXVpcmUoJy4vY29udGFpbmVyL0dyb3VwJyk7XG5cbiAgICAvLyBVc2UgdGltc29ydCBiZWNhdXNlIGluIG1vc3QgY2FzZSBlbGVtZW50cyBhcmUgcGFydGlhbGx5IHNvcnRlZFxuICAgIC8vIGh0dHBzOi8vanNmaWRkbGUubmV0L3Bpc3NhbmcvanI0eDdtZG0vOC9cbiAgICB2YXIgdGltc29ydCA9IHJlcXVpcmUoJy4vY29yZS90aW1zb3J0Jyk7XG5cbiAgICBmdW5jdGlvbiBzaGFwZUNvbXBhcmVGdW5jKGEsIGIpIHtcbiAgICAgICAgaWYgKGEuemxldmVsID09PSBiLnpsZXZlbCkge1xuICAgICAgICAgICAgaWYgKGEueiA9PT0gYi56KSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgKGEuejIgPT09IGIuejIpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgLy8gRklYTUUgU2xvdyBoYXMgcmVuZGVyaWR4IGNvbXBhcmVcbiAgICAgICAgICAgICAgICAvLyAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMDg4MzQyMS9zb3J0aW5nLWluLWphdmFzY3JpcHQtc2hvdWxkLWV2ZXJ5LWNvbXBhcmUtZnVuY3Rpb24taGF2ZS1hLXJldHVybi0wLXN0YXRlbWVudFxuICAgICAgICAgICAgICAgIC8vICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdjgvdjgvYmxvYi80N2NjZTU0NGEzMWVkNTU3N2ZmZTI5NjNmNjdhY2I0MTQ0ZWUwMjMyL3NyYy9qcy9hcnJheS5qcyNMMTAxMlxuICAgICAgICAgICAgICAgIC8vICAgICByZXR1cm4gYS5fX3JlbmRlcmlkeCAtIGIuX19yZW5kZXJpZHg7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIHJldHVybiBhLnoyIC0gYi56MjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhLnogLSBiLno7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGEuemxldmVsIC0gYi56bGV2ZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOWGheWuueS7k+W6kyAoTSlcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvU3RvcmFnZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBTdG9yYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyDmiYDmnInluLjop4TlvaLnirbvvIxpZOe0ouW8leeahG1hcFxuICAgICAgICB0aGlzLl9lbGVtZW50cyA9IHt9O1xuXG4gICAgICAgIHRoaXMuX3Jvb3RzID0gW107XG5cbiAgICAgICAgdGhpcy5fZGlzcGxheUxpc3QgPSBbXTtcblxuICAgICAgICB0aGlzLl9kaXNwbGF5TGlzdExlbiA9IDA7XG4gICAgfTtcblxuICAgIFN0b3JhZ2UucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBTdG9yYWdlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHRyYXZlcnNlOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yb290c1tpXS50cmF2ZXJzZShjYiwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOi/lOWbnuaJgOacieWbvuW9oueahOe7mOWItumYn+WIl1xuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1cGRhdGU9ZmFsc2VdIOaYr+WQpuWcqOi/lOWbnuWJjeabtOaWsOivpeaVsOe7hFxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdWRlSWdub3JlPWZhbHNlXSDmmK/lkKbljIXlkKsgaWdub3JlIOeahOaVsOe7hCwg5ZyoIHVwZGF0ZSDkuLogdHJ1ZSDnmoTml7blgJnmnInmlYhcbiAgICAgICAgICpcbiAgICAgICAgICog6K+m6KeBe0BsaW5rIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUucHJvdG90eXBlLnVwZGF0ZURpc3BsYXlMaXN0fVxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZT59XG4gICAgICAgICAqL1xuICAgICAgICBnZXREaXNwbGF5TGlzdDogZnVuY3Rpb24gKHVwZGF0ZSwgaW5jbHVkZUlnbm9yZSkge1xuICAgICAgICAgICAgaW5jbHVkZUlnbm9yZSA9IGluY2x1ZGVJZ25vcmUgfHwgZmFsc2U7XG4gICAgICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVEaXNwbGF5TGlzdChpbmNsdWRlSWdub3JlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXNwbGF5TGlzdDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5pu05paw5Zu+5b2i55qE57uY5Yi26Zif5YiX44CCXG4gICAgICAgICAqIOavj+asoee7mOWItuWJjemDveS8muiwg+eUqO+8jOivpeaWueazleS8muWFiOa3seW6puS8mOWFiOmBjeWOhuaVtOS4quagke+8jOabtOaWsOaJgOaciUdyb3Vw5ZKMU2hhcGXnmoTlj5jmjaLlubbkuJTmiormiYDmnInlj6/op4HnmoRTaGFwZeS/neWtmOWIsOaVsOe7hOS4re+8jFxuICAgICAgICAgKiDmnIDlkI7moLnmja7nu5jliLbnmoTkvJjlhYjnuqfvvIh6bGV2ZWwgPiB6ID4g5o+S5YWl6aG65bqP77yJ5o6S5bqP5b6X5Yiw57uY5Yi26Zif5YiXXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVJZ25vcmU9ZmFsc2VdIOaYr+WQpuWMheWQqyBpZ25vcmUg55qE5pWw57uEXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVEaXNwbGF5TGlzdDogZnVuY3Rpb24gKGluY2x1ZGVJZ25vcmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXlMaXN0TGVuID0gMDtcbiAgICAgICAgICAgIHZhciByb290cyA9IHRoaXMuX3Jvb3RzO1xuICAgICAgICAgICAgdmFyIGRpc3BsYXlMaXN0ID0gdGhpcy5fZGlzcGxheUxpc3Q7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcm9vdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVBbmRBZGREaXNwbGF5YWJsZShyb290c1tpXSwgbnVsbCwgaW5jbHVkZUlnbm9yZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXNwbGF5TGlzdC5sZW5ndGggPSB0aGlzLl9kaXNwbGF5TGlzdExlbjtcblxuICAgICAgICAgICAgLy8gZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRpc3BsYXlMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAvLyAgICAgZGlzcGxheUxpc3RbaV0uX19yZW5kZXJpZHggPSBpO1xuICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICAvLyBkaXNwbGF5TGlzdC5zb3J0KHNoYXBlQ29tcGFyZUZ1bmMpO1xuICAgICAgICAgICAgZW52LmNhbnZhc1N1cHBvcnRlZCAmJiB0aW1zb3J0KGRpc3BsYXlMaXN0LCBzaGFwZUNvbXBhcmVGdW5jKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfdXBkYXRlQW5kQWRkRGlzcGxheWFibGU6IGZ1bmN0aW9uIChlbCwgY2xpcFBhdGhzLCBpbmNsdWRlSWdub3JlKSB7XG5cbiAgICAgICAgICAgIGlmIChlbC5pZ25vcmUgJiYgIWluY2x1ZGVJZ25vcmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsLmJlZm9yZVVwZGF0ZSgpO1xuXG4gICAgICAgICAgICBpZiAoZWwuX19kaXJ0eSkge1xuXG4gICAgICAgICAgICAgICAgZWwudXBkYXRlKCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWwuYWZ0ZXJVcGRhdGUoKTtcblxuICAgICAgICAgICAgdmFyIGNsaXBQYXRoID0gZWwuY2xpcFBhdGg7XG4gICAgICAgICAgICBpZiAoY2xpcFBhdGgpIHtcbiAgICAgICAgICAgICAgICAvLyBjbGlwUGF0aCDnmoTlj5jmjaLmmK/ln7rkuo4gZ3JvdXAg55qE5Y+Y5o2iXG4gICAgICAgICAgICAgICAgY2xpcFBhdGgucGFyZW50ID0gZWw7XG4gICAgICAgICAgICAgICAgY2xpcFBhdGgudXBkYXRlVHJhbnNmb3JtKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBGSVhNRSDmlYjnjoflvbHlk41cbiAgICAgICAgICAgICAgICBpZiAoY2xpcFBhdGhzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsaXBQYXRocyA9IGNsaXBQYXRocy5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICBjbGlwUGF0aHMucHVzaChjbGlwUGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjbGlwUGF0aHMgPSBbY2xpcFBhdGhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVsLmlzR3JvdXApIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBlbC5fY2hpbGRyZW47XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvcmNlIHRvIG1hcmsgYXMgZGlydHkgaWYgZ3JvdXAgaXMgZGlydHlcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgX19kaXJ0eVBhdGggP1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWwuX19kaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuX19kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVBbmRBZGREaXNwbGF5YWJsZShjaGlsZCwgY2xpcFBhdGhzLCBpbmNsdWRlSWdub3JlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBNYXJrIGdyb3VwIGNsZWFuIGhlcmVcbiAgICAgICAgICAgICAgICBlbC5fX2RpcnR5ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsLl9fY2xpcFBhdGhzID0gY2xpcFBhdGhzO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGxheUxpc3RbdGhpcy5fZGlzcGxheUxpc3RMZW4rK10gPSBlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5re75Yqg5Zu+5b2iKFNoYXBlKeaIluiAhee7hChHcm91cCnliLDmoLnoioLngrlcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgICAgICAgKi9cbiAgICAgICAgYWRkUm9vdDogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAvLyBFbGVtZW50IGhhcyBiZWVuIGFkZGVkXG4gICAgICAgICAgICBpZiAodGhpcy5fZWxlbWVudHNbZWwuaWRdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWwgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgICAgIGVsLmFkZENoaWxkcmVuVG9TdG9yYWdlKHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmFkZFRvTWFwKGVsKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RzLnB1c2goZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliKDpmaTmjIflrprnmoTlm77lvaIoU2hhcGUp5oiW6ICF57uEKEdyb3VwKVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gW2VsSWRdIOWmguaenOS4uuepuua4heepuuaVtOS4qlN0b3JhZ2VcbiAgICAgICAgICovXG4gICAgICAgIGRlbFJvb3Q6IGZ1bmN0aW9uIChlbElkKSB7XG4gICAgICAgICAgICBpZiAoZWxJZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8g5LiN5oyH5a6aZWxJZOa4heepulxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvb3QgPSB0aGlzLl9yb290c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvb3QgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdC5kZWxDaGlsZHJlbkZyb21TdG9yYWdlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudHMgPSB7fTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yb290cyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXlMaXN0ID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGxheUxpc3RMZW4gPSAwO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWxJZCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbElkLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbFJvb3QoZWxJZFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGVsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZihlbElkKSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGVsID0gdGhpcy5fZWxlbWVudHNbZWxJZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbCA9IGVsSWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpZHggPSB1dGlsLmluZGV4T2YodGhpcy5fcm9vdHMsIGVsKTtcbiAgICAgICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsRnJvbU1hcChlbC5pZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcm9vdHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGVsIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkVG9NYXA6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKGVsIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICBlbC5fX3N0b3JhZ2UgPSB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWwuZGlydHkoZmFsc2UpO1xuXG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50c1tlbC5pZF0gPSBlbDtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoZWxJZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRzW2VsSWRdO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRlbEZyb21NYXA6IGZ1bmN0aW9uIChlbElkKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLl9lbGVtZW50cztcbiAgICAgICAgICAgIHZhciBlbCA9IGVsZW1lbnRzW2VsSWRdO1xuICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnRzW2VsSWRdO1xuICAgICAgICAgICAgICAgIGlmIChlbCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLl9fc3RvcmFnZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5riF56m65bm25LiU6YeK5pS+U3RvcmFnZVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudHMgPVxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyTGlzdCA9XG4gICAgICAgICAgICB0aGlzLl9yb290cyA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlzcGxheWFibGVTb3J0RnVuYzogc2hhcGVDb21wYXJlRnVuY1xuICAgIH07XG5cbiAgICByZXR1cm4gU3RvcmFnZTtcbn0pO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC96cmVuZGVyL1N0b3JhZ2UuanNcbiAqKiBtb2R1bGUgaWQgPSA4OFxuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL216aWNjYXJkL25vZGUtdGltc29ydFxuZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgREVGQVVMVF9NSU5fTUVSR0UgPSAzMjtcblxuICAgIHZhciBERUZBVUxUX01JTl9HQUxMT1BJTkcgPSA3O1xuXG4gICAgdmFyIERFRkFVTFRfVE1QX1NUT1JBR0VfTEVOR1RIID0gMjU2O1xuXG4gICAgZnVuY3Rpb24gbWluUnVuTGVuZ3RoKG4pIHtcbiAgICAgICAgdmFyIHIgPSAwO1xuXG4gICAgICAgIHdoaWxlIChuID49IERFRkFVTFRfTUlOX01FUkdFKSB7XG4gICAgICAgICAgICByIHw9IG4gJiAxO1xuICAgICAgICAgICAgbiA+Pj0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuICsgcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlQXNjZW5kaW5nUnVuKGFycmF5LCBsbywgaGksIGNvbXBhcmUpIHtcbiAgICAgICAgdmFyIHJ1bkhpID0gbG8gKyAxO1xuXG4gICAgICAgIGlmIChydW5IaSA9PT0gaGkpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbXBhcmUoYXJyYXlbcnVuSGkrK10sIGFycmF5W2xvXSkgPCAwKSB7XG4gICAgICAgICAgICB3aGlsZSAocnVuSGkgPCBoaSAmJiBjb21wYXJlKGFycmF5W3J1bkhpXSwgYXJyYXlbcnVuSGkgLSAxXSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSGkrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV2ZXJzZVJ1bihhcnJheSwgbG8sIHJ1bkhpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlIChydW5IaSA8IGhpICYmIGNvbXBhcmUoYXJyYXlbcnVuSGldLCBhcnJheVtydW5IaSAtIDFdKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBydW5IaSAtIGxvO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJldmVyc2VSdW4oYXJyYXksIGxvLCBoaSkge1xuICAgICAgICBoaS0tO1xuXG4gICAgICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICAgICAgICB2YXIgdCA9IGFycmF5W2xvXTtcbiAgICAgICAgICAgIGFycmF5W2xvKytdID0gYXJyYXlbaGldO1xuICAgICAgICAgICAgYXJyYXlbaGktLV0gPSB0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYmluYXJ5SW5zZXJ0aW9uU29ydChhcnJheSwgbG8sIGhpLCBzdGFydCwgY29tcGFyZSkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IGxvKSB7XG4gICAgICAgICAgICBzdGFydCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7IHN0YXJ0IDwgaGk7IHN0YXJ0KyspIHtcbiAgICAgICAgICAgIHZhciBwaXZvdCA9IGFycmF5W3N0YXJ0XTtcblxuICAgICAgICAgICAgdmFyIGxlZnQgPSBsbztcbiAgICAgICAgICAgIHZhciByaWdodCA9IHN0YXJ0O1xuICAgICAgICAgICAgdmFyIG1pZDtcblxuICAgICAgICAgICAgd2hpbGUgKGxlZnQgPCByaWdodCkge1xuICAgICAgICAgICAgICAgIG1pZCA9IGxlZnQgKyByaWdodCA+Pj4gMTtcblxuICAgICAgICAgICAgICAgIGlmIChjb21wYXJlKHBpdm90LCBhcnJheVttaWRdKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSBtaWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbWlkICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuID0gc3RhcnQgLSBsZWZ0O1xuXG4gICAgICAgICAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2xlZnQgKyAzXSA9IGFycmF5W2xlZnQgKyAyXTtcblxuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbbGVmdCArIDJdID0gYXJyYXlbbGVmdCArIDFdO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBhcnJheVtsZWZ0ICsgMV0gPSBhcnJheVtsZWZ0XTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG4gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVtsZWZ0ICsgbl0gPSBhcnJheVtsZWZ0ICsgbiAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbi0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFycmF5W2xlZnRdID0gcGl2b3Q7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnYWxsb3BMZWZ0KHZhbHVlLCBhcnJheSwgc3RhcnQsIGxlbmd0aCwgaGludCwgY29tcGFyZSkge1xuICAgICAgICB2YXIgbGFzdE9mZnNldCA9IDA7XG4gICAgICAgIHZhciBtYXhPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gMTtcblxuICAgICAgICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50XSkgPiAwKSB7XG4gICAgICAgICAgICBtYXhPZmZzZXQgPSBsZW5ndGggLSBoaW50O1xuXG4gICAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgbWF4T2Zmc2V0ICYmIGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludCArIG9mZnNldF0pID4gMCkge1xuICAgICAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGFzdE9mZnNldCArPSBoaW50O1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGhpbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtYXhPZmZzZXQgPSBoaW50ICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50IC0gb2Zmc2V0XSkgPD0gMCkge1xuICAgICAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0bXAgPSBsYXN0T2Zmc2V0O1xuICAgICAgICAgICAgbGFzdE9mZnNldCA9IGhpbnQgLSBvZmZzZXQ7XG4gICAgICAgICAgICBvZmZzZXQgPSBoaW50IC0gdG1wO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdE9mZnNldCsrO1xuICAgICAgICB3aGlsZSAobGFzdE9mZnNldCA8IG9mZnNldCkge1xuICAgICAgICAgICAgdmFyIG0gPSBsYXN0T2Zmc2V0ICsgKG9mZnNldCAtIGxhc3RPZmZzZXQgPj4+IDEpO1xuXG4gICAgICAgICAgICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBtXSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGFzdE9mZnNldCA9IG0gKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdhbGxvcFJpZ2h0KHZhbHVlLCBhcnJheSwgc3RhcnQsIGxlbmd0aCwgaGludCwgY29tcGFyZSkge1xuICAgICAgICB2YXIgbGFzdE9mZnNldCA9IDA7XG4gICAgICAgIHZhciBtYXhPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gMTtcblxuICAgICAgICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50XSkgPCAwKSB7XG4gICAgICAgICAgICBtYXhPZmZzZXQgPSBoaW50ICsgMTtcblxuICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgLSBvZmZzZXRdKSA8IDApIHtcbiAgICAgICAgICAgICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0bXAgPSBsYXN0T2Zmc2V0O1xuICAgICAgICAgICAgbGFzdE9mZnNldCA9IGhpbnQgLSBvZmZzZXQ7XG4gICAgICAgICAgICBvZmZzZXQgPSBoaW50IC0gdG1wO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWF4T2Zmc2V0ID0gbGVuZ3RoIC0gaGludDtcblxuICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IG1heE9mZnNldCAmJiBjb21wYXJlKHZhbHVlLCBhcnJheVtzdGFydCArIGhpbnQgKyBvZmZzZXRdKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAob2Zmc2V0IDw8IDEpICsgMTtcblxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXN0T2Zmc2V0ICs9IGhpbnQ7XG4gICAgICAgICAgICBvZmZzZXQgKz0gaGludDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RPZmZzZXQrKztcblxuICAgICAgICB3aGlsZSAobGFzdE9mZnNldCA8IG9mZnNldCkge1xuICAgICAgICAgICAgdmFyIG0gPSBsYXN0T2Zmc2V0ICsgKG9mZnNldCAtIGxhc3RPZmZzZXQgPj4+IDEpO1xuXG4gICAgICAgICAgICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBtXSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBtICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVGltU29ydChhcnJheSwgY29tcGFyZSkge1xuICAgICAgICB2YXIgbWluR2FsbG9wID0gREVGQVVMVF9NSU5fR0FMTE9QSU5HO1xuICAgICAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIHRtcFN0b3JhZ2VMZW5ndGggPSBERUZBVUxUX1RNUF9TVE9SQUdFX0xFTkdUSDtcbiAgICAgICAgdmFyIHN0YWNrTGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIHJ1blN0YXJ0O1xuICAgICAgICB2YXIgcnVuTGVuZ3RoO1xuICAgICAgICB2YXIgc3RhY2tTaXplID0gMDtcblxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGxlbmd0aCA8IDIgKiBERUZBVUxUX1RNUF9TVE9SQUdFX0xFTkdUSCkge1xuICAgICAgICAgICAgdG1wU3RvcmFnZUxlbmd0aCA9IGxlbmd0aCA+Pj4gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0bXAgPSBbXTtcblxuICAgICAgICBzdGFja0xlbmd0aCA9IGxlbmd0aCA8IDEyMCA/IDUgOiBsZW5ndGggPCAxNTQyID8gMTAgOiBsZW5ndGggPCAxMTkxNTEgPyAxOSA6IDQwO1xuXG4gICAgICAgIHJ1blN0YXJ0ID0gW107XG4gICAgICAgIHJ1bkxlbmd0aCA9IFtdO1xuXG4gICAgICAgIGZ1bmN0aW9uIHB1c2hSdW4oX3J1blN0YXJ0LCBfcnVuTGVuZ3RoKSB7XG4gICAgICAgICAgICBydW5TdGFydFtzdGFja1NpemVdID0gX3J1blN0YXJ0O1xuICAgICAgICAgICAgcnVuTGVuZ3RoW3N0YWNrU2l6ZV0gPSBfcnVuTGVuZ3RoO1xuICAgICAgICAgICAgc3RhY2tTaXplICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtZXJnZVJ1bnMoKSB7XG4gICAgICAgICAgICB3aGlsZSAoc3RhY2tTaXplID4gMSkge1xuICAgICAgICAgICAgICAgIHZhciBuID0gc3RhY2tTaXplIC0gMjtcblxuICAgICAgICAgICAgICAgIGlmIChuID49IDEgJiYgcnVuTGVuZ3RoW24gLSAxXSA8PSBydW5MZW5ndGhbbl0gKyBydW5MZW5ndGhbbiArIDFdIHx8IG4gPj0gMiAmJiBydW5MZW5ndGhbbiAtIDJdIDw9IHJ1bkxlbmd0aFtuXSArIHJ1bkxlbmd0aFtuIC0gMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bkxlbmd0aFtuIC0gMV0gPCBydW5MZW5ndGhbbiArIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocnVuTGVuZ3RoW25dID4gcnVuTGVuZ3RoW24gKyAxXSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWVyZ2VBdChuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGZvcmNlTWVyZ2VSdW5zKCkge1xuICAgICAgICAgICAgd2hpbGUgKHN0YWNrU2l6ZSA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHN0YWNrU2l6ZSAtIDI7XG5cbiAgICAgICAgICAgICAgICBpZiAobiA+IDAgJiYgcnVuTGVuZ3RoW24gLSAxXSA8IHJ1bkxlbmd0aFtuICsgMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbi0tO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1lcmdlQXQobik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtZXJnZUF0KGkpIHtcbiAgICAgICAgICAgIHZhciBzdGFydDEgPSBydW5TdGFydFtpXTtcbiAgICAgICAgICAgIHZhciBsZW5ndGgxID0gcnVuTGVuZ3RoW2ldO1xuICAgICAgICAgICAgdmFyIHN0YXJ0MiA9IHJ1blN0YXJ0W2kgKyAxXTtcbiAgICAgICAgICAgIHZhciBsZW5ndGgyID0gcnVuTGVuZ3RoW2kgKyAxXTtcblxuICAgICAgICAgICAgcnVuTGVuZ3RoW2ldID0gbGVuZ3RoMSArIGxlbmd0aDI7XG5cbiAgICAgICAgICAgIGlmIChpID09PSBzdGFja1NpemUgLSAzKSB7XG4gICAgICAgICAgICAgICAgcnVuU3RhcnRbaSArIDFdID0gcnVuU3RhcnRbaSArIDJdO1xuICAgICAgICAgICAgICAgIHJ1bkxlbmd0aFtpICsgMV0gPSBydW5MZW5ndGhbaSArIDJdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGFja1NpemUtLTtcblxuICAgICAgICAgICAgdmFyIGsgPSBnYWxsb3BSaWdodChhcnJheVtzdGFydDJdLCBhcnJheSwgc3RhcnQxLCBsZW5ndGgxLCAwLCBjb21wYXJlKTtcbiAgICAgICAgICAgIHN0YXJ0MSArPSBrO1xuICAgICAgICAgICAgbGVuZ3RoMSAtPSBrO1xuXG4gICAgICAgICAgICBpZiAobGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGVuZ3RoMiA9IGdhbGxvcExlZnQoYXJyYXlbc3RhcnQxICsgbGVuZ3RoMSAtIDFdLCBhcnJheSwgc3RhcnQyLCBsZW5ndGgyLCBsZW5ndGgyIC0gMSwgY29tcGFyZSk7XG5cbiAgICAgICAgICAgIGlmIChsZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGVuZ3RoMSA8PSBsZW5ndGgyKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VMb3coc3RhcnQxLCBsZW5ndGgxLCBzdGFydDIsIGxlbmd0aDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VIaWdoKHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1lcmdlTG93KHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKSB7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgxOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0bXBbaV0gPSBhcnJheVtzdGFydDEgKyBpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGN1cnNvcjEgPSAwO1xuICAgICAgICAgICAgdmFyIGN1cnNvcjIgPSBzdGFydDI7XG4gICAgICAgICAgICB2YXIgZGVzdCA9IHN0YXJ0MTtcblxuICAgICAgICAgICAgYXJyYXlbZGVzdCsrXSA9IGFycmF5W2N1cnNvcjIrK107XG5cbiAgICAgICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IHRtcFtjdXJzb3IxICsgaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxlbmd0aDEgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IGFycmF5W2N1cnNvcjIgKyBpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXJyYXlbZGVzdCArIGxlbmd0aDJdID0gdG1wW2N1cnNvcjFdO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIF9taW5HYWxsb3AgPSBtaW5HYWxsb3A7XG4gICAgICAgICAgICB2YXIgY291bnQxLCBjb3VudDIsIGV4aXQ7XG5cbiAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgY291bnQxID0gMDtcbiAgICAgICAgICAgICAgICBjb3VudDIgPSAwO1xuICAgICAgICAgICAgICAgIGV4aXQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUoYXJyYXlbY3Vyc29yMl0sIHRtcFtjdXJzb3IxXSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0KytdID0gYXJyYXlbY3Vyc29yMisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50MisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQxID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdCsrXSA9IHRtcFtjdXJzb3IxKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQxKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudDIgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoKGNvdW50MSB8IGNvdW50MikgPCBfbWluR2FsbG9wKTtcblxuICAgICAgICAgICAgICAgIGlmIChleGl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQxID0gZ2FsbG9wUmlnaHQoYXJyYXlbY3Vyc29yMl0sIHRtcCwgY3Vyc29yMSwgbGVuZ3RoMSwgMCwgY29tcGFyZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50MSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50MTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gdG1wW2N1cnNvcjEgKyBpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdCArPSBjb3VudDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IxICs9IGNvdW50MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aDEgLT0gY291bnQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbmd0aDEgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdCsrXSA9IGFycmF5W2N1cnNvcjIrK107XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvdW50MiA9IGdhbGxvcExlZnQodG1wW2N1cnNvcjFdLCBhcnJheSwgY3Vyc29yMiwgbGVuZ3RoMiwgMCwgY29tcGFyZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50MiAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50MjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gYXJyYXlbY3Vyc29yMiArIGldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0ICs9IGNvdW50MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjIgKz0gY291bnQyO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoMiAtPSBjb3VudDI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdCsrXSA9IHRtcFtjdXJzb3IxKytdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBfbWluR2FsbG9wLS07XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoY291bnQxID49IERFRkFVTFRfTUlOX0dBTExPUElORyB8fCBjb3VudDIgPj0gREVGQVVMVF9NSU5fR0FMTE9QSU5HKTtcblxuICAgICAgICAgICAgICAgIGlmIChleGl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfbWluR2FsbG9wIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBfbWluR2FsbG9wID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfbWluR2FsbG9wICs9IDI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1pbkdhbGxvcCA9IF9taW5HYWxsb3A7XG5cbiAgICAgICAgICAgIG1pbkdhbGxvcCA8IDEgJiYgKG1pbkdhbGxvcCA9IDEpO1xuXG4gICAgICAgICAgICBpZiAobGVuZ3RoMSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbZGVzdCArIGldID0gYXJyYXlbY3Vyc29yMiArIGldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcnJheVtkZXN0ICsgbGVuZ3RoMl0gPSB0bXBbY3Vyc29yMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKCdtZXJnZUxvdyBwcmVjb25kaXRpb25zIHdlcmUgbm90IHJlc3BlY3RlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSB0bXBbY3Vyc29yMSArIGldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1lcmdlSGlnaCAoc3RhcnQxLCBsZW5ndGgxLCBzdGFydDIsIGxlbmd0aDIpIHtcbiAgICAgICAgICAgIHZhciBpID0gMDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICAgICAgICAgIHRtcFtpXSA9IGFycmF5W3N0YXJ0MiArIGldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY3Vyc29yMSA9IHN0YXJ0MSArIGxlbmd0aDEgLSAxO1xuICAgICAgICAgICAgdmFyIGN1cnNvcjIgPSBsZW5ndGgyIC0gMTtcbiAgICAgICAgICAgIHZhciBkZXN0ID0gc3RhcnQyICsgbGVuZ3RoMiAtIDE7XG4gICAgICAgICAgICB2YXIgY3VzdG9tQ3Vyc29yID0gMDtcbiAgICAgICAgICAgIHZhciBjdXN0b21EZXN0ID0gMDtcblxuICAgICAgICAgICAgYXJyYXlbZGVzdC0tXSA9IGFycmF5W2N1cnNvcjEtLV07XG5cbiAgICAgICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjdXN0b21DdXJzb3IgPSBkZXN0IC0gKGxlbmd0aDIgLSAxKTtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV0gPSB0bXBbaV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGVuZ3RoMiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGRlc3QgLT0gbGVuZ3RoMTtcbiAgICAgICAgICAgICAgICBjdXJzb3IxIC09IGxlbmd0aDE7XG4gICAgICAgICAgICAgICAgY3VzdG9tRGVzdCA9IGRlc3QgKyAxO1xuICAgICAgICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGN1cnNvcjEgKyAxO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gbGVuZ3RoMSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2N1c3RvbURlc3QgKyBpXSA9IGFycmF5W2N1c3RvbUN1cnNvciArIGldO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFycmF5W2Rlc3RdID0gdG1wW2N1cnNvcjJdO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIF9taW5HYWxsb3AgPSBtaW5HYWxsb3A7XG5cbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50MSA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50MiA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGV4aXQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUodG1wW2N1cnNvcjJdLCBhcnJheVtjdXJzb3IxXSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVtkZXN0LS1dID0gYXJyYXlbY3Vyc29yMS0tXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50MSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QtLV0gPSB0bXBbY3Vyc29yMi0tXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50MisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQxID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKChjb3VudDEgfCBjb3VudDIpIDwgX21pbkdhbGxvcCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXhpdCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50MSA9IGxlbmd0aDEgLSBnYWxsb3BSaWdodCh0bXBbY3Vyc29yMl0sIGFycmF5LCBzdGFydDEsIGxlbmd0aDEsIGxlbmd0aDEgLSAxLCBjb21wYXJlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQxICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0IC09IGNvdW50MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjEgLT0gY291bnQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoMSAtPSBjb3VudDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IxICsgMTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gY291bnQxIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSBhcnJheVtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QtLV0gPSB0bXBbY3Vyc29yMi0tXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY291bnQyID0gbGVuZ3RoMiAtIGdhbGxvcExlZnQoYXJyYXlbY3Vyc29yMV0sIHRtcCwgMCwgbGVuZ3RoMiwgbGVuZ3RoMiAtIDEsIGNvbXBhcmUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudDIgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3QgLT0gY291bnQyO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yMiAtPSBjb3VudDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGgyIC09IGNvdW50MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbURlc3QgPSBkZXN0ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbUN1cnNvciA9IGN1cnNvcjIgKyAxO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSB0bXBbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW5ndGgyIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W2Rlc3QtLV0gPSBhcnJheVtjdXJzb3IxLS1dO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBfbWluR2FsbG9wLS07XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoY291bnQxID49IERFRkFVTFRfTUlOX0dBTExPUElORyB8fCBjb3VudDIgPj0gREVGQVVMVF9NSU5fR0FMTE9QSU5HKTtcblxuICAgICAgICAgICAgICAgIGlmIChleGl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfbWluR2FsbG9wIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBfbWluR2FsbG9wID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfbWluR2FsbG9wICs9IDI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1pbkdhbGxvcCA9IF9taW5HYWxsb3A7XG5cbiAgICAgICAgICAgIGlmIChtaW5HYWxsb3AgPCAxKSB7XG4gICAgICAgICAgICAgICAgbWluR2FsbG9wID0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxlbmd0aDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBkZXN0IC09IGxlbmd0aDE7XG4gICAgICAgICAgICAgICAgY3Vyc29yMSAtPSBsZW5ndGgxO1xuICAgICAgICAgICAgICAgIGN1c3RvbURlc3QgPSBkZXN0ICsgMTtcbiAgICAgICAgICAgICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IxICsgMTtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IGxlbmd0aDEgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSBhcnJheVtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhcnJheVtkZXN0XSA9IHRtcFtjdXJzb3IyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxlbmd0aDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoJ21lcmdlSGlnaCBwcmVjb25kaXRpb25zIHdlcmUgbm90IHJlc3BlY3RlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tQ3Vyc29yID0gZGVzdCAtIChsZW5ndGgyIC0gMSk7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhcnJheVtjdXN0b21DdXJzb3IgKyBpXSA9IHRtcFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1lcmdlUnVucyA9IG1lcmdlUnVucztcbiAgICAgICAgdGhpcy5mb3JjZU1lcmdlUnVucyA9IGZvcmNlTWVyZ2VSdW5zO1xuICAgICAgICB0aGlzLnB1c2hSdW4gPSBwdXNoUnVuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNvcnQoYXJyYXksIGNvbXBhcmUsIGxvLCBoaSkge1xuICAgICAgICBpZiAoIWxvKSB7XG4gICAgICAgICAgICBsbyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoaSkge1xuICAgICAgICAgICAgaGkgPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVtYWluaW5nID0gaGkgLSBsbztcblxuICAgICAgICBpZiAocmVtYWluaW5nIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJ1bkxlbmd0aCA9IDA7XG5cbiAgICAgICAgaWYgKHJlbWFpbmluZyA8IERFRkFVTFRfTUlOX01FUkdFKSB7XG4gICAgICAgICAgICBydW5MZW5ndGggPSBtYWtlQXNjZW5kaW5nUnVuKGFycmF5LCBsbywgaGksIGNvbXBhcmUpO1xuICAgICAgICAgICAgYmluYXJ5SW5zZXJ0aW9uU29ydChhcnJheSwgbG8sIGhpLCBsbyArIHJ1bkxlbmd0aCwgY29tcGFyZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdHMgPSBuZXcgVGltU29ydChhcnJheSwgY29tcGFyZSk7XG5cbiAgICAgICAgdmFyIG1pblJ1biA9IG1pblJ1bkxlbmd0aChyZW1haW5pbmcpO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHJ1bkxlbmd0aCA9IG1ha2VBc2NlbmRpbmdSdW4oYXJyYXksIGxvLCBoaSwgY29tcGFyZSk7XG4gICAgICAgICAgICBpZiAocnVuTGVuZ3RoIDwgbWluUnVuKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZvcmNlID0gcmVtYWluaW5nO1xuICAgICAgICAgICAgICAgIGlmIChmb3JjZSA+IG1pblJ1bikge1xuICAgICAgICAgICAgICAgICAgICBmb3JjZSA9IG1pblJ1bjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBiaW5hcnlJbnNlcnRpb25Tb3J0KGFycmF5LCBsbywgbG8gKyBmb3JjZSwgbG8gKyBydW5MZW5ndGgsIGNvbXBhcmUpO1xuICAgICAgICAgICAgICAgIHJ1bkxlbmd0aCA9IGZvcmNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cy5wdXNoUnVuKGxvLCBydW5MZW5ndGgpO1xuICAgICAgICAgICAgdHMubWVyZ2VSdW5zKCk7XG5cbiAgICAgICAgICAgIHJlbWFpbmluZyAtPSBydW5MZW5ndGg7XG4gICAgICAgICAgICBsbyArPSBydW5MZW5ndGg7XG4gICAgICAgIH0gd2hpbGUgKHJlbWFpbmluZyAhPT0gMCk7XG5cbiAgICAgICAgdHMuZm9yY2VNZXJnZVJ1bnMoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc29ydDtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvenJlbmRlci9jb3JlL3RpbXNvcnQuanNcbiAqKiBtb2R1bGUgaWQgPSA4OVxuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiLyoqXG4gKiDliqjnlLvkuLvnsbssIOiwg+W6puWSjOeuoeeQhuaJgOacieWKqOeUu+aOp+WItuWZqFxuICpcbiAqIEBtb2R1bGUgenJlbmRlci9hbmltYXRpb24vQW5pbWF0aW9uXG4gKiBAYXV0aG9yIHBpc3NhbmcoaHR0cHM6Ly9naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cbi8vIFRPRE8gQWRkaXRpdmUgYW5pbWF0aW9uXG4vLyBodHRwOi8vaW9zb3RlcmljLmNvbS9hZGRpdGl2ZS1hbmltYXRpb25zLWFuaW1hdGV3aXRoZHVyYXRpb24taW4taW9zLTgvXG4vLyBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vdmlkZW9zL3d3ZGMyMDE0LyMyMzZcbmRlZmluZShmdW5jdGlvbihyZXF1aXJlKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuICAgIHZhciBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vY29yZS9ldmVudCcpLkRpc3BhdGNoZXI7XG5cbiAgICB2YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcmVxdWlyZSgnLi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKTtcblxuICAgIHZhciBBbmltYXRvciA9IHJlcXVpcmUoJy4vQW5pbWF0b3InKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBJWlJlbmRlclN0YWdlXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gdXBkYXRlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdGlvblxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbmZyYW1lXVxuICAgICAqIEBwYXJhbSB7SVpSZW5kZXJTdGFnZX0gW29wdGlvbnMuc3RhZ2VdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgdmFyIGFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oKTtcbiAgICAgKiAgICAgdmFyIG9iaiA9IHtcbiAgICAgKiAgICAgICAgIHg6IDEwMCxcbiAgICAgKiAgICAgICAgIHk6IDEwMFxuICAgICAqICAgICB9O1xuICAgICAqICAgICBhbmltYXRpb24uYW5pbWF0ZShub2RlLnBvc2l0aW9uKVxuICAgICAqICAgICAgICAgLndoZW4oMTAwMCwge1xuICAgICAqICAgICAgICAgICAgIHg6IDUwMCxcbiAgICAgKiAgICAgICAgICAgICB5OiA1MDBcbiAgICAgKiAgICAgICAgIH0pXG4gICAgICogICAgICAgICAud2hlbigyMDAwLCB7XG4gICAgICogICAgICAgICAgICAgeDogMTAwLFxuICAgICAqICAgICAgICAgICAgIHk6IDEwMFxuICAgICAqICAgICAgICAgfSlcbiAgICAgKiAgICAgICAgIC5zdGFydCgnc3BsaW5lJyk7XG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdGhpcy5zdGFnZSA9IG9wdGlvbnMuc3RhZ2UgfHwge307XG5cbiAgICAgICAgdGhpcy5vbmZyYW1lID0gb3B0aW9ucy5vbmZyYW1lIHx8IGZ1bmN0aW9uKCkge307XG5cbiAgICAgICAgLy8gcHJpdmF0ZSBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMuX2NsaXBzID0gW107XG5cbiAgICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX3RpbWU7XG5cbiAgICAgICAgdGhpcy5fcGF1c2VkVGltZTtcblxuICAgICAgICB0aGlzLl9wYXVzZVN0YXJ0O1xuXG4gICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuXG4gICAgICAgIERpc3BhdGNoZXIuY2FsbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgQW5pbWF0aW9uLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogQW5pbWF0aW9uLFxuICAgICAgICAvKipcbiAgICAgICAgICog5re75YqgIGNsaXBcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQ2xpcH0gY2xpcFxuICAgICAgICAgKi9cbiAgICAgICAgYWRkQ2xpcDogZnVuY3Rpb24gKGNsaXApIHtcbiAgICAgICAgICAgIHRoaXMuX2NsaXBzLnB1c2goY2xpcCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqAgYW5pbWF0b3JcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9IGFuaW1hdG9yXG4gICAgICAgICAqL1xuICAgICAgICBhZGRBbmltYXRvcjogZnVuY3Rpb24gKGFuaW1hdG9yKSB7XG4gICAgICAgICAgICBhbmltYXRvci5hbmltYXRpb24gPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNsaXBzID0gYW5pbWF0b3IuZ2V0Q2xpcHMoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENsaXAoY2xpcHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5Yig6Zmk5Yqo55S754mH5q61XG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0NsaXB9IGNsaXBcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUNsaXA6IGZ1bmN0aW9uKGNsaXApIHtcbiAgICAgICAgICAgIHZhciBpZHggPSB1dGlsLmluZGV4T2YodGhpcy5fY2xpcHMsIGNsaXApO1xuICAgICAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xpcHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIoOmZpOWKqOeUu+eJh+autVxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn0gYW5pbWF0b3JcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUFuaW1hdG9yOiBmdW5jdGlvbiAoYW5pbWF0b3IpIHtcbiAgICAgICAgICAgIHZhciBjbGlwcyA9IGFuaW1hdG9yLmdldENsaXBzKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDbGlwKGNsaXBzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuaW1hdG9yLmFuaW1hdGlvbiA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3VwZGF0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIHZhciB0aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLl9wYXVzZWRUaW1lO1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gdGltZSAtIHRoaXMuX3RpbWU7XG4gICAgICAgICAgICB2YXIgY2xpcHMgPSB0aGlzLl9jbGlwcztcbiAgICAgICAgICAgIHZhciBsZW4gPSBjbGlwcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIHZhciBkZWZlcnJlZEV2ZW50cyA9IFtdO1xuICAgICAgICAgICAgdmFyIGRlZmVycmVkQ2xpcHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xpcCA9IGNsaXBzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBlID0gY2xpcC5zdGVwKHRpbWUpO1xuICAgICAgICAgICAgICAgIC8vIFRocm93IG91dCB0aGUgZXZlbnRzIG5lZWQgdG8gYmUgY2FsbGVkIGFmdGVyXG4gICAgICAgICAgICAgICAgLy8gc3RhZ2UudXBkYXRlLCBsaWtlIGRlc3Ryb3lcbiAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZEV2ZW50cy5wdXNoKGUpO1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZENsaXBzLnB1c2goY2xpcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGZpbmlzaGVkIGNsaXBcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgICAgICAgICAgIGlmIChjbGlwc1tpXS5fbmVlZHNSZW1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xpcHNbaV0gPSBjbGlwc1tsZW4gLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgY2xpcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGxlbi0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGVuID0gZGVmZXJyZWRFdmVudHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkQ2xpcHNbaV0uZmlyZShkZWZlcnJlZEV2ZW50c1tpXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3RpbWUgPSB0aW1lO1xuXG4gICAgICAgICAgICB0aGlzLm9uZnJhbWUoZGVsdGEpO1xuXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2ZyYW1lJywgZGVsdGEpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zdGFnZS51cGRhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWdlLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9zdGFydExvb3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgdGhpcy5fcnVubmluZyA9IHRydWU7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHN0ZXAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX3J1bm5pbmcpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG5cbiAgICAgICAgICAgICAgICAgICAgIXNlbGYuX3BhdXNlZCAmJiBzZWxmLl91cGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5byA5aeL6L+Q6KGM5Yqo55S7XG4gICAgICAgICAqL1xuICAgICAgICBzdGFydDogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICB0aGlzLl90aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB0aGlzLl9wYXVzZWRUaW1lID0gMDtcblxuICAgICAgICAgICAgdGhpcy5fc3RhcnRMb29wKCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlgZzmraLov5DooYzliqjnlLtcbiAgICAgICAgICovXG4gICAgICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUGF1c2VcbiAgICAgICAgICovXG4gICAgICAgIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3BhdXNlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhdXNlU3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXN1bWVcbiAgICAgICAgICovXG4gICAgICAgIHJlc3VtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BhdXNlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhdXNlZFRpbWUgKz0gKG5ldyBEYXRlKCkuZ2V0VGltZSgpKSAtIHRoaXMuX3BhdXNlU3RhcnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa4hemZpOaJgOacieWKqOeUu+eJh+autVxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NsaXBzID0gW107XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlr7nkuIDkuKrnm67moIfliJvlu7rkuIDkuKphbmltYXRvcuWvueixoe+8jOWPr+S7peaMh+Wumuebruagh+S4reeahOWxnuaAp+S9v+eUqOWKqOeUu1xuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHRhcmdldFxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgICAgICogQHBhcmFtICB7Ym9vbGVhbn0gW29wdGlvbnMubG9vcD1mYWxzZV0g5piv5ZCm5b6q546v5pKt5pS+5Yqo55S7XG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZXR0ZXI9bnVsbF1cbiAgICAgICAgICogICAgICAgICDlpoLmnpzmjIflrppnZXR0ZXLlh73mlbDvvIzkvJrpgJrov4dnZXR0ZXLlh73mlbDlj5blsZ7mgKflgLxcbiAgICAgICAgICogQHBhcmFtICB7RnVuY3Rpb259IFtvcHRpb25zLnNldHRlcj1udWxsXVxuICAgICAgICAgKiAgICAgICAgIOWmguaenOaMh+WumnNldHRlcuWHveaVsO+8jOS8mumAmui/h3NldHRlcuWHveaVsOiuvue9ruWxnuaAp+WAvFxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0aW9ufkFuaW1hdG9yfVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gVE9ETyBHYXBcbiAgICAgICAgYW5pbWF0ZTogZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgICAgICB2YXIgYW5pbWF0b3IgPSBuZXcgQW5pbWF0b3IoXG4gICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgIG9wdGlvbnMubG9vcCxcbiAgICAgICAgICAgICAgICBvcHRpb25zLmdldHRlcixcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNldHRlclxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgcmV0dXJuIGFuaW1hdG9yO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHV0aWwubWl4aW4oQW5pbWF0aW9uLCBEaXNwYXRjaGVyKTtcblxuICAgIHJldHVybiBBbmltYXRpb247XG59KTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvenJlbmRlci9hbmltYXRpb24vQW5pbWF0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gOTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsIi8qKlxuICog5LqL5Lu26L6F5Yqp57G7XG4gKiBAbW9kdWxlIHpyZW5kZXIvY29yZS9ldmVudFxuICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKi9cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgRXZlbnRmdWwgPSByZXF1aXJlKCcuLi9taXhpbi9FdmVudGZ1bCcpO1xuXG4gICAgdmFyIGlzRG9tTGV2ZWwyID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSAmJiAhIXdpbmRvdy5hZGRFdmVudExpc3RlbmVyO1xuXG4gICAgZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsKSB7XG4gICAgICAgIC8vIEJsYWNrQmVycnkgNSwgaU9TIDMgKG9yaWdpbmFsIGlQaG9uZSkgZG9uJ3QgaGF2ZSBnZXRCb3VuZGluZ1JlY3RcbiAgICAgICAgcmV0dXJuIGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCA/IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDoge2xlZnQ6IDAsIHRvcDogMH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xpZW50VG9Mb2NhbChlbCwgZSwgb3V0KSB7XG4gICAgICAgIC8vIGNsaWVudFgvY2xpZW50WSBpcyBhY2NvcmRpbmcgdG8gdmlldyBwb3J0LlxuICAgICAgICB2YXIgYm94ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsKTtcbiAgICAgICAgb3V0ID0gb3V0IHx8IHt9O1xuICAgICAgICBvdXQuenJYID0gZS5jbGllbnRYIC0gYm94LmxlZnQ7XG4gICAgICAgIG91dC56clkgPSBlLmNsaWVudFkgLSBib3gudG9wO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOWmguaenOWtmOWcqOesrOS4ieaWueW1jOWFpeeahOS4gOS6m2RvbeinpuWPkeeahOS6i+S7tu+8jOaIlnRvdWNo5LqL5Lu277yM6ZyA6KaB6L2s5o2i5LiA5LiL5LqL5Lu25Z2Q5qCHXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplRXZlbnQoZWwsIGUpIHtcblxuICAgICAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG5cbiAgICAgICAgaWYgKGUuenJYICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IGUudHlwZTtcbiAgICAgICAgdmFyIGlzVG91Y2ggPSBldmVudFR5cGUgJiYgZXZlbnRUeXBlLmluZGV4T2YoJ3RvdWNoJykgPj0gMDtcblxuICAgICAgICBpZiAoIWlzVG91Y2gpIHtcbiAgICAgICAgICAgIGNsaWVudFRvTG9jYWwoZWwsIGUsIGUpO1xuICAgICAgICAgICAgZS56ckRlbHRhID0gKGUud2hlZWxEZWx0YSkgPyBlLndoZWVsRGVsdGEgLyAxMjAgOiAtKGUuZGV0YWlsIHx8IDApIC8gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0b3VjaCA9IGV2ZW50VHlwZSAhPSAndG91Y2hlbmQnXG4gICAgICAgICAgICAgICAgPyBlLnRhcmdldFRvdWNoZXNbMF1cbiAgICAgICAgICAgICAgICA6IGUuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICAgICAgICB0b3VjaCAmJiBjbGllbnRUb0xvY2FsKGVsLCB0b3VjaCwgZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGVsLCBuYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmIChpc0RvbUxldmVsMikge1xuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsLmF0dGFjaEV2ZW50KCdvbicgKyBuYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGlzRG9tTGV2ZWwyKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWwuZGV0YWNoRXZlbnQoJ29uJyArIG5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5YGc5q2i5YaS5rOh5ZKM6Zi75q2i6buY6K6k6KGM5Li6XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvZXZlbnRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSA6IGV2ZW505a+56LGhXG4gICAgICovXG4gICAgdmFyIHN0b3AgPSBpc0RvbUxldmVsMlxuICAgICAgICA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGNsaWVudFRvTG9jYWw6IGNsaWVudFRvTG9jYWwsXG4gICAgICAgIG5vcm1hbGl6ZUV2ZW50OiBub3JtYWxpemVFdmVudCxcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogYWRkRXZlbnRMaXN0ZW5lcixcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogcmVtb3ZlRXZlbnRMaXN0ZW5lcixcblxuICAgICAgICBzdG9wOiBzdG9wLFxuICAgICAgICAvLyDlgZrlkJHkuIrlhbzlrrlcbiAgICAgICAgRGlzcGF0Y2hlcjogRXZlbnRmdWxcbiAgICB9O1xufSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL3pyZW5kZXIvY29yZS9ldmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDkxXG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCJkZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSkge1xuXG4gICAgcmV0dXJuICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmMsIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbn0pO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC96cmVuZGVyL2FuaW1hdGlvbi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanNcbiAqKiBtb2R1bGUgaWQgPSA5MlxuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cbiAgICB2YXIgZXZlbnRUb29sID0gcmVxdWlyZSgnLi4vY29yZS9ldmVudCcpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgRXZlbnRmdWwgPSByZXF1aXJlKCcuLi9taXhpbi9FdmVudGZ1bCcpO1xuICAgIHZhciBlbnYgPSByZXF1aXJlKCcuLi9jb3JlL2VudicpO1xuICAgIHZhciBHZXN0dXJlTWdyID0gcmVxdWlyZSgnLi4vY29yZS9HZXN0dXJlTWdyJyk7XG5cbiAgICB2YXIgYWRkRXZlbnRMaXN0ZW5lciA9IGV2ZW50VG9vbC5hZGRFdmVudExpc3RlbmVyO1xuICAgIHZhciByZW1vdmVFdmVudExpc3RlbmVyID0gZXZlbnRUb29sLnJlbW92ZUV2ZW50TGlzdGVuZXI7XG4gICAgdmFyIG5vcm1hbGl6ZUV2ZW50ID0gZXZlbnRUb29sLm5vcm1hbGl6ZUV2ZW50O1xuXG4gICAgdmFyIFRPVUNIX0NMSUNLX0RFTEFZID0gMzAwO1xuXG4gICAgdmFyIG1vdXNlSGFuZGxlck5hbWVzID0gW1xuICAgICAgICAnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2V3aGVlbCcsICdtb3VzZW91dCcsXG4gICAgICAgICdtb3VzZXVwJywgJ21vdXNlZG93bicsICdtb3VzZW1vdmUnXG4gICAgXTtcblxuICAgIHZhciB0b3VjaEhhbmRsZXJOYW1lcyA9IFtcbiAgICAgICAgJ3RvdWNoc3RhcnQnLCAndG91Y2hlbmQnLCAndG91Y2htb3ZlJ1xuICAgIF07XG5cbiAgICBmdW5jdGlvbiBldmVudE5hbWVGaXgobmFtZSkge1xuICAgICAgICByZXR1cm4gKG5hbWUgPT09ICdtb3VzZXdoZWVsJyAmJiBlbnYuYnJvd3Nlci5maXJlZm94KSA/ICdET01Nb3VzZVNjcm9sbCcgOiBuYW1lO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NHZXN0dXJlKHByb3h5LCBldmVudCwgc3RhZ2UpIHtcbiAgICAgICAgdmFyIGdlc3R1cmVNZ3IgPSBwcm94eS5fZ2VzdHVyZU1ncjtcblxuICAgICAgICBzdGFnZSA9PT0gJ3N0YXJ0JyAmJiBnZXN0dXJlTWdyLmNsZWFyKCk7XG5cbiAgICAgICAgdmFyIGdlc3R1cmVJbmZvID0gZ2VzdHVyZU1nci5yZWNvZ25pemUoXG4gICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgIHByb3h5LmhhbmRsZXIuZmluZEhvdmVyKGV2ZW50LnpyWCwgZXZlbnQuenJZLCBudWxsKSxcbiAgICAgICAgICAgIHByb3h5LmRvbVxuICAgICAgICApO1xuXG4gICAgICAgIHN0YWdlID09PSAnZW5kJyAmJiBnZXN0dXJlTWdyLmNsZWFyKCk7XG5cbiAgICAgICAgaWYgKGdlc3R1cmVJbmZvKSB7XG4gICAgICAgICAgICAvLyBldmVudFRvb2wuc3RvcChldmVudCk7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGdlc3R1cmVJbmZvLnR5cGU7XG4gICAgICAgICAgICBldmVudC5nZXN0dXJlRXZlbnQgPSB0eXBlO1xuXG4gICAgICAgICAgICBwcm94eS5oYW5kbGVyLmRpc3BhdGNoVG9FbGVtZW50KGdlc3R1cmVJbmZvLnRhcmdldCwgdHlwZSwgZ2VzdHVyZUluZm8uZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJldmVudCBtb3VzZSBldmVudCBmcm9tIGJlaW5nIGRpc3BhdGNoZWQgYWZ0ZXIgVG91Y2ggRXZlbnRzIGFjdGlvblxuICAgICAqIEBzZWUgPGh0dHBzOi8vZ2l0aHViLmNvbS9kZWx0YWtvc2gvaGFuZGpzL2Jsb2IvbWFzdGVyL3NyYy9oYW5kLmJhc2UuanM+XG4gICAgICogMS4gTW9iaWxlIGJyb3dzZXJzIGRpc3BhdGNoIG1vdXNlIGV2ZW50cyAzMDBtcyBhZnRlciB0b3VjaGVuZC5cbiAgICAgKiAyLiBDaHJvbWUgZm9yIEFuZHJvaWQgZGlzcGF0Y2ggbW91c2Vkb3duIGZvciBsb25nLXRvdWNoIGFib3V0IDY1MG1zXG4gICAgICogUmVzdWx0OiBCbG9ja2luZyBNb3VzZSBFdmVudHMgZm9yIDcwMG1zLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFRvdWNoVGltZXIoaW5zdGFuY2UpIHtcbiAgICAgICAgaW5zdGFuY2UuX3RvdWNoaW5nID0gdHJ1ZTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGluc3RhbmNlLl90b3VjaFRpbWVyKTtcbiAgICAgICAgaW5zdGFuY2UuX3RvdWNoVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLl90b3VjaGluZyA9IGZhbHNlO1xuICAgICAgICB9LCA3MDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVzZVRvdWNoRXZlbnQoKSB7XG4gICAgICAgIHJldHVybiBlbnYudG91Y2hFdmVudHNTdXBwb3J0ZWQ7XG4gICAgfVxuXG4gICAgdmFyIGRvbUhhbmRsZXJzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogTW91c2UgbW92ZSBoYW5kbGVyXG4gICAgICAgICAqIEBpbm5lclxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgbW91c2Vtb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcblxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdtb3VzZW1vdmUnLCBldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vdXNlIG91dCBoYW5kbGVyXG4gICAgICAgICAqIEBpbm5lclxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgbW91c2VvdXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpO1xuXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGV2ZW50LnRvRWxlbWVudCB8fCBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlICE9IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5b+955Wl5YyF5ZCr5Zyocm9vdOS4reeahGRvbeW8lei1t+eahG1vdXNlT3V0XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ID09PSB0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignbW91c2VvdXQnLCBldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRvdWNo5byA5aeL5ZON5bqU5Ye95pWwXG4gICAgICAgICAqIEBpbm5lclxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgdG91Y2hzdGFydDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBEZWZhdWx0IG1vdXNlIGJlaGF2aW91ciBzaG91bGQgbm90IGJlIGRpc2FibGVkIGhlcmUuXG4gICAgICAgICAgICAvLyBGb3IgZXhhbXBsZSwgcGFnZSBtYXkgbmVlZHMgdG8gYmUgc2xpZGVkLlxuXG4gICAgICAgICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7XG5cbiAgICAgICAgICAgIHRoaXMuX2xhc3RUb3VjaE1vbWVudCA9IG5ldyBEYXRlKCk7XG5cbiAgICAgICAgICAgIHByb2Nlc3NHZXN0dXJlKHRoaXMsIGV2ZW50LCAnc3RhcnQnKTtcblxuICAgICAgICAgICAgLy8g5bmz5p2/6KGl5YWF5LiA5qyhZmluZEhvdmVyXG4gICAgICAgICAgICAvLyB0aGlzLl9tb2JpbGVGaW5kRml4ZWQoZXZlbnQpO1xuICAgICAgICAgICAgLy8gVHJpZ2dlciBtb3VzZW1vdmUgYW5kIG1vdXNlZG93blxuICAgICAgICAgICAgZG9tSGFuZGxlcnMubW91c2Vtb3ZlLmNhbGwodGhpcywgZXZlbnQpO1xuXG4gICAgICAgICAgICBkb21IYW5kbGVycy5tb3VzZWRvd24uY2FsbCh0aGlzLCBldmVudCk7XG5cbiAgICAgICAgICAgIHNldFRvdWNoVGltZXIodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRvdWNo56e75Yqo5ZON5bqU5Ye95pWwXG4gICAgICAgICAqIEBpbm5lclxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgdG91Y2htb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcblxuICAgICAgICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpO1xuXG4gICAgICAgICAgICBwcm9jZXNzR2VzdHVyZSh0aGlzLCBldmVudCwgJ2NoYW5nZScpO1xuXG4gICAgICAgICAgICAvLyBNb3VzZSBtb3ZlIHNob3VsZCBhbHdheXMgYmUgdHJpZ2dlcmVkIG5vIG1hdHRlciB3aGV0aGVyXG4gICAgICAgICAgICAvLyB0aGVyZSBpcyBnZXN0cnVlIGV2ZW50LCBiZWNhdXNlIG1vdXNlIG1vdmUgYW5kIHBpbmNoIG1heVxuICAgICAgICAgICAgLy8gYmUgdXNlZCBhdCB0aGUgc2FtZSB0aW1lLlxuICAgICAgICAgICAgZG9tSGFuZGxlcnMubW91c2Vtb3ZlLmNhbGwodGhpcywgZXZlbnQpO1xuXG4gICAgICAgICAgICBzZXRUb3VjaFRpbWVyKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb3VjaOe7k+adn+WTjeW6lOWHveaVsFxuICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIHRvdWNoZW5kOiBmdW5jdGlvbiAoZXZlbnQpIHtcblxuICAgICAgICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpO1xuXG4gICAgICAgICAgICBwcm9jZXNzR2VzdHVyZSh0aGlzLCBldmVudCwgJ2VuZCcpO1xuXG4gICAgICAgICAgICBkb21IYW5kbGVycy5tb3VzZXVwLmNhbGwodGhpcywgZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyBjbGljayBldmVudCBzaG91bGQgYWx3YXlzIGJlIHRyaWdnZXJlZCBubyBtYXR0ZXIgd2hldGhlclxuICAgICAgICAgICAgLy8gdGhlcmUgaXMgZ2VzdHJ1ZSBldmVudC4gU3lzdGVtIGNsaWNrIGNhbiBub3QgYmUgcHJldmVudGVkLlxuICAgICAgICAgICAgaWYgKCtuZXcgRGF0ZSgpIC0gdGhpcy5fbGFzdFRvdWNoTW9tZW50IDwgVE9VQ0hfQ0xJQ0tfREVMQVkpIHtcbiAgICAgICAgICAgICAgICBkb21IYW5kbGVycy5jbGljay5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2V0VG91Y2hUaW1lcih0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBDb21tb24gaGFuZGxlcnNcbiAgICB6clV0aWwuZWFjaChbJ2NsaWNrJywgJ21vdXNlZG93bicsICdtb3VzZXVwJywgJ21vdXNld2hlZWwnLCAnZGJsY2xpY2snXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgZG9tSGFuZGxlcnNbbmFtZV0gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcihuYW1lLCBldmVudCk7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiDkuLrmjqfliLbnsbvlrp7kvovliJ3lp4vljJZkb20g5LqL5Lu25aSE55CG5Ye95pWwXG4gICAgICpcbiAgICAgKiBAaW5uZXJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0hhbmRsZXJ9IGluc3RhbmNlIOaOp+WItuexu+WunuS+i1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXREb21IYW5kbGVyKGluc3RhbmNlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG91Y2hIYW5kbGVyTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gdG91Y2hIYW5kbGVyTmFtZXNbaV07XG4gICAgICAgICAgICBpbnN0YW5jZS5faGFuZGxlcnNbbmFtZV0gPSB6clV0aWwuYmluZChkb21IYW5kbGVyc1tuYW1lXSwgaW5zdGFuY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb3VzZUhhbmRsZXJOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBtb3VzZUhhbmRsZXJOYW1lc1tpXTtcbiAgICAgICAgICAgIGluc3RhbmNlLl9oYW5kbGVyc1tuYW1lXSA9IG1ha2VNb3VzZUhhbmRsZXIoZG9tSGFuZGxlcnNbbmFtZV0sIGluc3RhbmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1ha2VNb3VzZUhhbmRsZXIoZm4sIGluc3RhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5fdG91Y2hpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBIYW5kbGVyRG9tUHJveHkoZG9tKSB7XG4gICAgICAgIEV2ZW50ZnVsLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdGhpcy5kb20gPSBkb207XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdG91Y2hpbmcgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3RvdWNoVGltZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0dlc3R1cmVNZ3J9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9nZXN0dXJlTWdyID0gbmV3IEdlc3R1cmVNZ3IoKTtcblxuICAgICAgICB0aGlzLl9oYW5kbGVycyA9IHt9O1xuXG4gICAgICAgIGluaXREb21IYW5kbGVyKHRoaXMpO1xuXG4gICAgICAgIGlmICh1c2VUb3VjaEV2ZW50KCkpIHtcbiAgICAgICAgICAgIG1vdW50SGFuZGxlcnModG91Y2hIYW5kbGVyTmFtZXMsIHRoaXMpO1xuXG4gICAgICAgICAgICAvLyBIYW5kbGVyIG9mICdtb3VzZW91dCcgZXZlbnQgaXMgbmVlZGVkIGluIHRvdWNoIG1vZGUsIHdoaWNoIHdpbGwgYmUgbW91bnRlZCBiZWxvdy5cbiAgICAgICAgICAgIC8vIGFkZEV2ZW50TGlzdGVuZXIocm9vdCwgJ21vdXNlb3V0JywgdGhpcy5fbW91c2VvdXRIYW5kbGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnNpZGVyaW5nIHNvbWUgZGV2aWNlcyB0aGF0IGJvdGggZW5hYmxlIHRvdWNoIGFuZCBtb3VzZSBldmVudCAobGlrZSBNUyBTdXJmYWNlXG4gICAgICAgIC8vIGFuZCBsZW5vdm8gWDI0MCwgQHNlZSAjMjM1MCksIHdlIG1ha2UgbW91c2UgZXZlbnQgYmUgYWx3YXlzIGxpc3RlbmVkLCBvdGhlcndpc2VcbiAgICAgICAgLy8gbW91c2UgZXZlbnQgY2FuIG5vdCBiZSBoYW5kbGUgaW4gdGhvc2UgZGV2aWNlcy5cbiAgICAgICAgbW91bnRIYW5kbGVycyhtb3VzZUhhbmRsZXJOYW1lcywgdGhpcyk7XG5cbiAgICAgICAgZnVuY3Rpb24gbW91bnRIYW5kbGVycyhoYW5kbGVyTmFtZXMsIGluc3RhbmNlKSB7XG4gICAgICAgICAgICB6clV0aWwuZWFjaChoYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihkb20sIGV2ZW50TmFtZUZpeChuYW1lKSwgaW5zdGFuY2UuX2hhbmRsZXJzW25hbWVdKTtcbiAgICAgICAgICAgIH0sIGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBoYW5kbGVyRG9tUHJveHlQcm90byA9IEhhbmRsZXJEb21Qcm94eS5wcm90b3R5cGU7XG4gICAgaGFuZGxlckRvbVByb3h5UHJvdG8uZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhhbmRsZXJOYW1lcyA9IG1vdXNlSGFuZGxlck5hbWVzLmNvbmNhdCh0b3VjaEhhbmRsZXJOYW1lcyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gaGFuZGxlck5hbWVzW2ldO1xuICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLmRvbSwgZXZlbnROYW1lRml4KG5hbWUpLCB0aGlzLl9oYW5kbGVyc1tuYW1lXSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgaGFuZGxlckRvbVByb3h5UHJvdG8uc2V0Q3Vyc29yID0gZnVuY3Rpb24gKGN1cnNvclN0eWxlKSB7XG4gICAgICAgIHRoaXMuZG9tLnN0eWxlLmN1cnNvciA9IGN1cnNvclN0eWxlIHx8ICdkZWZhdWx0JztcbiAgICB9O1xuXG4gICAgenJVdGlsLm1peGluKEhhbmRsZXJEb21Qcm94eSwgRXZlbnRmdWwpO1xuXG4gICAgcmV0dXJuIEhhbmRsZXJEb21Qcm94eTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvenJlbmRlci9kb20vSGFuZGxlclByb3h5LmpzXG4gKiogbW9kdWxlIGlkID0gOTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsIi8qKlxuICogT25seSBpbXBsZW1lbnRzIG5lZWRlZCBnZXN0dXJlcyBmb3IgbW9iaWxlLlxuICovXG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGV2ZW50VXRpbCA9IHJlcXVpcmUoJy4vZXZlbnQnKTtcblxuICAgIHZhciBHZXN0dXJlTWdyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90cmFjayA9IFtdO1xuICAgIH07XG5cbiAgICBHZXN0dXJlTWdyLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogR2VzdHVyZU1ncixcblxuICAgICAgICByZWNvZ25pemU6IGZ1bmN0aW9uIChldmVudCwgdGFyZ2V0LCByb290KSB7XG4gICAgICAgICAgICB0aGlzLl9kb1RyYWNrKGV2ZW50LCB0YXJnZXQsIHJvb3QpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlY29nbml6ZShldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYWNrLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBfZG9UcmFjazogZnVuY3Rpb24gKGV2ZW50LCB0YXJnZXQsIHJvb3QpIHtcbiAgICAgICAgICAgIHZhciB0b3VjaGVzID0gZXZlbnQudG91Y2hlcztcblxuICAgICAgICAgICAgaWYgKCF0b3VjaGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdHJhY2tJdGVtID0ge1xuICAgICAgICAgICAgICAgIHBvaW50czogW10sXG4gICAgICAgICAgICAgICAgdG91Y2hlczogW10sXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdG91Y2hlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB0b3VjaCA9IHRvdWNoZXNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IGV2ZW50VXRpbC5jbGllbnRUb0xvY2FsKHJvb3QsIHRvdWNoKTtcbiAgICAgICAgICAgICAgICB0cmFja0l0ZW0ucG9pbnRzLnB1c2goW3Bvcy56clgsIHBvcy56clldKTtcbiAgICAgICAgICAgICAgICB0cmFja0l0ZW0udG91Y2hlcy5wdXNoKHRvdWNoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fdHJhY2sucHVzaCh0cmFja0l0ZW0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9yZWNvZ25pemU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHJlY29nbml6ZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlY29nbml6ZXJzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdlc3R1cmVJbmZvID0gcmVjb2duaXplcnNbZXZlbnROYW1lXSh0aGlzLl90cmFjaywgZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2VzdHVyZUluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXN0dXJlSW5mbztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBkaXN0KHBvaW50UGFpcikge1xuICAgICAgICB2YXIgZHggPSBwb2ludFBhaXJbMV1bMF0gLSBwb2ludFBhaXJbMF1bMF07XG4gICAgICAgIHZhciBkeSA9IHBvaW50UGFpclsxXVsxXSAtIHBvaW50UGFpclswXVsxXTtcblxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjZW50ZXIocG9pbnRQYWlyKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAocG9pbnRQYWlyWzBdWzBdICsgcG9pbnRQYWlyWzFdWzBdKSAvIDIsXG4gICAgICAgICAgICAocG9pbnRQYWlyWzBdWzFdICsgcG9pbnRQYWlyWzFdWzFdKSAvIDJcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICB2YXIgcmVjb2duaXplcnMgPSB7XG5cbiAgICAgICAgcGluY2g6IGZ1bmN0aW9uICh0cmFjaywgZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciB0cmFja0xlbiA9IHRyYWNrLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKCF0cmFja0xlbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBpbmNoRW5kID0gKHRyYWNrW3RyYWNrTGVuIC0gMV0gfHwge30pLnBvaW50cztcbiAgICAgICAgICAgIHZhciBwaW5jaFByZSA9ICh0cmFja1t0cmFja0xlbiAtIDJdIHx8IHt9KS5wb2ludHMgfHwgcGluY2hFbmQ7XG5cbiAgICAgICAgICAgIGlmIChwaW5jaFByZVxuICAgICAgICAgICAgICAgICYmIHBpbmNoUHJlLmxlbmd0aCA+IDFcbiAgICAgICAgICAgICAgICAmJiBwaW5jaEVuZFxuICAgICAgICAgICAgICAgICYmIHBpbmNoRW5kLmxlbmd0aCA+IDFcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhciBwaW5jaFNjYWxlID0gZGlzdChwaW5jaEVuZCkgLyBkaXN0KHBpbmNoUHJlKTtcbiAgICAgICAgICAgICAgICAhaXNGaW5pdGUocGluY2hTY2FsZSkgJiYgKHBpbmNoU2NhbGUgPSAxKTtcblxuICAgICAgICAgICAgICAgIGV2ZW50LnBpbmNoU2NhbGUgPSBwaW5jaFNjYWxlO1xuXG4gICAgICAgICAgICAgICAgdmFyIHBpbmNoQ2VudGVyID0gY2VudGVyKHBpbmNoRW5kKTtcbiAgICAgICAgICAgICAgICBldmVudC5waW5jaFggPSBwaW5jaENlbnRlclswXTtcbiAgICAgICAgICAgICAgICBldmVudC5waW5jaFkgPSBwaW5jaENlbnRlclsxXTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwaW5jaCcsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogdHJhY2tbMF0udGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBldmVudDogZXZlbnRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gT25seSBwaW5jaCBjdXJyZW50bHkuXG4gICAgfTtcblxuICAgIHJldHVybiBHZXN0dXJlTWdyO1xufSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL3pyZW5kZXIvY29yZS9HZXN0dXJlTWdyLmpzXG4gKiogbW9kdWxlIGlkID0gOTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsIi8qKlxuICogRGVmYXVsdCBjYW52YXMgcGFpbnRlclxuICogQG1vZHVsZSB6cmVuZGVyL1BhaW50ZXJcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICogICAgICAgICBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cbiBkZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vY29yZS91dGlsJyk7XG4gICAgdmFyIGxvZyA9IHJlcXVpcmUoJy4vY29yZS9sb2cnKTtcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnLi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xuICAgIHZhciB0aW1zb3J0ID0gcmVxdWlyZSgnLi9jb3JlL3RpbXNvcnQnKTtcblxuICAgIHZhciBMYXllciA9IHJlcXVpcmUoJy4vTGF5ZXInKTtcblxuICAgIHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByZXF1aXJlKCcuL2FuaW1hdGlvbi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKTtcblxuICAgIC8vIFBFTkRJR05cbiAgICAvLyBMYXllciBleGNlZWRzIE1BWF9QUk9HUkVTU0lWRV9MQVlFUl9OVU1CRVIgbWF5IGhhdmUgc29tZSBwcm9ibGVtIHdoZW4gZmx1c2ggZGlyZWN0bHkgc2Vjb25kIHRpbWUuXG4gICAgLy9cbiAgICAvLyBNYXhpbXVtIHByb2dyZXNzaXZlIGxheWVyLiBXaGVuIGV4Y2VlZGluZyB0aGlzIG51bWJlci4gQWxsIGVsZW1lbnRzIHdpbGwgYmUgZHJhd2VkIGluIHRoZSBsYXN0IGxheWVyLlxuICAgIHZhciBNQVhfUFJPR1JFU1NJVkVfTEFZRVJfTlVNQkVSID0gNTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlSW50MTAodmFsKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludCh2YWwsIDEwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xheWVyVmFsaWQobGF5ZXIpIHtcbiAgICAgICAgaWYgKCFsYXllcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxheWVyLmlzQnVpbGRpbikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mKGxheWVyLnJlc2l6ZSkgIT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgIHx8IHR5cGVvZihsYXllci5yZWZyZXNoKSAhPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZVByb2Nlc3NMYXllcihsYXllcikge1xuICAgICAgICBsYXllci5fX3VudXNlZENvdW50Kys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9zdFByb2Nlc3NMYXllcihsYXllcikge1xuICAgICAgICBpZiAobGF5ZXIuX191bnVzZWRDb3VudCA9PSAxKSB7XG4gICAgICAgICAgICBsYXllci5jbGVhcigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRtcFJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KDAsIDAsIDAsIDApO1xuICAgIHZhciB2aWV3UmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoMCwgMCwgMCwgMCk7XG4gICAgZnVuY3Rpb24gaXNEaXNwbGF5YWJsZUN1bGxlZChlbCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0bXBSZWN0LmNvcHkoZWwuZ2V0Qm91bmRpbmdSZWN0KCkpO1xuICAgICAgICBpZiAoZWwudHJhbnNmb3JtKSB7XG4gICAgICAgICAgICB0bXBSZWN0LmFwcGx5VHJhbnNmb3JtKGVsLnRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICAgICAgdmlld1JlY3Qud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdmlld1JlY3QuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICByZXR1cm4gIXRtcFJlY3QuaW50ZXJzZWN0KHZpZXdSZWN0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0NsaXBQYXRoQ2hhbmdlZChjbGlwUGF0aHMsIHByZXZDbGlwUGF0aHMpIHtcbiAgICAgICAgaWYgKGNsaXBQYXRocyA9PSBwcmV2Q2xpcFBhdGhzKSB7IC8vIENhbiBib3RoIGJlIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNsaXBQYXRocyB8fCAhcHJldkNsaXBQYXRocyB8fCAoY2xpcFBhdGhzLmxlbmd0aCAhPT0gcHJldkNsaXBQYXRocy5sZW5ndGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBQYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNsaXBQYXRoc1tpXSAhPT0gcHJldkNsaXBQYXRoc1tpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG9DbGlwKGNsaXBQYXRocywgY3R4KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcFBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2xpcFBhdGggPSBjbGlwUGF0aHNbaV07XG4gICAgICAgICAgICB2YXIgcGF0aCA9IGNsaXBQYXRoLnBhdGg7XG5cbiAgICAgICAgICAgIGNsaXBQYXRoLnNldFRyYW5zZm9ybShjdHgpO1xuICAgICAgICAgICAgcGF0aC5iZWdpblBhdGgoY3R4KTtcbiAgICAgICAgICAgIGNsaXBQYXRoLmJ1aWxkUGF0aChwYXRoLCBjbGlwUGF0aC5zaGFwZSk7XG4gICAgICAgICAgICBjdHguY2xpcCgpO1xuICAgICAgICAgICAgLy8gVHJhbnNmb3JtIGJhY2tcbiAgICAgICAgICAgIGNsaXBQYXRoLnJlc3RvcmVUcmFuc2Zvcm0oY3R4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJvb3Qod2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgZG9tUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB2YXIgZG9tUm9vdFN0eWxlID0gZG9tUm9vdC5zdHlsZTtcblxuICAgICAgICAvLyBkb21Sb290Lm9uc2VsZWN0c3RhcnQgPSByZXR1cm5GYWxzZTsgLy8g6YG/5YWN6aG16Z2i6YCJ5Lit55qE5bC05bCsXG4gICAgICAgIGRvbVJvb3RTdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgIGRvbVJvb3RTdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICBkb21Sb290U3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICAgIGRvbVJvb3RTdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgICAgICByZXR1cm4gZG9tUm9vdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvUGFpbnRlclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJvb3Qg57uY5Zu+5a655ZmoXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9TdG9yYWdlfSBzdG9yYWdlXG4gICAgICogQHBhcmFtIHtPamJlY3R9IG9wdHNcbiAgICAgKi9cbiAgICB2YXIgUGFpbnRlciA9IGZ1bmN0aW9uIChyb290LCBzdG9yYWdlLCBvcHRzKSB7XG4gICAgICAgIC8vIEluIG5vZGUgZW52aXJvbm1lbnQgdXNpbmcgbm9kZS1jYW52YXNcbiAgICAgICAgdmFyIHNpbmdsZUNhbnZhcyA9ICFyb290Lm5vZGVOYW1lIC8vIEluIG5vZGUgP1xuICAgICAgICAgICAgfHwgcm9vdC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnQ0FOVkFTJztcblxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZHByID0gb3B0cy5kZXZpY2VQaXhlbFJhdGlvIHx8IGNvbmZpZy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zaW5nbGVDYW52YXMgPSBzaW5nbGVDYW52YXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnu5jlm77lrrnlmahcbiAgICAgICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcblxuICAgICAgICB2YXIgcm9vdFN0eWxlID0gcm9vdC5zdHlsZTtcblxuICAgICAgICBpZiAocm9vdFN0eWxlKSB7XG4gICAgICAgICAgICByb290U3R5bGVbJy13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvciddID0gJ3RyYW5zcGFyZW50JztcbiAgICAgICAgICAgIHJvb3RTdHlsZVsnLXdlYmtpdC11c2VyLXNlbGVjdCddID1cbiAgICAgICAgICAgIHJvb3RTdHlsZVsndXNlci1zZWxlY3QnXSA9XG4gICAgICAgICAgICByb290U3R5bGVbJy13ZWJraXQtdG91Y2gtY2FsbG91dCddID0gJ25vbmUnO1xuXG4gICAgICAgICAgICByb290LmlubmVySFRNTCA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9TdG9yYWdlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0ID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOnpyZW5kZXIvTGF5ZXI+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGxheWVycyA9IHRoaXMuX2xheWVycyA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIE9iamVjdD59XG4gICAgICAgICAqIEB0eXBlIHtwcml2YXRlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbGF5ZXJDb25maWcgPSB7fTtcblxuICAgICAgICBpZiAoIXNpbmdsZUNhbnZhcykge1xuICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB0aGlzLl9nZXRXaWR0aCgpO1xuICAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gdGhpcy5fZ2V0SGVpZ2h0KCk7XG5cbiAgICAgICAgICAgIHZhciBkb21Sb290ID0gdGhpcy5fZG9tUm9vdCA9IGNyZWF0ZVJvb3QoXG4gICAgICAgICAgICAgICAgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJvb3QuYXBwZW5kQ2hpbGQoZG9tUm9vdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBVc2UgY2FudmFzIHdpZHRoIGFuZCBoZWlnaHQgZGlyZWN0bHlcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHJvb3Qud2lkdGg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gcm9vdC5oZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgbGF5ZXIgaWYgb25seSBvbmUgZ2l2ZW4gY2FudmFzXG4gICAgICAgICAgICAvLyBEZXZpY2UgcGl4ZWwgcmF0aW8gaXMgZml4ZWQgdG8gMSBiZWNhdXNlIGdpdmVuIGNhbnZhcyBoYXMgaXRzIHNwZWNpZmllZCB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICAgICAgICB2YXIgbWFpbkxheWVyID0gbmV3IExheWVyKHJvb3QsIHRoaXMsIDEpO1xuICAgICAgICAgICAgbWFpbkxheWVyLmluaXRDb250ZXh0KCk7XG4gICAgICAgICAgICAvLyBGSVhNRSBVc2UgY2FudmFzIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgICAgICAgIC8vIG1haW5MYXllci5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICBsYXllcnNbMF0gPSBtYWluTGF5ZXI7XG4gICAgICAgICAgICB6bGV2ZWxMaXN0LnB1c2goMCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBhdGhUb0ltYWdlID0gdGhpcy5fY3JlYXRlUGF0aFRvSW1hZ2UoKTtcblxuICAgICAgICAvLyBMYXllcnMgZm9yIHByb2dyZXNzaXZlIHJlbmRlcmluZ1xuICAgICAgICB0aGlzLl9wcm9ncmVzc2l2ZUxheWVycyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvTGF5ZXJ9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9ob3ZlcmxheWVyO1xuXG4gICAgICAgIHRoaXMuX2hvdmVyRWxlbWVudHMgPSBbXTtcbiAgICB9O1xuXG4gICAgUGFpbnRlci5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFBhaW50ZXIsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHBhaW50ZXIgdXNlIGEgc2luZ2xlIGNhbnZhc1xuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgaXNTaW5nbGVDYW52YXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW5nbGVDYW52YXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtIVE1MRGl2RWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIGdldFZpZXdwb3J0Um9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbmdsZUNhbnZhcyA/IHRoaXMuX2xheWVyc1swXS5kb20gOiB0aGlzLl9kb21Sb290O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliLfmlrBcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbcGFpbnRBbGw9ZmFsc2VdIOW8uuWItue7mOWItuaJgOaciWRpc3BsYXlhYmxlXG4gICAgICAgICAqL1xuICAgICAgICByZWZyZXNoOiBmdW5jdGlvbiAocGFpbnRBbGwpIHtcblxuICAgICAgICAgICAgdmFyIGxpc3QgPSB0aGlzLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QodHJ1ZSk7XG5cbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcblxuICAgICAgICAgICAgdGhpcy5fcGFpbnRMaXN0KGxpc3QsIHBhaW50QWxsKTtcblxuICAgICAgICAgICAgLy8gUGFpbnQgY3VzdHVtIGxheWVyc1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB6bGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1t6XTtcbiAgICAgICAgICAgICAgICBpZiAoIWxheWVyLmlzQnVpbGRpbiAmJiBsYXllci5yZWZyZXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucmVmcmVzaEhvdmVyKCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9wcm9ncmVzc2l2ZUxheWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFByb2dlc3NpdmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkSG92ZXI6IGZ1bmN0aW9uIChlbCwgaG92ZXJTdHlsZSkge1xuICAgICAgICAgICAgaWYgKGVsLl9faG92ZXJNaXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZWxNaXJyb3IgPSBuZXcgZWwuY29uc3RydWN0b3Ioe1xuICAgICAgICAgICAgICAgIHN0eWxlOiBlbC5zdHlsZSxcbiAgICAgICAgICAgICAgICBzaGFwZTogZWwuc2hhcGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZWxNaXJyb3IuX19mcm9tID0gZWw7XG4gICAgICAgICAgICBlbC5fX2hvdmVyTWlyID0gZWxNaXJyb3I7XG4gICAgICAgICAgICBlbE1pcnJvci5zZXRTdHlsZShob3ZlclN0eWxlKTtcbiAgICAgICAgICAgIHRoaXMuX2hvdmVyRWxlbWVudHMucHVzaChlbE1pcnJvcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlSG92ZXI6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIGVsTWlycm9yID0gZWwuX19ob3Zlck1pcjtcbiAgICAgICAgICAgIHZhciBob3ZlckVsZW1lbnRzID0gdGhpcy5faG92ZXJFbGVtZW50cztcbiAgICAgICAgICAgIHZhciBpZHggPSB1dGlsLmluZGV4T2YoaG92ZXJFbGVtZW50cywgZWxNaXJyb3IpO1xuICAgICAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaG92ZXJFbGVtZW50cy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsLl9faG92ZXJNaXIgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsZWFySG92ZXI6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIGhvdmVyRWxlbWVudHMgPSB0aGlzLl9ob3ZlckVsZW1lbnRzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3ZlckVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyb20gPSBob3ZlckVsZW1lbnRzW2ldLl9fZnJvbTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSkge1xuICAgICAgICAgICAgICAgICAgICBmcm9tLl9faG92ZXJNaXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhvdmVyRWxlbWVudHMubGVuZ3RoID0gMDtcbiAgICAgICAgfSxcblxuICAgICAgICByZWZyZXNoSG92ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBob3ZlckVsZW1lbnRzID0gdGhpcy5faG92ZXJFbGVtZW50cztcbiAgICAgICAgICAgIHZhciBsZW4gPSBob3ZlckVsZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBob3ZlckxheWVyID0gdGhpcy5faG92ZXJsYXllcjtcbiAgICAgICAgICAgIGhvdmVyTGF5ZXIgJiYgaG92ZXJMYXllci5jbGVhcigpO1xuXG4gICAgICAgICAgICBpZiAoIWxlbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRpbXNvcnQoaG92ZXJFbGVtZW50cywgdGhpcy5zdG9yYWdlLmRpc3BsYXlhYmxlU29ydEZ1bmMpO1xuXG4gICAgICAgICAgICAvLyBVc2UgYSBleHRyZWFtIGxhcmdlIHpsZXZlbFxuICAgICAgICAgICAgLy8gRklYTUU/XG4gICAgICAgICAgICBpZiAoIWhvdmVyTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBob3ZlckxheWVyID0gdGhpcy5faG92ZXJsYXllciA9IHRoaXMuZ2V0TGF5ZXIoMWU1KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNjb3BlID0ge307XG4gICAgICAgICAgICBob3ZlckxheWVyLmN0eC5zYXZlKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBob3ZlckVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbEVsID0gZWwuX19mcm9tO1xuICAgICAgICAgICAgICAgIC8vIE9yaWdpbmFsIGVsIGlzIHJlbW92ZWRcbiAgICAgICAgICAgICAgICAvLyBQRU5ESU5HXG4gICAgICAgICAgICAgICAgaWYgKCEob3JpZ2luYWxFbCAmJiBvcmlnaW5hbEVsLl9fenIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvdmVyRWxlbWVudHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEVsLl9faG92ZXJNaXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBsZW4tLTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkrKztcblxuICAgICAgICAgICAgICAgIC8vIFVzZSB0cmFuc2Zvcm1cbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBzdHlsZSBhbmQgc2hhcGUgP1xuICAgICAgICAgICAgICAgIGlmICghb3JpZ2luYWxFbC5pbnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwudHJhbnNmb3JtID0gb3JpZ2luYWxFbC50cmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgICAgIGVsLmludlRyYW5zZm9ybSA9IG9yaWdpbmFsRWwuaW52VHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgICAgICBlbC5fX2NsaXBQYXRocyA9IG9yaWdpbmFsRWwuX19jbGlwUGF0aHM7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVsLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb1BhaW50RWwoZWwsIGhvdmVyTGF5ZXIsIHRydWUsIHNjb3BlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBob3ZlckxheWVyLmN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3N0YXJ0UHJvZ2Vzc2l2ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICBpZiAoIXNlbGYuX2Z1cnRoZXJQcm9ncmVzc2l2ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXNlIGEgdG9rZW4gdG8gc3RvcCBwcm9ncmVzcyBzdGVwcyB0cmlnZ2VyZWQgYnlcbiAgICAgICAgICAgIC8vIHByZXZpb3VzIHpyLnJlZnJlc2ggY2FsbGluZy5cbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHNlbGYuX3Byb2dyZXNzaXZlVG9rZW4gPSArbmV3IERhdGUoKTtcblxuICAgICAgICAgICAgc2VsZi5fcHJvZ3Jlc3MrKztcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gc3RlcCgpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIHJlZnJlc2hlZCBvciBkaXNwb3NlZFxuICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gc2VsZi5fcHJvZ3Jlc3NpdmVUb2tlbiAmJiBzZWxmLnN0b3JhZ2UpIHtcblxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9kb1BhaW50TGlzdChzZWxmLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QoKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX2Z1cnRoZXJQcm9ncmVzc2l2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fcHJvZ3Jlc3MrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3Byb2dyZXNzaXZlVG9rZW4gPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfY2xlYXJQcm9ncmVzc2l2ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3NpdmVUb2tlbiA9IC0xO1xuICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgICAgdXRpbC5lYWNoKHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzLCBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBsYXllci5fX2RpcnR5ICYmIGxheWVyLmNsZWFyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfcGFpbnRMaXN0OiBmdW5jdGlvbiAobGlzdCwgcGFpbnRBbGwpIHtcblxuICAgICAgICAgICAgaWYgKHBhaW50QWxsID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYWludEFsbCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVMYXllclN0YXR1cyhsaXN0KTtcblxuICAgICAgICAgICAgdGhpcy5fY2xlYXJQcm9ncmVzc2l2ZSgpO1xuXG4gICAgICAgICAgICB0aGlzLmVhY2hCdWlsZGluTGF5ZXIocHJlUHJvY2Vzc0xheWVyKTtcblxuICAgICAgICAgICAgdGhpcy5fZG9QYWludExpc3QobGlzdCwgcGFpbnRBbGwpO1xuXG4gICAgICAgICAgICB0aGlzLmVhY2hCdWlsZGluTGF5ZXIocG9zdFByb2Nlc3NMYXllcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RvUGFpbnRMaXN0OiBmdW5jdGlvbiAobGlzdCwgcGFpbnRBbGwpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50TGF5ZXI7XG4gICAgICAgICAgICB2YXIgY3VycmVudFpMZXZlbDtcbiAgICAgICAgICAgIHZhciBjdHg7XG5cbiAgICAgICAgICAgIC8vIHZhciBpbnZUcmFuc2Zvcm0gPSBbXTtcbiAgICAgICAgICAgIHZhciBzY29wZTtcblxuICAgICAgICAgICAgdmFyIHByb2dyZXNzaXZlTGF5ZXJJZHggPSAwO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyO1xuXG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgbGF5ZXJQcm9ncmVzcztcbiAgICAgICAgICAgIHZhciBmcmFtZSA9IHRoaXMuX3Byb2dyZXNzO1xuICAgICAgICAgICAgZnVuY3Rpb24gZmx1c2hQcm9ncmVzc2l2ZUxheWVyKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRwciA9IGN0eC5kcHIgfHwgMTtcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICAgICAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSAwO1xuICAgICAgICAgICAgICAgIC8vIEF2b2lkIGxheWVyIGRvbid0IGNsZWFyIGluIG5leHQgcHJvZ3Jlc3NpdmUgZnJhbWVcbiAgICAgICAgICAgICAgICBjdXJyZW50TGF5ZXIuX19kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGxheWVyLmRvbSwgMCwgMCwgd2lkdGggKiBkcHIsIGhlaWdodCAqIGRwcik7XG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IGxpc3RbaV07XG4gICAgICAgICAgICAgICAgdmFyIGVsWkxldmVsID0gdGhpcy5fc2luZ2xlQ2FudmFzID8gMCA6IGVsLnpsZXZlbDtcblxuICAgICAgICAgICAgICAgIHZhciBlbEZyYW1lID0gZWwuX19mcmFtZTtcblxuICAgICAgICAgICAgICAgIC8vIEZsdXNoIGF0IGN1cnJlbnQgY29udGV4dFxuICAgICAgICAgICAgICAgIC8vIFBFTkRJTkdcbiAgICAgICAgICAgICAgICBpZiAoZWxGcmFtZSA8IDAgJiYgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZmx1c2hQcm9ncmVzc2l2ZUxheWVyKGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENoYW5nZSBkcmF3IGxheWVyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRaTGV2ZWwgIT09IGVsWkxldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCBzY29wZVxuICAgICAgICAgICAgICAgICAgICBzY29wZSA9IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgMCB6bGV2ZWwgaWYgb25seSBoYXMgb25lIGNhbnZhc1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50WkxldmVsID0gZWxaTGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMYXllciA9IHRoaXMuZ2V0TGF5ZXIoY3VycmVudFpMZXZlbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50TGF5ZXIuaXNCdWlsZGluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2coXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1pMZXZlbCAnICsgY3VycmVudFpMZXZlbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgJyBoYXMgYmVlbiB1c2VkIGJ5IHVua293biBsYXllciAnICsgY3VycmVudExheWVyLmlkXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gY3VycmVudExheWVyLmN0eDtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgY291bnRcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudExheWVyLl9fdW51c2VkQ291bnQgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TGF5ZXIuX19kaXJ0eSB8fCBwYWludEFsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudExheWVyLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIShjdXJyZW50TGF5ZXIuX19kaXJ0eSB8fCBwYWludEFsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGVsRnJhbWUgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBQcm9ncmVzc2l2ZSBsYXllciBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyID0gdGhpcy5fcHJvZ3Jlc3NpdmVMYXllcnNbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4ocHJvZ3Jlc3NpdmVMYXllcklkeCsrLCBNQVhfUFJPR1JFU1NJVkVfTEFZRVJfTlVNQkVSIC0gMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLmN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5yZW5kZXJTY29wZSA9IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFByb2dyZXNzaXZlTGF5ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19wcm9ncmVzcyA+IGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbWF4UHJvZ3Jlc3MpXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmbHVzaFByb2dyZXNzaXZlTGF5ZXIoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFF1aWNrIGp1bXAgYWxsIHByb2dyZXNzaXZlIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsIHByb2dyZXNzaXZlIGVsZW1lbnQgYXJlIG5vdCBkaXJ0eSwganVtcCBvdmVyIGFuZCBmbHVzaCBkaXJlY3RseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX25leHRJZHhOb3RQcm9nIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyUHJvZ3Jlc3MgPSBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX3Byb2dyZXNzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIHJlbmRlcmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lID0gbGF5ZXJQcm9ncmVzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19wcm9ncmVzcyA9IGZyYW1lICsgMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbEZyYW1lID09PSBmcmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9QYWludEVsKGVsLCBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciwgdHJ1ZSwgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIucmVuZGVyU2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb1BhaW50RWwoZWwsIGN1cnJlbnRMYXllciwgcGFpbnRBbGwsIHNjb3BlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlbC5fX2RpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgICAgICAgICAgIGZsdXNoUHJvZ3Jlc3NpdmVMYXllcihjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIGxhc3RMYXllciBjdHhcbiAgICAgICAgICAgIGN0eCAmJiBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgLy8gSWYgc3RpbGwgaGFzIGNsaXBwaW5nIHN0YXRlXG4gICAgICAgICAgICAvLyBpZiAoc2NvcGUucHJldkVsQ2xpcFBhdGhzKSB7XG4gICAgICAgICAgICAvLyAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgdGhpcy5fZnVydGhlclByb2dyZXNzaXZlID0gZmFsc2U7XG4gICAgICAgICAgICB1dGlsLmVhY2godGhpcy5fcHJvZ3Jlc3NpdmVMYXllcnMsIGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICAgICAgICAgIGlmIChsYXllci5fX21heFByb2dyZXNzID49IGxheWVyLl9fcHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZnVydGhlclByb2dyZXNzaXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZG9QYWludEVsOiBmdW5jdGlvbiAoZWwsIGN1cnJlbnRMYXllciwgZm9yY2VQYWludCwgc2NvcGUpIHtcbiAgICAgICAgICAgIHZhciBjdHggPSBjdXJyZW50TGF5ZXIuY3R4O1xuICAgICAgICAgICAgdmFyIG0gPSBlbC50cmFuc2Zvcm07XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKGN1cnJlbnRMYXllci5fX2RpcnR5IHx8IGZvcmNlUGFpbnQpXG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIGludmlzaWJsZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgJiYgIWVsLmludmlzaWJsZVxuICAgICAgICAgICAgICAgIC8vIElnbm9yZSB0cmFuc3BhcmVudCBlbGVtZW50XG4gICAgICAgICAgICAgICAgJiYgZWwuc3R5bGUub3BhY2l0eSAhPT0gMFxuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBzY2FsZSAwIGVsZW1lbnQsIGluIHNvbWUgZW52aXJvbm1lbnQgbGlrZSBub2RlLWNhbnZhc1xuICAgICAgICAgICAgICAgIC8vIERyYXcgYSBzY2FsZSAwIGVsZW1lbnQgY2FuIGNhdXNlIGFsbCBmb2xsb3dpbmcgZHJhdyB3cm9uZ1xuICAgICAgICAgICAgICAgIC8vIEFuZCBzZXRUcmFuc2Zvcm0gd2l0aCBzY2FsZSAwIHdpbGwgY2F1c2Ugc2V0IGJhY2sgdHJhbnNmb3JtIGZhaWxlZC5cbiAgICAgICAgICAgICAgICAmJiAhKG0gJiYgIW1bMF0gJiYgIW1bM10pXG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIGN1bGxlZCBlbGVtZW50XG4gICAgICAgICAgICAgICAgJiYgIShlbC5jdWxsaW5nICYmIGlzRGlzcGxheWFibGVDdWxsZWQoZWwsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpKVxuICAgICAgICAgICAgKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgY2xpcFBhdGhzID0gZWwuX19jbGlwUGF0aHM7XG5cbiAgICAgICAgICAgICAgICAvLyBPcHRpbWl6ZSB3aGVuIGNsaXBwaW5nIG9uIGdyb3VwIHdpdGggc2V2ZXJhbCBlbGVtZW50c1xuICAgICAgICAgICAgICAgIGlmIChzY29wZS5wcmV2Q2xpcExheWVyICE9PSBjdXJyZW50TGF5ZXJcbiAgICAgICAgICAgICAgICAgICAgfHwgaXNDbGlwUGF0aENoYW5nZWQoY2xpcFBhdGhzLCBzY29wZS5wcmV2RWxDbGlwUGF0aHMpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGhhcyBwcmV2aW91cyBjbGlwcGluZyBzdGF0ZSwgcmVzdG9yZSBmcm9tIGl0XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY29wZS5wcmV2RWxDbGlwUGF0aHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLnByZXZDbGlwTGF5ZXIuY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLnByZXZDbGlwTGF5ZXIgPSBzY29wZS5wcmV2RWxDbGlwUGF0aHMgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCBwcmV2RWwgc2luY2UgY29udGV4dCBoYXMgYmVlbiByZXN0b3JlZFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUucHJldkVsID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBOZXcgY2xpcHBpbmcgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsaXBQYXRocykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvQ2xpcChjbGlwUGF0aHMsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5wcmV2Q2xpcExheWVyID0gY3VycmVudExheWVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUucHJldkVsQ2xpcFBhdGhzID0gY2xpcFBhdGhzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsLmJlZm9yZUJydXNoICYmIGVsLmJlZm9yZUJydXNoKGN0eCk7XG5cbiAgICAgICAgICAgICAgICBlbC5icnVzaChjdHgsIHNjb3BlLnByZXZFbCB8fCBudWxsKTtcbiAgICAgICAgICAgICAgICBzY29wZS5wcmV2RWwgPSBlbDtcblxuICAgICAgICAgICAgICAgIGVsLmFmdGVyQnJ1c2ggJiYgZWwuYWZ0ZXJCcnVzaChjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDojrflj5YgemxldmVsIOaJgOWcqOWxgu+8jOWmguaenOS4jeWtmOWcqOWImeS8muWIm+W7uuS4gOS4quaWsOeahOWxglxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gemxldmVsXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL0xheWVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TGF5ZXI6IGZ1bmN0aW9uICh6bGV2ZWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zaW5nbGVDYW52YXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXJzWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbemxldmVsXTtcbiAgICAgICAgICAgIGlmICghbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgbGF5ZXJcbiAgICAgICAgICAgICAgICBsYXllciA9IG5ldyBMYXllcignenJfJyArIHpsZXZlbCwgdGhpcywgdGhpcy5kcHIpO1xuICAgICAgICAgICAgICAgIGxheWVyLmlzQnVpbGRpbiA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbGF5ZXJDb25maWdbemxldmVsXSkge1xuICAgICAgICAgICAgICAgICAgICB1dGlsLm1lcmdlKGxheWVyLCB0aGlzLl9sYXllckNvbmZpZ1t6bGV2ZWxdLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydExheWVyKHpsZXZlbCwgbGF5ZXIpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29udGV4dCBpcyBjcmVhdGVkIGFmdGVyIGRvbSBpbnNlcnRlZCB0byBkb2N1bWVudFxuICAgICAgICAgICAgICAgIC8vIE9yIGV4Y2FudmFzIHdpbGwgZ2V0IDBweCBjbGllbnRXaWR0aCBhbmQgY2xpZW50SGVpZ2h0XG4gICAgICAgICAgICAgICAgbGF5ZXIuaW5pdENvbnRleHQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGxheWVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIGluc2VydExheWVyOiBmdW5jdGlvbiAoemxldmVsLCBsYXllcikge1xuXG4gICAgICAgICAgICB2YXIgbGF5ZXJzTWFwID0gdGhpcy5fbGF5ZXJzO1xuICAgICAgICAgICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0O1xuICAgICAgICAgICAgdmFyIGxlbiA9IHpsZXZlbExpc3QubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHByZXZMYXllciA9IG51bGw7XG4gICAgICAgICAgICB2YXIgaSA9IC0xO1xuICAgICAgICAgICAgdmFyIGRvbVJvb3QgPSB0aGlzLl9kb21Sb290O1xuXG4gICAgICAgICAgICBpZiAobGF5ZXJzTWFwW3psZXZlbF0pIHtcbiAgICAgICAgICAgICAgICBsb2coJ1pMZXZlbCAnICsgemxldmVsICsgJyBoYXMgYmVlbiB1c2VkIGFscmVhZHknKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBpcyBhIHZhbGlkIGxheWVyXG4gICAgICAgICAgICBpZiAoIWlzTGF5ZXJWYWxpZChsYXllcikpIHtcbiAgICAgICAgICAgICAgICBsb2coJ0xheWVyIG9mIHpsZXZlbCAnICsgemxldmVsICsgJyBpcyBub3QgdmFsaWQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsZW4gPiAwICYmIHpsZXZlbCA+IHpsZXZlbExpc3RbMF0pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHpsZXZlbExpc3RbaV0gPCB6bGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHpsZXZlbExpc3RbaSArIDFdID4gemxldmVsXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldkxheWVyID0gbGF5ZXJzTWFwW3psZXZlbExpc3RbaV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgemxldmVsTGlzdC5zcGxpY2UoaSArIDEsIDAsIHpsZXZlbCk7XG5cbiAgICAgICAgICAgIGlmIChwcmV2TGF5ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldkRvbSA9IHByZXZMYXllci5kb207XG4gICAgICAgICAgICAgICAgaWYgKHByZXZEb20ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tUm9vdC5pbnNlcnRCZWZvcmUoXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllci5kb20sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2RG9tLm5leHRTaWJsaW5nXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkb21Sb290LmFwcGVuZENoaWxkKGxheWVyLmRvbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvbVJvb3QuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBkb21Sb290Lmluc2VydEJlZm9yZShsYXllci5kb20sIGRvbVJvb3QuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkb21Sb290LmFwcGVuZENoaWxkKGxheWVyLmRvbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXllcnNNYXBbemxldmVsXSA9IGxheWVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEl0ZXJhdGUgZWFjaCBsYXllclxuICAgICAgICBlYWNoTGF5ZXI6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0O1xuICAgICAgICAgICAgdmFyIHo7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB6bGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgeiA9IHpsZXZlbExpc3RbaV07XG4gICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCB0aGlzLl9sYXllcnNbel0sIHopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEl0ZXJhdGUgZWFjaCBidWlsZGluIGxheWVyXG4gICAgICAgIGVhY2hCdWlsZGluTGF5ZXI6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0O1xuICAgICAgICAgICAgdmFyIGxheWVyO1xuICAgICAgICAgICAgdmFyIHo7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB6bGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgeiA9IHpsZXZlbExpc3RbaV07XG4gICAgICAgICAgICAgICAgbGF5ZXIgPSB0aGlzLl9sYXllcnNbel07XG4gICAgICAgICAgICAgICAgaWYgKGxheWVyLmlzQnVpbGRpbikge1xuICAgICAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIGxheWVyLCB6KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gSXRlcmF0ZSBlYWNoIG90aGVyIGxheWVyIGV4Y2VwdCBidWlsZGluIGxheWVyXG4gICAgICAgIGVhY2hPdGhlckxheWVyOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgICAgIHZhciBsYXllcjtcbiAgICAgICAgICAgIHZhciB6O1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgICAgICAgICAgIGxheWVyID0gdGhpcy5fbGF5ZXJzW3pdO1xuICAgICAgICAgICAgICAgIGlmICghIGxheWVyLmlzQnVpbGRpbikge1xuICAgICAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIGxheWVyLCB6KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPluaJgOacieW3suWIm+W7uueahOWxglxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5Ljxtb2R1bGU6enJlbmRlci9MYXllcj59IFtwcmV2TGF5ZXJdXG4gICAgICAgICAqL1xuICAgICAgICBnZXRMYXllcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXllcnM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3VwZGF0ZUxheWVyU3RhdHVzOiBmdW5jdGlvbiAobGlzdCkge1xuXG4gICAgICAgICAgICB2YXIgbGF5ZXJzID0gdGhpcy5fbGF5ZXJzO1xuICAgICAgICAgICAgdmFyIHByb2dyZXNzaXZlTGF5ZXJzID0gdGhpcy5fcHJvZ3Jlc3NpdmVMYXllcnM7XG5cbiAgICAgICAgICAgIHZhciBlbENvdW50c0xhc3RGcmFtZSA9IHt9O1xuICAgICAgICAgICAgdmFyIHByb2dyZXNzaXZlRWxDb3VudHNMYXN0RnJhbWUgPSB7fTtcblxuICAgICAgICAgICAgdGhpcy5lYWNoQnVpbGRpbkxheWVyKGZ1bmN0aW9uIChsYXllciwgeikge1xuICAgICAgICAgICAgICAgIGVsQ291bnRzTGFzdEZyYW1lW3pdID0gbGF5ZXIuZWxDb3VudDtcbiAgICAgICAgICAgICAgICBsYXllci5lbENvdW50ID0gMDtcbiAgICAgICAgICAgICAgICBsYXllci5fX2RpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdXRpbC5lYWNoKHByb2dyZXNzaXZlTGF5ZXJzLCBmdW5jdGlvbiAobGF5ZXIsIGlkeCkge1xuICAgICAgICAgICAgICAgIHByb2dyZXNzaXZlRWxDb3VudHNMYXN0RnJhbWVbaWR4XSA9IGxheWVyLmVsQ291bnQ7XG4gICAgICAgICAgICAgICAgbGF5ZXIuZWxDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgbGF5ZXIuX19kaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBwcm9ncmVzc2l2ZUxheWVyQ291bnQgPSAwO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyO1xuICAgICAgICAgICAgdmFyIGxhc3RQcm9ncmVzc2l2ZUtleTtcbiAgICAgICAgICAgIHZhciBmcmFtZUNvdW50ID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBsaXN0W2ldO1xuICAgICAgICAgICAgICAgIHZhciB6bGV2ZWwgPSB0aGlzLl9zaW5nbGVDYW52YXMgPyAwIDogZWwuemxldmVsO1xuICAgICAgICAgICAgICAgIHZhciBsYXllciA9IGxheWVyc1t6bGV2ZWxdO1xuICAgICAgICAgICAgICAgIHZhciBlbFByb2dyZXNzID0gZWwucHJvZ3Jlc3NpdmU7XG4gICAgICAgICAgICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLmVsQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuX19kaXJ0eSA9IGxheWVyLl9fZGlydHkgfHwgZWwuX19kaXJ0eTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLy8vLy8vIFVwZGF0ZSBwcm9ncmVzc2l2ZVxuICAgICAgICAgICAgICAgIGlmIChlbFByb2dyZXNzID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRml4IHdyb25nIHByb2dyZXNzaXZlIHNlcXVlbmNlIHByb2JsZW0uXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0UHJvZ3Jlc3NpdmVLZXkgIT09IGVsUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RQcm9ncmVzc2l2ZUtleSA9IGVsUHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFtZUNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsRnJhbWUgPSBlbC5fX2ZyYW1lID0gZnJhbWVDb3VudCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSBNYXRoLm1pbihwcm9ncmVzc2l2ZUxheWVyQ291bnQsIE1BWF9QUk9HUkVTU0lWRV9MQVlFUl9OVU1CRVIgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyID0gcHJvZ3Jlc3NpdmVMYXllcnNbaWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciA9IHByb2dyZXNzaXZlTGF5ZXJzW2lkeF0gPSBuZXcgTGF5ZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwcm9ncmVzc2l2ZScsIHRoaXMsIHRoaXMuZHByXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5pbml0Q29udGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19tYXhQcm9ncmVzcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19kaXJ0eSA9IGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fZGlydHkgfHwgZWwuX19kaXJ0eTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuZWxDb3VudCsrO1xuXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbWF4UHJvZ3Jlc3MgPSBNYXRoLm1heChcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbWF4UHJvZ3Jlc3MsIGVsRnJhbWVcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIuX19tYXhQcm9ncmVzcyA+PSBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllci5fX3Byb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG91bGQga2VlcCByZW5kZXJpbmcgdGhpcyAgbGF5ZXIgYmVjYXVzZSBwcm9ncmVzc2l2ZSByZW5kZXJpbmcgaXMgbm90IGZpbmlzaGVkIHlldFxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXIuX19kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLl9fZnJhbWUgPSAtMTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFByb2dyZXNzaXZlTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbmV4dElkeE5vdFByb2cgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NpdmVMYXllckNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3NpdmVMYXllciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50UHJvZ3Jlc3NpdmVMYXllcikge1xuICAgICAgICAgICAgICAgIHByb2dyZXNzaXZlTGF5ZXJDb3VudCsrO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmVzc2l2ZUxheWVyLl9fbmV4dElkeE5vdFByb2cgPSBpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyDlsYLkuK3nmoTlhYPntKDmlbDph4/mnInlj5HnlJ/lj5jljJZcbiAgICAgICAgICAgIHRoaXMuZWFjaEJ1aWxkaW5MYXllcihmdW5jdGlvbiAobGF5ZXIsIHopIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxDb3VudHNMYXN0RnJhbWVbel0gIT09IGxheWVyLmVsQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuX19kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHByb2dyZXNzaXZlTGF5ZXJzLmxlbmd0aCA9IE1hdGgubWluKHByb2dyZXNzaXZlTGF5ZXJDb3VudCwgTUFYX1BST0dSRVNTSVZFX0xBWUVSX05VTUJFUik7XG4gICAgICAgICAgICB1dGlsLmVhY2gocHJvZ3Jlc3NpdmVMYXllcnMsIGZ1bmN0aW9uIChsYXllciwgaWR4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb2dyZXNzaXZlRWxDb3VudHNMYXN0RnJhbWVbaWR4XSAhPT0gbGF5ZXIuZWxDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBlbC5fX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxheWVyLl9fZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuX19wcm9ncmVzcyA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa4hemZpGhvdmVy5bGC5aSW5omA5pyJ5YaF5a65XG4gICAgICAgICAqL1xuICAgICAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5lYWNoQnVpbGRpbkxheWVyKHRoaXMuX2NsZWFyTGF5ZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2NsZWFyTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICAgICAgbGF5ZXIuY2xlYXIoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5L+u5pS55oyH5a6aemxldmVs55qE57uY5Yi25Y+C5pWwXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB6bGV2ZWxcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyDphY3nva7lr7nosaFcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcuY2xlYXJDb2xvcj0wXSDmr4/mrKHmuIXnqbrnlLvluIPnmoTpopzoibJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcubW90aW9uQmx1cj1mYWxzZV0g5piv5ZCm5byA5ZCv5Yqo5oCB5qih57OKXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLmxhc3RGcmFtZUFscGhhPTAuN11cbiAgICAgICAgICogICAgICAgICAgICAgICAgIOWcqOW8gOWQr+WKqOaAgeaooeeziueahOaXtuWAmeS9v+eUqO+8jOS4juS4iuS4gOW4p+a3t+WQiOeahGFscGhh5YC877yM5YC86LaK5aSn5bC+6L+56LaK5piO5pi+XG4gICAgICAgICAqL1xuICAgICAgICBjb25maWdMYXllcjogZnVuY3Rpb24gKHpsZXZlbCwgY29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxheWVyQ29uZmlnID0gdGhpcy5fbGF5ZXJDb25maWc7XG4gICAgICAgICAgICAgICAgaWYgKCFsYXllckNvbmZpZ1t6bGV2ZWxdKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyQ29uZmlnW3psZXZlbF0gPSBjb25maWc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1dGlsLm1lcmdlKGxheWVyQ29uZmlnW3psZXZlbF0sIGNvbmZpZywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW3psZXZlbF07XG5cbiAgICAgICAgICAgICAgICBpZiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5tZXJnZShsYXllciwgbGF5ZXJDb25maWdbemxldmVsXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliKDpmaTmjIflrprlsYJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHpsZXZlbCDlsYLmiYDlnKjnmoR6bGV2ZWxcbiAgICAgICAgICovXG4gICAgICAgIGRlbExheWVyOiBmdW5jdGlvbiAoemxldmVsKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXJzID0gdGhpcy5fbGF5ZXJzO1xuICAgICAgICAgICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0O1xuICAgICAgICAgICAgdmFyIGxheWVyID0gbGF5ZXJzW3psZXZlbF07XG4gICAgICAgICAgICBpZiAoIWxheWVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGF5ZXIuZG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobGF5ZXIuZG9tKTtcbiAgICAgICAgICAgIGRlbGV0ZSBsYXllcnNbemxldmVsXTtcblxuICAgICAgICAgICAgemxldmVsTGlzdC5zcGxpY2UodXRpbC5pbmRleE9mKHpsZXZlbExpc3QsIHpsZXZlbCksIDEpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDljLrln5/lpKflsI/lj5jljJblkI7ph43nu5hcbiAgICAgICAgICovXG4gICAgICAgIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciBkb21Sb290ID0gdGhpcy5fZG9tUm9vdDtcbiAgICAgICAgICAgIC8vIEZJWE1FIFdoeSA/XG4gICAgICAgICAgICBkb21Sb290LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgICAgIHdpZHRoID0gd2lkdGggfHwgdGhpcy5fZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIGhlaWdodCA9IGhlaWdodCB8fCB0aGlzLl9nZXRIZWlnaHQoKTtcblxuICAgICAgICAgICAgZG9tUm9vdC5zdHlsZS5kaXNwbGF5ID0gJyc7XG5cbiAgICAgICAgICAgIC8vIOS8mOWMluayoeacieWunumZheaUueWPmOeahHJlc2l6ZVxuICAgICAgICAgICAgaWYgKHRoaXMuX3dpZHRoICE9IHdpZHRoIHx8IGhlaWdodCAhPSB0aGlzLl9oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBkb21Sb290LnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICAgICAgICAgIGRvbVJvb3Quc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXllcnNbaWRdLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2godHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmuIXpmaTljZXni6znmoTkuIDkuKrlsYJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHpsZXZlbFxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXJMYXllcjogZnVuY3Rpb24gKHpsZXZlbCkge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW3psZXZlbF07XG4gICAgICAgICAgICBpZiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBsYXllci5jbGVhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDph4rmlL5cbiAgICAgICAgICovXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdC5pbm5lckhUTUwgPSAnJztcblxuICAgICAgICAgICAgdGhpcy5yb290ID1cbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZSA9XG5cbiAgICAgICAgICAgIHRoaXMuX2RvbVJvb3QgPVxuICAgICAgICAgICAgdGhpcy5fbGF5ZXJzID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGNhbnZhcyB3aGljaCBoYXMgYWxsIHRoaW5nIHJlbmRlcmVkXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5iYWNrZ3JvdW5kQ29sb3JdXG4gICAgICAgICAqL1xuICAgICAgICBnZXRSZW5kZXJlZENhbnZhczogZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NpbmdsZUNhbnZhcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXllcnNbMF0uZG9tO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaW1hZ2VMYXllciA9IG5ldyBMYXllcignaW1hZ2UnLCB0aGlzLCBvcHRzLnBpeGVsUmF0aW8gfHwgdGhpcy5kcHIpO1xuICAgICAgICAgICAgaW1hZ2VMYXllci5pbml0Q29udGV4dCgpO1xuXG4gICAgICAgICAgICBpbWFnZUxheWVyLmNsZWFyQ29sb3IgPSBvcHRzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgIGltYWdlTGF5ZXIuY2xlYXIoKTtcblxuICAgICAgICAgICAgdmFyIGRpc3BsYXlMaXN0ID0gdGhpcy5zdG9yYWdlLmdldERpc3BsYXlMaXN0KHRydWUpO1xuXG4gICAgICAgICAgICB2YXIgc2NvcGUgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGxheUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBkaXNwbGF5TGlzdFtpXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kb1BhaW50RWwoZWwsIGltYWdlTGF5ZXIsIHRydWUsIHNjb3BlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGltYWdlTGF5ZXIuZG9tO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W57uY5Zu+5Yy65Z+f5a695bqmXG4gICAgICAgICAqL1xuICAgICAgICBnZXRXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDojrflj5bnu5jlm77ljLrln5/pq5jluqZcbiAgICAgICAgICovXG4gICAgICAgIGdldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gdGhpcy5yb290O1xuICAgICAgICAgICAgdmFyIHN0bCA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUocm9vdCk7XG5cbiAgICAgICAgICAgIC8vIEZJWE1FIEJldHRlciB3YXkgdG8gZ2V0IHRoZSB3aWR0aCBhbmQgaGVpZ2h0IHdoZW4gZWxlbWVudCBoYXMgbm90IGJlZW4gYXBwZW5kIHRvIHRoZSBkb2N1bWVudFxuICAgICAgICAgICAgcmV0dXJuICgocm9vdC5jbGllbnRXaWR0aCB8fCBwYXJzZUludDEwKHN0bC53aWR0aCkgfHwgcGFyc2VJbnQxMChyb290LnN0eWxlLndpZHRoKSlcbiAgICAgICAgICAgICAgICAgICAgLSAocGFyc2VJbnQxMChzdGwucGFkZGluZ0xlZnQpIHx8IDApXG4gICAgICAgICAgICAgICAgICAgIC0gKHBhcnNlSW50MTAoc3RsLnBhZGRpbmdSaWdodCkgfHwgMCkpIHwgMDtcbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0SGVpZ2h0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IHRoaXMucm9vdDtcbiAgICAgICAgICAgIHZhciBzdGwgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHJvb3QpO1xuXG4gICAgICAgICAgICByZXR1cm4gKChyb290LmNsaWVudEhlaWdodCB8fCBwYXJzZUludDEwKHN0bC5oZWlnaHQpIHx8IHBhcnNlSW50MTAocm9vdC5zdHlsZS5oZWlnaHQpKVxuICAgICAgICAgICAgICAgICAgICAtIChwYXJzZUludDEwKHN0bC5wYWRkaW5nVG9wKSB8fCAwKVxuICAgICAgICAgICAgICAgICAgICAtIChwYXJzZUludDEwKHN0bC5wYWRkaW5nQm90dG9tKSB8fCAwKSkgfCAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9wYXRoVG9JbWFnZTogZnVuY3Rpb24gKGlkLCBwYXRoLCB3aWR0aCwgaGVpZ2h0LCBkcHIpIHtcbiAgICAgICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGggKiBkcHI7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogZHByO1xuXG4gICAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoICogZHByLCBoZWlnaHQgKiBkcHIpO1xuXG4gICAgICAgICAgICB2YXIgcGF0aFRyYW5zZm9ybSA9IHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogcGF0aC5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogcGF0aC5yb3RhdGlvbixcbiAgICAgICAgICAgICAgICBzY2FsZTogcGF0aC5zY2FsZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBhdGgucG9zaXRpb24gPSBbMCwgMCwgMF07XG4gICAgICAgICAgICBwYXRoLnJvdGF0aW9uID0gMDtcbiAgICAgICAgICAgIHBhdGguc2NhbGUgPSBbMSwgMV07XG4gICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgIHBhdGguYnJ1c2goY3R4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIEltYWdlU2hhcGUgPSByZXF1aXJlKCcuL2dyYXBoaWMvSW1hZ2UnKTtcbiAgICAgICAgICAgIHZhciBpbWdTaGFwZSA9IG5ldyBJbWFnZVNoYXBlKHtcbiAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IGNhbnZhc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAocGF0aFRyYW5zZm9ybS5wb3NpdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW1nU2hhcGUucG9zaXRpb24gPSBwYXRoLnBvc2l0aW9uID0gcGF0aFRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBhdGhUcmFuc2Zvcm0ucm90YXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGltZ1NoYXBlLnJvdGF0aW9uID0gcGF0aC5yb3RhdGlvbiA9IHBhdGhUcmFuc2Zvcm0ucm90YXRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYXRoVHJhbnNmb3JtLnNjYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbWdTaGFwZS5zY2FsZSA9IHBhdGguc2NhbGUgPSBwYXRoVHJhbnNmb3JtLnNjYWxlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaW1nU2hhcGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2NyZWF0ZVBhdGhUb0ltYWdlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGlkLCBlLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lLl9wYXRoVG9JbWFnZShcbiAgICAgICAgICAgICAgICAgICAgaWQsIGUsIHdpZHRoLCBoZWlnaHQsIG1lLmRwclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBQYWludGVyO1xufSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL3pyZW5kZXIvUGFpbnRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDk1XG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCIvKipcbiAqIEBtb2R1bGUgenJlbmRlci9MYXllclxuICogQGF1dGhvciBwaXNzYW5nKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vY29yZS91dGlsJyk7XG4gICAgdmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG4gICAgdmFyIFN0eWxlID0gcmVxdWlyZSgnLi9ncmFwaGljL1N0eWxlJyk7XG4gICAgdmFyIFBhdHRlcm4gPSByZXF1aXJlKCcuL2dyYXBoaWMvUGF0dGVybicpO1xuXG4gICAgZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDliJvlu7pkb21cbiAgICAgKlxuICAgICAqIEBpbm5lclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBkb20gaWQg5b6F55SoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgZG9tIHR5cGXvvIxzdWNoIGFzIGNhbnZhcywgZGl2IGV0Yy5cbiAgICAgKiBAcGFyYW0ge1BhaW50ZXJ9IHBhaW50ZXIgcGFpbnRlciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVEb20oaWQsIHR5cGUsIHBhaW50ZXIsIGRwcikge1xuICAgICAgICB2YXIgbmV3RG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgICAgICAgdmFyIHdpZHRoID0gcGFpbnRlci5nZXRXaWR0aCgpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gcGFpbnRlci5nZXRIZWlnaHQoKTtcblxuICAgICAgICB2YXIgbmV3RG9tU3R5bGUgPSBuZXdEb20uc3R5bGU7XG4gICAgICAgIC8vIOayoWFwcGVuZOWRou+8jOivt+WOn+iwheaIkei/meagt+WGme+8jOa4heaZsH5cbiAgICAgICAgbmV3RG9tU3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBuZXdEb21TdHlsZS5sZWZ0ID0gMDtcbiAgICAgICAgbmV3RG9tU3R5bGUudG9wID0gMDtcbiAgICAgICAgbmV3RG9tU3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICAgIG5ld0RvbVN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgICAgIG5ld0RvbS53aWR0aCA9IHdpZHRoICogZHByO1xuICAgICAgICBuZXdEb20uaGVpZ2h0ID0gaGVpZ2h0ICogZHByO1xuXG4gICAgICAgIC8vIGlk5LiN5L2c5Li657Si5byV55So77yM6YG/5YWN5Y+v6IO96YCg5oiQ55qE6YeN5ZCN77yM5a6a5LmJ5Li656eB5pyJ5bGe5oCnXG4gICAgICAgIG5ld0RvbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtenItZG9tLWlkJywgaWQpO1xuICAgICAgICByZXR1cm4gbmV3RG9tO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9MYXllclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1BhaW50ZXJ9IHBhaW50ZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Rwcl1cbiAgICAgKi9cbiAgICB2YXIgTGF5ZXIgPSBmdW5jdGlvbihpZCwgcGFpbnRlciwgZHByKSB7XG4gICAgICAgIHZhciBkb207XG4gICAgICAgIGRwciA9IGRwciB8fCBjb25maWcuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGRvbSA9IGNyZWF0ZURvbShpZCwgJ2NhbnZhcycsIHBhaW50ZXIsIGRwcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90IHVzaW5nIGlzRG9tIGJlY2F1c2UgaW4gbm9kZSBpdCB3aWxsIHJldHVybiBmYWxzZVxuICAgICAgICBlbHNlIGlmICh1dGlsLmlzT2JqZWN0KGlkKSkge1xuICAgICAgICAgICAgZG9tID0gaWQ7XG4gICAgICAgICAgICBpZCA9IGRvbS5pZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuXG4gICAgICAgIHZhciBkb21TdHlsZSA9IGRvbS5zdHlsZTtcbiAgICAgICAgaWYgKGRvbVN0eWxlKSB7IC8vIE5vdCBpbiBub2RlXG4gICAgICAgICAgICBkb20ub25zZWxlY3RzdGFydCA9IHJldHVybkZhbHNlOyAvLyDpgb/lhY3pobXpnaLpgInkuK3nmoTlsLTlsKxcbiAgICAgICAgICAgIGRvbVN0eWxlWyctd2Via2l0LXVzZXItc2VsZWN0J10gPSAnbm9uZSc7XG4gICAgICAgICAgICBkb21TdHlsZVsndXNlci1zZWxlY3QnXSA9ICdub25lJztcbiAgICAgICAgICAgIGRvbVN0eWxlWyctd2Via2l0LXRvdWNoLWNhbGxvdXQnXSA9ICdub25lJztcbiAgICAgICAgICAgIGRvbVN0eWxlWyctd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3InXSA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZG9tQmFjayA9IG51bGw7XG4gICAgICAgIHRoaXMuY3R4QmFjayA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5wYWludGVyID0gcGFpbnRlcjtcblxuICAgICAgICB0aGlzLmNvbmZpZyA9IG51bGw7XG5cbiAgICAgICAgLy8gQ29uZmlnc1xuICAgICAgICAvKipcbiAgICAgICAgICog5q+P5qyh5riF56m655S75biD55qE6aKc6ImyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xlYXJDb2xvciA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKblvIDlkK/liqjmgIHmqKHns4pcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1vdGlvbkJsdXIgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWcqOW8gOWQr+WKqOaAgeaooeeziueahOaXtuWAmeS9v+eUqO+8jOS4juS4iuS4gOW4p+a3t+WQiOeahGFscGhh5YC877yM5YC86LaK5aSn5bC+6L+56LaK5piO5pi+XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDAuN1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXN0RnJhbWVBbHBoYSA9IDAuNztcblxuICAgICAgICAvKipcbiAgICAgICAgICogTGF5ZXIgZHByXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRwciA9IGRwcjtcbiAgICB9O1xuXG4gICAgTGF5ZXIucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBMYXllcixcblxuICAgICAgICBlbENvdW50OiAwLFxuXG4gICAgICAgIF9fZGlydHk6IHRydWUsXG5cbiAgICAgICAgaW5pdENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuY3R4ID0gdGhpcy5kb20uZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAgICAgdGhpcy5jdHguZHByID0gdGhpcy5kcHI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlQmFja0J1ZmZlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRwciA9IHRoaXMuZHByO1xuXG4gICAgICAgICAgICB0aGlzLmRvbUJhY2sgPSBjcmVhdGVEb20oJ2JhY2stJyArIHRoaXMuaWQsICdjYW52YXMnLCB0aGlzLnBhaW50ZXIsIGRwcik7XG4gICAgICAgICAgICB0aGlzLmN0eEJhY2sgPSB0aGlzLmRvbUJhY2suZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAgICAgaWYgKGRwciAhPSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdHhCYWNrLnNjYWxlKGRwciwgZHByKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB3aWR0aFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGhlaWdodFxuICAgICAgICAgKi9cbiAgICAgICAgcmVzaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgdmFyIGRwciA9IHRoaXMuZHByO1xuXG4gICAgICAgICAgICB2YXIgZG9tID0gdGhpcy5kb207XG4gICAgICAgICAgICB2YXIgZG9tU3R5bGUgPSBkb20uc3R5bGU7XG4gICAgICAgICAgICB2YXIgZG9tQmFjayA9IHRoaXMuZG9tQmFjaztcblxuICAgICAgICAgICAgZG9tU3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICAgICAgICBkb21TdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuXG4gICAgICAgICAgICBkb20ud2lkdGggPSB3aWR0aCAqIGRwcjtcbiAgICAgICAgICAgIGRvbS5oZWlnaHQgPSBoZWlnaHQgKiBkcHI7XG5cbiAgICAgICAgICAgIGlmIChkb21CYWNrKSB7XG4gICAgICAgICAgICAgICAgZG9tQmFjay53aWR0aCA9IHdpZHRoICogZHByO1xuICAgICAgICAgICAgICAgIGRvbUJhY2suaGVpZ2h0ID0gaGVpZ2h0ICogZHByO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRwciAhPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4QmFjay5zY2FsZShkcHIsIGRwcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmuIXnqbror6XlsYLnlLvluINcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBjbGVhckFsbCBDbGVhciBhbGwgd2l0aCBvdXQgbW90aW9uIGJsdXJcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbiAoY2xlYXJBbGwpIHtcbiAgICAgICAgICAgIHZhciBkb20gPSB0aGlzLmRvbTtcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGRvbS53aWR0aDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBkb20uaGVpZ2h0O1xuXG4gICAgICAgICAgICB2YXIgY2xlYXJDb2xvciA9IHRoaXMuY2xlYXJDb2xvcjtcbiAgICAgICAgICAgIHZhciBoYXZlTW90aW9uQkx1ciA9IHRoaXMubW90aW9uQmx1ciAmJiAhY2xlYXJBbGw7XG4gICAgICAgICAgICB2YXIgbGFzdEZyYW1lQWxwaGEgPSB0aGlzLmxhc3RGcmFtZUFscGhhO1xuXG4gICAgICAgICAgICB2YXIgZHByID0gdGhpcy5kcHI7XG5cbiAgICAgICAgICAgIGlmIChoYXZlTW90aW9uQkx1cikge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5kb21CYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlQmFja0J1ZmZlcigpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuY3R4QmFjay5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnY29weSc7XG4gICAgICAgICAgICAgICAgdGhpcy5jdHhCYWNrLmRyYXdJbWFnZShcbiAgICAgICAgICAgICAgICAgICAgZG9tLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aCAvIGRwcixcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0IC8gZHByXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGlmIChjbGVhckNvbG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybjtcbiAgICAgICAgICAgICAgICAvLyBHcmFkaWVudFxuICAgICAgICAgICAgICAgIGlmIChjbGVhckNvbG9yLmNvbG9yU3RvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgY2FudmFzIGdyYWRpZW50XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybiA9IGNsZWFyQ29sb3IuX19jYW52YXNHcmFkaWVudCB8fCBTdHlsZS5nZXRHcmFkaWVudChjdHgsIGNsZWFyQ29sb3IsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY2xlYXJDb2xvci5fX2NhbnZhc0dyYWRpZW50ID0gY2xlYXJDb2xvckdyYWRpZW50T3JQYXR0ZXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQYXR0ZXJuXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2xlYXJDb2xvci5pbWFnZSkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm4gPSBQYXR0ZXJuLnByb3RvdHlwZS5nZXRDYW52YXNQYXR0ZXJuLmNhbGwoY2xlYXJDb2xvciwgY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY2xlYXJDb2xvckdyYWRpZW50T3JQYXR0ZXJuIHx8IGNsZWFyQ29sb3I7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChoYXZlTW90aW9uQkx1cikge1xuICAgICAgICAgICAgICAgIHZhciBkb21CYWNrID0gdGhpcy5kb21CYWNrO1xuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gbGFzdEZyYW1lQWxwaGE7XG4gICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShkb21CYWNrLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBMYXllcjtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvenJlbmRlci9MYXllci5qc1xuICoqIG1vZHVsZSBpZCA9IDk2XG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCJkZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcbiAgICB2YXIgR3JhZGllbnQgPSByZXF1aXJlKCd6cmVuZGVyL2dyYXBoaWMvR3JhZGllbnQnKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVjTW9kZWwpIHtcbiAgICAgICAgZnVuY3Rpb24gZW5jb2RlQ29sb3Ioc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBjb2xvckFjY2Vzc1BhdGggPSAoc2VyaWVzTW9kZWwudmlzdWFsQ29sb3JBY2Nlc3NQYXRoIHx8ICdpdGVtU3R5bGUubm9ybWFsLmNvbG9yJykuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgdmFyIGNvbG9yID0gc2VyaWVzTW9kZWwuZ2V0KGNvbG9yQWNjZXNzUGF0aCkgLy8gU2V0IGluIGl0ZW1TdHlsZVxuICAgICAgICAgICAgICAgIHx8IHNlcmllc01vZGVsLmdldENvbG9yRnJvbVBhbGV0dGUoc2VyaWVzTW9kZWwuZ2V0KCduYW1lJykpOyAgLy8gRGVmYXVsdCBjb2xvclxuXG4gICAgICAgICAgICAvLyBGSVhNRSBTZXQgY29sb3IgZnVuY3Rpb24gb3IgdXNlIHRoZSBwbGF0dGUgY29sb3JcbiAgICAgICAgICAgIGRhdGEuc2V0VmlzdWFsKCdjb2xvcicsIGNvbG9yKTtcblxuICAgICAgICAgICAgLy8gT25seSB2aXNpYmxlIHNlcmllcyBoYXMgZWFjaCBkYXRhIGJlIHZpc3VhbCBlbmNvZGVkXG4gICAgICAgICAgICBpZiAoIWVjTW9kZWwuaXNTZXJpZXNGaWx0ZXJlZChzZXJpZXNNb2RlbCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbG9yID09PSAnZnVuY3Rpb24nICYmICEoY29sb3IgaW5zdGFuY2VvZiBHcmFkaWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc2V0SXRlbVZpc3VhbChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHgsICdjb2xvcicsIGNvbG9yKHNlcmllc01vZGVsLmdldERhdGFQYXJhbXMoaWR4KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGl0ZW1TdHlsZSBpbiBlYWNoIGRhdGEgaXRlbVxuICAgICAgICAgICAgICAgIGRhdGEuZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBpdGVtTW9kZWwuZ2V0KGNvbG9yQWNjZXNzUGF0aCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xvciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNldEl0ZW1WaXN1YWwoaWR4LCAnY29sb3InLCBjb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlY01vZGVsLmVhY2hSYXdTZXJpZXMoZW5jb2RlQ29sb3IpO1xuICAgIH07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL2VjaGFydHMvdmlzdWFsL3Nlcmllc0NvbG9yLmpzXG4gKiogbW9kdWxlIGlkID0gOTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsIi8vIENvbXBhdGl0YWJsZSB3aXRoIDIuMFxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9jb3JlL3V0aWwnKTtcbiAgICB2YXIgY29tcGF0U3R5bGUgPSByZXF1aXJlKCcuL2hlbHBlci9jb21wYXRTdHlsZScpO1xuXG4gICAgZnVuY3Rpb24gZ2V0KG9wdCwgcGF0aCkge1xuICAgICAgICBwYXRoID0gcGF0aC5zcGxpdCgnLCcpO1xuICAgICAgICB2YXIgb2JqID0gb3B0O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG9iaiA9IG9iaiAmJiBvYmpbcGF0aFtpXV07XG4gICAgICAgICAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldChvcHQsIHBhdGgsIHZhbCwgb3ZlcndyaXRlKSB7XG4gICAgICAgIHBhdGggPSBwYXRoLnNwbGl0KCcsJyk7XG4gICAgICAgIHZhciBvYmogPSBvcHQ7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGtleSA9IHBhdGhbaV07XG4gICAgICAgICAgICBpZiAob2JqW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG9ialtrZXldID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmogPSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3ZlcndyaXRlIHx8IG9ialtwYXRoW2ldXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBvYmpbcGF0aFtpXV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wYXRMYXlvdXRQcm9wZXJ0aWVzKG9wdGlvbikge1xuICAgICAgICBlYWNoKExBWU9VVF9QUk9QRVJUSUVTLCBmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgaWYgKHByb3BbMF0gaW4gb3B0aW9uICYmICEocHJvcFsxXSBpbiBvcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uW3Byb3BbMV1dID0gb3B0aW9uW3Byb3BbMF1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgTEFZT1VUX1BST1BFUlRJRVMgPSBbXG4gICAgICAgIFsneCcsICdsZWZ0J10sIFsneScsICd0b3AnXSwgWyd4MicsICdyaWdodCddLCBbJ3kyJywgJ2JvdHRvbSddXG4gICAgXTtcblxuICAgIHZhciBDT01QQVRJVEFCTEVfQ09NUE9ORU5UUyA9IFtcbiAgICAgICAgJ2dyaWQnLCAnZ2VvJywgJ3BhcmFsbGVsJywgJ2xlZ2VuZCcsICd0b29sYm94JywgJ3RpdGxlJywgJ3Zpc3VhbE1hcCcsICdkYXRhWm9vbScsICd0aW1lbGluZSdcbiAgICBdO1xuXG4gICAgdmFyIENPTVBBVElUQUJMRV9TRVJJRVMgPSBbXG4gICAgICAgICdiYXInLCAnYm94cGxvdCcsICdjYW5kbGVzdGljaycsICdjaG9yZCcsICdlZmZlY3RTY2F0dGVyJyxcbiAgICAgICAgJ2Z1bm5lbCcsICdnYXVnZScsICdsaW5lcycsICdncmFwaCcsICdoZWF0bWFwJywgJ2xpbmUnLCAnbWFwJywgJ3BhcmFsbGVsJyxcbiAgICAgICAgJ3BpZScsICdyYWRhcicsICdzYW5rZXknLCAnc2NhdHRlcicsICd0cmVlbWFwJ1xuICAgIF07XG5cbiAgICB2YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgZWFjaChvcHRpb24uc2VyaWVzLCBmdW5jdGlvbiAoc2VyaWVzT3B0KSB7XG4gICAgICAgICAgICBpZiAoIXpyVXRpbC5pc09iamVjdChzZXJpZXNPcHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2VyaWVzVHlwZSA9IHNlcmllc09wdC50eXBlO1xuXG4gICAgICAgICAgICBjb21wYXRTdHlsZShzZXJpZXNPcHQpO1xuXG4gICAgICAgICAgICBpZiAoc2VyaWVzVHlwZSA9PT0gJ3BpZScgfHwgc2VyaWVzVHlwZSA9PT0gJ2dhdWdlJykge1xuICAgICAgICAgICAgICAgIGlmIChzZXJpZXNPcHQuY2xvY2tXaXNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzT3B0LmNsb2Nrd2lzZSA9IHNlcmllc09wdC5jbG9ja1dpc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlcmllc1R5cGUgPT09ICdnYXVnZScpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRlckNvbG9yID0gZ2V0KHNlcmllc09wdCwgJ3BvaW50ZXIuY29sb3InKTtcbiAgICAgICAgICAgICAgICBwb2ludGVyQ29sb3IgIT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAmJiBzZXQoc2VyaWVzT3B0LCAnaXRlbVN0eWxlLm5vcm1hbC5jb2xvcicsIHBvaW50ZXJDb2xvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgQ09NUEFUSVRBQkxFX1NFUklFUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChDT01QQVRJVEFCTEVfU0VSSUVTW2ldID09PSBzZXJpZXNPcHQudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjb21wYXRMYXlvdXRQcm9wZXJ0aWVzKHNlcmllc09wdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZGF0YVJhbmdlIGhhcyBjaGFuZ2VkIHRvIHZpc3VhbE1hcFxuICAgICAgICBpZiAob3B0aW9uLmRhdGFSYW5nZSkge1xuICAgICAgICAgICAgb3B0aW9uLnZpc3VhbE1hcCA9IG9wdGlvbi5kYXRhUmFuZ2U7XG4gICAgICAgIH1cblxuICAgICAgICBlYWNoKENPTVBBVElUQUJMRV9DT01QT05FTlRTLCBmdW5jdGlvbiAoY29tcG9uZW50TmFtZSkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBvcHRpb25bY29tcG9uZW50TmFtZV07XG4gICAgICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICghenJVdGlsLmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IFtvcHRpb25zXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWFjaChvcHRpb25zLCBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhdExheW91dFByb3BlcnRpZXMob3B0aW9uKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvZWNoYXJ0cy9wcmVwcm9jZXNzb3IvYmFja3dhcmRDb21wYXQuanNcbiAqKiBtb2R1bGUgaWQgPSA5OFxuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9jb3JlL3V0aWwnKTtcblxuICAgIHZhciBQT1NTSUJMRV9TVFlMRVMgPSBbXG4gICAgICAgICdhcmVhU3R5bGUnLCAnbGluZVN0eWxlJywgJ25vZGVTdHlsZScsICdsaW5rU3R5bGUnLFxuICAgICAgICAnY2hvcmRTdHlsZScsICdsYWJlbCcsICdsYWJlbExpbmUnXG4gICAgXTtcblxuICAgIGZ1bmN0aW9uIGNvbXBhdEl0ZW1TdHlsZShvcHQpIHtcbiAgICAgICAgdmFyIGl0ZW1TdHlsZU9wdCA9IG9wdCAmJiBvcHQuaXRlbVN0eWxlO1xuICAgICAgICBpZiAoaXRlbVN0eWxlT3B0KSB7XG4gICAgICAgICAgICB6clV0aWwuZWFjaChQT1NTSUJMRV9TVFlMRVMsIGZ1bmN0aW9uIChzdHlsZU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsSXRlbVN0eWxlT3B0ID0gaXRlbVN0eWxlT3B0Lm5vcm1hbDtcbiAgICAgICAgICAgICAgICB2YXIgZW1waGFzaXNJdGVtU3R5bGVPcHQgPSBpdGVtU3R5bGVPcHQuZW1waGFzaXM7XG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbEl0ZW1TdHlsZU9wdCAmJiBub3JtYWxJdGVtU3R5bGVPcHRbc3R5bGVOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRbc3R5bGVOYW1lXSA9IG9wdFtzdHlsZU5hbWVdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdFtzdHlsZU5hbWVdLm5vcm1hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0W3N0eWxlTmFtZV0ubm9ybWFsID0gbm9ybWFsSXRlbVN0eWxlT3B0W3N0eWxlTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB6clV0aWwubWVyZ2Uob3B0W3N0eWxlTmFtZV0ubm9ybWFsLCBub3JtYWxJdGVtU3R5bGVPcHRbc3R5bGVOYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsSXRlbVN0eWxlT3B0W3N0eWxlTmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZW1waGFzaXNJdGVtU3R5bGVPcHQgJiYgZW1waGFzaXNJdGVtU3R5bGVPcHRbc3R5bGVOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRbc3R5bGVOYW1lXSA9IG9wdFtzdHlsZU5hbWVdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdFtzdHlsZU5hbWVdLmVtcGhhc2lzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRbc3R5bGVOYW1lXS5lbXBoYXNpcyA9IGVtcGhhc2lzSXRlbVN0eWxlT3B0W3N0eWxlTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB6clV0aWwubWVyZ2Uob3B0W3N0eWxlTmFtZV0uZW1waGFzaXMsIGVtcGhhc2lzSXRlbVN0eWxlT3B0W3N0eWxlTmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVtcGhhc2lzSXRlbVN0eWxlT3B0W3N0eWxlTmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzZXJpZXNPcHQpIHtcbiAgICAgICAgaWYgKCFzZXJpZXNPcHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb21wYXRJdGVtU3R5bGUoc2VyaWVzT3B0KTtcbiAgICAgICAgY29tcGF0SXRlbVN0eWxlKHNlcmllc09wdC5tYXJrUG9pbnQpO1xuICAgICAgICBjb21wYXRJdGVtU3R5bGUoc2VyaWVzT3B0Lm1hcmtMaW5lKTtcbiAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNPcHQuZGF0YTtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbXBhdEl0ZW1TdHlsZShkYXRhW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG1hcmsgcG9pbnQgZGF0YVxuICAgICAgICAgICAgdmFyIG1hcmtQb2ludCA9IHNlcmllc09wdC5tYXJrUG9pbnQ7XG4gICAgICAgICAgICBpZiAobWFya1BvaW50ICYmIG1hcmtQb2ludC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1wRGF0YSA9IG1hcmtQb2ludC5kYXRhO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXBEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhdEl0ZW1TdHlsZShtcERhdGFbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG1hcmsgbGluZSBkYXRhXG4gICAgICAgICAgICB2YXIgbWFya0xpbmUgPSBzZXJpZXNPcHQubWFya0xpbmU7XG4gICAgICAgICAgICBpZiAobWFya0xpbmUgJiYgbWFya0xpbmUuZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBtbERhdGEgPSBtYXJrTGluZS5kYXRhO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWxEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh6clV0aWwuaXNBcnJheShtbERhdGFbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wYXRJdGVtU3R5bGUobWxEYXRhW2ldWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhdEl0ZW1TdHlsZShtbERhdGFbaV1bMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGF0SXRlbVN0eWxlKG1sRGF0YVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC9lY2hhcnRzL3ByZXByb2Nlc3Nvci9oZWxwZXIvY29tcGF0U3R5bGUuanNcbiAqKiBtb2R1bGUgaWQgPSA5OVxuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4uL3V0aWwvZ3JhcGhpYycpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2NvcmUvdXRpbCcpO1xuICAgIHZhciBQSSA9IE1hdGguUEk7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c11cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMudGV4dF1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29sb3JdXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnRleHRDb2xvcl1cbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9FbGVtZW50fVxuICAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXBpLCBvcHRzKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICB6clV0aWwuZGVmYXVsdHMob3B0cywge1xuICAgICAgICAgICAgdGV4dDogJ2xvYWRpbmcnLFxuICAgICAgICAgICAgY29sb3I6ICcjYzIzNTMxJyxcbiAgICAgICAgICAgIHRleHRDb2xvcjogJyMwMDAnLFxuICAgICAgICAgICAgbWFza0NvbG9yOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjgpJyxcbiAgICAgICAgICAgIHpsZXZlbDogMFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG1hc2sgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgZmlsbDogb3B0cy5tYXNrQ29sb3JcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB6bGV2ZWw6IG9wdHMuemxldmVsLFxuICAgICAgICAgICAgejogMTAwMDBcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBhcmMgPSBuZXcgZ3JhcGhpYy5BcmMoe1xuICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICBzdGFydEFuZ2xlOiAtUEkgLyAyLFxuICAgICAgICAgICAgICAgIGVuZEFuZ2xlOiAtUEkgLyAyICsgMC4xLFxuICAgICAgICAgICAgICAgIHI6IDEwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBzdHJva2U6IG9wdHMuY29sb3IsXG4gICAgICAgICAgICAgICAgbGluZUNhcDogJ3JvdW5kJyxcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IDVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB6bGV2ZWw6IG9wdHMuemxldmVsLFxuICAgICAgICAgICAgejogMTAwMDFcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBsYWJlbFJlY3QgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICAgICAgICAgIHRleHQ6IG9wdHMudGV4dCxcbiAgICAgICAgICAgICAgICB0ZXh0UG9zaXRpb246ICdyaWdodCcsXG4gICAgICAgICAgICAgICAgdGV4dERpc3RhbmNlOiAxMCxcbiAgICAgICAgICAgICAgICB0ZXh0RmlsbDogb3B0cy50ZXh0Q29sb3JcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB6bGV2ZWw6IG9wdHMuemxldmVsLFxuICAgICAgICAgICAgejogMTAwMDFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXJjLmFuaW1hdGVTaGFwZSh0cnVlKVxuICAgICAgICAgICAgLndoZW4oMTAwMCwge1xuICAgICAgICAgICAgICAgIGVuZEFuZ2xlOiBQSSAqIDMgLyAyXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnN0YXJ0KCdjaXJjdWxhckluT3V0Jyk7XG4gICAgICAgIGFyYy5hbmltYXRlU2hhcGUodHJ1ZSlcbiAgICAgICAgICAgIC53aGVuKDEwMDAsIHtcbiAgICAgICAgICAgICAgICBzdGFydEFuZ2xlOiBQSSAqIDMgLyAyXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmRlbGF5KDMwMClcbiAgICAgICAgICAgIC5zdGFydCgnY2lyY3VsYXJJbk91dCcpO1xuXG4gICAgICAgIHZhciBncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gICAgICAgIGdyb3VwLmFkZChhcmMpO1xuICAgICAgICBncm91cC5hZGQobGFiZWxSZWN0KTtcbiAgICAgICAgZ3JvdXAuYWRkKG1hc2spO1xuICAgICAgICAvLyBJbmplY3QgcmVzaXplXG4gICAgICAgIGdyb3VwLnJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjeCA9IGFwaS5nZXRXaWR0aCgpIC8gMjtcbiAgICAgICAgICAgIHZhciBjeSA9IGFwaS5nZXRIZWlnaHQoKSAvIDI7XG4gICAgICAgICAgICBhcmMuc2V0U2hhcGUoe1xuICAgICAgICAgICAgICAgIGN4OiBjeCxcbiAgICAgICAgICAgICAgICBjeTogY3lcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHIgPSBhcmMuc2hhcGUucjtcbiAgICAgICAgICAgIGxhYmVsUmVjdC5zZXRTaGFwZSh7XG4gICAgICAgICAgICAgICAgeDogY3ggLSByLFxuICAgICAgICAgICAgICAgIHk6IGN5IC0gcixcbiAgICAgICAgICAgICAgICB3aWR0aDogciAqIDIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiByICogMlxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1hc2suc2V0U2hhcGUoe1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICB3aWR0aDogYXBpLmdldFdpZHRoKCksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBhcGkuZ2V0SGVpZ2h0KClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBncm91cC5yZXNpemUoKTtcbiAgICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL2VjaGFydHMvbG9hZGluZy9kZWZhdWx0LmpzXG4gKiogbW9kdWxlIGlkID0gMTAwXG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCIvKipcbiAqIExpc3QgZm9yIGRhdGEgc3RvcmFnZVxuICogQG1vZHVsZSBlY2hhcnRzL2RhdGEvTGlzdFxuICovXG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuICAgIHZhciBVTkRFRklORUQgPSAndW5kZWZpbmVkJztcbiAgICB2YXIgZ2xvYmFsT2JqID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB3aW5kb3c7XG4gICAgdmFyIEZsb2F0NjRBcnJheSA9IHR5cGVvZiBnbG9iYWxPYmouRmxvYXQ2NEFycmF5ID09PSBVTkRFRklORURcbiAgICAgICAgPyBBcnJheSA6IGdsb2JhbE9iai5GbG9hdDY0QXJyYXk7XG4gICAgdmFyIEludDMyQXJyYXkgPSB0eXBlb2YgZ2xvYmFsT2JqLkludDMyQXJyYXkgPT09IFVOREVGSU5FRFxuICAgICAgICA/IEFycmF5IDogZ2xvYmFsT2JqLkludDMyQXJyYXk7XG5cbiAgICB2YXIgZGF0YUN0b3JzID0ge1xuICAgICAgICAnZmxvYXQnOiBGbG9hdDY0QXJyYXksXG4gICAgICAgICdpbnQnOiBJbnQzMkFycmF5LFxuICAgICAgICAvLyBPcmRpbmFsIGRhdGEgdHlwZSBjYW4gYmUgc3RyaW5nIG9yIGludFxuICAgICAgICAnb3JkaW5hbCc6IEFycmF5LFxuICAgICAgICAnbnVtYmVyJzogQXJyYXksXG4gICAgICAgICd0aW1lJzogQXJyYXlcbiAgICB9O1xuXG4gICAgdmFyIE1vZGVsID0gcmVxdWlyZSgnLi4vbW9kZWwvTW9kZWwnKTtcbiAgICB2YXIgRGF0YURpZmZlciA9IHJlcXVpcmUoJy4vRGF0YURpZmZlcicpO1xuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvY29yZS91dGlsJyk7XG4gICAgdmFyIG1vZGVsVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvbW9kZWwnKTtcbiAgICB2YXIgaXNPYmplY3QgPSB6clV0aWwuaXNPYmplY3Q7XG5cbiAgICB2YXIgVFJBTlNGRVJBQkxFX1BST1BFUlRJRVMgPSBbXG4gICAgICAgICdzdGFja2VkT24nLCAnaGFzSXRlbU9wdGlvbicsICdfbmFtZUxpc3QnLCAnX2lkTGlzdCcsICdfcmF3RGF0YSdcbiAgICBdO1xuXG4gICAgdmFyIHRyYW5zZmVyUHJvcGVydGllcyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHpyVXRpbC5lYWNoKFRSQU5TRkVSQUJMRV9QUk9QRVJUSUVTLmNvbmNhdChiLl9fd3JhcHBlZE1ldGhvZHMgfHwgW10pLCBmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgICAgICAgIGlmIChiLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICAgICAgICAgIGFbcHJvcE5hbWVdID0gYltwcm9wTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGEuX193cmFwcGVkTWV0aG9kcyA9IGIuX193cmFwcGVkTWV0aG9kcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL2RhdGEvTGlzdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gZGltZW5zaW9uc1xuICAgICAqICAgICAgICBEaW1lbnNpb25zIHNob3VsZCBiZSBjb25jcmV0ZSBuYW1lcyBsaWtlIHgsIHksIHosIGxuZywgbGF0LCBhbmdsZSwgcmFkaXVzXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gaG9zdE1vZGVsXG4gICAgICovXG4gICAgdmFyIExpc3QgPSBmdW5jdGlvbiAoZGltZW5zaW9ucywgaG9zdE1vZGVsKSB7XG5cbiAgICAgICAgZGltZW5zaW9ucyA9IGRpbWVuc2lvbnMgfHwgWyd4JywgJ3knXTtcblxuICAgICAgICB2YXIgZGltZW5zaW9uSW5mb3MgPSB7fTtcbiAgICAgICAgdmFyIGRpbWVuc2lvbk5hbWVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGltZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGRpbWVuc2lvbk5hbWU7XG4gICAgICAgICAgICB2YXIgZGltZW5zaW9uSW5mbyA9IHt9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkaW1lbnNpb25zW2ldID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbk5hbWUgPSBkaW1lbnNpb25zW2ldO1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbkluZm8gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGRpbWVuc2lvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIC8vIFR5cGUgY2FuIGJlICdmbG9hdCcsICdpbnQnLCAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IGlzIG51bWJlciwgUHJlY2lzaW9uIG9mIGZsb2F0IG1heSBub3QgZW5vdWdoXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdudW1iZXInXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbkluZm8gPSBkaW1lbnNpb25zW2ldO1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbk5hbWUgPSBkaW1lbnNpb25JbmZvLm5hbWU7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9uSW5mby50eXBlID0gZGltZW5zaW9uSW5mby50eXBlIHx8ICdudW1iZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGltZW5zaW9uTmFtZXMucHVzaChkaW1lbnNpb25OYW1lKTtcbiAgICAgICAgICAgIGRpbWVuc2lvbkluZm9zW2RpbWVuc2lvbk5hbWVdID0gZGltZW5zaW9uSW5mbztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGltZW5zaW9ucyA9IGRpbWVuc2lvbk5hbWVzO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmZvbWF0aW9uIG9mIGVhY2ggZGF0YSBkaW1lbnNpb24sIGxpa2UgZGF0YSB0eXBlLlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZGltZW5zaW9uSW5mb3MgPSBkaW1lbnNpb25JbmZvcztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ob3N0TW9kZWwgPSBob3N0TW9kZWw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YVR5cGU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljZXMgc3RvcmVzIHRoZSBpbmRpY2VzIG9mIGRhdGEgc3Vic2V0IGFmdGVyIGZpbHRlcmVkLlxuICAgICAgICAgKiBUaGlzIGRhdGEgc3Vic2V0IHdpbGwgYmUgdXNlZCBpbiBjaGFydC5cbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5kaWNlcyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEYXRhIHN0b3JhZ2VcbiAgICAgICAgICogQHR5cGUge09iamVjdC48a2V5LCBUeXBlZEFycmF5fEFycmF5Pn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3N0b3JhZ2UgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxzdHJpbmc+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbmFtZUxpc3QgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2lkTGlzdCA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogTW9kZWxzIG9mIGRhdGEgb3B0aW9uIGlzIHN0b3JlZCBzcGFyc2UgZm9yIG9wdGltaXppbmcgbWVtb3J5IGNvc3RcbiAgICAgICAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbD59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vcHRpb25Nb2RlbHMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0xpc3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YWNrZWRPbiA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdsb2JhbCB2aXN1YWwgcHJvcGVydGllcyBhZnRlciB2aXN1YWwgY29kaW5nXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl92aXN1YWwgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2xvYmVsIGxheW91dCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbGF5b3V0ID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0ZW0gdmlzdWFsIHByb3BlcnRpZXMgYWZ0ZXIgdmlzdWFsIGNvZGluZ1xuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pdGVtVmlzdWFscyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJdGVtIGxheW91dCBwcm9wZXJ0aWVzIGFmdGVyIGxheW91dFxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pdGVtTGF5b3V0cyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHcmFwaGljIGVsZW1uZW50c1xuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL0VsZW1lbnQ+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZ3JhcGhpY0VscyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPEFycmF5fE9iamVjdD59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9yYXdEYXRhO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZXh0ZW50O1xuICAgIH07XG5cbiAgICB2YXIgbGlzdFByb3RvID0gTGlzdC5wcm90b3R5cGU7XG5cbiAgICBsaXN0UHJvdG8udHlwZSA9ICdsaXN0JztcbiAgICAvKipcbiAgICAgKiBJZiBlYWNoIGRhdGEgaXRlbSBoYXMgaXQncyBvd24gb3B0aW9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgbGlzdFByb3RvLmhhc0l0ZW1PcHRpb24gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogR2V0IGRpbWVuc2lvbiBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBkaW1cbiAgICAgKiAgICAgICAgRGltZW5zaW9uIGNhbiBiZSBjb25jcmV0ZSBuYW1lcyBsaWtlIHgsIHksIHosIGxuZywgbGF0LCBhbmdsZSwgcmFkaXVzXG4gICAgICogICAgICAgIE9yIGEgb3JkaW5hbCBudW1iZXIuIEZvciBleGFtcGxlIGdldERpbWVuc2lvbkluZm8oMCkgd2lsbCByZXR1cm4gJ3gnIG9yICdsbmcnIG9yICdyYWRpdXMnXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBDb25jcmV0ZSBkaW0gbmFtZS5cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uZ2V0RGltZW5zaW9uID0gZnVuY3Rpb24gKGRpbSkge1xuICAgICAgICBpZiAoIWlzTmFOKGRpbSkpIHtcbiAgICAgICAgICAgIGRpbSA9IHRoaXMuZGltZW5zaW9uc1tkaW1dIHx8IGRpbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGltO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHR5cGUgYW5kIHN0YWNrYWJsZSBpbmZvIG9mIHBhcnRpY3VsYXIgZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBkaW1cbiAgICAgKiAgICAgICAgRGltZW5zaW9uIGNhbiBiZSBjb25jcmV0ZSBuYW1lcyBsaWtlIHgsIHksIHosIGxuZywgbGF0LCBhbmdsZSwgcmFkaXVzXG4gICAgICogICAgICAgIE9yIGEgb3JkaW5hbCBudW1iZXIuIEZvciBleGFtcGxlIGdldERpbWVuc2lvbkluZm8oMCkgd2lsbCByZXR1cm4gJ3gnIG9yICdsbmcnIG9yICdyYWRpdXMnXG4gICAgICovXG4gICAgbGlzdFByb3RvLmdldERpbWVuc2lvbkluZm8gPSBmdW5jdGlvbiAoZGltKSB7XG4gICAgICAgIHJldHVybiB6clV0aWwuY2xvbmUodGhpcy5fZGltZW5zaW9uSW5mb3NbdGhpcy5nZXREaW1lbnNpb24oZGltKV0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGZyb20gZGF0YVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdHxudW1iZXJ8QXJyYXk+fSBkYXRhXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gW25hbWVMaXN0XVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtkaW1WYWx1ZUdldHRlcl0gKGRhdGFJdGVtLCBkaW1OYW1lLCBkYXRhSW5kZXgsIGRpbUluZGV4KSA9PiBudW1iZXJcbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uaW5pdERhdGEgPSBmdW5jdGlvbiAoZGF0YSwgbmFtZUxpc3QsIGRpbVZhbHVlR2V0dGVyKSB7XG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IFtdO1xuXG4gICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICBpZiAoIXpyVXRpbC5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRhdGEuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yYXdEYXRhID0gZGF0YTtcblxuICAgICAgICAvLyBDbGVhclxuICAgICAgICB2YXIgc3RvcmFnZSA9IHRoaXMuX3N0b3JhZ2UgPSB7fTtcbiAgICAgICAgdmFyIGluZGljZXMgPSB0aGlzLmluZGljZXMgPSBbXTtcblxuICAgICAgICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuZGltZW5zaW9ucztcbiAgICAgICAgdmFyIHNpemUgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdmFyIGRpbWVuc2lvbkluZm9NYXAgPSB0aGlzLl9kaW1lbnNpb25JbmZvcztcblxuICAgICAgICB2YXIgaWRMaXN0ID0gW107XG4gICAgICAgIHZhciBuYW1lUmVwZWF0Q291bnQgPSB7fTtcblxuICAgICAgICBuYW1lTGlzdCA9IG5hbWVMaXN0IHx8IFtdO1xuXG4gICAgICAgIC8vIEluaXQgc3RvcmFnZVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbWVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkaW1JbmZvID0gZGltZW5zaW9uSW5mb01hcFtkaW1lbnNpb25zW2ldXTtcbiAgICAgICAgICAgIHZhciBEYXRhQ3RvciA9IGRhdGFDdG9yc1tkaW1JbmZvLnR5cGVdO1xuICAgICAgICAgICAgc3RvcmFnZVtkaW1lbnNpb25zW2ldXSA9IG5ldyBEYXRhQ3RvcihzaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKCFkaW1WYWx1ZUdldHRlcikge1xuICAgICAgICAgICAgc2VsZi5oYXNJdGVtT3B0aW9uID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVmYXVsdCBkaW0gdmFsdWUgZ2V0dGVyXG4gICAgICAgIGRpbVZhbHVlR2V0dGVyID0gZGltVmFsdWVHZXR0ZXIgfHwgZnVuY3Rpb24gKGRhdGFJdGVtLCBkaW1OYW1lLCBkYXRhSW5kZXgsIGRpbUluZGV4KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBtb2RlbFV0aWwuZ2V0RGF0YUl0ZW1WYWx1ZShkYXRhSXRlbSk7XG4gICAgICAgICAgICAvLyBJZiBhbnkgZGF0YUl0ZW0gaXMgbGlrZSB7IHZhbHVlOiAxMCB9XG4gICAgICAgICAgICBpZiAobW9kZWxVdGlsLmlzRGF0YUl0ZW1PcHRpb24oZGF0YUl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5oYXNJdGVtT3B0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtb2RlbFV0aWwuY29udmVyRGF0YVZhbHVlKFxuICAgICAgICAgICAgICAgICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgICAgICAgICA/IHZhbHVlW2RpbUluZGV4XVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB2YWx1ZSBpcyBhIHNpbmdsZSBudW1iZXIgb3Igc29tZXRoaW5nIGVsc2Ugbm90IGFycmF5LlxuICAgICAgICAgICAgICAgICAgICA6IHZhbHVlLFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbkluZm9NYXBbZGltTmFtZV1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgZGF0YS5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICB2YXIgZGF0YUl0ZW0gPSBkYXRhW2lkeF07XG4gICAgICAgICAgICAvLyBFYWNoIGRhdGEgaXRlbSBpcyB2YWx1ZVxuICAgICAgICAgICAgLy8gWzEsIDJdXG4gICAgICAgICAgICAvLyAyXG4gICAgICAgICAgICAvLyBCYXIgY2hhcnQsIGxpbmUgY2hhcnQgd2hpY2ggdXNlcyBjYXRlZ29yeSBheGlzXG4gICAgICAgICAgICAvLyBvbmx5IGdpdmVzIHRoZSAneScgdmFsdWUuICd4JyB2YWx1ZSBpcyB0aGUgaW5kaWNlcyBvZiBjYXRlb2dyeVxuICAgICAgICAgICAgLy8gVXNlIGEgdGVtcFZhbHVlIHRvIG5vcm1hbGl6ZSB0aGUgdmFsdWUgdG8gYmUgYSAoeCwgeSkgdmFsdWVcblxuICAgICAgICAgICAgLy8gU3RvcmUgdGhlIGRhdGEgYnkgZGltZW5zaW9uc1xuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBkaW1lbnNpb25zLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpbSA9IGRpbWVuc2lvbnNba107XG4gICAgICAgICAgICAgICAgdmFyIGRpbVN0b3JhZ2UgPSBzdG9yYWdlW2RpbV07XG4gICAgICAgICAgICAgICAgLy8gUEVORElORyBOVUxMIGlzIGVtcHR5IG9yIHplcm9cbiAgICAgICAgICAgICAgICBkaW1TdG9yYWdlW2lkeF0gPSBkaW1WYWx1ZUdldHRlcihkYXRhSXRlbSwgZGltLCBpZHgsIGspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbmRpY2VzLnB1c2goaWR4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVzZSB0aGUgbmFtZSBpbiBvcHRpb24gYW5kIGNyZWF0ZSBpZFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghbmFtZUxpc3RbaV0pIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVtpXSAmJiBkYXRhW2ldLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuYW1lTGlzdFtpXSA9IGRhdGFbaV0ubmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmFtZSA9IG5hbWVMaXN0W2ldIHx8ICcnO1xuICAgICAgICAgICAgLy8gVHJ5IHVzaW5nIHRoZSBpZCBpbiBvcHRpb25cbiAgICAgICAgICAgIHZhciBpZCA9IGRhdGFbaV0gJiYgZGF0YVtpXS5pZDtcblxuICAgICAgICAgICAgaWYgKCFpZCAmJiBuYW1lKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIG5hbWUgYXMgaWQgYW5kIGFkZCBjb3VudGVyIHRvIGF2b2lkIHNhbWUgbmFtZVxuICAgICAgICAgICAgICAgIG5hbWVSZXBlYXRDb3VudFtuYW1lXSA9IG5hbWVSZXBlYXRDb3VudFtuYW1lXSB8fCAwO1xuICAgICAgICAgICAgICAgIGlkID0gbmFtZTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZVJlcGVhdENvdW50W25hbWVdID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZCArPSAnX19lY19fJyArIG5hbWVSZXBlYXRDb3VudFtuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmFtZVJlcGVhdENvdW50W25hbWVdKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZCAmJiAoaWRMaXN0W2ldID0gaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbmFtZUxpc3QgPSBuYW1lTGlzdDtcbiAgICAgICAgdGhpcy5faWRMaXN0ID0gaWRMaXN0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgbGlzdFByb3RvLmNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRpY2VzLmxlbmd0aDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHZhbHVlLiBSZXR1cm4gTmFOIGlmIGlkeCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRpbSBEaW0gbXVzdCBiZSBjb25jcmV0ZSBuYW1lLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0YWNrXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGxpc3RQcm90by5nZXQgPSBmdW5jdGlvbiAoZGltLCBpZHgsIHN0YWNrKSB7XG4gICAgICAgIHZhciBzdG9yYWdlID0gdGhpcy5fc3RvcmFnZTtcbiAgICAgICAgdmFyIGRhdGFJbmRleCA9IHRoaXMuaW5kaWNlc1tpZHhdO1xuXG4gICAgICAgIC8vIElmIHZhbHVlIG5vdCBleGlzdHNcbiAgICAgICAgaWYgKGRhdGFJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbHVlID0gc3RvcmFnZVtkaW1dICYmIHN0b3JhZ2VbZGltXVtkYXRhSW5kZXhdO1xuICAgICAgICAvLyBGSVhNRSBvcmRpbmFsIGRhdGEgdHlwZSBpcyBub3Qgc3RhY2thYmxlXG4gICAgICAgIGlmIChzdGFjaykge1xuICAgICAgICAgICAgdmFyIGRpbWVuc2lvbkluZm8gPSB0aGlzLl9kaW1lbnNpb25JbmZvc1tkaW1dO1xuICAgICAgICAgICAgaWYgKGRpbWVuc2lvbkluZm8gJiYgZGltZW5zaW9uSW5mby5zdGFja2FibGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2tlZE9uID0gdGhpcy5zdGFja2VkT247XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrZWRPbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgbm8gc3RhY2tlZCBkYXRhIG9mIHN0YWNrZWQgb25cbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YWNrZWRWYWx1ZSA9IHN0YWNrZWRPbi5nZXQoZGltLCBpZHgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBDb25zaWRlcmluZyBwb3NpdGl2ZSBzdGFjaywgbmVnYXRpdmUgc3RhY2sgYW5kIGVtcHR5IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSA+PSAwICYmIHN0YWNrZWRWYWx1ZSA+IDApICAvLyBQb3NpdGl2ZSBzdGFja1xuICAgICAgICAgICAgICAgICAgICAgICAgfHwgKHZhbHVlIDw9IDAgJiYgc3RhY2tlZFZhbHVlIDwgMCkgLy8gTmVnYXRpdmUgc3RhY2tcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBzdGFja2VkVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhY2tlZE9uID0gc3RhY2tlZE9uLnN0YWNrZWRPbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdmFsdWUgZm9yIG11bHRpIGRpbWVuc2lvbnMuXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gW2RpbWVuc2lvbnNdIElmIGlnbm9yZWQsIHVzaW5nIGFsbCBkaW1lbnNpb25zLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0YWNrXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGxpc3RQcm90by5nZXRWYWx1ZXMgPSBmdW5jdGlvbiAoZGltZW5zaW9ucywgaWR4LCBzdGFjaykge1xuICAgICAgICB2YXIgdmFsdWVzID0gW107XG5cbiAgICAgICAgaWYgKCF6clV0aWwuaXNBcnJheShkaW1lbnNpb25zKSkge1xuICAgICAgICAgICAgc3RhY2sgPSBpZHg7XG4gICAgICAgICAgICBpZHggPSBkaW1lbnNpb25zO1xuICAgICAgICAgICAgZGltZW5zaW9ucyA9IHRoaXMuZGltZW5zaW9ucztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkaW1lbnNpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh0aGlzLmdldChkaW1lbnNpb25zW2ldLCBpZHgsIHN0YWNrKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJZiB2YWx1ZSBpcyBOYU4uIElubGN1ZGluZyAnLSdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGltXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uaGFzVmFsdWUgPSBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgIHZhciBkaW1lbnNpb25zID0gdGhpcy5kaW1lbnNpb25zO1xuICAgICAgICB2YXIgZGltZW5zaW9uSW5mb3MgPSB0aGlzLl9kaW1lbnNpb25JbmZvcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRpbWVuc2lvbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAvLyBPcmRpbmFsIHR5cGUgY2FuIGJlIHN0cmluZyBvciBudW1iZXJcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25JbmZvc1tkaW1lbnNpb25zW2ldXS50eXBlICE9PSAnb3JkaW5hbCdcbiAgICAgICAgICAgICAgICAmJiBpc05hTih0aGlzLmdldChkaW1lbnNpb25zW2ldLCBpZHgpKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZXh0ZW50IG9mIGRhdGEgaW4gb25lIGRpbWVuc2lvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaW1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0YWNrXG4gICAgICovXG4gICAgbGlzdFByb3RvLmdldERhdGFFeHRlbnQgPSBmdW5jdGlvbiAoZGltLCBzdGFjaykge1xuICAgICAgICBkaW0gPSB0aGlzLmdldERpbWVuc2lvbihkaW0pO1xuICAgICAgICB2YXIgZGltRGF0YSA9IHRoaXMuX3N0b3JhZ2VbZGltXTtcbiAgICAgICAgdmFyIGRpbUluZm8gPSB0aGlzLmdldERpbWVuc2lvbkluZm8oZGltKTtcbiAgICAgICAgc3RhY2sgPSAoZGltSW5mbyAmJiBkaW1JbmZvLnN0YWNrYWJsZSkgJiYgc3RhY2s7XG4gICAgICAgIHZhciBkaW1FeHRlbnQgPSAodGhpcy5fZXh0ZW50IHx8ICh0aGlzLl9leHRlbnQgPSB7fSkpW2RpbSArICghIXN0YWNrKV07XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgaWYgKGRpbUV4dGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGRpbUV4dGVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyB2YXIgZGltSW5mbyA9IHRoaXMuX2RpbWVuc2lvbkluZm9zW2RpbV07XG4gICAgICAgIGlmIChkaW1EYXRhKSB7XG4gICAgICAgICAgICB2YXIgbWluID0gSW5maW5pdHk7XG4gICAgICAgICAgICB2YXIgbWF4ID0gLUluZmluaXR5O1xuICAgICAgICAgICAgLy8gdmFyIGlzT3JkaW5hbCA9IGRpbUluZm8udHlwZSA9PT0gJ29yZGluYWwnO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY291bnQoKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdldChkaW0sIGksIHN0YWNrKTtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgICAgIC8vIGlmIChpc09yZGluYWwgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vICAgICB2YWx1ZSA9IHpyVXRpbC5pbmRleE9mKGRpbURhdGEsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPCBtaW4gJiYgKG1pbiA9IHZhbHVlKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA+IG1heCAmJiAobWF4ID0gdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9leHRlbnRbZGltICsgISFzdGFja10gPSBbbWluLCBtYXhdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHN1bSBvZiBkYXRhIGluIG9uZSBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGltXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzdGFja1xuICAgICAqL1xuICAgIGxpc3RQcm90by5nZXRTdW0gPSBmdW5jdGlvbiAoZGltLCBzdGFjaykge1xuICAgICAgICB2YXIgZGltRGF0YSA9IHRoaXMuX3N0b3JhZ2VbZGltXTtcbiAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgIGlmIChkaW1EYXRhKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jb3VudCgpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldChkaW0sIGksIHN0YWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHJlaXZlIHRoZSBpbmRleCB3aXRoIGdpdmVuIHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICAvLyBGSVhNRSBQcmVjaXNpb24gb2YgZmxvYXQgdmFsdWVcbiAgICBsaXN0UHJvdG8uaW5kZXhPZiA9IGZ1bmN0aW9uIChkaW0sIHZhbHVlKSB7XG4gICAgICAgIHZhciBzdG9yYWdlID0gdGhpcy5fc3RvcmFnZTtcbiAgICAgICAgdmFyIGRpbURhdGEgPSBzdG9yYWdlW2RpbV07XG4gICAgICAgIHZhciBpbmRpY2VzID0gdGhpcy5pbmRpY2VzO1xuXG4gICAgICAgIGlmIChkaW1EYXRhKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciByYXdJbmRleCA9IGluZGljZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGRpbURhdGFbcmF3SW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXRyZWl2ZSB0aGUgaW5kZXggd2l0aCBnaXZlbiBuYW1lXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuYW1lXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGxpc3RQcm90by5pbmRleE9mTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBpbmRpY2VzID0gdGhpcy5pbmRpY2VzO1xuICAgICAgICB2YXIgbmFtZUxpc3QgPSB0aGlzLl9uYW1lTGlzdDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHJhd0luZGV4ID0gaW5kaWNlc1tpXTtcbiAgICAgICAgICAgIGlmIChuYW1lTGlzdFtyYXdJbmRleF0gPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0cmVpdmUgdGhlIGluZGV4IHdpdGggZ2l2ZW4gcmF3IGRhdGEgaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgbGlzdFByb3RvLmluZGV4T2ZSYXdJbmRleCA9IGZ1bmN0aW9uIChyYXdJbmRleCkge1xuICAgICAgICAvLyBJbmRpY2VzIGFyZSBhc2NlbmRpbmdcbiAgICAgICAgdmFyIGluZGljZXMgPSB0aGlzLmluZGljZXM7XG4gICAgICAgIHZhciBsZWZ0ID0gMDtcbiAgICAgICAgdmFyIHJpZ2h0ID0gaW5kaWNlcy5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAobGVmdCA8PSByaWdodCkge1xuICAgICAgICAgICAgdmFyIG1pZCA9IChsZWZ0ICsgcmlnaHQpIC8gMiB8IDA7XG4gICAgICAgICAgICBpZiAoaW5kaWNlc1ttaWRdIDwgcmF3SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gbWlkICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGluZGljZXNbbWlkXSA+IHJhd0luZGV4KSB7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSBtaWQgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHJlaXZlIHRoZSBpbmRleCBvZiBuZWFyZXN0IHZhbHVlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRpbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhY2sgSWYgZ2l2ZW4gdmFsdWUgaXMgYWZ0ZXIgc3RhY2tlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4RGlzdGFuY2U9SW5maW5pdHldXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGxpc3RQcm90by5pbmRleE9mTmVhcmVzdCA9IGZ1bmN0aW9uIChkaW0sIHZhbHVlLCBzdGFjaywgbWF4RGlzdGFuY2UpIHtcbiAgICAgICAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9zdG9yYWdlO1xuICAgICAgICB2YXIgZGltRGF0YSA9IHN0b3JhZ2VbZGltXTtcblxuICAgICAgICBpZiAobWF4RGlzdGFuY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgbWF4RGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZWFyZXN0SWR4ID0gLTE7XG4gICAgICAgIGlmIChkaW1EYXRhKSB7XG4gICAgICAgICAgICB2YXIgbWluRGlzdCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jb3VudCgpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlmZiA9IHZhbHVlIC0gdGhpcy5nZXQoZGltLCBpLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgdmFyIGRpc3QgPSBNYXRoLmFicyhkaWZmKTtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGRpZmYgPD0gbWF4RGlzdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgJiYgKGRpc3QgPCBtaW5EaXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3IgdGhlIGNhc2Ugb2YgdHdvIGRhdGEgYXJlIHNhbWUgb24geEF4aXMsIHdoaWNoIGhhcyBzZXF1ZW5jZSBkYXRhLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvdyB0aGUgbmVhcmVzdCBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Vjb21mZS9lY2hhcnRzL2lzc3Vlcy8yODY5XG4gICAgICAgICAgICAgICAgICAgICAgICB8fCAoZGlzdCA9PT0gbWluRGlzdCAmJiBkaWZmID4gMClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBtaW5EaXN0ID0gZGlzdDtcbiAgICAgICAgICAgICAgICAgICAgbmVhcmVzdElkeCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZWFyZXN0SWR4O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgcmF3IGRhdGEgaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGxpc3RQcm90by5nZXRSYXdJbmRleCA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgdmFyIHJhd0lkeCA9IHRoaXMuaW5kaWNlc1tpZHhdO1xuICAgICAgICByZXR1cm4gcmF3SWR4ID09IG51bGwgPyAtMSA6IHJhd0lkeDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHJhdyBkYXRhIGl0ZW1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGxpc3RQcm90by5nZXRSYXdEYXRhSXRlbSA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jhd0RhdGFbdGhpcy5nZXRSYXdJbmRleChpZHgpXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW25vdERlZmF1bHRJZHg9ZmFsc2VdXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGxpc3RQcm90by5nZXROYW1lID0gZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZUxpc3RbdGhpcy5pbmRpY2VzW2lkeF1dIHx8ICcnO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbbm90RGVmYXVsdElkeD1mYWxzZV1cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgbGlzdFByb3RvLmdldElkID0gZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faWRMaXN0W3RoaXMuaW5kaWNlc1tpZHhdXSB8fCAodGhpcy5nZXRSYXdJbmRleChpZHgpICsgJycpO1xuICAgIH07XG5cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZURpbWVuc2lvbnMoZGltZW5zaW9ucykge1xuICAgICAgICBpZiAoIXpyVXRpbC5pc0FycmF5KGRpbWVuc2lvbnMpKSB7XG4gICAgICAgICAgICBkaW1lbnNpb25zID0gW2RpbWVuc2lvbnNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaW1lbnNpb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERhdGEgaXRlcmF0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzdGFjaz1mYWxzZV1cbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICBsaXN0LmVhY2goJ3gnLCBmdW5jdGlvbiAoeCwgaWR4KSB7fSk7XG4gICAgICogIGxpc3QuZWFjaChbJ3gnLCAneSddLCBmdW5jdGlvbiAoeCwgeSwgaWR4KSB7fSk7XG4gICAgICogIGxpc3QuZWFjaChmdW5jdGlvbiAoaWR4KSB7fSlcbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uZWFjaCA9IGZ1bmN0aW9uIChkaW1zLCBjYiwgc3RhY2ssIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkaW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gc3RhY2s7XG4gICAgICAgICAgICBzdGFjayA9IGNiO1xuICAgICAgICAgICAgY2IgPSBkaW1zO1xuICAgICAgICAgICAgZGltcyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgZGltcyA9IHpyVXRpbC5tYXAobm9ybWFsaXplRGltZW5zaW9ucyhkaW1zKSwgdGhpcy5nZXREaW1lbnNpb24sIHRoaXMpO1xuXG4gICAgICAgIHZhciB2YWx1ZSA9IFtdO1xuICAgICAgICB2YXIgZGltU2l6ZSA9IGRpbXMubGVuZ3RoO1xuICAgICAgICB2YXIgaW5kaWNlcyA9IHRoaXMuaW5kaWNlcztcblxuICAgICAgICBjb250ZXh0ID0gY29udGV4dCB8fCB0aGlzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gU2ltcGxlIG9wdGltaXphdGlvblxuICAgICAgICAgICAgc3dpdGNoIChkaW1TaXplKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIGkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgdGhpcy5nZXQoZGltc1swXSwgaSwgc3RhY2spLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHRoaXMuZ2V0KGRpbXNbMF0sIGksIHN0YWNrKSwgdGhpcy5nZXQoZGltc1sxXSwgaSwgc3RhY2spLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBkaW1TaXplOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2tdID0gdGhpcy5nZXQoZGltc1trXSwgaSwgc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEluZGV4XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlW2tdID0gaTtcbiAgICAgICAgICAgICAgICAgICAgY2IuYXBwbHkoY29udGV4dCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERhdGEgZmlsdGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzdGFjaz1mYWxzZV1cbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdXG4gICAgICovXG4gICAgbGlzdFByb3RvLmZpbHRlclNlbGYgPSBmdW5jdGlvbiAoZGltZW5zaW9ucywgY2IsIHN0YWNrLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGltZW5zaW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29udGV4dCA9IHN0YWNrO1xuICAgICAgICAgICAgc3RhY2sgPSBjYjtcbiAgICAgICAgICAgIGNiID0gZGltZW5zaW9ucztcbiAgICAgICAgICAgIGRpbWVuc2lvbnMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpbWVuc2lvbnMgPSB6clV0aWwubWFwKFxuICAgICAgICAgICAgbm9ybWFsaXplRGltZW5zaW9ucyhkaW1lbnNpb25zKSwgdGhpcy5nZXREaW1lbnNpb24sIHRoaXNcbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgbmV3SW5kaWNlcyA9IFtdO1xuICAgICAgICB2YXIgdmFsdWUgPSBbXTtcbiAgICAgICAgdmFyIGRpbVNpemUgPSBkaW1lbnNpb25zLmxlbmd0aDtcbiAgICAgICAgdmFyIGluZGljZXMgPSB0aGlzLmluZGljZXM7XG5cbiAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgdGhpcztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZWVwO1xuICAgICAgICAgICAgLy8gU2ltcGxlIG9wdGltaXphdGlvblxuICAgICAgICAgICAgaWYgKGRpbVNpemUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBrZWVwID0gY2IuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dCwgdGhpcy5nZXQoZGltZW5zaW9uc1swXSwgaSwgc3RhY2spLCBpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZGltU2l6ZTsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlW2tdID0gdGhpcy5nZXQoZGltZW5zaW9uc1trXSwgaSwgc3RhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZVtrXSA9IGk7XG4gICAgICAgICAgICAgICAga2VlcCA9IGNiLmFwcGx5KGNvbnRleHQsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZWVwKSB7XG4gICAgICAgICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGljZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbmRpY2VzID0gbmV3SW5kaWNlcztcblxuICAgICAgICAvLyBSZXNldCBkYXRhIGV4dGVudFxuICAgICAgICB0aGlzLl9leHRlbnQgPSB7fTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGF0YSBtYXBwaW5nIHRvIGEgcGxhaW4gYXJyYXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gW2RpbWVuc2lvbnNdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzdGFjaz1mYWxzZV1cbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgbGlzdFByb3RvLm1hcEFycmF5ID0gZnVuY3Rpb24gKGRpbWVuc2lvbnMsIGNiLCBzdGFjaywgY29udGV4dCkge1xuICAgICAgICBpZiAodHlwZW9mIGRpbWVuc2lvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSBzdGFjaztcbiAgICAgICAgICAgIHN0YWNrID0gY2I7XG4gICAgICAgICAgICBjYiA9IGRpbWVuc2lvbnM7XG4gICAgICAgICAgICBkaW1lbnNpb25zID0gW107XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHRoaXMuZWFjaChkaW1lbnNpb25zLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjYiAmJiBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgICAgfSwgc3RhY2ssIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjbG9uZUxpc3RGb3JNYXBBbmRTYW1wbGUob3JpZ2luYWwsIGV4Y2x1ZGVEaW1lbnNpb25zKSB7XG4gICAgICAgIHZhciBhbGxEaW1lbnNpb25zID0gb3JpZ2luYWwuZGltZW5zaW9ucztcbiAgICAgICAgdmFyIGxpc3QgPSBuZXcgTGlzdChcbiAgICAgICAgICAgIHpyVXRpbC5tYXAoYWxsRGltZW5zaW9ucywgb3JpZ2luYWwuZ2V0RGltZW5zaW9uSW5mbywgb3JpZ2luYWwpLFxuICAgICAgICAgICAgb3JpZ2luYWwuaG9zdE1vZGVsXG4gICAgICAgICk7XG4gICAgICAgIC8vIEZJWE1FIElmIG5lZWRzIHN0YWNrZWRPbiwgdmFsdWUgbWF5IGFscmVhZHkgYmVlbiBzdGFja2VkXG4gICAgICAgIHRyYW5zZmVyUHJvcGVydGllcyhsaXN0LCBvcmlnaW5hbCk7XG5cbiAgICAgICAgdmFyIHN0b3JhZ2UgPSBsaXN0Ll9zdG9yYWdlID0ge307XG4gICAgICAgIHZhciBvcmlnaW5hbFN0b3JhZ2UgPSBvcmlnaW5hbC5fc3RvcmFnZTtcbiAgICAgICAgLy8gSW5pdCBzdG9yYWdlXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsRGltZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGRpbSA9IGFsbERpbWVuc2lvbnNbaV07XG4gICAgICAgICAgICB2YXIgZGltU3RvcmUgPSBvcmlnaW5hbFN0b3JhZ2VbZGltXTtcbiAgICAgICAgICAgIGlmICh6clV0aWwuaW5kZXhPZihleGNsdWRlRGltZW5zaW9ucywgZGltKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RvcmFnZVtkaW1dID0gbmV3IGRpbVN0b3JlLmNvbnN0cnVjdG9yKFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFN0b3JhZ2VbZGltXS5sZW5ndGhcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRGlyZWN0IHJlZmVyZW5jZSBmb3Igb3RoZXIgZGltZW5zaW9uc1xuICAgICAgICAgICAgICAgIHN0b3JhZ2VbZGltXSA9IG9yaWdpbmFsU3RvcmFnZVtkaW1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERhdGEgbWFwcGluZyB0byBhIG5ldyBMaXN0IHdpdGggZ2l2ZW4gZGltZW5zaW9uc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fSBkaW1lbnNpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzdGFjaz1mYWxzZV1cbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgbGlzdFByb3RvLm1hcCA9IGZ1bmN0aW9uIChkaW1lbnNpb25zLCBjYiwgc3RhY2ssIGNvbnRleHQpIHtcbiAgICAgICAgZGltZW5zaW9ucyA9IHpyVXRpbC5tYXAoXG4gICAgICAgICAgICBub3JtYWxpemVEaW1lbnNpb25zKGRpbWVuc2lvbnMpLCB0aGlzLmdldERpbWVuc2lvbiwgdGhpc1xuICAgICAgICApO1xuXG4gICAgICAgIHZhciBsaXN0ID0gY2xvbmVMaXN0Rm9yTWFwQW5kU2FtcGxlKHRoaXMsIGRpbWVuc2lvbnMpO1xuICAgICAgICAvLyBGb2xsb3dpbmcgcHJvcGVydGllcyBhcmUgYWxsIGltbXV0YWJsZS5cbiAgICAgICAgLy8gU28gd2UgY2FuIHJlZmVyZW5jZSB0byB0aGUgc2FtZSB2YWx1ZVxuICAgICAgICB2YXIgaW5kaWNlcyA9IGxpc3QuaW5kaWNlcyA9IHRoaXMuaW5kaWNlcztcblxuICAgICAgICB2YXIgc3RvcmFnZSA9IGxpc3QuX3N0b3JhZ2U7XG5cbiAgICAgICAgdmFyIHRtcFJldFZhbHVlID0gW107XG4gICAgICAgIHRoaXMuZWFjaChkaW1lbnNpb25zLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHZhciByZXRWYWx1ZSA9IGNiICYmIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAocmV0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGEgbnVtYmVyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXRWYWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wUmV0VmFsdWVbMF0gPSByZXRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0VmFsdWUgPSB0bXBSZXRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXRWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGltID0gZGltZW5zaW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpbVN0b3JlID0gc3RvcmFnZVtkaW1dO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmF3SWR4ID0gaW5kaWNlc1tpZHhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGltU3RvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpbVN0b3JlW3Jhd0lkeF0gPSByZXRWYWx1ZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgc3RhY2ssIGNvbnRleHQpO1xuXG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBMYXJnZSBkYXRhIGRvd24gc2FtcGxpbmcgb24gZ2l2ZW4gZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRpbWVuc2lvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2FtcGxlVmFsdWVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzYW1wbGVJbmRleCBTYW1wbGUgaW5kZXggZm9yIG5hbWUgYW5kIGlkXG4gICAgICovXG4gICAgbGlzdFByb3RvLmRvd25TYW1wbGUgPSBmdW5jdGlvbiAoZGltZW5zaW9uLCByYXRlLCBzYW1wbGVWYWx1ZSwgc2FtcGxlSW5kZXgpIHtcbiAgICAgICAgdmFyIGxpc3QgPSBjbG9uZUxpc3RGb3JNYXBBbmRTYW1wbGUodGhpcywgW2RpbWVuc2lvbl0pO1xuICAgICAgICB2YXIgc3RvcmFnZSA9IHRoaXMuX3N0b3JhZ2U7XG4gICAgICAgIHZhciB0YXJnZXRTdG9yYWdlID0gbGlzdC5fc3RvcmFnZTtcblxuICAgICAgICB2YXIgb3JpZ2luYWxJbmRpY2VzID0gdGhpcy5pbmRpY2VzO1xuICAgICAgICB2YXIgaW5kaWNlcyA9IGxpc3QuaW5kaWNlcyA9IFtdO1xuXG4gICAgICAgIHZhciBmcmFtZVZhbHVlcyA9IFtdO1xuICAgICAgICB2YXIgZnJhbWVJbmRpY2VzID0gW107XG4gICAgICAgIHZhciBmcmFtZVNpemUgPSBNYXRoLmZsb29yKDEgLyByYXRlKTtcblxuICAgICAgICB2YXIgZGltU3RvcmUgPSB0YXJnZXRTdG9yYWdlW2RpbWVuc2lvbl07XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLmNvdW50KCk7XG4gICAgICAgIC8vIENvcHkgZGF0YSBmcm9tIG9yaWdpbmFsIGRhdGFcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdG9yYWdlW2RpbWVuc2lvbl0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRhcmdldFN0b3JhZ2VbZGltZW5zaW9uXVtpXSA9IHN0b3JhZ2VbZGltZW5zaW9uXVtpXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSBmcmFtZVNpemUpIHtcbiAgICAgICAgICAgIC8vIExhc3QgZnJhbWVcbiAgICAgICAgICAgIGlmIChmcmFtZVNpemUgPiBsZW4gLSBpKSB7XG4gICAgICAgICAgICAgICAgZnJhbWVTaXplID0gbGVuIC0gaTtcbiAgICAgICAgICAgICAgICBmcmFtZVZhbHVlcy5sZW5ndGggPSBmcmFtZVNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGZyYW1lU2l6ZTsgaysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IG9yaWdpbmFsSW5kaWNlc1tpICsga107XG4gICAgICAgICAgICAgICAgZnJhbWVWYWx1ZXNba10gPSBkaW1TdG9yZVtpZHhdO1xuICAgICAgICAgICAgICAgIGZyYW1lSW5kaWNlc1trXSA9IGlkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHNhbXBsZVZhbHVlKGZyYW1lVmFsdWVzKTtcbiAgICAgICAgICAgIHZhciBpZHggPSBmcmFtZUluZGljZXNbc2FtcGxlSW5kZXgoZnJhbWVWYWx1ZXMsIHZhbHVlKSB8fCAwXTtcbiAgICAgICAgICAgIC8vIE9ubHkgd3JpdGUgdmFsdWUgb24gdGhlIGZpbHRlcmVkIGRhdGFcbiAgICAgICAgICAgIGRpbVN0b3JlW2lkeF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGluZGljZXMucHVzaChpZHgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBtb2RlbCBvZiBvbmUgZGF0YSBpdGVtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAqL1xuICAgIC8vIEZJWE1FIE1vZGVsIHByb3h5ID9cbiAgICBsaXN0UHJvdG8uZ2V0SXRlbU1vZGVsID0gZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICB2YXIgaG9zdE1vZGVsID0gdGhpcy5ob3N0TW9kZWw7XG4gICAgICAgIGlkeCA9IHRoaXMuaW5kaWNlc1tpZHhdO1xuICAgICAgICByZXR1cm4gbmV3IE1vZGVsKHRoaXMuX3Jhd0RhdGFbaWR4XSwgaG9zdE1vZGVsLCBob3N0TW9kZWwgJiYgaG9zdE1vZGVsLmVjTW9kZWwpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBkYXRhIGRpZmZlclxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvZGF0YS9MaXN0fSBvdGhlckxpc3RcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9kYXRhL0RhdGFEaWZmZXJ9XG4gICAgICovXG4gICAgbGlzdFByb3RvLmRpZmYgPSBmdW5jdGlvbiAob3RoZXJMaXN0KSB7XG4gICAgICAgIHZhciBpZExpc3QgPSB0aGlzLl9pZExpc3Q7XG4gICAgICAgIHZhciBvdGhlcklkTGlzdCA9IG90aGVyTGlzdCAmJiBvdGhlckxpc3QuX2lkTGlzdDtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhRGlmZmVyKFxuICAgICAgICAgICAgb3RoZXJMaXN0ID8gb3RoZXJMaXN0LmluZGljZXMgOiBbXSwgdGhpcy5pbmRpY2VzLCBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG90aGVySWRMaXN0W2lkeF0gfHwgKGlkeCArICcnKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWRMaXN0W2lkeF0gfHwgKGlkeCArICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB2aXN1YWwgcHJvcGVydHkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqL1xuICAgIGxpc3RQcm90by5nZXRWaXN1YWwgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB2aXN1YWwgPSB0aGlzLl92aXN1YWw7XG4gICAgICAgIHJldHVybiB2aXN1YWwgJiYgdmlzdWFsW2tleV07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCB2aXN1YWwgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gW3ZhbHVlXVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgc2V0VmlzdWFsKCdjb2xvcicsIGNvbG9yKTtcbiAgICAgKiAgc2V0VmlzdWFsKHtcbiAgICAgKiAgICAgICdjb2xvcic6IGNvbG9yXG4gICAgICogIH0pO1xuICAgICAqL1xuICAgIGxpc3RQcm90by5zZXRWaXN1YWwgPSBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KGtleSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4ga2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFZpc3VhbChuYW1lLCBrZXlbbmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92aXN1YWwgPSB0aGlzLl92aXN1YWwgfHwge307XG4gICAgICAgIHRoaXMuX3Zpc3VhbFtrZXldID0gdmFsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXQgbGF5b3V0IHByb3BlcnR5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IFt2YWxdXG4gICAgICovXG4gICAgbGlzdFByb3RvLnNldExheW91dCA9IGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICAgICAgICBpZiAoaXNPYmplY3Qoa2V5KSkge1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5Lmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0TGF5b3V0KG5hbWUsIGtleVtuYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xheW91dFtrZXldID0gdmFsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgbGF5b3V0IHByb3BlcnR5LlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30ga2V5LlxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICovXG4gICAgbGlzdFByb3RvLmdldExheW91dCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xheW91dFtrZXldO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgbGF5b3V0IG9mIHNpbmdsZSBkYXRhIGl0ZW1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gICAgICovXG4gICAgbGlzdFByb3RvLmdldEl0ZW1MYXlvdXQgPSBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtTGF5b3V0c1tpZHhdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXQgbGF5b3V0IG9mIHNpbmdsZSBkYXRhIGl0ZW1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxheW91dFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IFttZXJnZT1mYWxzZV1cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8uc2V0SXRlbUxheW91dCA9IGZ1bmN0aW9uIChpZHgsIGxheW91dCwgbWVyZ2UpIHtcbiAgICAgICAgdGhpcy5faXRlbUxheW91dHNbaWR4XSA9IG1lcmdlXG4gICAgICAgICAgICA/IHpyVXRpbC5leHRlbmQodGhpcy5faXRlbUxheW91dHNbaWR4XSB8fCB7fSwgbGF5b3V0KVxuICAgICAgICAgICAgOiBsYXlvdXQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENsZWFyIGFsbCBsYXlvdXQgb2Ygc2luZ2xlIGRhdGEgaXRlbVxuICAgICAqL1xuICAgIGxpc3RQcm90by5jbGVhckl0ZW1MYXlvdXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9pdGVtTGF5b3V0cy5sZW5ndGggPSAwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdmlzdWFsIHByb3BlcnR5IG9mIHNpbmdsZSBkYXRhIGl0ZW1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaWdub3JlUGFyZW50XG4gICAgICovXG4gICAgbGlzdFByb3RvLmdldEl0ZW1WaXN1YWwgPSBmdW5jdGlvbiAoaWR4LCBrZXksIGlnbm9yZVBhcmVudCkge1xuICAgICAgICB2YXIgaXRlbVZpc3VhbCA9IHRoaXMuX2l0ZW1WaXN1YWxzW2lkeF07XG4gICAgICAgIHZhciB2YWwgPSBpdGVtVmlzdWFsICYmIGl0ZW1WaXN1YWxba2V5XTtcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsICYmICFpZ25vcmVQYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIFVzZSBnbG9iYWwgdmlzdWFsIHByb3BlcnR5XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRWaXN1YWwoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdmlzdWFsIHByb3BlcnR5IG9mIHNpbmdsZSBkYXRhIGl0ZW1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gW3ZhbHVlXVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgc2V0SXRlbVZpc3VhbCgwLCAnY29sb3InLCBjb2xvcik7XG4gICAgICogIHNldEl0ZW1WaXN1YWwoMCwge1xuICAgICAqICAgICAgJ2NvbG9yJzogY29sb3JcbiAgICAgKiAgfSk7XG4gICAgICovXG4gICAgbGlzdFByb3RvLnNldEl0ZW1WaXN1YWwgPSBmdW5jdGlvbiAoaWR4LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBpdGVtVmlzdWFsID0gdGhpcy5faXRlbVZpc3VhbHNbaWR4XSB8fCB7fTtcbiAgICAgICAgdGhpcy5faXRlbVZpc3VhbHNbaWR4XSA9IGl0ZW1WaXN1YWw7XG5cbiAgICAgICAgaWYgKGlzT2JqZWN0KGtleSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4ga2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtVmlzdWFsW25hbWVdID0ga2V5W25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpdGVtVmlzdWFsW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgaXRlbVZpc3VhbHMgYW5kIGxpc3QgdmlzdWFsLlxuICAgICAqL1xuICAgIGxpc3RQcm90by5jbGVhckFsbFZpc3VhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdmlzdWFsID0ge307XG4gICAgICAgIHRoaXMuX2l0ZW1WaXN1YWxzID0gW107XG4gICAgfTtcblxuICAgIHZhciBzZXRJdGVtRGF0YUFuZFNlcmllc0luZGV4ID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkLnNlcmllc0luZGV4ID0gdGhpcy5zZXJpZXNJbmRleDtcbiAgICAgICAgY2hpbGQuZGF0YUluZGV4ID0gdGhpcy5kYXRhSW5kZXg7XG4gICAgICAgIGNoaWxkLmRhdGFUeXBlID0gdGhpcy5kYXRhVHlwZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBncmFwaGljIGVsZW1lbnQgcmVsYXRpdmUgdG8gZGF0YS4gSXQgY2FuIGJlIHNldCBhcyBudWxsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gW2VsXVxuICAgICAqL1xuICAgIGxpc3RQcm90by5zZXRJdGVtR3JhcGhpY0VsID0gZnVuY3Rpb24gKGlkeCwgZWwpIHtcbiAgICAgICAgdmFyIGhvc3RNb2RlbCA9IHRoaXMuaG9zdE1vZGVsO1xuXG4gICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgLy8gQWRkIGRhdGEgaW5kZXggYW5kIHNlcmllcyBpbmRleCBmb3IgaW5kZXhpbmcgdGhlIGRhdGEgYnkgZWxlbWVudFxuICAgICAgICAgICAgLy8gVXNlZnVsIGluIHRvb2x0aXBcbiAgICAgICAgICAgIGVsLmRhdGFJbmRleCA9IGlkeDtcbiAgICAgICAgICAgIGVsLmRhdGFUeXBlID0gdGhpcy5kYXRhVHlwZTtcbiAgICAgICAgICAgIGVsLnNlcmllc0luZGV4ID0gaG9zdE1vZGVsICYmIGhvc3RNb2RlbC5zZXJpZXNJbmRleDtcbiAgICAgICAgICAgIGlmIChlbC50eXBlID09PSAnZ3JvdXAnKSB7XG4gICAgICAgICAgICAgICAgZWwudHJhdmVyc2Uoc2V0SXRlbURhdGFBbmRTZXJpZXNJbmRleCwgZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZ3JhcGhpY0Vsc1tpZHhdID0gZWw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9FbGVtZW50fVxuICAgICAqL1xuICAgIGxpc3RQcm90by5nZXRJdGVtR3JhcGhpY0VsID0gZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JhcGhpY0Vsc1tpZHhdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAqIEBwYXJhbSB7Kn0gY29udGV4dFxuICAgICAqL1xuICAgIGxpc3RQcm90by5lYWNoSXRlbUdyYXBoaWNFbCA9IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgICAgICB6clV0aWwuZWFjaCh0aGlzLl9ncmFwaGljRWxzLCBmdW5jdGlvbiAoZWwsIGlkeCkge1xuICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgICAgY2IgJiYgY2IuY2FsbChjb250ZXh0LCBlbCwgaWR4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNoYWxsb3cgY2xvbmUgYSBuZXcgbGlzdCBleGNlcHQgdmlzdWFsIGFuZCBsYXlvdXQgcHJvcGVydGllcywgYW5kIGdyYXBoIGVsZW1lbnRzLlxuICAgICAqIE5ldyBsaXN0IG9ubHkgY2hhbmdlIHRoZSBpbmRpY2VzLlxuICAgICAqL1xuICAgIGxpc3RQcm90by5jbG9uZVNoYWxsb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkaW1lbnNpb25JbmZvTGlzdCA9IHpyVXRpbC5tYXAodGhpcy5kaW1lbnNpb25zLCB0aGlzLmdldERpbWVuc2lvbkluZm8sIHRoaXMpO1xuICAgICAgICB2YXIgbGlzdCA9IG5ldyBMaXN0KGRpbWVuc2lvbkluZm9MaXN0LCB0aGlzLmhvc3RNb2RlbCk7XG5cbiAgICAgICAgLy8gRklYTUVcbiAgICAgICAgbGlzdC5fc3RvcmFnZSA9IHRoaXMuX3N0b3JhZ2U7XG5cbiAgICAgICAgdHJhbnNmZXJQcm9wZXJ0aWVzKGxpc3QsIHRoaXMpO1xuXG5cbiAgICAgICAgLy8gQ2xvbmUgd2lsbCBub3QgY2hhbmdlIHRoZSBkYXRhIGV4dGVudCBhbmQgaW5kaWNlc1xuICAgICAgICBsaXN0LmluZGljZXMgPSB0aGlzLmluZGljZXMuc2xpY2UoKTtcblxuICAgICAgICBpZiAodGhpcy5fZXh0ZW50KSB7XG4gICAgICAgICAgICBsaXN0Ll9leHRlbnQgPSB6clV0aWwuZXh0ZW5kKHt9LCB0aGlzLl9leHRlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFdyYXAgc29tZSBtZXRob2QgdG8gYWRkIG1vcmUgZmVhdHVyZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW5qZWN0RnVuY3Rpb25cbiAgICAgKi9cbiAgICBsaXN0UHJvdG8ud3JhcE1ldGhvZCA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmplY3RGdW5jdGlvbikge1xuICAgICAgICB2YXIgb3JpZ2luYWxNZXRob2QgPSB0aGlzW21ldGhvZE5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIG9yaWdpbmFsTWV0aG9kICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX3dyYXBwZWRNZXRob2RzID0gdGhpcy5fX3dyYXBwZWRNZXRob2RzIHx8IFtdO1xuICAgICAgICB0aGlzLl9fd3JhcHBlZE1ldGhvZHMucHVzaChtZXRob2ROYW1lKTtcbiAgICAgICAgdGhpc1ttZXRob2ROYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBvcmlnaW5hbE1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGluamVjdEZ1bmN0aW9uLmFwcGx5KHRoaXMsIFtyZXNdLmNvbmNhdCh6clV0aWwuc2xpY2UoYXJndW1lbnRzKSkpO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBNZXRob2RzIHRoYXQgY3JlYXRlIGEgbmV3IGxpc3QgYmFzZWQgb24gdGhpcyBsaXN0IHNob3VsZCBiZSBsaXN0ZWQgaGVyZS5cbiAgICAvLyBOb3RpY2UgdGhhdCB0aG9zZSBtZXRob2Qgc2hvdWxkIGBSRVRVUk5gIHRoZSBuZXcgbGlzdC5cbiAgICBsaXN0UHJvdG8uVFJBTlNGRVJBQkxFX01FVEhPRFMgPSBbJ2Nsb25lU2hhbGxvdycsICdkb3duU2FtcGxlJywgJ21hcCddO1xuICAgIC8vIE1ldGhvZHMgdGhhdCBjaGFuZ2UgaW5kaWNlcyBvZiB0aGlzIGxpc3Qgc2hvdWxkIGJlIGxpc3RlZCBoZXJlLlxuICAgIGxpc3RQcm90by5DSEFOR0FCTEVfTUVUSE9EUyA9IFsnZmlsdGVyU2VsZiddO1xuXG4gICAgcmV0dXJuIExpc3Q7XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL2VjaGFydHMvZGF0YS9MaXN0LmpzXG4gKiogbW9kdWxlIGlkID0gMTAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCJkZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRLZXlHZXR0ZXIoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBEYXRhRGlmZmVyKG9sZEFyciwgbmV3QXJyLCBvbGRLZXlHZXR0ZXIsIG5ld0tleUdldHRlcikge1xuICAgICAgICB0aGlzLl9vbGQgPSBvbGRBcnI7XG4gICAgICAgIHRoaXMuX25ldyA9IG5ld0FycjtcblxuICAgICAgICB0aGlzLl9vbGRLZXlHZXR0ZXIgPSBvbGRLZXlHZXR0ZXIgfHwgZGVmYXVsdEtleUdldHRlcjtcbiAgICAgICAgdGhpcy5fbmV3S2V5R2V0dGVyID0gbmV3S2V5R2V0dGVyIHx8IGRlZmF1bHRLZXlHZXR0ZXI7XG4gICAgfVxuXG4gICAgRGF0YURpZmZlci5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IERhdGFEaWZmZXIsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gYWRkIGEgZGF0YVxuICAgICAgICAgKi9cbiAgICAgICAgYWRkOiBmdW5jdGlvbiAoZnVuYykge1xuICAgICAgICAgICAgdGhpcy5fYWRkID0gZnVuYztcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsYmFjayBmdW5jdGlvbiB3aGVuIHVwZGF0ZSBhIGRhdGFcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSA9IGZ1bmM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGJhY2sgZnVuY3Rpb24gd2hlbiByZW1vdmUgYSBkYXRhXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmUgPSBmdW5jO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXhlY3V0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9sZEFyciA9IHRoaXMuX29sZDtcbiAgICAgICAgICAgIHZhciBuZXdBcnIgPSB0aGlzLl9uZXc7XG4gICAgICAgICAgICB2YXIgb2xkS2V5R2V0dGVyID0gdGhpcy5fb2xkS2V5R2V0dGVyO1xuICAgICAgICAgICAgdmFyIG5ld0tleUdldHRlciA9IHRoaXMuX25ld0tleUdldHRlcjtcblxuICAgICAgICAgICAgdmFyIG9sZERhdGFJbmRleE1hcCA9IHt9O1xuICAgICAgICAgICAgdmFyIG5ld0RhdGFJbmRleE1hcCA9IHt9O1xuICAgICAgICAgICAgdmFyIG9sZERhdGFLZXlBcnIgPSBbXTtcbiAgICAgICAgICAgIHZhciBuZXdEYXRhS2V5QXJyID0gW107XG4gICAgICAgICAgICB2YXIgaTtcblxuICAgICAgICAgICAgaW5pdEluZGV4TWFwKG9sZEFyciwgb2xkRGF0YUluZGV4TWFwLCBvbGREYXRhS2V5QXJyLCBvbGRLZXlHZXR0ZXIpO1xuICAgICAgICAgICAgaW5pdEluZGV4TWFwKG5ld0FyciwgbmV3RGF0YUluZGV4TWFwLCBuZXdEYXRhS2V5QXJyLCBuZXdLZXlHZXR0ZXIpO1xuXG4gICAgICAgICAgICAvLyBUcmF2ZWwgYnkgaW52ZXJ0ZWQgb3JkZXIgdG8gbWFrZSBzdXJlIG9yZGVyIGNvbnNpc3RlbmN5XG4gICAgICAgICAgICAvLyB3aGVuIGR1cGxpY2F0ZSBrZXlzIGV4aXN0cyAoY29uc2lkZXIgbmV3RGF0YUluZGV4LnBvcCgpIGJlbG93KS5cbiAgICAgICAgICAgIC8vIEZvciBwZXJmb3JtYW5jZSBjb25zaWRlcmF0aW9uLCB0aGVzZSBjb2RlIGJlbG93IGRvIG5vdCBsb29rIG5lYXQuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb2xkQXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IG9sZERhdGFLZXlBcnJbaV07XG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IG5ld0RhdGFJbmRleE1hcFtrZXldO1xuXG4gICAgICAgICAgICAgICAgLy8gaWR4IGNhbiBuZXZlciBiZSBlbXB0eSBhcnJheSBoZXJlLiBzZWUgJ3NldCBudWxsJyBsb2dpYyBiZWxvdy5cbiAgICAgICAgICAgICAgICBpZiAoaWR4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc2lkZXIgdGhlcmUgaXMgZHVwbGljYXRlIGtleSAoZm9yIGV4YW1wbGUsIHVzZSBkYXRhSXRlbS5uYW1lIGFzIGtleSkuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHNob3VsZCBtYWtlIHN1cmUgZXZlcnkgaXRlbSBpbiBuZXdBcnIgYW5kIG9sZEFyciBjYW4gYmUgdmlzaXRlZC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IGlkeC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbiA9PT0gMSAmJiAobmV3RGF0YUluZGV4TWFwW2tleV0gPSBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkeCA9IGlkeC51bnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdEYXRhSW5kZXhNYXBba2V5XSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlICYmIHRoaXMuX3VwZGF0ZShpZHgsIGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlICYmIHRoaXMuX3JlbW92ZShpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3RGF0YUtleUFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBuZXdEYXRhS2V5QXJyW2ldO1xuICAgICAgICAgICAgICAgIGlmIChuZXdEYXRhSW5kZXhNYXAuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gbmV3RGF0YUluZGV4TWFwW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZHggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gaWR4IGNhbiBuZXZlciBiZSBlbXB0eSBhcnJheSBoZXJlLiBzZWUgJ3NldCBudWxsJyBsb2dpYyBhYm92ZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpZHgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGQgJiYgdGhpcy5fYWRkKGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbGVuID0gaWR4Lmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkICYmIHRoaXMuX2FkZChpZHhbal0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGluaXRJbmRleE1hcChhcnIsIG1hcCwga2V5QXJyLCBrZXlHZXR0ZXIpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlHZXR0ZXIoYXJyW2ldLCBpKTtcbiAgICAgICAgICAgIHZhciBleGlzdGVuY2UgPSBtYXBba2V5XTtcbiAgICAgICAgICAgIGlmIChleGlzdGVuY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGtleUFyci5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgbWFwW2tleV0gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFleGlzdGVuY2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcFtrZXldID0gZXhpc3RlbmNlID0gW2V4aXN0ZW5jZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4aXN0ZW5jZS5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIERhdGFEaWZmZXI7XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL2VjaGFydHMvZGF0YS9EYXRhRGlmZmVyLmpzXG4gKiogbW9kdWxlIGlkID0gMTAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCJkZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2NvcmUvdXRpbCcpO1xuXG4gICAgcmVxdWlyZSgnLi4vY29vcmQvY2FydGVzaWFuL0dyaWQnKTtcblxuICAgIHJlcXVpcmUoJy4vYmFyL0JhclNlcmllcycpO1xuICAgIHJlcXVpcmUoJy4vYmFyL0JhclZpZXcnKTtcblxuICAgIHZhciBiYXJMYXlvdXRHcmlkID0gcmVxdWlyZSgnLi4vbGF5b3V0L2JhckdyaWQnKTtcbiAgICB2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoJy4uL2VjaGFydHMnKTtcblxuICAgIGVjaGFydHMucmVnaXN0ZXJMYXlvdXQoenJVdGlsLmN1cnJ5KGJhckxheW91dEdyaWQsICdiYXInKSk7XG4gICAgLy8gVmlzdWFsIGNvZGluZyBmb3IgbGVnZW5kXG4gICAgZWNoYXJ0cy5yZWdpc3RlclZpc3VhbChmdW5jdGlvbiAoZWNNb2RlbCkge1xuICAgICAgICBlY01vZGVsLmVhY2hTZXJpZXNCeVR5cGUoJ2JhcicsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgICAgICBkYXRhLnNldFZpc3VhbCgnbGVnZW5kU3ltYm9sJywgJ3JvdW5kUmVjdCcpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIEluIGNhc2UgZGV2ZWxvcGVyIGZvcmdldCB0byBpbmNsdWRlIGdyaWQgY29tcG9uZW50XG4gICAgcmVxdWlyZSgnLi4vY29tcG9uZW50L2dyaWQnKTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvZWNoYXJ0cy9jaGFydC9iYXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsIi8qKlxuICogR3JpZCBpcyBhIHJlZ2lvbiB3aGljaCBjb250YWlucyBhdCBtb3N0IDQgY2FydGVzaWFuIHN5c3RlbXNcbiAqXG4gKiBUT0RPIERlZmF1bHQgY2FydGVzaWFuXG4gKi9cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBmYWN0b3J5KSB7XG5cbiAgICB2YXIgbGF5b3V0ID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9sYXlvdXQnKTtcbiAgICB2YXIgYXhpc0hlbHBlciA9IHJlcXVpcmUoJy4uLy4uL2Nvb3JkL2F4aXNIZWxwZXInKTtcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2NvcmUvdXRpbCcpO1xuICAgIHZhciBDYXJ0ZXNpYW4yRCA9IHJlcXVpcmUoJy4vQ2FydGVzaWFuMkQnKTtcbiAgICB2YXIgQXhpczJEID0gcmVxdWlyZSgnLi9BeGlzMkQnKTtcblxuICAgIHZhciBlYWNoID0genJVdGlsLmVhY2g7XG5cbiAgICB2YXIgaWZBeGlzQ3Jvc3NaZXJvID0gYXhpc0hlbHBlci5pZkF4aXNDcm9zc1plcm87XG4gICAgdmFyIG5pY2VTY2FsZUV4dGVudCA9IGF4aXNIZWxwZXIubmljZVNjYWxlRXh0ZW50O1xuXG4gICAgLy8g5L6d6LWWIEdyaWRNb2RlbCwgQXhpc01vZGVsIOWBmumihOWkhOeQhlxuICAgIHJlcXVpcmUoJy4vR3JpZE1vZGVsJyk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgYXhpcyBpcyB1c2VkIGluIHRoZSBzcGVjaWZpZWQgZ3JpZFxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXhpc1VzZWRJblRoZUdyaWQoYXhpc01vZGVsLCBncmlkTW9kZWwsIGVjTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIGF4aXNNb2RlbC5maW5kR3JpZE1vZGVsKCkgPT09IGdyaWRNb2RlbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRMYWJlbFVuaW9uUmVjdChheGlzKSB7XG4gICAgICAgIHZhciBheGlzTW9kZWwgPSBheGlzLm1vZGVsO1xuICAgICAgICB2YXIgbGFiZWxzID0gYXhpc01vZGVsLmdldEZvcm1hdHRlZExhYmVscygpO1xuICAgICAgICB2YXIgcmVjdDtcbiAgICAgICAgdmFyIHN0ZXAgPSAxO1xuICAgICAgICB2YXIgbGFiZWxDb3VudCA9IGxhYmVscy5sZW5ndGg7XG4gICAgICAgIGlmIChsYWJlbENvdW50ID4gNDApIHtcbiAgICAgICAgICAgIC8vIFNpbXBsZSBvcHRpbWl6YXRpb24gZm9yIGxhcmdlIGFtb3VudCBvZiBsYWJlbHNcbiAgICAgICAgICAgIHN0ZXAgPSBNYXRoLmNlaWwobGFiZWxDb3VudCAvIDQwKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhYmVsQ291bnQ7IGkgKz0gc3RlcCkge1xuICAgICAgICAgICAgaWYgKCFheGlzLmlzTGFiZWxJZ25vcmVkKGkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNpbmdsZVJlY3QgPSBheGlzTW9kZWwuZ2V0VGV4dFJlY3QobGFiZWxzW2ldKTtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBjb25zaWRlciBsYWJlbCByb3RhdGVcbiAgICAgICAgICAgICAgICByZWN0ID8gcmVjdC51bmlvbihzaW5nbGVSZWN0KSA6IChyZWN0ID0gc2luZ2xlUmVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gR3JpZChncmlkTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBtb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vQ2FydGVzaWFuMkQ+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY29vcmRzTWFwID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0NhcnRlc2lhbj59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jb29yZHNMaXN0ID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0F4aXMyRD59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9heGVzTWFwID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0F4aXMyRD59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9heGVzTGlzdCA9IFtdO1xuXG4gICAgICAgIHRoaXMuX2luaXRDYXJ0ZXNpYW4oZ3JpZE1vZGVsLCBlY01vZGVsLCBhcGkpO1xuXG4gICAgICAgIHRoaXMuX21vZGVsID0gZ3JpZE1vZGVsO1xuICAgIH1cblxuICAgIHZhciBncmlkUHJvdG8gPSBHcmlkLnByb3RvdHlwZTtcblxuICAgIGdyaWRQcm90by50eXBlID0gJ2dyaWQnO1xuXG4gICAgZ3JpZFByb3RvLmdldFJlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWN0O1xuICAgIH07XG5cbiAgICBncmlkUHJvdG8udXBkYXRlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuXG4gICAgICAgIHZhciBheGVzTWFwID0gdGhpcy5fYXhlc01hcDtcblxuICAgICAgICB0aGlzLl91cGRhdGVTY2FsZShlY01vZGVsLCB0aGlzLl9tb2RlbCk7XG5cbiAgICAgICAgZnVuY3Rpb24gaWZBeGlzQ2FuTm90T25aZXJvKG90aGVyQXhpc0RpbSkge1xuICAgICAgICAgICAgdmFyIGF4ZXMgPSBheGVzTWFwW290aGVyQXhpc0RpbV07XG4gICAgICAgICAgICBmb3IgKHZhciBpZHggaW4gYXhlcykge1xuICAgICAgICAgICAgICAgIHZhciBheGlzID0gYXhlc1tpZHhdO1xuICAgICAgICAgICAgICAgIGlmIChheGlzICYmIChheGlzLnR5cGUgPT09ICdjYXRlZ29yeScgfHwgIWlmQXhpc0Nyb3NzWmVybyhheGlzKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZWFjaChheGVzTWFwLngsIGZ1bmN0aW9uICh4QXhpcykge1xuICAgICAgICAgICAgbmljZVNjYWxlRXh0ZW50KHhBeGlzLCB4QXhpcy5tb2RlbCk7XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoKGF4ZXNNYXAueSwgZnVuY3Rpb24gKHlBeGlzKSB7XG4gICAgICAgICAgICBuaWNlU2NhbGVFeHRlbnQoeUF4aXMsIHlBeGlzLm1vZGVsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEZpeCBjb25maWd1cmF0aW9uXG4gICAgICAgIGVhY2goYXhlc01hcC54LCBmdW5jdGlvbiAoeEF4aXMpIHtcbiAgICAgICAgICAgIC8vIG9uWmVybyBjYW4gbm90IGJlIGVuYWJsZWQgaW4gdGhlc2UgdHdvIHNpdHVhdGlvbnNcbiAgICAgICAgICAgIC8vIDEuIFdoZW4gYW55IG90aGVyIGF4aXMgaXMgYSBjYXRlZ29yeSBheGlzXG4gICAgICAgICAgICAvLyAyLiBXaGVuIGFueSBvdGhlciBheGlzIG5vdCBhY3Jvc3MgMCBwb2ludFxuICAgICAgICAgICAgaWYgKGlmQXhpc0Nhbk5vdE9uWmVybygneScpKSB7XG4gICAgICAgICAgICAgICAgeEF4aXMub25aZXJvID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoKGF4ZXNNYXAueSwgZnVuY3Rpb24gKHlBeGlzKSB7XG4gICAgICAgICAgICBpZiAoaWZBeGlzQ2FuTm90T25aZXJvKCd4JykpIHtcbiAgICAgICAgICAgICAgICB5QXhpcy5vblplcm8gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmVzaXplIGFnYWluIGlmIGNvbnRhaW5MYWJlbCBpcyBlbmFibGVkXG4gICAgICAgIC8vIEZJWE1FIEl0IG1heSBjYXVzZSBnZXR0aW5nIHdyb25nIGdyaWQgc2l6ZSBpbiBkYXRhIHByb2Nlc3Npbmcgc3RhZ2VcbiAgICAgICAgdGhpcy5yZXNpemUodGhpcy5fbW9kZWwsIGFwaSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZSB0aGUgZ3JpZFxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0dyaWRNb2RlbH0gZ3JpZE1vZGVsXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICAgICAqL1xuICAgIGdyaWRQcm90by5yZXNpemUgPSBmdW5jdGlvbiAoZ3JpZE1vZGVsLCBhcGkpIHtcblxuICAgICAgICB2YXIgZ3JpZFJlY3QgPSBsYXlvdXQuZ2V0TGF5b3V0UmVjdChcbiAgICAgICAgICAgIGdyaWRNb2RlbC5nZXRCb3hMYXlvdXRQYXJhbXMoKSwge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBhcGkuZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGFwaS5nZXRIZWlnaHQoKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fcmVjdCA9IGdyaWRSZWN0O1xuXG4gICAgICAgIHZhciBheGVzTGlzdCA9IHRoaXMuX2F4ZXNMaXN0O1xuXG4gICAgICAgIGFkanVzdEF4ZXMoKTtcblxuICAgICAgICAvLyBNaW51cyBsYWJlbCBzaXplXG4gICAgICAgIGlmIChncmlkTW9kZWwuZ2V0KCdjb250YWluTGFiZWwnKSkge1xuICAgICAgICAgICAgZWFjaChheGVzTGlzdCwgZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWF4aXMubW9kZWwuZ2V0KCdheGlzTGFiZWwuaW5zaWRlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhYmVsVW5pb25SZWN0ID0gZ2V0TGFiZWxVbmlvblJlY3QoYXhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbFVuaW9uUmVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpbSA9IGF4aXMuaXNIb3Jpem9udGFsKCkgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFyZ2luID0gYXhpcy5tb2RlbC5nZXQoJ2F4aXNMYWJlbC5tYXJnaW4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRSZWN0W2RpbV0gLT0gbGFiZWxVbmlvblJlY3RbZGltXSArIG1hcmdpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChheGlzLnBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRSZWN0LnkgKz0gbGFiZWxVbmlvblJlY3QuaGVpZ2h0ICsgbWFyZ2luO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYXhpcy5wb3NpdGlvbiA9PT0gJ2xlZnQnKSAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRSZWN0LnggKz0gbGFiZWxVbmlvblJlY3Qud2lkdGggKyBtYXJnaW47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYWRqdXN0QXhlcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYWRqdXN0QXhlcygpIHtcbiAgICAgICAgICAgIGVhY2goYXhlc0xpc3QsIGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzSG9yaXpvbnRhbCA9IGF4aXMuaXNIb3Jpem9udGFsKCk7XG4gICAgICAgICAgICAgICAgdmFyIGV4dGVudCA9IGlzSG9yaXpvbnRhbCA/IFswLCBncmlkUmVjdC53aWR0aF0gOiBbMCwgZ3JpZFJlY3QuaGVpZ2h0XTtcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gYXhpcy5pbnZlcnNlID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgYXhpcy5zZXRFeHRlbnQoZXh0ZW50W2lkeF0sIGV4dGVudFsxIC0gaWR4XSk7XG4gICAgICAgICAgICAgICAgdXBkYXRlQXhpc1RyYW5zZnJvbShheGlzLCBpc0hvcml6b250YWwgPyBncmlkUmVjdC54IDogZ3JpZFJlY3QueSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXhpc1R5cGVcbiAgICAgKiBAcGFyYW0ge25kdW1iZXJ9IFtheGlzSW5kZXhdXG4gICAgICovXG4gICAgZ3JpZFByb3RvLmdldEF4aXMgPSBmdW5jdGlvbiAoYXhpc1R5cGUsIGF4aXNJbmRleCkge1xuICAgICAgICB2YXIgYXhlc01hcE9uRGltID0gdGhpcy5fYXhlc01hcFtheGlzVHlwZV07XG4gICAgICAgIGlmIChheGVzTWFwT25EaW0gIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGF4aXNJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gRmluZCBmaXJzdCBheGlzXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBheGVzTWFwT25EaW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF4ZXNNYXBPbkRpbVtuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXhlc01hcE9uRGltW2F4aXNJbmRleF07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZ3JpZFByb3RvLmdldENhcnRlc2lhbiA9IGZ1bmN0aW9uICh4QXhpc0luZGV4LCB5QXhpc0luZGV4KSB7XG4gICAgICAgIGlmICh4QXhpc0luZGV4ICE9IG51bGwgJiYgeUF4aXNJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gJ3gnICsgeEF4aXNJbmRleCArICd5JyArIHlBeGlzSW5kZXg7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29vcmRzTWFwW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXaGVuIG9ubHkgeEF4aXNJbmRleCBvciB5QXhpc0luZGV4IGdpdmVuLCBmaW5kIGl0cyBmaXJzdCBjYXJ0ZXNpYW4uXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgY29vcmRMaXN0ID0gdGhpcy5fY29vcmRzTGlzdDsgaSA8IGNvb3JkTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChjb29yZExpc3RbaV0uZ2V0QXhpcygneCcpLmluZGV4ID09PSB4QXhpc0luZGV4XG4gICAgICAgICAgICAgICAgICAgIHx8IGNvb3JkTGlzdFtpXS5nZXRBeGlzKCd5JykuaW5kZXggPT09IHlBeGlzSW5kZXhcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvb3JkTGlzdFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBjYXJ0ZXNpYW4gY29vcmRpbmF0ZSBzeXN0ZW1zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBncmlkUHJvdG8uX2luaXRDYXJ0ZXNpYW4gPSBmdW5jdGlvbiAoZ3JpZE1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgdmFyIGF4aXNQb3NpdGlvblVzZWQgPSB7XG4gICAgICAgICAgICBsZWZ0OiBmYWxzZSxcbiAgICAgICAgICAgIHJpZ2h0OiBmYWxzZSxcbiAgICAgICAgICAgIHRvcDogZmFsc2UsXG4gICAgICAgICAgICBib3R0b206IGZhbHNlXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGF4ZXNNYXAgPSB7XG4gICAgICAgICAgICB4OiB7fSxcbiAgICAgICAgICAgIHk6IHt9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBheGVzQ291bnQgPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vLyBDcmVhdGUgYXhpc1xuICAgICAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoJ3hBeGlzJywgY3JlYXRlQXhpc0NyZWF0b3IoJ3gnKSwgdGhpcyk7XG4gICAgICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudCgneUF4aXMnLCBjcmVhdGVBeGlzQ3JlYXRvcigneScpLCB0aGlzKTtcblxuICAgICAgICBpZiAoIWF4ZXNDb3VudC54IHx8ICFheGVzQ291bnQueSkge1xuICAgICAgICAgICAgLy8gUm9sbCBiYWNrIHdoZW4gdGhlcmUgbm8gZWl0aGVyIHggb3IgeSBheGlzXG4gICAgICAgICAgICB0aGlzLl9heGVzTWFwID0ge307XG4gICAgICAgICAgICB0aGlzLl9heGVzTGlzdCA9IFtdO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYXhlc01hcCA9IGF4ZXNNYXA7XG5cbiAgICAgICAgLy8vIENyZWF0ZSBjYXJ0ZXNpYW4yZFxuICAgICAgICBlYWNoKGF4ZXNNYXAueCwgZnVuY3Rpb24gKHhBeGlzLCB4QXhpc0luZGV4KSB7XG4gICAgICAgICAgICBlYWNoKGF4ZXNNYXAueSwgZnVuY3Rpb24gKHlBeGlzLCB5QXhpc0luZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9ICd4JyArIHhBeGlzSW5kZXggKyAneScgKyB5QXhpc0luZGV4O1xuICAgICAgICAgICAgICAgIHZhciBjYXJ0ZXNpYW4gPSBuZXcgQ2FydGVzaWFuMkQoa2V5KTtcblxuICAgICAgICAgICAgICAgIGNhcnRlc2lhbi5ncmlkID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHRoaXMuX2Nvb3Jkc01hcFtrZXldID0gY2FydGVzaWFuO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nvb3Jkc0xpc3QucHVzaChjYXJ0ZXNpYW4pO1xuXG4gICAgICAgICAgICAgICAgY2FydGVzaWFuLmFkZEF4aXMoeEF4aXMpO1xuICAgICAgICAgICAgICAgIGNhcnRlc2lhbi5hZGRBeGlzKHlBeGlzKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVBeGlzQ3JlYXRvcihheGlzVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChheGlzTW9kZWwsIGlkeCkge1xuICAgICAgICAgICAgICAgIGlmICghaXNBeGlzVXNlZEluVGhlR3JpZChheGlzTW9kZWwsIGdyaWRNb2RlbCwgZWNNb2RlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBheGlzUG9zaXRpb24gPSBheGlzTW9kZWwuZ2V0KCdwb3NpdGlvbicpO1xuICAgICAgICAgICAgICAgIGlmIChheGlzVHlwZSA9PT0gJ3gnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeCBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAoYXhpc1Bvc2l0aW9uICE9PSAndG9wJyAmJiBheGlzUG9zaXRpb24gIT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IGJvdHRvbSBvZiBYXG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzUG9zaXRpb24gPSAnYm90dG9tJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChheGlzUG9zaXRpb25Vc2VkW2F4aXNQb3NpdGlvbl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzUG9zaXRpb24gPSBheGlzUG9zaXRpb24gPT09ICd0b3AnID8gJ2JvdHRvbScgOiAndG9wJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRml4IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChheGlzUG9zaXRpb24gIT09ICdsZWZ0JyAmJiBheGlzUG9zaXRpb24gIT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgbGVmdCBvZiBZXG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzUG9zaXRpb24gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXhpc1Bvc2l0aW9uVXNlZFtheGlzUG9zaXRpb25dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpc1Bvc2l0aW9uID0gYXhpc1Bvc2l0aW9uID09PSAnbGVmdCcgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF4aXNQb3NpdGlvblVzZWRbYXhpc1Bvc2l0aW9uXSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICB2YXIgYXhpcyA9IG5ldyBBeGlzMkQoXG4gICAgICAgICAgICAgICAgICAgIGF4aXNUeXBlLCBheGlzSGVscGVyLmNyZWF0ZVNjYWxlQnlNb2RlbChheGlzTW9kZWwpLFxuICAgICAgICAgICAgICAgICAgICBbMCwgMF0sXG4gICAgICAgICAgICAgICAgICAgIGF4aXNNb2RlbC5nZXQoJ3R5cGUnKSxcbiAgICAgICAgICAgICAgICAgICAgYXhpc1Bvc2l0aW9uXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIHZhciBpc0NhdGVnb3J5ID0gYXhpcy50eXBlID09PSAnY2F0ZWdvcnknO1xuICAgICAgICAgICAgICAgIGF4aXMub25CYW5kID0gaXNDYXRlZ29yeSAmJiBheGlzTW9kZWwuZ2V0KCdib3VuZGFyeUdhcCcpO1xuICAgICAgICAgICAgICAgIGF4aXMuaW52ZXJzZSA9IGF4aXNNb2RlbC5nZXQoJ2ludmVyc2UnKTtcblxuICAgICAgICAgICAgICAgIGF4aXMub25aZXJvID0gYXhpc01vZGVsLmdldCgnYXhpc0xpbmUub25aZXJvJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBJbmplY3QgYXhpcyBpbnRvIGF4aXNNb2RlbFxuICAgICAgICAgICAgICAgIGF4aXNNb2RlbC5heGlzID0gYXhpcztcblxuICAgICAgICAgICAgICAgIC8vIEluamVjdCBheGlzTW9kZWwgaW50byBheGlzXG4gICAgICAgICAgICAgICAgYXhpcy5tb2RlbCA9IGF4aXNNb2RlbDtcblxuICAgICAgICAgICAgICAgIC8vIEluamVjdCBncmlkIGluZm8gYXhpc1xuICAgICAgICAgICAgICAgIGF4aXMuZ3JpZCA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAvLyBJbmRleCBvZiBheGlzLCBjYW4gYmUgdXNlZCBhcyBrZXlcbiAgICAgICAgICAgICAgICBheGlzLmluZGV4ID0gaWR4O1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fYXhlc0xpc3QucHVzaChheGlzKTtcblxuICAgICAgICAgICAgICAgIGF4ZXNNYXBbYXhpc1R5cGVdW2lkeF0gPSBheGlzO1xuICAgICAgICAgICAgICAgIGF4ZXNDb3VudFtheGlzVHlwZV0rKztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGNhcnRlc2lhbiBwcm9wZXJ0aWVzIGZyb20gc2VyaWVzXG4gICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvbW9kZWwvT3B0aW9ufSBvcHRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdyaWRQcm90by5fdXBkYXRlU2NhbGUgPSBmdW5jdGlvbiAoZWNNb2RlbCwgZ3JpZE1vZGVsKSB7XG4gICAgICAgIC8vIFJlc2V0IHNjYWxlXG4gICAgICAgIHpyVXRpbC5lYWNoKHRoaXMuX2F4ZXNMaXN0LCBmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICAgICAgYXhpcy5zY2FsZS5zZXRFeHRlbnQoSW5maW5pdHksIC1JbmZpbml0eSk7XG4gICAgICAgIH0pO1xuICAgICAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICBpZiAoaXNDYXJ0ZXNpYW4yRChzZXJpZXNNb2RlbCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXhlc01vZGVscyA9IGZpbmRBeGVzTW9kZWxzKHNlcmllc01vZGVsLCBlY01vZGVsKTtcbiAgICAgICAgICAgICAgICB2YXIgeEF4aXNNb2RlbCA9IGF4ZXNNb2RlbHNbMF07XG4gICAgICAgICAgICAgICAgdmFyIHlBeGlzTW9kZWwgPSBheGVzTW9kZWxzWzFdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpc0F4aXNVc2VkSW5UaGVHcmlkKHhBeGlzTW9kZWwsIGdyaWRNb2RlbCwgZWNNb2RlbClcbiAgICAgICAgICAgICAgICAgICAgfHwgIWlzQXhpc1VzZWRJblRoZUdyaWQoeUF4aXNNb2RlbCwgZ3JpZE1vZGVsLCBlY01vZGVsKVxuICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjYXJ0ZXNpYW4gPSB0aGlzLmdldENhcnRlc2lhbihcbiAgICAgICAgICAgICAgICAgICAgeEF4aXNNb2RlbC5jb21wb25lbnRJbmRleCwgeUF4aXNNb2RlbC5jb21wb25lbnRJbmRleFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgICAgICAgICAgdmFyIHhBeGlzID0gY2FydGVzaWFuLmdldEF4aXMoJ3gnKTtcbiAgICAgICAgICAgICAgICB2YXIgeUF4aXMgPSBjYXJ0ZXNpYW4uZ2V0QXhpcygneScpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ2xpc3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuaW9uRXh0ZW50KGRhdGEsIHhBeGlzLCBzZXJpZXNNb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgIHVuaW9uRXh0ZW50KGRhdGEsIHlBeGlzLCBzZXJpZXNNb2RlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBmdW5jdGlvbiB1bmlvbkV4dGVudChkYXRhLCBheGlzLCBzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgZWFjaChzZXJpZXNNb2RlbC5jb29yZERpbVRvRGF0YURpbShheGlzLmRpbSksIGZ1bmN0aW9uIChkaW0pIHtcbiAgICAgICAgICAgICAgICBheGlzLnNjYWxlLnVuaW9uRXh0ZW50KGRhdGEuZ2V0RGF0YUV4dGVudChcbiAgICAgICAgICAgICAgICAgICAgZGltLCBheGlzLnNjYWxlLnR5cGUgIT09ICdvcmRpbmFsJ1xuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlQXhpc1RyYW5zZnJvbShheGlzLCBjb29yZEJhc2UpIHtcbiAgICAgICAgdmFyIGF4aXNFeHRlbnQgPSBheGlzLmdldEV4dGVudCgpO1xuICAgICAgICB2YXIgYXhpc0V4dGVudFN1bSA9IGF4aXNFeHRlbnRbMF0gKyBheGlzRXh0ZW50WzFdO1xuXG4gICAgICAgIC8vIEZhc3QgdHJhbnNmb3JtXG4gICAgICAgIGF4aXMudG9HbG9iYWxDb29yZCA9IGF4aXMuZGltID09PSAneCdcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvb3JkICsgY29vcmRCYXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBmdW5jdGlvbiAoY29vcmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXhpc0V4dGVudFN1bSAtIGNvb3JkICsgY29vcmRCYXNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgYXhpcy50b0xvY2FsQ29vcmQgPSBheGlzLmRpbSA9PT0gJ3gnXG4gICAgICAgICAgICA/IGZ1bmN0aW9uIChjb29yZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb29yZCAtIGNvb3JkQmFzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF4aXNFeHRlbnRTdW0gLSBjb29yZCArIGNvb3JkQmFzZTtcbiAgICAgICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGF4ZXNUeXBlcyA9IFsneEF4aXMnLCAneUF4aXMnXTtcbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kQXhlc01vZGVscyhzZXJpZXNNb2RlbCwgZWNNb2RlbCkge1xuICAgICAgICByZXR1cm4genJVdGlsLm1hcChheGVzVHlwZXMsIGZ1bmN0aW9uIChheGlzVHlwZSkge1xuICAgICAgICAgICAgdmFyIGF4aXNNb2RlbCA9IGVjTW9kZWwucXVlcnlDb21wb25lbnRzKHtcbiAgICAgICAgICAgICAgICBtYWluVHlwZTogYXhpc1R5cGUsXG4gICAgICAgICAgICAgICAgaW5kZXg6IHNlcmllc01vZGVsLmdldChheGlzVHlwZSArICdJbmRleCcpLFxuICAgICAgICAgICAgICAgIGlkOiBzZXJpZXNNb2RlbC5nZXQoYXhpc1R5cGUgKyAnSWQnKVxuICAgICAgICAgICAgfSlbMF07XG5cbiAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFheGlzTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGF4aXNUeXBlICsgJyBcIicgKyB6clV0aWwucmV0cmlldmUoXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXQoYXhpc1R5cGUgKyAnSW5kZXgnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc01vZGVsLmdldChheGlzVHlwZSArICdJZCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICAgICApICsgJ1wiIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBheGlzTW9kZWw7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQ2FydGVzaWFuMkQoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHNlcmllc01vZGVsLmdldCgnY29vcmRpbmF0ZVN5c3RlbScpID09PSAnY2FydGVzaWFuMmQnO1xuICAgIH1cblxuICAgIEdyaWQuY3JlYXRlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgICAgICB2YXIgZ3JpZHMgPSBbXTtcbiAgICAgICAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KCdncmlkJywgZnVuY3Rpb24gKGdyaWRNb2RlbCwgaWR4KSB7XG4gICAgICAgICAgICB2YXIgZ3JpZCA9IG5ldyBHcmlkKGdyaWRNb2RlbCwgZWNNb2RlbCwgYXBpKTtcbiAgICAgICAgICAgIGdyaWQubmFtZSA9ICdncmlkXycgKyBpZHg7XG4gICAgICAgICAgICBncmlkLnJlc2l6ZShncmlkTW9kZWwsIGFwaSk7XG5cbiAgICAgICAgICAgIGdyaWRNb2RlbC5jb29yZGluYXRlU3lzdGVtID0gZ3JpZDtcblxuICAgICAgICAgICAgZ3JpZHMucHVzaChncmlkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gSW5qZWN0IHRoZSBjb29yZGluYXRlU3lzdGVtcyBpbnRvIHNlcmllc01vZGVsXG4gICAgICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAgIGlmICghaXNDYXJ0ZXNpYW4yRChzZXJpZXNNb2RlbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBheGVzTW9kZWxzID0gZmluZEF4ZXNNb2RlbHMoc2VyaWVzTW9kZWwsIGVjTW9kZWwpO1xuICAgICAgICAgICAgdmFyIHhBeGlzTW9kZWwgPSBheGVzTW9kZWxzWzBdO1xuICAgICAgICAgICAgdmFyIHlBeGlzTW9kZWwgPSBheGVzTW9kZWxzWzFdO1xuXG4gICAgICAgICAgICB2YXIgZ3JpZE1vZGVsID0geEF4aXNNb2RlbC5maW5kR3JpZE1vZGVsKCk7XG5cbiAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFncmlkTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dyaWQgXCInICsgenJVdGlsLnJldHJpZXZlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhBeGlzTW9kZWwuZ2V0KCdncmlkSW5kZXgnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4QXhpc01vZGVsLmdldCgnZ3JpZElkJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICAgICAgICAgKSArICdcIiBub3QgZm91bmQnXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh4QXhpc01vZGVsLmZpbmRHcmlkTW9kZWwoKSAhPT0geUF4aXNNb2RlbC5maW5kR3JpZE1vZGVsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd4QXhpcyBhbmQgeUF4aXMgbXVzdCB1c2UgdGhlIHNhbWUgZ3JpZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGdyaWQgPSBncmlkTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcblxuICAgICAgICAgICAgc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbSA9IGdyaWQuZ2V0Q2FydGVzaWFuKFxuICAgICAgICAgICAgICAgIHhBeGlzTW9kZWwuY29tcG9uZW50SW5kZXgsIHlBeGlzTW9kZWwuY29tcG9uZW50SW5kZXhcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBncmlkcztcbiAgICB9O1xuXG4gICAgLy8gRm9yIGRlY2lkaW5nIHdoaWNoIGRpbWVuc2lvbnMgdG8gdXNlIHdoZW4gY3JlYXRpbmcgbGlzdCBkYXRhXG4gICAgR3JpZC5kaW1lbnNpb25zID0gQ2FydGVzaWFuMkQucHJvdG90eXBlLmRpbWVuc2lvbnM7XG5cbiAgICByZXF1aXJlKCcuLi8uLi9Db29yZGluYXRlU3lzdGVtJykucmVnaXN0ZXIoJ2NhcnRlc2lhbjJkJywgR3JpZCk7XG5cbiAgICByZXR1cm4gR3JpZDtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vR3JpZC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNFxuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cbiAgICB2YXIgT3JkaW5hbFNjYWxlID0gcmVxdWlyZSgnLi4vc2NhbGUvT3JkaW5hbCcpO1xuICAgIHZhciBJbnRlcnZhbFNjYWxlID0gcmVxdWlyZSgnLi4vc2NhbGUvSW50ZXJ2YWwnKTtcbiAgICByZXF1aXJlKCcuLi9zY2FsZS9UaW1lJyk7XG4gICAgcmVxdWlyZSgnLi4vc2NhbGUvTG9nJyk7XG4gICAgdmFyIFNjYWxlID0gcmVxdWlyZSgnLi4vc2NhbGUvU2NhbGUnKTtcblxuICAgIHZhciBudW1iZXJVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9udW1iZXInKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9jb3JlL3V0aWwnKTtcbiAgICB2YXIgdGV4dENvbnRhaW4gPSByZXF1aXJlKCd6cmVuZGVyL2NvbnRhaW4vdGV4dCcpO1xuICAgIHZhciBheGlzSGVscGVyID0ge307XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYXhpcyBzY2FsZSBleHRlbnQgYmVmb3JlIG5pY2VkLlxuICAgICAqL1xuICAgIGF4aXNIZWxwZXIuZ2V0U2NhbGVFeHRlbnQgPSBmdW5jdGlvbiAoYXhpcywgbW9kZWwpIHtcbiAgICAgICAgdmFyIHNjYWxlID0gYXhpcy5zY2FsZTtcbiAgICAgICAgdmFyIG9yaWdpbmFsRXh0ZW50ID0gc2NhbGUuZ2V0RXh0ZW50KCk7XG4gICAgICAgIHZhciBzcGFuID0gb3JpZ2luYWxFeHRlbnRbMV0gLSBvcmlnaW5hbEV4dGVudFswXTtcbiAgICAgICAgaWYgKHNjYWxlLnR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICAgICAgLy8gSWYgc2VyaWVzIGhhcyBubyBkYXRhLCBzY2FsZSBleHRlbnQgbWF5IGJlIHdyb25nXG4gICAgICAgICAgICBpZiAoIWlzRmluaXRlKHNwYW4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbEV4dGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbWluID0gbW9kZWwuZ2V0TWluID8gbW9kZWwuZ2V0TWluKCkgOiBtb2RlbC5nZXQoJ21pbicpO1xuICAgICAgICB2YXIgbWF4ID0gbW9kZWwuZ2V0TWF4ID8gbW9kZWwuZ2V0TWF4KCkgOiBtb2RlbC5nZXQoJ21heCcpO1xuICAgICAgICB2YXIgY3Jvc3NaZXJvID0gbW9kZWwuZ2V0TmVlZENyb3NzWmVyb1xuICAgICAgICAgICAgPyBtb2RlbC5nZXROZWVkQ3Jvc3NaZXJvKCkgOiAhbW9kZWwuZ2V0KCdzY2FsZScpO1xuICAgICAgICB2YXIgYm91bmRhcnlHYXAgPSBtb2RlbC5nZXQoJ2JvdW5kYXJ5R2FwJyk7XG4gICAgICAgIGlmICghenJVdGlsLmlzQXJyYXkoYm91bmRhcnlHYXApKSB7XG4gICAgICAgICAgICBib3VuZGFyeUdhcCA9IFtib3VuZGFyeUdhcCB8fCAwLCBib3VuZGFyeUdhcCB8fCAwXTtcbiAgICAgICAgfVxuICAgICAgICBib3VuZGFyeUdhcFswXSA9IG51bWJlclV0aWwucGFyc2VQZXJjZW50KGJvdW5kYXJ5R2FwWzBdLCAxKTtcbiAgICAgICAgYm91bmRhcnlHYXBbMV0gPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudChib3VuZGFyeUdhcFsxXSwgMSk7XG4gICAgICAgIHZhciBmaXhNaW4gPSB0cnVlO1xuICAgICAgICB2YXIgZml4TWF4ID0gdHJ1ZTtcbiAgICAgICAgLy8gQWRkIGJvdW5kYXJ5IGdhcFxuICAgICAgICBpZiAobWluID09IG51bGwpIHtcbiAgICAgICAgICAgIG1pbiA9IG9yaWdpbmFsRXh0ZW50WzBdIC0gYm91bmRhcnlHYXBbMF0gKiBzcGFuO1xuICAgICAgICAgICAgZml4TWluID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgICAgICAgICBtYXggPSBvcmlnaW5hbEV4dGVudFsxXSArIGJvdW5kYXJ5R2FwWzFdICogc3BhbjtcbiAgICAgICAgICAgIGZpeE1heCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaW4gPT09ICdkYXRhTWluJykge1xuICAgICAgICAgICAgbWluID0gb3JpZ2luYWxFeHRlbnRbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heCA9PT0gJ2RhdGFNYXgnKSB7XG4gICAgICAgICAgICBtYXggPSBvcmlnaW5hbEV4dGVudFsxXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFdmFsdWF0ZSBpZiBheGlzIG5lZWRzIGNyb3NzIHplcm9cbiAgICAgICAgaWYgKGNyb3NzWmVybykge1xuICAgICAgICAgICAgLy8gQXhpcyBpcyBvdmVyIHplcm8gYW5kIG1pbiBpcyBub3Qgc2V0XG4gICAgICAgICAgICBpZiAobWluID4gMCAmJiBtYXggPiAwICYmICFmaXhNaW4pIHtcbiAgICAgICAgICAgICAgICBtaW4gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXhpcyBpcyB1bmRlciB6ZXJvIGFuZCBtYXggaXMgbm90IHNldFxuICAgICAgICAgICAgaWYgKG1pbiA8IDAgJiYgbWF4IDwgMCAmJiAhZml4TWF4KSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW21pbiwgbWF4XTtcbiAgICB9O1xuXG4gICAgYXhpc0hlbHBlci5uaWNlU2NhbGVFeHRlbnQgPSBmdW5jdGlvbiAoYXhpcywgbW9kZWwpIHtcbiAgICAgICAgdmFyIHNjYWxlID0gYXhpcy5zY2FsZTtcbiAgICAgICAgdmFyIGV4dGVudCA9IGF4aXNIZWxwZXIuZ2V0U2NhbGVFeHRlbnQoYXhpcywgbW9kZWwpO1xuICAgICAgICB2YXIgZml4TWluID0gKG1vZGVsLmdldE1pbiA/IG1vZGVsLmdldE1pbigpIDogbW9kZWwuZ2V0KCdtaW4nKSkgIT0gbnVsbDtcbiAgICAgICAgdmFyIGZpeE1heCA9IChtb2RlbC5nZXRNYXggPyBtb2RlbC5nZXRNYXgoKSA6IG1vZGVsLmdldCgnbWF4JykpICE9IG51bGw7XG4gICAgICAgIHZhciBzcGxpdE51bWJlciA9IG1vZGVsLmdldCgnc3BsaXROdW1iZXInKTtcblxuICAgICAgICBpZiAoc2NhbGUudHlwZSA9PT0gJ2xvZycpIHtcbiAgICAgICAgICAgIHNjYWxlLmJhc2UgPSBtb2RlbC5nZXQoJ2xvZ0Jhc2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjYWxlLnNldEV4dGVudChleHRlbnRbMF0sIGV4dGVudFsxXSk7XG4gICAgICAgIHNjYWxlLm5pY2VFeHRlbnQoc3BsaXROdW1iZXIsIGZpeE1pbiwgZml4TWF4KTtcblxuICAgICAgICAvLyBVc2UgbWluSW50ZXJ2YWwgdG8gY29uc3RyYWludCB0aGUgY2FsY3VsYXRlZCBpbnRlcnZhbC5cbiAgICAgICAgLy8gSWYgY2FsY3VsYXRlZCBpbnRlcnZhbCBpcyBsZXNzIHRoYW4gbWluSW50ZXJ2YWwuIGluY3JlYXNlIHRoZSBpbnRlcnZhbCBxdWFudGl0eSB1bnRpbFxuICAgICAgICAvLyBpdCBpcyBsYXJnZXIgdGhhbiBtaW5JbnRlcnZhbC5cbiAgICAgICAgLy8gRm9yIGV4YW1wbGU6XG4gICAgICAgIC8vICBtaW5JbnRlcnZhbCBpcyAxLCBjYWxjdWxhdGVkIGludGVydmFsIGlzIDAuMiwgc28gaW5jcmVhc2UgaXQgdG8gYmUgMS4gSW4gdGhpcyB3YXkgd2UgY2FuIGdldFxuICAgICAgICAvLyAgYW4gaW50ZWdlciBheGlzLlxuICAgICAgICB2YXIgbWluSW50ZXJ2YWwgPSBtb2RlbC5nZXQoJ21pbkludGVydmFsJyk7XG4gICAgICAgIGlmIChpc0Zpbml0ZShtaW5JbnRlcnZhbCkgJiYgIWZpeE1pbiAmJiAhZml4TWF4ICYmIHNjYWxlLnR5cGUgPT09ICdpbnRlcnZhbCcpIHtcbiAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IHNjYWxlLmdldEludGVydmFsKCk7XG4gICAgICAgICAgICB2YXIgaW50ZXJ2YWxTY2FsZSA9IE1hdGgubWF4KE1hdGguYWJzKGludGVydmFsKSwgbWluSW50ZXJ2YWwpIC8gaW50ZXJ2YWw7XG4gICAgICAgICAgICAvLyB3aGlsZSAoaW50ZXJ2YWwgPCBtaW5JbnRlcnZhbCkge1xuICAgICAgICAgICAgLy8gICAgIHZhciBxdWFudGl0eSA9IG51bWJlclV0aWwucXVhbnRpdHkoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgLy8gICAgIGludGVydmFsID0gcXVhbnRpdHkgKiAxMDtcbiAgICAgICAgICAgIC8vICAgICBzY2FsZVF1YW50aXR5ICo9IDEwO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgZXh0ZW50ID0gc2NhbGUuZ2V0RXh0ZW50KCk7XG4gICAgICAgICAgICBzY2FsZS5zZXRFeHRlbnQoaW50ZXJ2YWxTY2FsZSAqIGV4dGVudFswXSwgZXh0ZW50WzFdICogaW50ZXJ2YWxTY2FsZSk7XG4gICAgICAgICAgICBzY2FsZS5uaWNlRXh0ZW50KHNwbGl0TnVtYmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHNvbWUgb25lIHNwZWNpZmllZCB0aGUgbWluLCBtYXguIEFuZCB0aGUgZGVmYXVsdCBjYWxjdWxhdGVkIGludGVydmFsXG4gICAgICAgIC8vIGlzIG5vdCBnb29kIGVub3VnaC4gSGUgY2FuIHNwZWNpZnkgdGhlIGludGVydmFsLiBJdCBpcyBvZnRlbiBhcHBlYXJlZFxuICAgICAgICAvLyBpbiBhbmdsZSBheGlzIHdpdGggYW5nbGUgMCAtIDM2MC4gSW50ZXJ2YWwgY2FsY3VsYXRlZCBpbiBpbnRlcnZhbCBzY2FsZSBpcyBoYXJkXG4gICAgICAgIC8vIHRvIGJlIDYwLlxuICAgICAgICAvLyBGSVhNRVxuICAgICAgICB2YXIgaW50ZXJ2YWwgPSBtb2RlbC5nZXQoJ2ludGVydmFsJyk7XG4gICAgICAgIGlmIChpbnRlcnZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzY2FsZS5zZXRJbnRlcnZhbCAmJiBzY2FsZS5zZXRJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9Nb2RlbH0gbW9kZWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2F4aXNUeXBlXSBEZWZhdWx0IHJldHJpZXZlIGZyb20gbW9kZWwudHlwZVxuICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL3NjYWxlLyp9XG4gICAgICovXG4gICAgYXhpc0hlbHBlci5jcmVhdGVTY2FsZUJ5TW9kZWwgPSBmdW5jdGlvbihtb2RlbCwgYXhpc1R5cGUpIHtcbiAgICAgICAgYXhpc1R5cGUgPSBheGlzVHlwZSB8fCBtb2RlbC5nZXQoJ3R5cGUnKTtcbiAgICAgICAgaWYgKGF4aXNUeXBlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGF4aXNUeXBlKSB7XG4gICAgICAgICAgICAgICAgLy8gQnVpbGRpbiBzY2FsZVxuICAgICAgICAgICAgICAgIGNhc2UgJ2NhdGVnb3J5JzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBPcmRpbmFsU2NhbGUoXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5nZXRDYXRlZ29yaWVzKCksIFtJbmZpbml0eSwgLUluZmluaXR5XVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcnZhbFNjYWxlKCk7XG4gICAgICAgICAgICAgICAgLy8gRXh0ZW5kZWQgc2NhbGUsIGxpa2UgdGltZSBhbmQgbG9nXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChTY2FsZS5nZXRDbGFzcyhheGlzVHlwZSkgfHwgSW50ZXJ2YWxTY2FsZSkuY3JlYXRlKG1vZGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgYXhpcyBjb3JzcyAwXG4gICAgICovXG4gICAgYXhpc0hlbHBlci5pZkF4aXNDcm9zc1plcm8gPSBmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICB2YXIgZGF0YUV4dGVudCA9IGF4aXMuc2NhbGUuZ2V0RXh0ZW50KCk7XG4gICAgICAgIHZhciBtaW4gPSBkYXRhRXh0ZW50WzBdO1xuICAgICAgICB2YXIgbWF4ID0gZGF0YUV4dGVudFsxXTtcbiAgICAgICAgcmV0dXJuICEoKG1pbiA+IDAgJiYgbWF4ID4gMCkgfHwgKG1pbiA8IDAgJiYgbWF4IDwgMCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0aWNrQ29vcmRzIEluIGF4aXMgc2VsZiBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGxhYmVsc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmb250XG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0F4aXNIb3Jpem9udGFsXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGF4aXNIZWxwZXIuZ2V0QXhpc0xhYmVsSW50ZXJ2YWwgPSBmdW5jdGlvbiAodGlja0Nvb3JkcywgbGFiZWxzLCBmb250LCBpc0F4aXNIb3Jpem9udGFsKSB7XG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIC8vIOS4jeWQjOinkueahGF4aXPlkoxsYWJlbO+8jOS4jeWPquaYr2hvcml6b250YWzlkox2ZXJ0aWNhbC5cblxuICAgICAgICB2YXIgdGV4dFNwYWNlVGFrZW5SZWN0O1xuICAgICAgICB2YXIgYXV0b0xhYmVsSW50ZXJ2YWwgPSAwO1xuICAgICAgICB2YXIgYWNjdW11bGF0ZWRMYWJlbEludGVydmFsID0gMDtcblxuICAgICAgICB2YXIgc3RlcCA9IDE7XG4gICAgICAgIGlmIChsYWJlbHMubGVuZ3RoID4gNDApIHtcbiAgICAgICAgICAgIC8vIFNpbXBsZSBvcHRpbWl6YXRpb24gZm9yIGxhcmdlIGFtb3VudCBvZiBsYWJlbHNcbiAgICAgICAgICAgIHN0ZXAgPSBNYXRoLmZsb29yKGxhYmVscy5sZW5ndGggLyA0MCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpY2tDb29yZHMubGVuZ3RoOyBpICs9IHN0ZXApIHtcbiAgICAgICAgICAgIHZhciB0aWNrQ29vcmQgPSB0aWNrQ29vcmRzW2ldO1xuICAgICAgICAgICAgdmFyIHJlY3QgPSB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QoXG4gICAgICAgICAgICAgICAgbGFiZWxzW2ldLCBmb250LCAnY2VudGVyJywgJ3RvcCdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZWN0W2lzQXhpc0hvcml6b250YWwgPyAneCcgOiAneSddICs9IHRpY2tDb29yZDtcbiAgICAgICAgICAgIC8vIEZJWE1FIE1hZ2ljIG51bWJlciAxLjVcbiAgICAgICAgICAgIHJlY3RbaXNBeGlzSG9yaXpvbnRhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0J10gKj0gMS4zO1xuICAgICAgICAgICAgaWYgKCF0ZXh0U3BhY2VUYWtlblJlY3QpIHtcbiAgICAgICAgICAgICAgICB0ZXh0U3BhY2VUYWtlblJlY3QgPSByZWN0LmNsb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBzcGFjZSBmb3IgY3VycmVudCBsYWJlbDtcbiAgICAgICAgICAgIGVsc2UgaWYgKHRleHRTcGFjZVRha2VuUmVjdC5pbnRlcnNlY3QocmVjdCkpIHtcbiAgICAgICAgICAgICAgICBhY2N1bXVsYXRlZExhYmVsSW50ZXJ2YWwrKztcbiAgICAgICAgICAgICAgICBhdXRvTGFiZWxJbnRlcnZhbCA9IE1hdGgubWF4KGF1dG9MYWJlbEludGVydmFsLCBhY2N1bXVsYXRlZExhYmVsSW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGV4dFNwYWNlVGFrZW5SZWN0LnVuaW9uKHJlY3QpO1xuICAgICAgICAgICAgICAgIC8vIFJlc2V0XG4gICAgICAgICAgICAgICAgYWNjdW11bGF0ZWRMYWJlbEludGVydmFsID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXV0b0xhYmVsSW50ZXJ2YWwgPT09IDAgJiYgc3RlcCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoYXV0b0xhYmVsSW50ZXJ2YWwgKyAxKSAqIHN0ZXAgLSAxO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXhpc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxhYmVsRm9ybWF0dGVyXG4gICAgICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59XG4gICAgICovXG4gICAgYXhpc0hlbHBlci5nZXRGb3JtYXR0ZWRMYWJlbHMgPSBmdW5jdGlvbiAoYXhpcywgbGFiZWxGb3JtYXR0ZXIpIHtcbiAgICAgICAgdmFyIHNjYWxlID0gYXhpcy5zY2FsZTtcbiAgICAgICAgdmFyIGxhYmVscyA9IHNjYWxlLmdldFRpY2tzTGFiZWxzKCk7XG4gICAgICAgIHZhciB0aWNrcyA9IHNjYWxlLmdldFRpY2tzKCk7XG4gICAgICAgIGlmICh0eXBlb2YgbGFiZWxGb3JtYXR0ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBsYWJlbEZvcm1hdHRlciA9IChmdW5jdGlvbiAodHBsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRwbC5yZXBsYWNlKCd7dmFsdWV9JywgdmFsKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkobGFiZWxGb3JtYXR0ZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHpyVXRpbC5tYXAobGFiZWxzLCBsYWJlbEZvcm1hdHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGxhYmVsRm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4genJVdGlsLm1hcCh0aWNrcywgZnVuY3Rpb24gKHRpY2ssIGlkeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsYWJlbEZvcm1hdHRlcihcbiAgICAgICAgICAgICAgICAgICAgYXhpcy50eXBlID09PSAnY2F0ZWdvcnknID8gc2NhbGUuZ2V0TGFiZWwodGljaykgOiB0aWNrLFxuICAgICAgICAgICAgICAgICAgICBpZHhcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbGFiZWxzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBheGlzSGVscGVyO1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC9lY2hhcnRzL2Nvb3JkL2F4aXNIZWxwZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsIi8qKlxuICogTGluZWFyIGNvbnRpbnVvdXMgc2NhbGVcbiAqIEBtb2R1bGUgZWNoYXJ0cy9jb29yZC9zY2FsZS9PcmRpbmFsXG4gKlxuICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MZXZlbF9vZl9tZWFzdXJlbWVudFxuICovXG5cbi8vIEZJWE1FIG9ubHkgb25lIGRhdGFcbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvY29yZS91dGlsJyk7XG4gICAgdmFyIFNjYWxlID0gcmVxdWlyZSgnLi9TY2FsZScpO1xuXG4gICAgdmFyIHNjYWxlUHJvdG8gPSBTY2FsZS5wcm90b3R5cGU7XG5cbiAgICB2YXIgT3JkaW5hbFNjYWxlID0gU2NhbGUuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnb3JkaW5hbCcsXG5cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKGRhdGEsIGV4dGVudCkge1xuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICB0aGlzLl9leHRlbnQgPSBleHRlbnQgfHwgWzAsIGRhdGEubGVuZ3RoIC0gMV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgID8genJVdGlsLmluZGV4T2YodGhpcy5fZGF0YSwgdmFsKVxuICAgICAgICAgICAgICAgIC8vIHZhbCBtaWdodCBiZSBmbG9hdC5cbiAgICAgICAgICAgICAgICA6IE1hdGgucm91bmQodmFsKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb250YWluOiBmdW5jdGlvbiAocmFuaykge1xuICAgICAgICAgICAgcmFuayA9IHRoaXMucGFyc2UocmFuayk7XG4gICAgICAgICAgICByZXR1cm4gc2NhbGVQcm90by5jb250YWluLmNhbGwodGhpcywgcmFuaylcbiAgICAgICAgICAgICAgICAmJiB0aGlzLl9kYXRhW3JhbmtdICE9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vcm1hbGl6ZSBnaXZlbiByYW5rIG9yIG5hbWUgdG8gbGluZWFyIFswLCAxXVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFt2YWxdXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIG5vcm1hbGl6ZTogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHNjYWxlUHJvdG8ubm9ybWFsaXplLmNhbGwodGhpcywgdGhpcy5wYXJzZSh2YWwpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzY2FsZTogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoc2NhbGVQcm90by5zY2FsZS5jYWxsKHRoaXMsIHZhbCkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIGdldFRpY2tzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGlja3MgPSBbXTtcbiAgICAgICAgICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgICAgICAgICB2YXIgcmFuayA9IGV4dGVudFswXTtcblxuICAgICAgICAgICAgd2hpbGUgKHJhbmsgPD0gZXh0ZW50WzFdKSB7XG4gICAgICAgICAgICAgICAgdGlja3MucHVzaChyYW5rKTtcbiAgICAgICAgICAgICAgICByYW5rKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aWNrcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGl0ZW0gb24gcmFuayBuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGdldExhYmVsOiBmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFbbl07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGNvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXh0ZW50WzFdIC0gdGhpcy5fZXh0ZW50WzBdICsgMTtcbiAgICAgICAgfSxcblxuICAgICAgICBuaWNlVGlja3M6IHpyVXRpbC5ub29wLFxuICAgICAgICBuaWNlRXh0ZW50OiB6clV0aWwubm9vcFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvc2NhbGUvVGltZX1cbiAgICAgKi9cbiAgICBPcmRpbmFsU2NhbGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IE9yZGluYWxTY2FsZSgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gT3JkaW5hbFNjYWxlO1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC9lY2hhcnRzL3NjYWxlL09yZGluYWwuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsIi8qKlxuICogLy8gU2NhbGUgY2xhc3MgbWFuYWdlbWVudFxuICogQG1vZHVsZSBlY2hhcnRzL3NjYWxlL1NjYWxlXG4gKi9cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG4gICAgdmFyIGNsYXp6VXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvY2xhenonKTtcblxuICAgIGZ1bmN0aW9uIFNjYWxlKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogRXh0ZW50XG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZXh0ZW50ID0gW0luZmluaXR5LCAtSW5maW5pdHldO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGVwIGlzIGNhbGN1bGF0ZWQgaW4gYWRqdXN0RXh0ZW50XG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faW50ZXJ2YWwgPSAwO1xuXG4gICAgICAgIHRoaXMuaW5pdCAmJiB0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICB2YXIgc2NhbGVQcm90byA9IFNjYWxlLnByb3RvdHlwZTtcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIGlucHV0IHZhbCB0byB2YWxpZCBpbm5lciBudW1iZXIuXG4gICAgICogQHBhcmFtIHsqfSB2YWxcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgc2NhbGVQcm90by5wYXJzZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgLy8gTm90aWNlOiBUaGlzIHdvdWxkIGJlIGEgdHJhcCBoZXJlLCBJZiB0aGUgaW1wbGVtZW50YXRpb25cbiAgICAgICAgLy8gb2YgdGhpcyBtZXRob2QgZGVwZW5kcyBvbiBleHRlbnQsIGFuZCB0aGlzIG1ldGhvZCBpcyB1c2VkXG4gICAgICAgIC8vIGJlZm9yZSBleHRlbnQgc2V0IChsaWtlIGluIGRhdGFab29tKSwgaXQgd291bGQgYmUgd3JvbmcuXG4gICAgICAgIC8vIE5ldmVydGhlbGVzcywgcGFyc2UgZG9lcyBub3QgZGVwZW5kIG9uIGV4dGVudCBnZW5lcmFsbHkuXG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcblxuICAgIHNjYWxlUHJvdG8uY29udGFpbiA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICAgICAgcmV0dXJuIHZhbCA+PSBleHRlbnRbMF0gJiYgdmFsIDw9IGV4dGVudFsxXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplIHZhbHVlIHRvIGxpbmVhciBbMCwgMV0sIHJldHVybiAwLjUgaWYgZXh0ZW50IHNwYW4gaXMgMFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWxcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgc2NhbGVQcm90by5ub3JtYWxpemUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgICAgIGlmIChleHRlbnRbMV0gPT09IGV4dGVudFswXSkge1xuICAgICAgICAgICAgcmV0dXJuIDAuNTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHZhbCAtIGV4dGVudFswXSkgLyAoZXh0ZW50WzFdIC0gZXh0ZW50WzBdKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2NhbGUgbm9ybWFsaXplZCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWxcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgc2NhbGVQcm90by5zY2FsZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICAgICAgcmV0dXJuIHZhbCAqIChleHRlbnRbMV0gLSBleHRlbnRbMF0pICsgZXh0ZW50WzBdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXQgZXh0ZW50IGZyb20gZGF0YVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG90aGVyXG4gICAgICovXG4gICAgc2NhbGVQcm90by51bmlvbkV4dGVudCA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICBvdGhlclswXSA8IGV4dGVudFswXSAmJiAoZXh0ZW50WzBdID0gb3RoZXJbMF0pO1xuICAgICAgICBvdGhlclsxXSA+IGV4dGVudFsxXSAmJiAoZXh0ZW50WzFdID0gb3RoZXJbMV0pO1xuICAgICAgICAvLyBub3Qgc2V0RXh0ZW50IGJlY2F1c2UgaW4gbG9nIGF4aXMgaXQgbWF5IHRyYW5zZm9ybWVkIHRvIHBvd2VyXG4gICAgICAgIC8vIHRoaXMuc2V0RXh0ZW50KGV4dGVudFswXSwgZXh0ZW50WzFdKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGV4dGVudFxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAqL1xuICAgIHNjYWxlUHJvdG8uZ2V0RXh0ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXh0ZW50LnNsaWNlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCBleHRlbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kXG4gICAgICovXG4gICAgc2NhbGVQcm90by5zZXRFeHRlbnQgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgdGhpc0V4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICAgICAgaWYgKCFpc05hTihzdGFydCkpIHtcbiAgICAgICAgICAgIHRoaXNFeHRlbnRbMF0gPSBzdGFydDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzTmFOKGVuZCkpIHtcbiAgICAgICAgICAgIHRoaXNFeHRlbnRbMV0gPSBlbmQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59XG4gICAgICovXG4gICAgc2NhbGVQcm90by5nZXRUaWNrc0xhYmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxhYmVscyA9IFtdO1xuICAgICAgICB2YXIgdGlja3MgPSB0aGlzLmdldFRpY2tzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGlja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxhYmVscy5wdXNoKHRoaXMuZ2V0TGFiZWwodGlja3NbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFiZWxzO1xuICAgIH07XG5cbiAgICBjbGF6elV0aWwuZW5hYmxlQ2xhc3NFeHRlbmQoU2NhbGUpO1xuICAgIGNsYXp6VXRpbC5lbmFibGVDbGFzc01hbmFnZW1lbnQoU2NhbGUsIHtcbiAgICAgICAgcmVnaXN0ZXJXaGVuRXh0ZW5kOiB0cnVlXG4gICAgfSk7XG5cbiAgICByZXR1cm4gU2NhbGU7XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL2VjaGFydHMvc2NhbGUvU2NhbGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsIi8qKlxuICogSW50ZXJ2YWwgc2NhbGVcbiAqIEBtb2R1bGUgZWNoYXJ0cy9zY2FsZS9JbnRlcnZhbFxuICovXG5cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG4gICAgdmFyIG51bWJlclV0aWwgPSByZXF1aXJlKCcuLi91dGlsL251bWJlcicpO1xuICAgIHZhciBmb3JtYXRVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9mb3JtYXQnKTtcbiAgICB2YXIgU2NhbGUgPSByZXF1aXJlKCcuL1NjYWxlJyk7XG5cbiAgICB2YXIgbWF0aEZsb29yID0gTWF0aC5mbG9vcjtcbiAgICB2YXIgbWF0aENlaWwgPSBNYXRoLmNlaWw7XG5cbiAgICB2YXIgZ2V0UHJlY2lzaW9uU2FmZSA9IG51bWJlclV0aWwuZ2V0UHJlY2lzaW9uU2FmZTtcbiAgICB2YXIgcm91bmRpbmdFcnJvckZpeCA9IG51bWJlclV0aWwucm91bmQ7XG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL2Nvb3JkL3NjYWxlL0ludGVydmFsXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIEludGVydmFsU2NhbGUgPSBTY2FsZS5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdpbnRlcnZhbCcsXG5cbiAgICAgICAgX2ludGVydmFsOiAwLFxuXG4gICAgICAgIHNldEV4dGVudDogZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICAgIHZhciB0aGlzRXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICAgICAgLy9zdGFydCxlbmQgbWF5IGJlIGEgTnVtYmVyIGxpa2UgJzI1Jyxzby4uLlxuICAgICAgICAgICAgaWYgKCFpc05hTihzdGFydCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzRXh0ZW50WzBdID0gcGFyc2VGbG9hdChzdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzTmFOKGVuZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzRXh0ZW50WzFdID0gcGFyc2VGbG9hdChlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHVuaW9uRXh0ZW50OiBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgICAgICAgICBvdGhlclswXSA8IGV4dGVudFswXSAmJiAoZXh0ZW50WzBdID0gb3RoZXJbMF0pO1xuICAgICAgICAgICAgb3RoZXJbMV0gPiBleHRlbnRbMV0gJiYgKGV4dGVudFsxXSA9IG90aGVyWzFdKTtcblxuICAgICAgICAgICAgLy8gdW5pb25FeHRlbnQgbWF5IGNhbGxlZCBieSBpdCdzIHN1YiBjbGFzc2VzXG4gICAgICAgICAgICBJbnRlcnZhbFNjYWxlLnByb3RvdHlwZS5zZXRFeHRlbnQuY2FsbCh0aGlzLCBleHRlbnRbMF0sIGV4dGVudFsxXSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgaW50ZXJ2YWxcbiAgICAgICAgICovXG4gICAgICAgIGdldEludGVydmFsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2ludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uaWNlVGlja3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnRlcnZhbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGludGVydmFsXG4gICAgICAgICAqL1xuICAgICAgICBzZXRJbnRlcnZhbDogZnVuY3Rpb24gKGludGVydmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcnZhbCA9IGludGVydmFsO1xuICAgICAgICAgICAgLy8gRHJvcHBlZCBhdXRvIGNhbGN1bGF0ZWQgbmljZUV4dGVudCBhbmQgdXNlIHVzZXIgc2V0dGVkIGV4dGVudFxuICAgICAgICAgICAgLy8gV2UgYXNzdW1lIHVzZXIgd2FuJ3QgdG8gc2V0IGJvdGggaW50ZXJ2YWwsIG1pbiwgbWF4IHRvIGdldCBhIGJldHRlciByZXN1bHRcbiAgICAgICAgICAgIHRoaXMuX25pY2VFeHRlbnQgPSB0aGlzLl9leHRlbnQuc2xpY2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICBnZXRUaWNrczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmljZVRpY2tzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSB0aGlzLl9pbnRlcnZhbDtcbiAgICAgICAgICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgICAgICAgICB2YXIgdGlja3MgPSBbXTtcblxuICAgICAgICAgICAgLy8gQ29uc2lkZXIgdGhpcyBjYXNlOiB1c2luZyBkYXRhWm9vbSB0b29sYm94LCB6b29tIGFuZCB6b29tLlxuICAgICAgICAgICAgdmFyIHNhZmVMaW1pdCA9IDEwMDAwO1xuXG4gICAgICAgICAgICBpZiAoaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmljZUV4dGVudCA9IHRoaXMuX25pY2VFeHRlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIHByZWNpc2lvbiA9IGdldFByZWNpc2lvblNhZmUoaW50ZXJ2YWwpICsgMjtcblxuICAgICAgICAgICAgICAgIGlmIChleHRlbnRbMF0gPCBuaWNlRXh0ZW50WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpY2tzLnB1c2goZXh0ZW50WzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHRpY2sgPSBuaWNlRXh0ZW50WzBdO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aWNrIDw9IG5pY2VFeHRlbnRbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGlja3MucHVzaCh0aWNrKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXZvaWQgcm91bmRpbmcgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgdGljayA9IHJvdW5kaW5nRXJyb3JGaXgodGljayArIGludGVydmFsLCBwcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGlja3MubGVuZ3RoID4gc2FmZUxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV4dGVudFsxXSA+IG5pY2VFeHRlbnRbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGlja3MucHVzaChleHRlbnRbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRpY2tzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFRpY2tzTGFiZWxzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGFiZWxzID0gW107XG4gICAgICAgICAgICB2YXIgdGlja3MgPSB0aGlzLmdldFRpY2tzKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGFiZWxzLnB1c2godGhpcy5nZXRMYWJlbCh0aWNrc1tpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxhYmVscztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG5cbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TGFiZWw6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0VXRpbC5hZGRDb21tYXMoZGF0YSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSBpbnRlcnZhbCBhbmQgZXh0ZW50IG9mIGludGVydmFscyBmb3IgbmljZSB0aWNrc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NwbGl0TnVtYmVyID0gNV0gRGVzaXJlZCBudW1iZXIgb2YgdGlja3NcbiAgICAgICAgICovXG4gICAgICAgIG5pY2VUaWNrczogZnVuY3Rpb24gKHNwbGl0TnVtYmVyKSB7XG4gICAgICAgICAgICBzcGxpdE51bWJlciA9IHNwbGl0TnVtYmVyIHx8IDU7XG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICAgICAgdmFyIHNwYW4gPSBleHRlbnRbMV0gLSBleHRlbnRbMF07XG4gICAgICAgICAgICBpZiAoIWlzRmluaXRlKHNwYW4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXNlciBtYXkgc2V0IGF4aXMgbWluIDAgYW5kIGRhdGEgYXJlIGFsbCBuZWdhdGl2ZVxuICAgICAgICAgICAgLy8gRklYTUUgSWYgaXQgbmVlZHMgdG8gcmV2ZXJzZSA/XG4gICAgICAgICAgICBpZiAoc3BhbiA8IDApIHtcbiAgICAgICAgICAgICAgICBzcGFuID0gLXNwYW47XG4gICAgICAgICAgICAgICAgZXh0ZW50LnJldmVyc2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRnJvbSBcIk5pY2UgTnVtYmVycyBmb3IgR3JhcGggTGFiZWxzXCIgb2YgR3JhcGhpYyBHZW1zXG4gICAgICAgICAgICAvLyB2YXIgbmljZVNwYW4gPSBudW1iZXJVdGlsLm5pY2Uoc3BhbiwgZmFsc2UpO1xuICAgICAgICAgICAgdmFyIHN0ZXAgPSByb3VuZGluZ0Vycm9yRml4KFxuICAgICAgICAgICAgICAgIG51bWJlclV0aWwubmljZShzcGFuIC8gc3BsaXROdW1iZXIsIHRydWUpLFxuICAgICAgICAgICAgICAgIE1hdGgubWF4KFxuICAgICAgICAgICAgICAgICAgICBnZXRQcmVjaXNpb25TYWZlKGV4dGVudFswXSksXG4gICAgICAgICAgICAgICAgICAgIGdldFByZWNpc2lvblNhZmUoZXh0ZW50WzFdKVxuICAgICAgICAgICAgICAgIC8vIGV4dGVudCBtYXkgYmUgWzAsIDFdLCBhbmQgc3RlcCBzaG91bGQgaGF2ZSAxIG1vcmUgZGlnaXRzLlxuICAgICAgICAgICAgICAgIC8vIFRvIG1ha2UgaXQgc2FmZSB3ZSBhZGQgMiBtb3JlIGRpZ2l0c1xuICAgICAgICAgICAgICAgICkgKyAyXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB2YXIgcHJlY2lzaW9uID0gZ2V0UHJlY2lzaW9uU2FmZShzdGVwKSArIDI7XG4gICAgICAgICAgICAvLyBOaWNlZCBleHRlbnQgaW5zaWRlIG9yaWdpbmFsIGV4dGVudFxuICAgICAgICAgICAgdmFyIG5pY2VFeHRlbnQgPSBbXG4gICAgICAgICAgICAgICAgcm91bmRpbmdFcnJvckZpeChtYXRoQ2VpbChleHRlbnRbMF0gLyBzdGVwKSAqIHN0ZXAsIHByZWNpc2lvbiksXG4gICAgICAgICAgICAgICAgcm91bmRpbmdFcnJvckZpeChtYXRoRmxvb3IoZXh0ZW50WzFdIC8gc3RlcCkgKiBzdGVwLCBwcmVjaXNpb24pXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICB0aGlzLl9pbnRlcnZhbCA9IHN0ZXA7XG4gICAgICAgICAgICB0aGlzLl9uaWNlRXh0ZW50ID0gbmljZUV4dGVudDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTmljZSBleHRlbnQuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3BsaXROdW1iZXIgPSA1XSBHaXZlbiBhcHByb3ggdGljayBudW1iZXJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbZml4TWluPWZhbHNlXVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmaXhNYXg9ZmFsc2VdXG4gICAgICAgICAqL1xuICAgICAgICBuaWNlRXh0ZW50OiBmdW5jdGlvbiAoc3BsaXROdW1iZXIsIGZpeE1pbiwgZml4TWF4KSB7XG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICAgICAgLy8gSWYgZXh0ZW50IHN0YXJ0IGFuZCBlbmQgYXJlIHNhbWUsIGV4cGFuZCB0aGVtXG4gICAgICAgICAgICBpZiAoZXh0ZW50WzBdID09PSBleHRlbnRbMV0pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXh0ZW50WzBdICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4cGFuZCBleHRlbnRcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4cGFuZFNpemUgPSBleHRlbnRbMF07XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIHRoZSBmb3dsbG93aW5nIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICBBeGlzIGhhcyBiZWVuIGZpeGVkIG1heCAxMDBcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICBQbHVzIGRhdGEgYXJlIGFsbCAxMDAgYW5kIGF4aXMgZXh0ZW50IGFyZSBbMTAwLCAxMDBdLlxuICAgICAgICAgICAgICAgICAgICAvLyBFeHRlbmQgdG8gdGhlIGJvdGggc2lkZSB3aWxsIGNhdXNlIGV4cGFuZGVkIG1heCBpcyBsYXJnZXIgdGhhbiBmaXhlZCBtYXguXG4gICAgICAgICAgICAgICAgICAgIC8vIFNvIG9ubHkgZXhwYW5kIHRvIHRoZSBzbWFsbGVyIHNpZGUuXG4gICAgICAgICAgICAgICAgICAgIGlmICghZml4TWF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbnRbMV0gKz0gZXhwYW5kU2l6ZSAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbnRbMF0gLT0gZXhwYW5kU2l6ZSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbnRbMF0gLT0gZXhwYW5kU2l6ZSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVudFsxXSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNwYW4gPSBleHRlbnRbMV0gLSBleHRlbnRbMF07XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gZGF0YSBhbmQgZXh0ZW50IGFyZSBbSW5maW5pdHksIC1JbmZpbml0eV1cbiAgICAgICAgICAgIGlmICghaXNGaW5pdGUoc3BhbikpIHtcbiAgICAgICAgICAgICAgICBleHRlbnRbMF0gPSAwO1xuICAgICAgICAgICAgICAgIGV4dGVudFsxXSA9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubmljZVRpY2tzKHNwbGl0TnVtYmVyKTtcblxuICAgICAgICAgICAgLy8gdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IHRoaXMuX2ludGVydmFsO1xuXG4gICAgICAgICAgICBpZiAoIWZpeE1pbikge1xuICAgICAgICAgICAgICAgIGV4dGVudFswXSA9IHJvdW5kaW5nRXJyb3JGaXgobWF0aEZsb29yKGV4dGVudFswXSAvIGludGVydmFsKSAqIGludGVydmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZml4TWF4KSB7XG4gICAgICAgICAgICAgICAgZXh0ZW50WzFdID0gcm91bmRpbmdFcnJvckZpeChtYXRoQ2VpbChleHRlbnRbMV0gLyBpbnRlcnZhbCkgKiBpbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge21vZHVsZTplY2hhcnRzL3NjYWxlL1RpbWV9XG4gICAgICovXG4gICAgSW50ZXJ2YWxTY2FsZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50ZXJ2YWxTY2FsZSgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gSW50ZXJ2YWxTY2FsZTtcbn0pO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC9lY2hhcnRzL3NjYWxlL0ludGVydmFsLmpzXG4gKiogbW9kdWxlIGlkID0gMTA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCIvKipcbiAqIEludGVydmFsIHNjYWxlXG4gKiBAbW9kdWxlIGVjaGFydHMvY29vcmQvc2NhbGUvVGltZVxuICovXG5cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvY29yZS91dGlsJyk7XG4gICAgdmFyIG51bWJlclV0aWwgPSByZXF1aXJlKCcuLi91dGlsL251bWJlcicpO1xuICAgIHZhciBmb3JtYXRVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC9mb3JtYXQnKTtcblxuICAgIHZhciBJbnRlcnZhbFNjYWxlID0gcmVxdWlyZSgnLi9JbnRlcnZhbCcpO1xuXG4gICAgdmFyIGludGVydmFsU2NhbGVQcm90byA9IEludGVydmFsU2NhbGUucHJvdG90eXBlO1xuXG4gICAgdmFyIG1hdGhDZWlsID0gTWF0aC5jZWlsO1xuICAgIHZhciBtYXRoRmxvb3IgPSBNYXRoLmZsb29yO1xuICAgIHZhciBPTkVfU0VDT05EID0gMTAwMDtcbiAgICB2YXIgT05FX01JTlVURSA9IE9ORV9TRUNPTkQgKiA2MDtcbiAgICB2YXIgT05FX0hPVVIgPSBPTkVfTUlOVVRFICogNjA7XG4gICAgdmFyIE9ORV9EQVkgPSBPTkVfSE9VUiAqIDI0O1xuXG4gICAgLy8gRklYTUUg5YWs55So77yfXG4gICAgdmFyIGJpc2VjdCA9IGZ1bmN0aW9uIChhLCB4LCBsbywgaGkpIHtcbiAgICAgICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgICAgICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuICAgICAgICAgICAgaWYgKGFbbWlkXVsyXSA8IHgpIHtcbiAgICAgICAgICAgICAgICBsbyA9IG1pZCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoaSAgPSBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOmVjaGFydHMvY29vcmQvc2NhbGUvVGltZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBUaW1lU2NhbGUgPSBJbnRlcnZhbFNjYWxlLmV4dGVuZCh7XG4gICAgICAgIHR5cGU6ICd0aW1lJyxcblxuICAgICAgICAvLyBPdmVyd3JpdGVcbiAgICAgICAgZ2V0TGFiZWw6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHZhciBzdGVwTHZsID0gdGhpcy5fc3RlcEx2bDtcblxuICAgICAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh2YWwpO1xuXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0VXRpbC5mb3JtYXRUaW1lKHN0ZXBMdmxbMF0sIGRhdGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIE92ZXJ3cml0ZVxuICAgICAgICBuaWNlRXh0ZW50OiBmdW5jdGlvbiAoYXBwcm94VGlja051bSwgZml4TWluLCBmaXhNYXgpIHtcbiAgICAgICAgICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgICAgICAgICAvLyBJZiBleHRlbnQgc3RhcnQgYW5kIGVuZCBhcmUgc2FtZSwgZXhwYW5kIHRoZW1cbiAgICAgICAgICAgIGlmIChleHRlbnRbMF0gPT09IGV4dGVudFsxXSkge1xuICAgICAgICAgICAgICAgIC8vIEV4cGFuZCBleHRlbnRcbiAgICAgICAgICAgICAgICBleHRlbnRbMF0gLT0gT05FX0RBWTtcbiAgICAgICAgICAgICAgICBleHRlbnRbMV0gKz0gT05FX0RBWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBkYXRhIGFuZCBleHRlbnQgYXJlIFtJbmZpbml0eSwgLUluZmluaXR5XVxuICAgICAgICAgICAgaWYgKGV4dGVudFsxXSA9PT0gLUluZmluaXR5ICYmIGV4dGVudFswXSA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgZXh0ZW50WzFdID0gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCBkLmdldE1vbnRoKCksIGQuZ2V0RGF0ZSgpKTtcbiAgICAgICAgICAgICAgICBleHRlbnRbMF0gPSBleHRlbnRbMV0gLSBPTkVfREFZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm5pY2VUaWNrcyhhcHByb3hUaWNrTnVtKTtcblxuICAgICAgICAgICAgLy8gdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IHRoaXMuX2ludGVydmFsO1xuXG4gICAgICAgICAgICBpZiAoIWZpeE1pbikge1xuICAgICAgICAgICAgICAgIGV4dGVudFswXSA9IG51bWJlclV0aWwucm91bmQobWF0aEZsb29yKGV4dGVudFswXSAvIGludGVydmFsKSAqIGludGVydmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZml4TWF4KSB7XG4gICAgICAgICAgICAgICAgZXh0ZW50WzFdID0gbnVtYmVyVXRpbC5yb3VuZChtYXRoQ2VpbChleHRlbnRbMV0gLyBpbnRlcnZhbCkgKiBpbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gT3ZlcndyaXRlXG4gICAgICAgIG5pY2VUaWNrczogZnVuY3Rpb24gKGFwcHJveFRpY2tOdW0pIHtcbiAgICAgICAgICAgIGFwcHJveFRpY2tOdW0gPSBhcHByb3hUaWNrTnVtIHx8IDEwO1xuXG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICAgICAgdmFyIHNwYW4gPSBleHRlbnRbMV0gLSBleHRlbnRbMF07XG4gICAgICAgICAgICB2YXIgYXBwcm94SW50ZXJ2YWwgPSBzcGFuIC8gYXBwcm94VGlja051bTtcbiAgICAgICAgICAgIHZhciBzY2FsZUxldmVsc0xlbiA9IHNjYWxlTGV2ZWxzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBpZHggPSBiaXNlY3Qoc2NhbGVMZXZlbHMsIGFwcHJveEludGVydmFsLCAwLCBzY2FsZUxldmVsc0xlbik7XG5cbiAgICAgICAgICAgIHZhciBsZXZlbCA9IHNjYWxlTGV2ZWxzW01hdGgubWluKGlkeCwgc2NhbGVMZXZlbHNMZW4gLSAxKV07XG4gICAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSBsZXZlbFsyXTtcbiAgICAgICAgICAgIC8vIFNhbWUgd2l0aCBpbnRlcnZhbCBzY2FsZSBpZiBzcGFuIGlzIG11Y2ggbGFyZ2VyIHRoYW4gMSB5ZWFyXG4gICAgICAgICAgICBpZiAobGV2ZWxbMF0gPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgICAgIHZhciB5ZWFyU3BhbiA9IHNwYW4gLyBpbnRlcnZhbDtcblxuICAgICAgICAgICAgICAgIC8vIEZyb20gXCJOaWNlIE51bWJlcnMgZm9yIEdyYXBoIExhYmVsc1wiIG9mIEdyYXBoaWMgR2Vtc1xuICAgICAgICAgICAgICAgIC8vIHZhciBuaWNlWWVhclNwYW4gPSBudW1iZXJVdGlsLm5pY2UoeWVhclNwYW4sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB2YXIgeWVhclN0ZXAgPSBudW1iZXJVdGlsLm5pY2UoeWVhclNwYW4gLyBhcHByb3hUaWNrTnVtLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIGludGVydmFsICo9IHllYXJTdGVwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbmljZUV4dGVudCA9IFtcbiAgICAgICAgICAgICAgICBtYXRoQ2VpbChleHRlbnRbMF0gLyBpbnRlcnZhbCkgKiBpbnRlcnZhbCxcbiAgICAgICAgICAgICAgICBtYXRoRmxvb3IoZXh0ZW50WzFdIC8gaW50ZXJ2YWwpICogaW50ZXJ2YWxcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIHRoaXMuX3N0ZXBMdmwgPSBsZXZlbDtcbiAgICAgICAgICAgIC8vIEludGVydmFsIHdpbGwgYmUgdXNlZCBpbiBnZXRUaWNrc1xuICAgICAgICAgICAgdGhpcy5faW50ZXJ2YWwgPSBpbnRlcnZhbDtcbiAgICAgICAgICAgIHRoaXMuX25pY2VFeHRlbnQgPSBuaWNlRXh0ZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAvLyB2YWwgbWlnaHQgYmUgZmxvYXQuXG4gICAgICAgICAgICByZXR1cm4gK251bWJlclV0aWwucGFyc2VEYXRlKHZhbCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHpyVXRpbC5lYWNoKFsnY29udGFpbicsICdub3JtYWxpemUnXSwgZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgVGltZVNjYWxlLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcnZhbFNjYWxlUHJvdG9bbWV0aG9kTmFtZV0uY2FsbCh0aGlzLCB0aGlzLnBhcnNlKHZhbCkpO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gU3RlcHMgZnJvbSBkM1xuICAgIHZhciBzY2FsZUxldmVscyA9IFtcbiAgICAgICAgLy8gRm9ybWF0ICAgICAgIHN0ZXAgICAgaW50ZXJ2YWxcbiAgICAgICAgWydoaDptbTpzcycsICAgIDEsICAgICAgT05FX1NFQ09ORF0sICAgICAgICAgICAvLyAxc1xuICAgICAgICBbJ2hoOm1tOnNzJywgICAgNSwgICAgICBPTkVfU0VDT05EICogNV0sICAgICAgIC8vIDVzXG4gICAgICAgIFsnaGg6bW06c3MnLCAgICAxMCwgICAgIE9ORV9TRUNPTkQgKiAxMF0sICAgICAgLy8gMTBzXG4gICAgICAgIFsnaGg6bW06c3MnLCAgICAxNSwgICAgIE9ORV9TRUNPTkQgKiAxNV0sICAgICAgLy8gMTVzXG4gICAgICAgIFsnaGg6bW06c3MnLCAgICAzMCwgICAgIE9ORV9TRUNPTkQgKiAzMF0sICAgICAgLy8gMzBzXG4gICAgICAgIFsnaGg6bW1cXG5NTS1kZCcsMSwgICAgICBPTkVfTUlOVVRFXSwgICAgICAgICAgLy8gMW1cbiAgICAgICAgWydoaDptbVxcbk1NLWRkJyw1LCAgICAgIE9ORV9NSU5VVEUgKiA1XSwgICAgICAvLyA1bVxuICAgICAgICBbJ2hoOm1tXFxuTU0tZGQnLDEwLCAgICAgT05FX01JTlVURSAqIDEwXSwgICAgIC8vIDEwbVxuICAgICAgICBbJ2hoOm1tXFxuTU0tZGQnLDE1LCAgICAgT05FX01JTlVURSAqIDE1XSwgICAgIC8vIDE1bVxuICAgICAgICBbJ2hoOm1tXFxuTU0tZGQnLDMwLCAgICAgT05FX01JTlVURSAqIDMwXSwgICAgIC8vIDMwbVxuICAgICAgICBbJ2hoOm1tXFxuTU0tZGQnLDEsICAgICAgT05FX0hPVVJdLCAgICAgICAgLy8gMWhcbiAgICAgICAgWydoaDptbVxcbk1NLWRkJywyLCAgICAgIE9ORV9IT1VSICogMl0sICAgIC8vIDJoXG4gICAgICAgIFsnaGg6bW1cXG5NTS1kZCcsNiwgICAgICBPTkVfSE9VUiAqIDZdLCAgICAvLyA2aFxuICAgICAgICBbJ2hoOm1tXFxuTU0tZGQnLDEyLCAgICAgT05FX0hPVVIgKiAxMl0sICAgLy8gMTJoXG4gICAgICAgIFsnTU0tZGRcXG55eXl5JywgMSwgICAgICBPTkVfREFZXSwgICAvLyAxZFxuICAgICAgICBbJ3dlZWsnLCAgICAgICAgNywgICAgICBPTkVfREFZICogN10sICAgICAgICAvLyA3ZFxuICAgICAgICBbJ21vbnRoJywgICAgICAgMSwgICAgICBPTkVfREFZICogMzFdLCAgICAgICAvLyAxTVxuICAgICAgICBbJ3F1YXJ0ZXInLCAgICAgMywgICAgICBPTkVfREFZICogMzgwIC8gNF0sICAvLyAzTVxuICAgICAgICBbJ2hhbGYteWVhcicsICAgNiwgICAgICBPTkVfREFZICogMzgwIC8gMl0sICAvLyA2TVxuICAgICAgICBbJ3llYXInLCAgICAgICAgMSwgICAgICBPTkVfREFZICogMzgwXSAgICAgICAvLyAxWVxuICAgIF07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9zY2FsZS9UaW1lfVxuICAgICAqL1xuICAgIFRpbWVTY2FsZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGltZVNjYWxlKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBUaW1lU2NhbGU7XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL2VjaGFydHMvc2NhbGUvVGltZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEwOVxuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiLyoqXG4gKiBMb2cgc2NhbGVcbiAqIEBtb2R1bGUgZWNoYXJ0cy9zY2FsZS9Mb2dcbiAqL1xuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9jb3JlL3V0aWwnKTtcbiAgICB2YXIgU2NhbGUgPSByZXF1aXJlKCcuL1NjYWxlJyk7XG4gICAgdmFyIG51bWJlclV0aWwgPSByZXF1aXJlKCcuLi91dGlsL251bWJlcicpO1xuXG4gICAgLy8gVXNlIHNvbWUgbWV0aG9kIG9mIEludGVydmFsU2NhbGVcbiAgICB2YXIgSW50ZXJ2YWxTY2FsZSA9IHJlcXVpcmUoJy4vSW50ZXJ2YWwnKTtcblxuICAgIHZhciBzY2FsZVByb3RvID0gU2NhbGUucHJvdG90eXBlO1xuICAgIHZhciBpbnRlcnZhbFNjYWxlUHJvdG8gPSBJbnRlcnZhbFNjYWxlLnByb3RvdHlwZTtcblxuICAgIHZhciBtYXRoRmxvb3IgPSBNYXRoLmZsb29yO1xuICAgIHZhciBtYXRoQ2VpbCA9IE1hdGguY2VpbDtcbiAgICB2YXIgbWF0aFBvdyA9IE1hdGgucG93O1xuXG4gICAgdmFyIG1hdGhMb2cgPSBNYXRoLmxvZztcblxuICAgIHZhciBMb2dTY2FsZSA9IFNjYWxlLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ2xvZycsXG5cbiAgICAgICAgYmFzZTogMTAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VGlja3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB6clV0aWwubWFwKGludGVydmFsU2NhbGVQcm90by5nZXRUaWNrcy5jYWxsKHRoaXMpLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlclV0aWwucm91bmQobWF0aFBvdyh0aGlzLmJhc2UsIHZhbCkpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWxcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TGFiZWw6IGludGVydmFsU2NhbGVQcm90by5nZXRMYWJlbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB2YWxcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgc2NhbGU6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHZhbCA9IHNjYWxlUHJvdG8uc2NhbGUuY2FsbCh0aGlzLCB2YWwpO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGhQb3codGhpcy5iYXNlLCB2YWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0RXh0ZW50OiBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgdmFyIGJhc2UgPSB0aGlzLmJhc2U7XG4gICAgICAgICAgICBzdGFydCA9IG1hdGhMb2coc3RhcnQpIC8gbWF0aExvZyhiYXNlKTtcbiAgICAgICAgICAgIGVuZCA9IG1hdGhMb2coZW5kKSAvIG1hdGhMb2coYmFzZSk7XG4gICAgICAgICAgICBpbnRlcnZhbFNjYWxlUHJvdG8uc2V0RXh0ZW50LmNhbGwodGhpcywgc3RhcnQsIGVuZCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gZW5kXG4gICAgICAgICAqL1xuICAgICAgICBnZXRFeHRlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBiYXNlID0gdGhpcy5iYXNlO1xuICAgICAgICAgICAgdmFyIGV4dGVudCA9IHNjYWxlUHJvdG8uZ2V0RXh0ZW50LmNhbGwodGhpcyk7XG4gICAgICAgICAgICBleHRlbnRbMF0gPSBtYXRoUG93KGJhc2UsIGV4dGVudFswXSk7XG4gICAgICAgICAgICBleHRlbnRbMV0gPSBtYXRoUG93KGJhc2UsIGV4dGVudFsxXSk7XG4gICAgICAgICAgICByZXR1cm4gZXh0ZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gZXh0ZW50XG4gICAgICAgICAqL1xuICAgICAgICB1bmlvbkV4dGVudDogZnVuY3Rpb24gKGV4dGVudCkge1xuICAgICAgICAgICAgdmFyIGJhc2UgPSB0aGlzLmJhc2U7XG4gICAgICAgICAgICBleHRlbnRbMF0gPSBtYXRoTG9nKGV4dGVudFswXSkgLyBtYXRoTG9nKGJhc2UpO1xuICAgICAgICAgICAgZXh0ZW50WzFdID0gbWF0aExvZyhleHRlbnRbMV0pIC8gbWF0aExvZyhiYXNlKTtcbiAgICAgICAgICAgIHNjYWxlUHJvdG8udW5pb25FeHRlbnQuY2FsbCh0aGlzLCBleHRlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgaW50ZXJ2YWwgYW5kIGV4dGVudCBvZiBpbnRlcnZhbHMgZm9yIG5pY2UgdGlja3NcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBbYXBwcm94VGlja051bSA9IDEwXSBHaXZlbiBhcHByb3ggdGljayBudW1iZXJcbiAgICAgICAgICovXG4gICAgICAgIG5pY2VUaWNrczogZnVuY3Rpb24gKGFwcHJveFRpY2tOdW0pIHtcbiAgICAgICAgICAgIGFwcHJveFRpY2tOdW0gPSBhcHByb3hUaWNrTnVtIHx8IDEwO1xuICAgICAgICAgICAgdmFyIGV4dGVudCA9IHRoaXMuX2V4dGVudDtcbiAgICAgICAgICAgIHZhciBzcGFuID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdO1xuICAgICAgICAgICAgaWYgKHNwYW4gPT09IEluZmluaXR5IHx8IHNwYW4gPD0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGludGVydmFsID0gbnVtYmVyVXRpbC5xdWFudGl0eShzcGFuKTtcbiAgICAgICAgICAgIHZhciBlcnIgPSBhcHByb3hUaWNrTnVtIC8gc3BhbiAqIGludGVydmFsO1xuXG4gICAgICAgICAgICAvLyBGaWx0ZXIgdGlja3MgdG8gZ2V0IGNsb3NlciB0byB0aGUgZGVzaXJlZCBjb3VudC5cbiAgICAgICAgICAgIGlmIChlcnIgPD0gMC41KSB7XG4gICAgICAgICAgICAgICAgaW50ZXJ2YWwgKj0gMTA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEludGVydmFsIHNob3VsZCBiZSBpbnRlZ2VyXG4gICAgICAgICAgICB3aGlsZSAoIWlzTmFOKGludGVydmFsKSAmJiBNYXRoLmFicyhpbnRlcnZhbCkgPCAxICYmIE1hdGguYWJzKGludGVydmFsKSA+IDApIHtcbiAgICAgICAgICAgICAgICBpbnRlcnZhbCAqPSAxMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG5pY2VFeHRlbnQgPSBbXG4gICAgICAgICAgICAgICAgbnVtYmVyVXRpbC5yb3VuZChtYXRoQ2VpbChleHRlbnRbMF0gLyBpbnRlcnZhbCkgKiBpbnRlcnZhbCksXG4gICAgICAgICAgICAgICAgbnVtYmVyVXRpbC5yb3VuZChtYXRoRmxvb3IoZXh0ZW50WzFdIC8gaW50ZXJ2YWwpICogaW50ZXJ2YWwpXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICB0aGlzLl9pbnRlcnZhbCA9IGludGVydmFsO1xuICAgICAgICAgICAgdGhpcy5fbmljZUV4dGVudCA9IG5pY2VFeHRlbnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5pY2UgZXh0ZW50LlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FwcHJveFRpY2tOdW0gPSAxMF0gR2l2ZW4gYXBwcm94IHRpY2sgbnVtYmVyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZpeE1pbj1mYWxzZV1cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbZml4TWF4PWZhbHNlXVxuICAgICAgICAgKi9cbiAgICAgICAgbmljZUV4dGVudDogaW50ZXJ2YWxTY2FsZVByb3RvLm5pY2VFeHRlbnRcbiAgICB9KTtcblxuICAgIHpyVXRpbC5lYWNoKFsnY29udGFpbicsICdub3JtYWxpemUnXSwgZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgTG9nU2NhbGUucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdmFsID0gbWF0aExvZyh2YWwpIC8gbWF0aExvZyh0aGlzLmJhc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHNjYWxlUHJvdG9bbWV0aG9kTmFtZV0uY2FsbCh0aGlzLCB2YWwpO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgTG9nU2NhbGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IExvZ1NjYWxlKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBMb2dTY2FsZTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvZWNoYXJ0cy9zY2FsZS9Mb2cuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsImRlZmluZShmdW5jdGlvbihyZXF1aXJlKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9jb3JlL3V0aWwnKTtcbiAgICB2YXIgQ2FydGVzaWFuID0gcmVxdWlyZSgnLi9DYXJ0ZXNpYW4nKTtcblxuICAgIGZ1bmN0aW9uIENhcnRlc2lhbjJEKG5hbWUpIHtcblxuICAgICAgICBDYXJ0ZXNpYW4uY2FsbCh0aGlzLCBuYW1lKTtcbiAgICB9XG5cbiAgICBDYXJ0ZXNpYW4yRC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IENhcnRlc2lhbjJELFxuXG4gICAgICAgIHR5cGU6ICdjYXJ0ZXNpYW4yZCcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICBkaW1lbnNpb25zOiBbJ3gnLCAneSddLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCYXNlIGF4aXMgd2lsbCBiZSB1c2VkIG9uIHN0YWNraW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vQXhpczJEfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QmFzZUF4aXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEF4ZXNCeVNjYWxlKCdvcmRpbmFsJylbMF1cbiAgICAgICAgICAgICAgICB8fCB0aGlzLmdldEF4ZXNCeVNjYWxlKCd0aW1lJylbMF1cbiAgICAgICAgICAgICAgICB8fCB0aGlzLmdldEF4aXMoJ3gnKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgY29udGFpbiBwb2ludFxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBwb2ludFxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpblBvaW50OiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICAgIHZhciBheGlzWCA9IHRoaXMuZ2V0QXhpcygneCcpO1xuICAgICAgICAgICAgdmFyIGF4aXNZID0gdGhpcy5nZXRBeGlzKCd5Jyk7XG4gICAgICAgICAgICByZXR1cm4gYXhpc1guY29udGFpbihheGlzWC50b0xvY2FsQ29vcmQocG9pbnRbMF0pKVxuICAgICAgICAgICAgICAgICYmIGF4aXNZLmNvbnRhaW4oYXhpc1kudG9Mb2NhbENvb3JkKHBvaW50WzFdKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGNvbnRhaW4gZGF0YVxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBkYXRhXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluRGF0YTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEF4aXMoJ3gnKS5jb250YWluRGF0YShkYXRhWzBdKVxuICAgICAgICAgICAgICAgICYmIHRoaXMuZ2V0QXhpcygneScpLmNvbnRhaW5EYXRhKGRhdGFbMV0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0IHNlcmllcyBkYXRhIHRvIGFuIGFycmF5IG9mIHBvaW50c1xuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2RhdGEvTGlzdH0gZGF0YVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0YWNrXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAgICAgKiAgUmV0dXJuIGFycmF5IG9mIHBvaW50cy4gRm9yIGV4YW1wbGU6XG4gICAgICAgICAqICBgW1sxMCwgMTBdLCBbMjAsIDIwXSwgWzMwLCAzMF1dYFxuICAgICAgICAgKi9cbiAgICAgICAgZGF0YVRvUG9pbnRzOiBmdW5jdGlvbiAoZGF0YSwgc3RhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLm1hcEFycmF5KFsneCcsICd5J10sIGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVRvUG9pbnQoW3gsIHldKTtcbiAgICAgICAgICAgIH0sIHN0YWNrLCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZGF0YVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjbGFtcD1mYWxzZV1cbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICBkYXRhVG9Qb2ludDogZnVuY3Rpb24gKGRhdGEsIGNsYW1wKSB7XG4gICAgICAgICAgICB2YXIgeEF4aXMgPSB0aGlzLmdldEF4aXMoJ3gnKTtcbiAgICAgICAgICAgIHZhciB5QXhpcyA9IHRoaXMuZ2V0QXhpcygneScpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB4QXhpcy50b0dsb2JhbENvb3JkKHhBeGlzLmRhdGFUb0Nvb3JkKGRhdGFbMF0sIGNsYW1wKSksXG4gICAgICAgICAgICAgICAgeUF4aXMudG9HbG9iYWxDb29yZCh5QXhpcy5kYXRhVG9Db29yZChkYXRhWzFdLCBjbGFtcCkpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBwb2ludFxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjbGFtcD1mYWxzZV1cbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICBwb2ludFRvRGF0YTogZnVuY3Rpb24gKHBvaW50LCBjbGFtcCkge1xuICAgICAgICAgICAgdmFyIHhBeGlzID0gdGhpcy5nZXRBeGlzKCd4Jyk7XG4gICAgICAgICAgICB2YXIgeUF4aXMgPSB0aGlzLmdldEF4aXMoJ3knKTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgeEF4aXMuY29vcmRUb0RhdGEoeEF4aXMudG9Mb2NhbENvb3JkKHBvaW50WzBdKSwgY2xhbXApLFxuICAgICAgICAgICAgICAgIHlBeGlzLmNvb3JkVG9EYXRhKHlBeGlzLnRvTG9jYWxDb29yZChwb2ludFsxXSksIGNsYW1wKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IG90aGVyIGF4aXNcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vQXhpczJEfSBheGlzXG4gICAgICAgICAqL1xuICAgICAgICBnZXRPdGhlckF4aXM6IGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBeGlzKGF4aXMuZGltID09PSAneCcgPyAneScgOiAneCcpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHpyVXRpbC5pbmhlcml0cyhDYXJ0ZXNpYW4yRCwgQ2FydGVzaWFuKTtcblxuICAgIHJldHVybiBDYXJ0ZXNpYW4yRDtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vQ2FydGVzaWFuMkQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsIi8qKlxuICogQ2FydGVzaWFuIGNvb3JkaW5hdGUgc3lzdGVtXG4gKiBAbW9kdWxlICBlY2hhcnRzL2Nvb3JkL0NhcnRlc2lhblxuICpcbiAqL1xuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9jb3JlL3V0aWwnKTtcblxuICAgIGZ1bmN0aW9uIGRpbUF4aXNNYXBwZXIoZGltKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9heGVzW2RpbV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL2Nvb3JkL0NhcnRlc2lhblxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBDYXJ0ZXNpYW4gPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB0aGlzLl9heGVzID0ge307XG5cbiAgICAgICAgdGhpcy5fZGltTGlzdCA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZSB8fCAnJztcbiAgICB9O1xuXG4gICAgQ2FydGVzaWFuLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogQ2FydGVzaWFuLFxuXG4gICAgICAgIHR5cGU6ICdjYXJ0ZXNpYW4nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYXhpc1xuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ8c3RyaW5nfSBkaW1cbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvY29vcmQvQ2FydGVzaWFufkF4aXN9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRBeGlzOiBmdW5jdGlvbiAoZGltKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXhlc1tkaW1dO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYXhlcyBsaXN0XG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6ZWNoYXJ0cy9jb29yZC9DYXJ0ZXNpYW5+QXhpcz59XG4gICAgICAgICAqL1xuICAgICAgICBnZXRBeGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4genJVdGlsLm1hcCh0aGlzLl9kaW1MaXN0LCBkaW1BeGlzTWFwcGVyLCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGF4ZXMgbGlzdCBieSBnaXZlbiBzY2FsZSB0eXBlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRBeGVzQnlTY2FsZTogZnVuY3Rpb24gKHNjYWxlVHlwZSkge1xuICAgICAgICAgICAgc2NhbGVUeXBlID0gc2NhbGVUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICByZXR1cm4genJVdGlsLmZpbHRlcihcbiAgICAgICAgICAgICAgICB0aGlzLmdldEF4ZXMoKSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXhpcy5zY2FsZS50eXBlID09PSBzY2FsZVR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGF4aXNcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9DYXJ0ZXNpYW4uQXhpc31cbiAgICAgICAgICovXG4gICAgICAgIGFkZEF4aXM6IGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgICAgICB2YXIgZGltID0gYXhpcy5kaW07XG5cbiAgICAgICAgICAgIHRoaXMuX2F4ZXNbZGltXSA9IGF4aXM7XG5cbiAgICAgICAgICAgIHRoaXMuX2RpbUxpc3QucHVzaChkaW0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0IGRhdGEgdG8gY29vcmQgaW4gbmQgc3BhY2VcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPnxPYmplY3QuPHN0cmluZywgbnVtYmVyPn0gdmFsXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fE9iamVjdC48c3RyaW5nLCBudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgZGF0YVRvQ29vcmQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhQ29vcmRDb252ZXJ0KHZhbCwgJ2RhdGFUb0Nvb3JkJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnQgY29vcmQgaW4gbmQgc3BhY2UgdG8gZGF0YVxuICAgICAgICAgKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPnxPYmplY3QuPHN0cmluZywgbnVtYmVyPn0gdmFsXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fE9iamVjdC48c3RyaW5nLCBudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgY29vcmRUb0RhdGE6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhQ29vcmRDb252ZXJ0KHZhbCwgJ2Nvb3JkVG9EYXRhJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RhdGFDb29yZENvbnZlcnQ6IGZ1bmN0aW9uIChpbnB1dCwgbWV0aG9kKSB7XG4gICAgICAgICAgICB2YXIgZGltTGlzdCA9IHRoaXMuX2RpbUxpc3Q7XG5cbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBpbnB1dCBpbnN0YW5jZW9mIEFycmF5ID8gW10gOiB7fTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaW1MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpbSA9IGRpbUxpc3RbaV07XG4gICAgICAgICAgICAgICAgdmFyIGF4aXMgPSB0aGlzLl9heGVzW2RpbV07XG5cbiAgICAgICAgICAgICAgICBvdXRwdXRbZGltXSA9IGF4aXNbbWV0aG9kXShpbnB1dFtkaW1dKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gQ2FydGVzaWFuO1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC9lY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9DYXJ0ZXNpYW4uanNcbiAqKiBtb2R1bGUgaWQgPSAxMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsImRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvY29yZS91dGlsJyk7XG4gICAgdmFyIEF4aXMgPSByZXF1aXJlKCcuLi9BeGlzJyk7XG4gICAgdmFyIGF4aXNMYWJlbEludGVydmFsID0gcmVxdWlyZSgnLi9heGlzTGFiZWxJbnRlcnZhbCcpO1xuXG4gICAgLyoqXG4gICAgICogRXh0ZW5kIGF4aXMgMmRcbiAgICAgKiBAY29uc3RydWN0b3IgbW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0F4aXMyRFxuICAgICAqIEBleHRlbmRzIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vQXhpc31cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGltXG4gICAgICogQHBhcmFtIHsqfSBzY2FsZVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGNvb3JkRXh0ZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGF4aXNUeXBlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBvc2l0aW9uXG4gICAgICovXG4gICAgdmFyIEF4aXMyRCA9IGZ1bmN0aW9uIChkaW0sIHNjYWxlLCBjb29yZEV4dGVudCwgYXhpc1R5cGUsIHBvc2l0aW9uKSB7XG4gICAgICAgIEF4aXMuY2FsbCh0aGlzLCBkaW0sIHNjYWxlLCBjb29yZEV4dGVudCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBeGlzIHR5cGVcbiAgICAgICAgICogIC0gJ2NhdGVnb3J5J1xuICAgICAgICAgKiAgLSAndmFsdWUnXG4gICAgICAgICAqICAtICd0aW1lJ1xuICAgICAgICAgKiAgLSAnbG9nJ1xuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50eXBlID0gYXhpc1R5cGUgfHwgJ3ZhbHVlJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXhpcyBwb3NpdGlvblxuICAgICAgICAgKiAgLSAndG9wJ1xuICAgICAgICAgKiAgLSAnYm90dG9tJ1xuICAgICAgICAgKiAgLSAnbGVmdCdcbiAgICAgICAgICogIC0gJ3JpZ2h0J1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uIHx8ICdib3R0b20nO1xuICAgIH07XG5cbiAgICBBeGlzMkQucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBBeGlzMkQsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGV4IG9mIGF4aXMsIGNhbiBiZSB1c2VkIGFzIGtleVxuICAgICAgICAgKi9cbiAgICAgICAgaW5kZXg6IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBheGlzIGlzIG9uIHRoZSB6ZXJvIHBvc2l0aW9uIG9mIHRoZSBvdGhlciBheGlzXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgb25aZXJvOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXhpcyBtb2RlbFxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzTW9kZWx9XG4gICAgICAgICAqL1xuICAgICAgICBtb2RlbDogbnVsbCxcblxuICAgICAgICBpc0hvcml6b250YWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICAgICAgICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJztcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRHbG9iYWxFeHRlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXQgPSB0aGlzLmdldEV4dGVudCgpO1xuICAgICAgICAgICAgcmV0WzBdID0gdGhpcy50b0dsb2JhbENvb3JkKHJldFswXSk7XG4gICAgICAgICAgICByZXRbMV0gPSB0aGlzLnRvR2xvYmFsQ29vcmQocmV0WzFdKTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldExhYmVsSW50ZXJ2YWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsYWJlbEludGVydmFsID0gdGhpcy5fbGFiZWxJbnRlcnZhbDtcbiAgICAgICAgICAgIGlmICghbGFiZWxJbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIGxhYmVsSW50ZXJ2YWwgPSB0aGlzLl9sYWJlbEludGVydmFsID0gYXhpc0xhYmVsSW50ZXJ2YWwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGFiZWxJbnRlcnZhbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgbGFiZWwgaXMgaWdub3JlZC5cbiAgICAgICAgICogQXV0b21hdGljYWxseSB1c2VkIHdoZW4gYXhpcyBpcyBjYXRlZ29yeSBhbmQgbGFiZWwgY2FuIG5vdCBiZSBhbGwgc2hvd25cbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgaWR4XG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBpc0xhYmVsSWdub3JlZDogZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2NhdGVnb3J5Jykge1xuICAgICAgICAgICAgICAgIHZhciBsYWJlbEludGVydmFsID0gdGhpcy5nZXRMYWJlbEludGVydmFsKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgodHlwZW9mIGxhYmVsSW50ZXJ2YWwgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgICYmICFsYWJlbEludGVydmFsKGlkeCwgdGhpcy5zY2FsZS5nZXRMYWJlbChpZHgpKSlcbiAgICAgICAgICAgICAgICAgICAgfHwgaWR4ICUgKGxhYmVsSW50ZXJ2YWwgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVHJhbnNmb3JtIGdsb2JhbCBjb29yZCB0byBsb2NhbCBjb29yZCxcbiAgICAgICAgICogaS5lLiB2YXIgbG9jYWxDb29yZCA9IGF4aXMudG9Mb2NhbENvb3JkKDgwKTtcbiAgICAgICAgICogZGVzaWduYXRlIGJ5IG1vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9HcmlkLlxuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICB0b0xvY2FsQ29vcmQ6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYW5zZm9ybSBnbG9iYWwgY29vcmQgdG8gbG9jYWwgY29vcmQsXG4gICAgICAgICAqIGkuZS4gdmFyIGdsb2JhbENvb3JkID0gYXhpcy50b0xvY2FsQ29vcmQoNDApO1xuICAgICAgICAgKiBkZXNpZ25hdGUgYnkgbW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0dyaWQuXG4gICAgICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIHRvR2xvYmFsQ29vcmQ6IG51bGxcblxuICAgIH07XG4gICAgenJVdGlsLmluaGVyaXRzKEF4aXMyRCwgQXhpcyk7XG5cbiAgICByZXR1cm4gQXhpczJEO1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC9lY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzMkQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsImRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG4gICAgdmFyIG51bWJlclV0aWwgPSByZXF1aXJlKCcuLi91dGlsL251bWJlcicpO1xuICAgIHZhciBsaW5lYXJNYXAgPSBudW1iZXJVdGlsLmxpbmVhck1hcDtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9jb3JlL3V0aWwnKTtcblxuICAgIGZ1bmN0aW9uIGZpeEV4dGVudFdpdGhCYW5kcyhleHRlbnQsIG5UaWNrKSB7XG4gICAgICAgIHZhciBzaXplID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdO1xuICAgICAgICB2YXIgbGVuID0gblRpY2s7XG4gICAgICAgIHZhciBtYXJnaW4gPSBzaXplIC8gbGVuIC8gMjtcbiAgICAgICAgZXh0ZW50WzBdICs9IG1hcmdpbjtcbiAgICAgICAgZXh0ZW50WzFdIC09IG1hcmdpbjtcbiAgICB9XG5cbiAgICB2YXIgbm9ybWFsaXplZEV4dGVudCA9IFswLCAxXTtcbiAgICAvKipcbiAgICAgKiBAbmFtZSBtb2R1bGU6ZWNoYXJ0cy9jb29yZC9DYXJ0ZXNpYW5BeGlzXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIEF4aXMgPSBmdW5jdGlvbiAoZGltLCBzY2FsZSwgZXh0ZW50KSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF4aXMgZGltZW5zaW9uLiBTdWNoIGFzICd4JywgJ3knLCAneicsICdhbmdsZScsICdyYWRpdXMnXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpbSA9IGRpbTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXhpcyBzY2FsZVxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvY29vcmQvc2NhbGUvKn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZXh0ZW50ID0gZXh0ZW50IHx8IFswLCAwXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmludmVyc2UgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXN1YWxseSB0cnVlIHdoZW4gYXhpcyBoYXMgYSBvcmRpbmFsIHNjYWxlXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkJhbmQgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgQXhpcy5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IEF4aXMsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGF4aXMgZXh0ZW50IGNvbnRhaW4gZ2l2ZW4gY29vcmRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGNvb3JkXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluOiBmdW5jdGlvbiAoY29vcmQpIHtcbiAgICAgICAgICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgICAgICAgICB2YXIgbWluID0gTWF0aC5taW4oZXh0ZW50WzBdLCBleHRlbnRbMV0pO1xuICAgICAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4KGV4dGVudFswXSwgZXh0ZW50WzFdKTtcbiAgICAgICAgICAgIHJldHVybiBjb29yZCA+PSBtaW4gJiYgY29vcmQgPD0gbWF4O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBheGlzIGV4dGVudCBjb250YWluIGdpdmVuIGRhdGFcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGRhdGFcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW5EYXRhOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbih0aGlzLmRhdGFUb0Nvb3JkKGRhdGEpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGNvb3JkIGV4dGVudC5cbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICBnZXRFeHRlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXQgPSB0aGlzLl9leHRlbnQuc2xpY2UoKTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBwcmVjaXNpb24gdXNlZCBmb3IgZm9ybWF0dGluZ1xuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBbZGF0YUV4dGVudF1cbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0UGl4ZWxQcmVjaXNpb246IGZ1bmN0aW9uIChkYXRhRXh0ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyVXRpbC5nZXRQaXhlbFByZWNpc2lvbihcbiAgICAgICAgICAgICAgICBkYXRhRXh0ZW50IHx8IHRoaXMuc2NhbGUuZ2V0RXh0ZW50KCksXG4gICAgICAgICAgICAgICAgdGhpcy5fZXh0ZW50XG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgY29vcmQgZXh0ZW50XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kXG4gICAgICAgICAqL1xuICAgICAgICBzZXRFeHRlbnQ6IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICAgICAgZXh0ZW50WzBdID0gc3RhcnQ7XG4gICAgICAgICAgICBleHRlbnRbMV0gPSBlbmQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnQgZGF0YSB0byBjb29yZC4gRGF0YSBpcyB0aGUgcmFuayBpZiBpdCBoYXMgYSBvcmRpbmFsIHNjYWxlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhXG4gICAgICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IGNsYW1wXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGRhdGFUb0Nvb3JkOiBmdW5jdGlvbiAoZGF0YSwgY2xhbXApIHtcbiAgICAgICAgICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgICAgICAgICAgZGF0YSA9IHNjYWxlLm5vcm1hbGl6ZShkYXRhKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMub25CYW5kICYmIHNjYWxlLnR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICAgICAgICAgIGV4dGVudCA9IGV4dGVudC5zbGljZSgpO1xuICAgICAgICAgICAgICAgIGZpeEV4dGVudFdpdGhCYW5kcyhleHRlbnQsIHNjYWxlLmNvdW50KCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbGluZWFyTWFwKGRhdGEsIG5vcm1hbGl6ZWRFeHRlbnQsIGV4dGVudCwgY2xhbXApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0IGNvb3JkIHRvIGRhdGEuIERhdGEgaXMgdGhlIHJhbmsgaWYgaXQgaGFzIGEgb3JkaW5hbCBzY2FsZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gY29vcmRcbiAgICAgICAgICogQHBhcmFtICB7Ym9vbGVhbn0gY2xhbXBcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgY29vcmRUb0RhdGE6IGZ1bmN0aW9uIChjb29yZCwgY2xhbXApIHtcbiAgICAgICAgICAgIHZhciBleHRlbnQgPSB0aGlzLl9leHRlbnQ7XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vbkJhbmQgJiYgc2NhbGUudHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICAgICAgICAgICAgZXh0ZW50ID0gZXh0ZW50LnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgZml4RXh0ZW50V2l0aEJhbmRzKGV4dGVudCwgc2NhbGUuY291bnQoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0ID0gbGluZWFyTWFwKGNvb3JkLCBleHRlbnQsIG5vcm1hbGl6ZWRFeHRlbnQsIGNsYW1wKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGUuc2NhbGUodCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFRpY2tzQ29vcmRzOiBmdW5jdGlvbiAoYWxpZ25XaXRoTGFiZWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uQmFuZCAmJiAhYWxpZ25XaXRoTGFiZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmFuZHMgPSB0aGlzLmdldEJhbmRzKCk7XG4gICAgICAgICAgICAgICAgdmFyIGNvb3JkcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmFuZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzLnB1c2goYmFuZHNbaV1bMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmFuZHNbaSAtIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvb3Jkcy5wdXNoKGJhbmRzW2kgLSAxXVsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb29yZHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4genJVdGlsLm1hcCh0aGlzLnNjYWxlLmdldFRpY2tzKCksIHRoaXMuZGF0YVRvQ29vcmQsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb29yZHMgb2YgbGFiZWxzIGFyZSBvbiB0aGUgdGlja3Mgb3Igb24gdGhlIG1pZGRsZSBvZiBiYW5kc1xuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldExhYmVsc0Nvb3JkczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHpyVXRpbC5tYXAodGhpcy5zY2FsZS5nZXRUaWNrcygpLCB0aGlzLmRhdGFUb0Nvb3JkLCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGJhbmRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBheGlzIGhhcyBsYWJlbHMgWzEsIDIsIDMsIDRdLiBCYW5kcyBvbiB0aGUgYXhpcyBhcmVcbiAgICAgICAgICogfC0tLTEtLS18LS0tMi0tLXwtLS0zLS0tfC0tLTQtLS18LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgICAvLyBGSVhNRSBTaXR1YXRpb24gd2hlbiBsYWJlbHMgaXMgb24gdGlja3NcbiAgICAgICAgZ2V0QmFuZHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBleHRlbnQgPSB0aGlzLmdldEV4dGVudCgpO1xuICAgICAgICAgICAgdmFyIGJhbmRzID0gW107XG4gICAgICAgICAgICB2YXIgbGVuID0gdGhpcy5zY2FsZS5jb3VudCgpO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gZXh0ZW50WzBdO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGV4dGVudFsxXTtcbiAgICAgICAgICAgIHZhciBzcGFuID0gZW5kIC0gc3RhcnQ7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBiYW5kcy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgc3BhbiAqIGkgLyBsZW4gKyBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgc3BhbiAqIChpICsgMSkgLyBsZW4gKyBzdGFydFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJhbmRzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgd2lkdGggb2YgYmFuZFxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRCYW5kV2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBheGlzRXh0ZW50ID0gdGhpcy5fZXh0ZW50O1xuICAgICAgICAgICAgdmFyIGRhdGFFeHRlbnQgPSB0aGlzLnNjYWxlLmdldEV4dGVudCgpO1xuXG4gICAgICAgICAgICB2YXIgbGVuID0gZGF0YUV4dGVudFsxXSAtIGRhdGFFeHRlbnRbMF0gKyAodGhpcy5vbkJhbmQgPyAxIDogMCk7XG4gICAgICAgICAgICAvLyBGaXggIzI3MjgsIGF2b2lkIE5hTiB3aGVuIG9ubHkgb25lIGRhdGEuXG4gICAgICAgICAgICBsZW4gPT09IDAgJiYgKGxlbiA9IDEpO1xuXG4gICAgICAgICAgICB2YXIgc2l6ZSA9IE1hdGguYWJzKGF4aXNFeHRlbnRbMV0gLSBheGlzRXh0ZW50WzBdKTtcblxuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHNpemUpIC8gbGVuO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBBeGlzO1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC9lY2hhcnRzL2Nvb3JkL0F4aXMuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsIi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIGZvciBheGlzTGFiZWxJbnRlcnZhbCBjYWxjdWxhdGlvblxuICovXG5cbmRlZmluZShmdW5jdGlvbihyZXF1aXJlKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvY29yZS91dGlsJyk7XG4gICAgdmFyIGF4aXNIZWxwZXIgPSByZXF1aXJlKCcuLi9heGlzSGVscGVyJyk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgdmFyIGF4aXNNb2RlbCA9IGF4aXMubW9kZWw7XG4gICAgICAgIHZhciBsYWJlbE1vZGVsID0gYXhpc01vZGVsLmdldE1vZGVsKCdheGlzTGFiZWwnKTtcbiAgICAgICAgdmFyIGxhYmVsSW50ZXJ2YWwgPSBsYWJlbE1vZGVsLmdldCgnaW50ZXJ2YWwnKTtcbiAgICAgICAgaWYgKCEoYXhpcy50eXBlID09PSAnY2F0ZWdvcnknICYmIGxhYmVsSW50ZXJ2YWwgPT09ICdhdXRvJykpIHtcbiAgICAgICAgICAgIHJldHVybiBsYWJlbEludGVydmFsID09PSAnYXV0bycgPyAwIDogbGFiZWxJbnRlcnZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBheGlzSGVscGVyLmdldEF4aXNMYWJlbEludGVydmFsKFxuICAgICAgICAgICAgenJVdGlsLm1hcChheGlzLnNjYWxlLmdldFRpY2tzKCksIGF4aXMuZGF0YVRvQ29vcmQsIGF4aXMpLFxuICAgICAgICAgICAgYXhpc01vZGVsLmdldEZvcm1hdHRlZExhYmVscygpLFxuICAgICAgICAgICAgbGFiZWxNb2RlbC5nZXRNb2RlbCgndGV4dFN0eWxlJykuZ2V0Rm9udCgpLFxuICAgICAgICAgICAgYXhpcy5pc0hvcml6b250YWwoKVxuICAgICAgICApO1xuICAgIH07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL2VjaGFydHMvY29vcmQvY2FydGVzaWFuL2F4aXNMYWJlbEludGVydmFsLmpzXG4gKiogbW9kdWxlIGlkID0gMTE1XG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCIvLyBHcmlkIOaYr+WcqOacieebtOinkuWdkOagh+ezu+eahOaXtuWAmeW/hemhu+imgeWtmOWcqOeahFxuLy8g5omA5Lul6L+Z6YeM5Lmf6KaB6KKrIENhcnRlc2lhbjJEIOS+nei1llxuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHJlcXVpcmUoJy4vQXhpc01vZGVsJyk7XG4gICAgdmFyIENvbXBvbmVudE1vZGVsID0gcmVxdWlyZSgnLi4vLi4vbW9kZWwvQ29tcG9uZW50Jyk7XG5cbiAgICByZXR1cm4gQ29tcG9uZW50TW9kZWwuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnZ3JpZCcsXG5cbiAgICAgICAgZGVwZW5kZW5jaWVzOiBbJ3hBeGlzJywgJ3lBeGlzJ10sXG5cbiAgICAgICAgbGF5b3V0TW9kZTogJ2JveCcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vR3JpZH1cbiAgICAgICAgICovXG4gICAgICAgIGNvb3JkaW5hdGVTeXN0ZW06IG51bGwsXG5cbiAgICAgICAgZGVmYXVsdE9wdGlvbjoge1xuICAgICAgICAgICAgc2hvdzogZmFsc2UsXG4gICAgICAgICAgICB6bGV2ZWw6IDAsXG4gICAgICAgICAgICB6OiAwLFxuICAgICAgICAgICAgbGVmdDogJzEwJScsXG4gICAgICAgICAgICB0b3A6IDYwLFxuICAgICAgICAgICAgcmlnaHQ6ICcxMCUnLFxuICAgICAgICAgICAgYm90dG9tOiA2MCxcbiAgICAgICAgICAgIC8vIElmIGdyaWQgc2l6ZSBjb250YWluIGxhYmVsXG4gICAgICAgICAgICBjb250YWluTGFiZWw6IGZhbHNlLFxuICAgICAgICAgICAgLy8gd2lkdGg6IHt0b3RhbFdpZHRofSAtIGxlZnQgLSByaWdodCxcbiAgICAgICAgICAgIC8vIGhlaWdodDoge3RvdGFsSGVpZ2h0fSAtIHRvcCAtIGJvdHRvbSxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDEsXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogJyNjY2MnXG4gICAgICAgIH1cbiAgICB9KTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vR3JpZE1vZGVsLmpzXG4gKiogbW9kdWxlIGlkID0gMTE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCJkZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIENvbXBvbmVudE1vZGVsID0gcmVxdWlyZSgnLi4vLi4vbW9kZWwvQ29tcG9uZW50Jyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvY29yZS91dGlsJyk7XG4gICAgdmFyIGF4aXNNb2RlbENyZWF0b3IgPSByZXF1aXJlKCcuLi9heGlzTW9kZWxDcmVhdG9yJyk7XG5cbiAgICB2YXIgQXhpc01vZGVsID0gQ29tcG9uZW50TW9kZWwuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnY2FydGVzaWFuMmRBeGlzJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzMkR9XG4gICAgICAgICAqL1xuICAgICAgICBheGlzOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAgICovXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIEF4aXNNb2RlbC5zdXBlckFwcGx5KHRoaXMsICdpbml0JywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0UmFuZ2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICBtZXJnZU9wdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgQXhpc01vZGVsLnN1cGVyQXBwbHkodGhpcywgJ21lcmdlT3B0aW9uJywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0UmFuZ2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAqL1xuICAgICAgICByZXN0b3JlRGF0YTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgQXhpc01vZGVsLnN1cGVyQXBwbHkodGhpcywgJ3Jlc3RvcmVEYXRhJywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0UmFuZ2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFuZ2VTdGFydFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFuZ2VFbmRcbiAgICAgICAgICovXG4gICAgICAgIHNldFJhbmdlOiBmdW5jdGlvbiAocmFuZ2VTdGFydCwgcmFuZ2VFbmQpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uLnJhbmdlU3RhcnQgPSByYW5nZVN0YXJ0O1xuICAgICAgICAgICAgdGhpcy5vcHRpb24ucmFuZ2VFbmQgPSByYW5nZUVuZDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyfHN0cmluZ3xEYXRlPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldE1pbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbiA9IHRoaXMub3B0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbi5yYW5nZVN0YXJ0ICE9IG51bGwgPyBvcHRpb24ucmFuZ2VTdGFydCA6IG9wdGlvbi5taW47XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcnxzdHJpbmd8RGF0ZT59XG4gICAgICAgICAqL1xuICAgICAgICBnZXRNYXg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb24ucmFuZ2VFbmQgIT0gbnVsbCA/IG9wdGlvbi5yYW5nZUVuZCA6IG9wdGlvbi5tYXg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGdldE5lZWRDcm9zc1plcm86IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICAgICAgICAgIHJldHVybiAob3B0aW9uLnJhbmdlU3RhcnQgIT0gbnVsbCB8fCBvcHRpb24ucmFuZ2VFbmQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICA/IGZhbHNlIDogIW9wdGlvbi5zY2FsZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9XG4gICAgICAgICAqL1xuICAgICAgICBmaW5kR3JpZE1vZGVsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lY01vZGVsLnF1ZXJ5Q29tcG9uZW50cyh7XG4gICAgICAgICAgICAgICAgbWFpblR5cGU6ICdncmlkJyxcbiAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5nZXQoJ2dyaWRJbmRleCcpLFxuICAgICAgICAgICAgICAgIGlkOiB0aGlzLmdldCgnZ3JpZElkJylcbiAgICAgICAgICAgIH0pWzBdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3Jlc2V0UmFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHJhbmdlU3RhcnQgYW5kIHJhbmdlRW5kIGlzIHJlYWRvbmx5LlxuICAgICAgICAgICAgdGhpcy5vcHRpb24ucmFuZ2VTdGFydCA9IHRoaXMub3B0aW9uLnJhbmdlRW5kID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBnZXRBeGlzVHlwZShheGlzRGltLCBvcHRpb24pIHtcbiAgICAgICAgLy8gRGVmYXVsdCBheGlzIHdpdGggZGF0YSBpcyBjYXRlZ29yeSBheGlzXG4gICAgICAgIHJldHVybiBvcHRpb24udHlwZSB8fCAob3B0aW9uLmRhdGEgPyAnY2F0ZWdvcnknIDogJ3ZhbHVlJyk7XG4gICAgfVxuXG4gICAgenJVdGlsLm1lcmdlKEF4aXNNb2RlbC5wcm90b3R5cGUsIHJlcXVpcmUoJy4uL2F4aXNNb2RlbENvbW1vbk1peGluJykpO1xuXG4gICAgdmFyIGV4dHJhT3B0aW9uID0ge1xuICAgICAgICAvLyBncmlkSW5kZXg6IDAsXG4gICAgICAgIC8vIGdyaWRJZDogJycsXG5cbiAgICAgICAgLy8gT2Zmc2V0IGlzIGZvciBtdWx0aXBsZSBheGlzIG9uIHRoZSBzYW1lIHBvc2l0aW9uXG4gICAgICAgIG9mZnNldDogMFxuICAgIH07XG5cbiAgICBheGlzTW9kZWxDcmVhdG9yKCd4JywgQXhpc01vZGVsLCBnZXRBeGlzVHlwZSwgZXh0cmFPcHRpb24pO1xuICAgIGF4aXNNb2RlbENyZWF0b3IoJ3knLCBBeGlzTW9kZWwsIGdldEF4aXNUeXBlLCBleHRyYU9wdGlvbik7XG5cbiAgICByZXR1cm4gQXhpc01vZGVsO1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC9lY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzTW9kZWwuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsImRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG4gICAgdmFyIGF4aXNEZWZhdWx0ID0gcmVxdWlyZSgnLi9heGlzRGVmYXVsdCcpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2NvcmUvdXRpbCcpO1xuICAgIHZhciBDb21wb25lbnRNb2RlbCA9IHJlcXVpcmUoJy4uL21vZGVsL0NvbXBvbmVudCcpO1xuICAgIHZhciBsYXlvdXQgPSByZXF1aXJlKCcuLi91dGlsL2xheW91dCcpO1xuXG4gICAgLy8gRklYTUUgYXhpc1R5cGUgaXMgZml4ZWQgP1xuICAgIHZhciBBWElTX1RZUEVTID0gWyd2YWx1ZScsICdjYXRlZ29yeScsICd0aW1lJywgJ2xvZyddO1xuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgc3ViIGF4aXMgbW9kZWwgY2xhc3NcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXhpc05hbWUgJ3gnICd5JyAncmFkaXVzJyAnYW5nbGUnICdwYXJhbGxlbCdcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL0NvbXBvbmVudH0gQmFzZUF4aXNNb2RlbENsYXNzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXhpc1R5cGVEZWZhdWx0ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2V4dHJhRGVmYXVsdE9wdGlvbl1cbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24gKGF4aXNOYW1lLCBCYXNlQXhpc01vZGVsQ2xhc3MsIGF4aXNUeXBlRGVmYXVsdGVyLCBleHRyYURlZmF1bHRPcHRpb24pIHtcblxuICAgICAgICB6clV0aWwuZWFjaChBWElTX1RZUEVTLCBmdW5jdGlvbiAoYXhpc1R5cGUpIHtcblxuICAgICAgICAgICAgQmFzZUF4aXNNb2RlbENsYXNzLmV4dGVuZCh7XG5cbiAgICAgICAgICAgICAgICB0eXBlOiBheGlzTmFtZSArICdBeGlzLicgKyBheGlzVHlwZSxcblxuICAgICAgICAgICAgICAgIG1lcmdlRGVmYXVsdEFuZFRoZW1lOiBmdW5jdGlvbiAob3B0aW9uLCBlY01vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXlvdXRNb2RlID0gdGhpcy5sYXlvdXRNb2RlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXRQb3NpdGlvblBhcmFtcyA9IGxheW91dE1vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbGF5b3V0LmdldExheW91dFBhcmFtcyhvcHRpb24pIDoge307XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoZW1lTW9kZWwgPSBlY01vZGVsLmdldFRoZW1lKCk7XG4gICAgICAgICAgICAgICAgICAgIHpyVXRpbC5tZXJnZShvcHRpb24sIHRoZW1lTW9kZWwuZ2V0KGF4aXNUeXBlICsgJ0F4aXMnKSk7XG4gICAgICAgICAgICAgICAgICAgIHpyVXRpbC5tZXJnZShvcHRpb24sIHRoaXMuZ2V0RGVmYXVsdE9wdGlvbigpKTtcblxuICAgICAgICAgICAgICAgICAgICBvcHRpb24udHlwZSA9IGF4aXNUeXBlRGVmYXVsdGVyKGF4aXNOYW1lLCBvcHRpb24pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXlvdXRNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXQubWVyZ2VMYXlvdXRQYXJhbShvcHRpb24sIGlucHV0UG9zaXRpb25QYXJhbXMsIGxheW91dE1vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb246IHpyVXRpbC5tZXJnZUFsbChcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzRGVmYXVsdFtheGlzVHlwZSArICdBeGlzJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYURlZmF1bHRPcHRpb25cbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBDb21wb25lbnRNb2RlbC5yZWdpc3RlclN1YlR5cGVEZWZhdWx0ZXIoXG4gICAgICAgICAgICBheGlzTmFtZSArICdBeGlzJyxcbiAgICAgICAgICAgIHpyVXRpbC5jdXJyeShheGlzVHlwZURlZmF1bHRlciwgYXhpc05hbWUpXG4gICAgICAgICk7XG4gICAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvZWNoYXJ0cy9jb29yZC9heGlzTW9kZWxDcmVhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMTE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCJkZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2NvcmUvdXRpbCcpO1xuXG4gICAgdmFyIGRlZmF1bHRPcHRpb24gPSB7XG4gICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgIHpsZXZlbDogMCwgICAgICAgICAgICAgICAgICAvLyDkuIDnuqflsYLlj6BcbiAgICAgICAgejogMCwgICAgICAgICAgICAgICAgICAgICAgIC8vIOS6jOe6p+WxguWPoFxuICAgICAgICAvLyDlj43lkJHlnZDmoIfovbRcbiAgICAgICAgaW52ZXJzZTogZmFsc2UsXG5cbiAgICAgICAgLy8g5Z2Q5qCH6L205ZCN5a2X77yM6buY6K6k5Li656m6XG4gICAgICAgIG5hbWU6ICcnLFxuICAgICAgICAvLyDlnZDmoIfovbTlkI3lrZfkvY3nva7vvIzmlK/mjIEnc3RhcnQnIHwgJ21pZGRsZScgfCAnZW5kJ1xuICAgICAgICBuYW1lTG9jYXRpb246ICdlbmQnLFxuICAgICAgICAvLyDlnZDmoIfovbTlkI3lrZfml4vovazvvIxkZWdyZWXjgIJcbiAgICAgICAgbmFtZVJvdGF0ZTogbnVsbCwgLy8gQWRhcHQgdG8gYXhpcyByb3RhdGUsIHdoZW4gbmFtZUxvY2F0aW9uIGlzICdtaWRkbGUnLlxuICAgICAgICBuYW1lVHJ1bmNhdGU6IHtcbiAgICAgICAgICAgIG1heFdpZHRoOiBudWxsLFxuICAgICAgICAgICAgZWxsaXBzaXM6ICcuLi4nLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICcuJ1xuICAgICAgICB9LFxuICAgICAgICAvLyDlnZDmoIfovbTmloflrZfmoLflvI/vvIzpu5jorqTlj5blhajlsYDmoLflvI9cbiAgICAgICAgbmFtZVRleHRTdHlsZToge30sXG4gICAgICAgIC8vIOaWh+Wtl+S4jui9tOe6v+i3neemu1xuICAgICAgICBuYW1lR2FwOiAxNSxcblxuICAgICAgICBzaWxlbnQ6IGZhbHNlLCAvLyBEZWZhdWx0IGZhbHNlIHRvIHN1cHBvcnQgdG9vbHRpcC5cbiAgICAgICAgdHJpZ2dlckV2ZW50OiBmYWxzZSwgLy8gRGVmYXVsdCBmYWxzZSB0byBhdm9pZCBsZWdhY3kgdXNlciBldmVudCBsaXN0ZW5lciBmYWlsLlxuXG4gICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICAgIHNob3c6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g5Z2Q5qCH6L2057q/XG4gICAgICAgIGF4aXNMaW5lOiB7XG4gICAgICAgICAgICAvLyDpu5jorqTmmL7npLrvvIzlsZ7mgKdzaG935o6n5Yi25pi+56S65LiO5ZCmXG4gICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgb25aZXJvOiB0cnVlLFxuICAgICAgICAgICAgLy8g5bGe5oCnbGluZVN0eWxl5o6n5Yi257q/5p2h5qC35byPXG4gICAgICAgICAgICBsaW5lU3R5bGU6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJyMzMzMnLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdzb2xpZCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8g5Z2Q5qCH6L205bCP5qCH6K6wXG4gICAgICAgIGF4aXNUaWNrOiB7XG4gICAgICAgICAgICAvLyDlsZ7mgKdzaG935o6n5Yi25pi+56S65LiO5ZCm77yM6buY6K6k5pi+56S6XG4gICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgLy8g5o6n5Yi25bCP5qCH6K6w5piv5ZCm5ZyoZ3JpZOmHjFxuICAgICAgICAgICAgaW5zaWRlOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIOWxnuaAp2xlbmd0aOaOp+WItue6v+mVv1xuICAgICAgICAgICAgbGVuZ3RoOiA1LFxuICAgICAgICAgICAgLy8g5bGe5oCnbGluZVN0eWxl5o6n5Yi257q/5p2h5qC35byPXG4gICAgICAgICAgICBsaW5lU3R5bGU6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyDlnZDmoIfovbTmlofmnKzmoIfnrb7vvIzor6bop4FheGlzLmF4aXNMYWJlbFxuICAgICAgICBheGlzTGFiZWw6IHtcbiAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAvLyDmjqfliLbmlofmnKzmoIfnrb7mmK/lkKblnKhncmlk6YeMXG4gICAgICAgICAgICBpbnNpZGU6IGZhbHNlLFxuICAgICAgICAgICAgcm90YXRlOiAwLFxuICAgICAgICAgICAgbWFyZ2luOiA4LFxuICAgICAgICAgICAgLy8gZm9ybWF0dGVyOiBudWxsLFxuICAgICAgICAgICAgLy8g5YW25L2Z5bGe5oCn6buY6K6k5L2/55So5YWo5bGA5paH5pys5qC35byP77yM6K+m6KeBVEVYVFNUWUxFXG4gICAgICAgICAgICB0ZXh0U3R5bGU6IHtcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogMTJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8g5YiG6ZqU57q/XG4gICAgICAgIHNwbGl0TGluZToge1xuICAgICAgICAgICAgLy8g6buY6K6k5pi+56S677yM5bGe5oCnc2hvd+aOp+WItuaYvuekuuS4juWQplxuICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgIC8vIOWxnuaAp2xpbmVTdHlsZe+8iOivpuingWxpbmVTdHlsZe+8ieaOp+WItue6v+adoeagt+W8j1xuICAgICAgICAgICAgbGluZVN0eWxlOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6IFsnI2NjYyddLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdzb2xpZCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8g5YiG6ZqU5Yy65Z+fXG4gICAgICAgIHNwbGl0QXJlYToge1xuICAgICAgICAgICAgLy8g6buY6K6k5LiN5pi+56S677yM5bGe5oCnc2hvd+aOp+WItuaYvuekuuS4juWQplxuICAgICAgICAgICAgc2hvdzogZmFsc2UsXG4gICAgICAgICAgICAvLyDlsZ7mgKdhcmVhU3R5bGXvvIjor6bop4FhcmVhU3R5bGXvvInmjqfliLbljLrln5/moLflvI9cbiAgICAgICAgICAgIGFyZWFTdHlsZToge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBbJ3JnYmEoMjUwLDI1MCwyNTAsMC4zKScsJ3JnYmEoMjAwLDIwMCwyMDAsMC4zKSddXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGNhdGVnb3J5QXhpcyA9IHpyVXRpbC5tZXJnZSh7XG4gICAgICAgIC8vIOexu+ebrui1t+Wni+WSjOe7k+adn+S4pOerr+epuueZveetlueVpVxuICAgICAgICBib3VuZGFyeUdhcDogdHJ1ZSxcbiAgICAgICAgLy8gc3BsaXRBcmVhOiB7XG4gICAgICAgICAgICAvLyBzaG93OiBmYWxzZVxuICAgICAgICAvLyB9LFxuICAgICAgICBzcGxpdExpbmU6IHtcbiAgICAgICAgICAgIHNob3c6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIC8vIOWdkOagh+i9tOWwj+agh+iusFxuICAgICAgICBheGlzVGljazoge1xuICAgICAgICAgICAgLy8gSWYgdGljayBpcyBhbGlnbiB3aXRoIGxhYmVsIHdoZW4gYm91bmRhcnlHYXAgaXMgdHJ1ZVxuICAgICAgICAgICAgLy8gRGVmYXVsdCB3aXRoIGF4aXNUaWNrXG4gICAgICAgICAgICBhbGlnbldpdGhMYWJlbDogZmFsc2UsXG4gICAgICAgICAgICBpbnRlcnZhbDogJ2F1dG8nXG4gICAgICAgIH0sXG4gICAgICAgIC8vIOWdkOagh+i9tOaWh+acrOagh+etvu+8jOivpuingWF4aXMuYXhpc0xhYmVsXG4gICAgICAgIGF4aXNMYWJlbDoge1xuICAgICAgICAgICAgaW50ZXJ2YWw6ICdhdXRvJ1xuICAgICAgICB9XG4gICAgfSwgZGVmYXVsdE9wdGlvbik7XG5cbiAgICB2YXIgdmFsdWVBeGlzID0genJVdGlsLm1lcmdlKHtcbiAgICAgICAgLy8g5pWw5YC86LW35aeL5ZKM57uT5p2f5Lik56uv56m655m9562W55WlXG4gICAgICAgIGJvdW5kYXJ5R2FwOiBbMCwgMF0sXG4gICAgICAgIC8vIOacgOWwj+WAvCwg6K6+572u5oiQICdkYXRhTWluJyDliJnku47mlbDmja7kuK3orqHnrpfmnIDlsI/lgLxcbiAgICAgICAgLy8gbWluOiBudWxsLFxuICAgICAgICAvLyDmnIDlpKflgLzvvIzorr7nva7miJAgJ2RhdGFNYXgnIOWImeS7juaVsOaNruS4reiuoeeul+acgOWkp+WAvFxuICAgICAgICAvLyBtYXg6IG51bGwsXG4gICAgICAgIC8vIFJlYWRvbmx5IHByb3AsIHNwZWNpZmllcyBzdGFydCB2YWx1ZSBvZiB0aGUgcmFuZ2Ugd2hlbiB1c2luZyBkYXRhIHpvb20uXG4gICAgICAgIC8vIHJhbmdlU3RhcnQ6IG51bGxcbiAgICAgICAgLy8gUmVhZG9ubHkgcHJvcCwgc3BlY2lmaWVzIGVuZCB2YWx1ZSBvZiB0aGUgcmFuZ2Ugd2hlbiB1c2luZyBkYXRhIHpvb20uXG4gICAgICAgIC8vIHJhbmdlRW5kOiBudWxsXG4gICAgICAgIC8vIOiEseemuzDlgLzmr5TkvovvvIzmlL7lpKfogZrnhKbliLDmnIDnu4hfbWlu77yMX21heOWMuumXtFxuICAgICAgICAvLyBzY2FsZTogZmFsc2UsXG4gICAgICAgIC8vIOWIhuWJsuauteaVsO+8jOm7mOiupOS4ujVcbiAgICAgICAgc3BsaXROdW1iZXI6IDVcbiAgICAgICAgLy8gTWluaW11bSBpbnRlcnZhbFxuICAgICAgICAvLyBtaW5JbnRlcnZhbDogbnVsbFxuICAgIH0sIGRlZmF1bHRPcHRpb24pO1xuXG4gICAgLy8gRklYTUVcbiAgICB2YXIgdGltZUF4aXMgPSB6clV0aWwuZGVmYXVsdHMoe1xuICAgICAgICBzY2FsZTogdHJ1ZSxcbiAgICAgICAgbWluOiAnZGF0YU1pbicsXG4gICAgICAgIG1heDogJ2RhdGFNYXgnXG4gICAgfSwgdmFsdWVBeGlzKTtcbiAgICB2YXIgbG9nQXhpcyA9IHpyVXRpbC5kZWZhdWx0cyh7XG4gICAgICAgIGxvZ0Jhc2U6IDEwXG4gICAgfSwgdmFsdWVBeGlzKTtcbiAgICBsb2dBeGlzLnNjYWxlID0gdHJ1ZTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGNhdGVnb3J5QXhpczogY2F0ZWdvcnlBeGlzLFxuICAgICAgICB2YWx1ZUF4aXM6IHZhbHVlQXhpcyxcbiAgICAgICAgdGltZUF4aXM6IHRpbWVBeGlzLFxuICAgICAgICBsb2dBeGlzOiBsb2dBeGlzXG4gICAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvZWNoYXJ0cy9jb29yZC9heGlzRGVmYXVsdC5qc1xuICoqIG1vZHVsZSBpZCA9IDExOVxuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9jb3JlL3V0aWwnKTtcbiAgICB2YXIgYXhpc0hlbHBlciA9IHJlcXVpcmUoJy4vYXhpc0hlbHBlcicpO1xuXG4gICAgZnVuY3Rpb24gZ2V0TmFtZShvYmopIHtcbiAgICAgICAgaWYgKHpyVXRpbC5pc09iamVjdChvYmopICYmIG9iai52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgY2F0ZWdvcmllc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldENhdGVnb3JpZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldCgndHlwZScpID09PSAnY2F0ZWdvcnknXG4gICAgICAgICAgICAmJiB6clV0aWwubWFwKHRoaXMuZ2V0KCdkYXRhJyksIGdldE5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcm1hdCBsYWJlbHNcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRGb3JtYXR0ZWRMYWJlbHMoKSB7XG4gICAgICAgIHJldHVybiBheGlzSGVscGVyLmdldEZvcm1hdHRlZExhYmVscyhcbiAgICAgICAgICAgIHRoaXMuYXhpcyxcbiAgICAgICAgICAgIHRoaXMuZ2V0KCdheGlzTGFiZWwuZm9ybWF0dGVyJylcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuXG4gICAgICAgIGdldEZvcm1hdHRlZExhYmVsczogZ2V0Rm9ybWF0dGVkTGFiZWxzLFxuXG4gICAgICAgIGdldENhdGVnb3JpZXM6IGdldENhdGVnb3JpZXNcbiAgICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC9lY2hhcnRzL2Nvb3JkL2F4aXNNb2RlbENvbW1vbk1peGluLmpzXG4gKiogbW9kdWxlIGlkID0gMTIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCJkZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSkge1xuXG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIFNlcmllc01vZGVsID0gcmVxdWlyZSgnLi4vLi4vbW9kZWwvU2VyaWVzJyk7XG4gICAgdmFyIGNyZWF0ZUxpc3RGcm9tQXJyYXkgPSByZXF1aXJlKCcuLi9oZWxwZXIvY3JlYXRlTGlzdEZyb21BcnJheScpO1xuXG4gICAgcmV0dXJuIFNlcmllc01vZGVsLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ3Nlcmllcy5iYXInLFxuXG4gICAgICAgIGRlcGVuZGVuY2llczogWydncmlkJywgJ3BvbGFyJ10sXG5cbiAgICAgICAgZ2V0SW5pdGlhbERhdGE6IGZ1bmN0aW9uIChvcHRpb24sIGVjTW9kZWwpIHtcbiAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvb3JkU3lzID0gb3B0aW9uLmNvb3JkaW5hdGVTeXN0ZW07XG4gICAgICAgICAgICAgICAgaWYgKGNvb3JkU3lzICE9PSAnY2FydGVzaWFuMmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQmFyIG9ubHkgc3VwcG9ydCBjYXJ0ZXNpYW4yZCBjb29yZGluYXRlU3lzdGVtJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxpc3RGcm9tQXJyYXkob3B0aW9uLmRhdGEsIHRoaXMsIGVjTW9kZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldE1hcmtlclBvc2l0aW9uOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBjb29yZFN5cyA9IHRoaXMuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgICAgIGlmIChjb29yZFN5cykge1xuICAgICAgICAgICAgICAgIC8vIFBFTkRJTkcgaWYgY2xhbXAgP1xuICAgICAgICAgICAgICAgIHZhciBwdCA9IGNvb3JkU3lzLmRhdGFUb1BvaW50KHZhbHVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBkYXRhLmdldExheW91dCgnb2Zmc2V0Jyk7XG4gICAgICAgICAgICAgICAgdmFyIHNpemUgPSBkYXRhLmdldExheW91dCgnc2l6ZScpO1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRJbmRleCA9IGNvb3JkU3lzLmdldEJhc2VBeGlzKCkuaXNIb3Jpem9udGFsKCkgPyAwIDogMTtcbiAgICAgICAgICAgICAgICBwdFtvZmZzZXRJbmRleF0gKz0gb2Zmc2V0ICsgc2l6ZSAvIDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHB0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtOYU4sIE5hTl07XG4gICAgICAgIH0sXG5cbiAgICAgICAgYnJ1c2hTZWxlY3RvcjogJ3JlY3QnLFxuXG4gICAgICAgIGRlZmF1bHRPcHRpb246IHtcbiAgICAgICAgICAgIHpsZXZlbDogMCwgICAgICAgICAgICAgICAgICAvLyDkuIDnuqflsYLlj6BcbiAgICAgICAgICAgIHo6IDIsICAgICAgICAgICAgICAgICAgICAgICAvLyDkuoznuqflsYLlj6BcbiAgICAgICAgICAgIGNvb3JkaW5hdGVTeXN0ZW06ICdjYXJ0ZXNpYW4yZCcsXG4gICAgICAgICAgICBsZWdlbmRIb3Zlckxpbms6IHRydWUsXG4gICAgICAgICAgICAvLyBzdGFjazogbnVsbFxuXG4gICAgICAgICAgICAvLyBDYXJ0ZXNpYW4gY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICAgICAgICAgIC8vIHhBeGlzSW5kZXg6IDAsXG4gICAgICAgICAgICAvLyB5QXhpc0luZGV4OiAwLFxuXG4gICAgICAgICAgICAvLyDmnIDlsI/pq5jluqbmlLnkuLowXG4gICAgICAgICAgICBiYXJNaW5IZWlnaHQ6IDAsXG5cbiAgICAgICAgICAgIC8vIGJhck1heFdpZHRoOiBudWxsLFxuICAgICAgICAgICAgLy8g6buY6K6k6Ieq6YCC5bqUXG4gICAgICAgICAgICAvLyBiYXJXaWR0aDogbnVsbCxcbiAgICAgICAgICAgIC8vIOafsemXtOi3neemu++8jOm7mOiupOS4uuafseW9ouWuveW6pueahDMwJe+8jOWPr+iuvuWbuuWumuWAvFxuICAgICAgICAgICAgLy8gYmFyR2FwOiAnMzAlJyxcbiAgICAgICAgICAgIC8vIOexu+ebrumXtOafseW9oui3neemu++8jOm7mOiupOS4uuexu+ebrumXtOi3neeahDIwJe+8jOWPr+iuvuWbuuWumuWAvFxuICAgICAgICAgICAgLy8gYmFyQ2F0ZWdvcnlHYXA6ICcyMCUnLFxuICAgICAgICAgICAgLy8gbGFiZWw6IHtcbiAgICAgICAgICAgIC8vICAgICBub3JtYWw6IHtcbiAgICAgICAgICAgIC8vICAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAvLyB9LFxuICAgICAgICAgICAgaXRlbVN0eWxlOiB7XG4gICAgICAgICAgICAgICAgbm9ybWFsOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbG9yOiAn5ZCE5byCJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW1waGFzaXM6IHt9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvZWNoYXJ0cy9jaGFydC9iYXIvQmFyU2VyaWVzLmpzXG4gKiogbW9kdWxlIGlkID0gMTIxXG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCJkZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBMaXN0ID0gcmVxdWlyZSgnLi4vLi4vZGF0YS9MaXN0Jyk7XG4gICAgdmFyIGNvbXBsZXRlRGltZW5zaW9ucyA9IHJlcXVpcmUoJy4uLy4uL2RhdGEvaGVscGVyL2NvbXBsZXRlRGltZW5zaW9ucycpO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2NvcmUvdXRpbCcpO1xuICAgIHZhciBtb2RlbFV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL21vZGVsJyk7XG4gICAgdmFyIENvb3JkaW5hdGVTeXN0ZW0gPSByZXF1aXJlKCcuLi8uLi9Db29yZGluYXRlU3lzdGVtJyk7XG4gICAgdmFyIGdldERhdGFJdGVtVmFsdWUgPSBtb2RlbFV0aWwuZ2V0RGF0YUl0ZW1WYWx1ZTtcbiAgICB2YXIgY29udmVyRGF0YVZhbHVlID0gbW9kZWxVdGlsLmNvbnZlckRhdGFWYWx1ZTtcblxuICAgIGZ1bmN0aW9uIGZpcnN0RGF0YU5vdE51bGwoZGF0YSkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgZGF0YS5sZW5ndGggJiYgZGF0YVtpXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGFbaV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlmTmVlZENvbXBsZXRlT3JkaW5hbERhdGEoZGF0YSkge1xuICAgICAgICB2YXIgc2FtcGxlSXRlbSA9IGZpcnN0RGF0YU5vdE51bGwoZGF0YSk7XG4gICAgICAgIHJldHVybiBzYW1wbGVJdGVtICE9IG51bGxcbiAgICAgICAgICAgICYmICF6clV0aWwuaXNBcnJheShnZXREYXRhSXRlbVZhbHVlKHNhbXBsZUl0ZW0pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGEgbGlzdCBmcm9tIG9wdGlvbiBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlTGlzdEZyb21BcnJheShkYXRhLCBzZXJpZXNNb2RlbCwgZWNNb2RlbCkge1xuICAgICAgICAvLyBJZiBkYXRhIGlzIHVuZGVmaW5lZFxuICAgICAgICBkYXRhID0gZGF0YSB8fCBbXTtcblxuICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgaWYgKCF6clV0aWwuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRhLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvb3JkU3lzTmFtZSA9IHNlcmllc01vZGVsLmdldCgnY29vcmRpbmF0ZVN5c3RlbScpO1xuICAgICAgICB2YXIgY3JlYXRvciA9IGNyZWF0b3JzW2Nvb3JkU3lzTmFtZV07XG4gICAgICAgIHZhciByZWdpc3RlcmVkQ29vcmRTeXMgPSBDb29yZGluYXRlU3lzdGVtLmdldChjb29yZFN5c05hbWUpO1xuICAgICAgICAvLyBGSVhNRVxuICAgICAgICB2YXIgYXhlc0luZm8gPSBjcmVhdG9yICYmIGNyZWF0b3IoZGF0YSwgc2VyaWVzTW9kZWwsIGVjTW9kZWwpO1xuICAgICAgICB2YXIgZGltZW5zaW9ucyA9IGF4ZXNJbmZvICYmIGF4ZXNJbmZvLmRpbWVuc2lvbnM7XG4gICAgICAgIGlmICghZGltZW5zaW9ucykge1xuICAgICAgICAgICAgLy8gR2V0IGRpbWVuc2lvbnMgZnJvbSByZWdpc3RlcmVkIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgICAgICAgICBkaW1lbnNpb25zID0gKHJlZ2lzdGVyZWRDb29yZFN5cyAmJiByZWdpc3RlcmVkQ29vcmRTeXMuZGltZW5zaW9ucykgfHwgWyd4JywgJ3knXTtcbiAgICAgICAgICAgIGRpbWVuc2lvbnMgPSBjb21wbGV0ZURpbWVuc2lvbnMoZGltZW5zaW9ucywgZGF0YSwgZGltZW5zaW9ucy5jb25jYXQoWyd2YWx1ZSddKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhdGVnb3J5SW5kZXggPSBheGVzSW5mbyA/IGF4ZXNJbmZvLmNhdGVnb3J5SW5kZXggOiAtMTtcblxuICAgICAgICB2YXIgbGlzdCA9IG5ldyBMaXN0KGRpbWVuc2lvbnMsIHNlcmllc01vZGVsKTtcblxuICAgICAgICB2YXIgbmFtZUxpc3QgPSBjcmVhdGVOYW1lTGlzdChheGVzSW5mbywgZGF0YSk7XG5cbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSB7fTtcbiAgICAgICAgdmFyIGRpbVZhbHVlR2V0dGVyID0gKGNhdGVnb3J5SW5kZXggPj0gMCAmJiBpZk5lZWRDb21wbGV0ZU9yZGluYWxEYXRhKGRhdGEpKVxuICAgICAgICAgICAgPyBmdW5jdGlvbiAoaXRlbU9wdCwgZGltTmFtZSwgZGF0YUluZGV4LCBkaW1JbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIElmIGFueSBkYXRhSXRlbSBpcyBsaWtlIHsgdmFsdWU6IDEwIH1cbiAgICAgICAgICAgICAgICBpZiAobW9kZWxVdGlsLmlzRGF0YUl0ZW1PcHRpb24oaXRlbU9wdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5oYXNJdGVtT3B0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBVc2UgZGF0YUluZGV4IGFzIG9yZGluYWwgdmFsdWUgaW4gY2F0ZWdvcnlBeGlzXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpbUluZGV4ID09PSBjYXRlZ29yeUluZGV4XG4gICAgICAgICAgICAgICAgICAgID8gZGF0YUluZGV4XG4gICAgICAgICAgICAgICAgICAgIDogY29udmVyRGF0YVZhbHVlKGdldERhdGFJdGVtVmFsdWUoaXRlbU9wdCksIGRpbWVuc2lvbnNbZGltSW5kZXhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogZnVuY3Rpb24gKGl0ZW1PcHQsIGRpbU5hbWUsIGRhdGFJbmRleCwgZGltSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBnZXREYXRhSXRlbVZhbHVlKGl0ZW1PcHQpO1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBjb252ZXJEYXRhVmFsdWUodmFsdWUgJiYgdmFsdWVbZGltSW5kZXhdLCBkaW1lbnNpb25zW2RpbUluZGV4XSk7XG4gICAgICAgICAgICAgICAgLy8gSWYgYW55IGRhdGFJdGVtIGlzIGxpa2UgeyB2YWx1ZTogMTAgfVxuICAgICAgICAgICAgICAgIGlmIChtb2RlbFV0aWwuaXNEYXRhSXRlbU9wdGlvbihpdGVtT3B0KSkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0Lmhhc0l0ZW1PcHRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjYXRlZ29yeUF4ZXNNb2RlbHMgPSBheGVzSW5mbyAmJiBheGVzSW5mby5jYXRlZ29yeUF4ZXNNb2RlbHM7XG4gICAgICAgICAgICAgICAgaWYgKGNhdGVnb3J5QXhlc01vZGVscyAmJiBjYXRlZ29yeUF4ZXNNb2RlbHNbZGltTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgZ2l2ZW4gdmFsdWUgaXMgYSBjYXRlZ29yeSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMYXp5IGdldCBjYXRlZ29yaWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRlZ29yaWVzW2RpbU5hbWVdID0gY2F0ZWdvcmllc1tkaW1OYW1lXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGNhdGVnb3J5QXhlc01vZGVsc1tkaW1OYW1lXS5nZXRDYXRlZ29yaWVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSB6clV0aWwuaW5kZXhPZihjYXRlZ29yaWVzW2RpbU5hbWVdLCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA8IDAgJiYgIWlzTmFOKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIHNvbWUgb25lIHdyaXRlICcxJywgJzInIGlzdGVhZCBvZiAxLCAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gK3ZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICBsaXN0Lmhhc0l0ZW1PcHRpb24gPSBmYWxzZTtcbiAgICAgICAgbGlzdC5pbml0RGF0YShkYXRhLCBuYW1lTGlzdCwgZGltVmFsdWVHZXR0ZXIpO1xuXG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU3RhY2thYmxlKGF4aXNUeXBlKSB7XG4gICAgICAgIHJldHVybiBheGlzVHlwZSAhPT0gJ2NhdGVnb3J5JyAmJiBheGlzVHlwZSAhPT0gJ3RpbWUnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERpbVR5cGVCeUF4aXMoYXhpc1R5cGUpIHtcbiAgICAgICAgcmV0dXJuIGF4aXNUeXBlID09PSAnY2F0ZWdvcnknXG4gICAgICAgICAgICA/ICdvcmRpbmFsJ1xuICAgICAgICAgICAgOiBheGlzVHlwZSA9PT0gJ3RpbWUnXG4gICAgICAgICAgICA/ICd0aW1lJ1xuICAgICAgICAgICAgOiAnZmxvYXQnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXJzIGZvciBlYWNoIGNvb3JkIHN5c3RlbS5cbiAgICAgKi9cbiAgICB2YXIgY3JlYXRvcnMgPSB7XG5cbiAgICAgICAgY2FydGVzaWFuMmQ6IGZ1bmN0aW9uIChkYXRhLCBzZXJpZXNNb2RlbCwgZWNNb2RlbCkge1xuXG4gICAgICAgICAgICB2YXIgYXhlc01vZGVscyA9IHpyVXRpbC5tYXAoWyd4QXhpcycsICd5QXhpcyddLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlY01vZGVsLnF1ZXJ5Q29tcG9uZW50cyh7XG4gICAgICAgICAgICAgICAgICAgIG1haW5UeXBlOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogc2VyaWVzTW9kZWwuZ2V0KG5hbWUgKyAnSW5kZXgnKSxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHNlcmllc01vZGVsLmdldChuYW1lICsgJ0lkJylcbiAgICAgICAgICAgICAgICB9KVswXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHhBeGlzTW9kZWwgPSBheGVzTW9kZWxzWzBdO1xuICAgICAgICAgICAgdmFyIHlBeGlzTW9kZWwgPSBheGVzTW9kZWxzWzFdO1xuXG4gICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICAgIGlmICgheEF4aXNNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3hBeGlzIFwiJyArIHpyVXRpbC5yZXRyaWV2ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc01vZGVsLmdldCgneEF4aXNJbmRleCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0KCd4QXhpc0lkJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgICkgKyAnXCIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgheUF4aXNNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3lBeGlzIFwiJyArIHpyVXRpbC5yZXRyaWV2ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc01vZGVsLmdldCgneEF4aXNJbmRleCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0KCd5QXhpc0lkJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgICkgKyAnXCIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgeEF4aXNUeXBlID0geEF4aXNNb2RlbC5nZXQoJ3R5cGUnKTtcbiAgICAgICAgICAgIHZhciB5QXhpc1R5cGUgPSB5QXhpc01vZGVsLmdldCgndHlwZScpO1xuXG4gICAgICAgICAgICB2YXIgZGltZW5zaW9ucyA9IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4JyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogZ2V0RGltVHlwZUJ5QXhpcyh4QXhpc1R5cGUpLFxuICAgICAgICAgICAgICAgICAgICBzdGFja2FibGU6IGlzU3RhY2thYmxlKHhBeGlzVHlwZSlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3knLFxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0d28gY2F0ZWdvcnkgYXhlc1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBnZXREaW1UeXBlQnlBeGlzKHlBeGlzVHlwZSksXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrYWJsZTogaXNTdGFja2FibGUoeUF4aXNUeXBlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIHZhciBpc1hBeGlzQ2F0ZW9ncnkgPSB4QXhpc1R5cGUgPT09ICdjYXRlZ29yeSc7XG4gICAgICAgICAgICB2YXIgaXNZQXhpc0NhdGVnb3J5ID0geUF4aXNUeXBlID09PSAnY2F0ZWdvcnknO1xuXG4gICAgICAgICAgICBjb21wbGV0ZURpbWVuc2lvbnMoZGltZW5zaW9ucywgZGF0YSwgWyd4JywgJ3knLCAneiddKTtcblxuICAgICAgICAgICAgdmFyIGNhdGVnb3J5QXhlc01vZGVscyA9IHt9O1xuICAgICAgICAgICAgaWYgKGlzWEF4aXNDYXRlb2dyeSkge1xuICAgICAgICAgICAgICAgIGNhdGVnb3J5QXhlc01vZGVscy54ID0geEF4aXNNb2RlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1lBeGlzQ2F0ZWdvcnkpIHtcbiAgICAgICAgICAgICAgICBjYXRlZ29yeUF4ZXNNb2RlbHMueSA9IHlBeGlzTW9kZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnM6IGRpbWVuc2lvbnMsXG4gICAgICAgICAgICAgICAgY2F0ZWdvcnlJbmRleDogaXNYQXhpc0NhdGVvZ3J5ID8gMCA6IChpc1lBeGlzQ2F0ZWdvcnkgPyAxIDogLTEpLFxuICAgICAgICAgICAgICAgIGNhdGVnb3J5QXhlc01vZGVsczogY2F0ZWdvcnlBeGVzTW9kZWxzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIHBvbGFyOiBmdW5jdGlvbiAoZGF0YSwgc2VyaWVzTW9kZWwsIGVjTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBwb2xhck1vZGVsID0gZWNNb2RlbC5xdWVyeUNvbXBvbmVudHMoe1xuICAgICAgICAgICAgICAgIG1haW5UeXBlOiAncG9sYXInLFxuICAgICAgICAgICAgICAgIGluZGV4OiBzZXJpZXNNb2RlbC5nZXQoJ3BvbGFySW5kZXgnKSxcbiAgICAgICAgICAgICAgICBpZDogc2VyaWVzTW9kZWwuZ2V0KCdwb2xhcklkJylcbiAgICAgICAgICAgIH0pWzBdO1xuXG4gICAgICAgICAgICB2YXIgYW5nbGVBeGlzTW9kZWwgPSBwb2xhck1vZGVsLmZpbmRBeGlzTW9kZWwoJ2FuZ2xlQXhpcycpO1xuICAgICAgICAgICAgdmFyIHJhZGl1c0F4aXNNb2RlbCA9IHBvbGFyTW9kZWwuZmluZEF4aXNNb2RlbCgncmFkaXVzQXhpcycpO1xuXG4gICAgICAgICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICAgICAgICAgIGlmICghYW5nbGVBeGlzTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbmdsZUF4aXMgb3B0aW9uIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXJhZGl1c0F4aXNNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl1c0F4aXMgb3B0aW9uIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJhZGl1c0F4aXNUeXBlID0gcmFkaXVzQXhpc01vZGVsLmdldCgndHlwZScpO1xuICAgICAgICAgICAgdmFyIGFuZ2xlQXhpc1R5cGUgPSBhbmdsZUF4aXNNb2RlbC5nZXQoJ3R5cGUnKTtcblxuICAgICAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAncmFkaXVzJyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogZ2V0RGltVHlwZUJ5QXhpcyhyYWRpdXNBeGlzVHlwZSksXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrYWJsZTogaXNTdGFja2FibGUocmFkaXVzQXhpc1R5cGUpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdhbmdsZScsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGdldERpbVR5cGVCeUF4aXMoYW5nbGVBeGlzVHlwZSksXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrYWJsZTogaXNTdGFja2FibGUoYW5nbGVBeGlzVHlwZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgdmFyIGlzQW5nbGVBeGlzQ2F0ZW9ncnkgPSBhbmdsZUF4aXNUeXBlID09PSAnY2F0ZWdvcnknO1xuICAgICAgICAgICAgdmFyIGlzUmFkaXVzQXhpc0NhdGVvZ3J5ID0gcmFkaXVzQXhpc1R5cGUgPT09ICdjYXRlZ29yeSc7XG5cbiAgICAgICAgICAgIGNvbXBsZXRlRGltZW5zaW9ucyhkaW1lbnNpb25zLCBkYXRhLCBbJ3JhZGl1cycsICdhbmdsZScsICd2YWx1ZSddKTtcblxuICAgICAgICAgICAgdmFyIGNhdGVnb3J5QXhlc01vZGVscyA9IHt9O1xuICAgICAgICAgICAgaWYgKGlzUmFkaXVzQXhpc0NhdGVvZ3J5KSB7XG4gICAgICAgICAgICAgICAgY2F0ZWdvcnlBeGVzTW9kZWxzLnJhZGl1cyA9IHJhZGl1c0F4aXNNb2RlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0FuZ2xlQXhpc0NhdGVvZ3J5KSB7XG4gICAgICAgICAgICAgICAgY2F0ZWdvcnlBeGVzTW9kZWxzLmFuZ2xlID0gYW5nbGVBeGlzTW9kZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnM6IGRpbWVuc2lvbnMsXG4gICAgICAgICAgICAgICAgY2F0ZWdvcnlJbmRleDogaXNBbmdsZUF4aXNDYXRlb2dyeSA/IDEgOiAoaXNSYWRpdXNBeGlzQ2F0ZW9ncnkgPyAwIDogLTEpLFxuICAgICAgICAgICAgICAgIGNhdGVnb3J5QXhlc01vZGVsczogY2F0ZWdvcnlBeGVzTW9kZWxzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGdlbzogZnVuY3Rpb24gKGRhdGEsIHNlcmllc01vZGVsLCBlY01vZGVsKSB7XG4gICAgICAgICAgICAvLyBUT0RPIFJlZ2lvblxuICAgICAgICAgICAgLy8g5aSa5Liq5pWj54K55Zu+57O75YiX5Zyo5ZCM5LiA5Liq5Zyw5Yy655qE5pe25YCZXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnM6IGNvbXBsZXRlRGltZW5zaW9ucyhbXG4gICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnbG5nJ30sXG4gICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnbGF0J31cbiAgICAgICAgICAgICAgICBdLCBkYXRhLCBbJ2xuZycsICdsYXQnLCAndmFsdWUnXSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlTmFtZUxpc3QocmVzdWx0LCBkYXRhKSB7XG4gICAgICAgIHZhciBuYW1lTGlzdCA9IFtdO1xuXG4gICAgICAgIHZhciBjYXRlZ29yeURpbSA9IHJlc3VsdCAmJiByZXN1bHQuZGltZW5zaW9uc1tyZXN1bHQuY2F0ZWdvcnlJbmRleF07XG4gICAgICAgIHZhciBjYXRlZ29yeUF4aXNNb2RlbDtcbiAgICAgICAgaWYgKGNhdGVnb3J5RGltKSB7XG4gICAgICAgICAgICBjYXRlZ29yeUF4aXNNb2RlbCA9IHJlc3VsdC5jYXRlZ29yeUF4ZXNNb2RlbHNbY2F0ZWdvcnlEaW0ubmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2F0ZWdvcnlBeGlzTW9kZWwpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FIFR3byBjYXRlZ29yeSBheGlzXG4gICAgICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IGNhdGVnb3J5QXhpc01vZGVsLmdldENhdGVnb3JpZXMoKTtcbiAgICAgICAgICAgIGlmIChjYXRlZ29yaWVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFMZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBPcmRlcmVkIGRhdGEgaXMgZ2l2ZW4gZXhwbGljaXRseSBsaWtlXG4gICAgICAgICAgICAgICAgLy8gW1szLCAwLjJdLCBbMSwgMC4zXSwgWzIsIDAuMTVdXVxuICAgICAgICAgICAgICAgIC8vIG9yIGdpdmVuIHNjYXR0ZXIgZGF0YSxcbiAgICAgICAgICAgICAgICAvLyBwaWNrIHRoZSBjYXRlZ29yeVxuICAgICAgICAgICAgICAgIGlmICh6clV0aWwuaXNBcnJheShkYXRhWzBdKSAmJiBkYXRhWzBdLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZUxpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVMaXN0W2ldID0gY2F0ZWdvcmllc1tkYXRhW2ldW3Jlc3VsdC5jYXRlZ29yeUluZGV4IHx8IDBdXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZUxpc3QgPSBjYXRlZ29yaWVzLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuYW1lTGlzdDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlTGlzdEZyb21BcnJheTtcblxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC9lY2hhcnRzL2NoYXJ0L2hlbHBlci9jcmVhdGVMaXN0RnJvbUFycmF5LmpzXG4gKiogbW9kdWxlIGlkID0gMTIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCIvKipcbiAqIENvbXBsZXRlIGRpbWVuc2lvbnMgYnkgZGF0YSAoZ3Vlc3MgZGltZW5zaW9uKS5cbiAqL1xuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9jb3JlL3V0aWwnKTtcblxuICAgIC8qKlxuICAgICAqIENvbXBsZXRlIHRoZSBkaW1lbnNpb25zIGFycmF5IGd1ZXNzZWQgZnJvbSB0aGUgZGF0YSBzdHJ1Y3R1cmUuXG4gICAgICogQHBhcmFtICB7QXJyYXkuPHN0cmluZz59IGRpbWVuc2lvbnMgICAgICBOZWNlc3NhcnkgZGltZW5zaW9ucywgbGlrZSBbJ3gnLCAneSddXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGRhdGEgICAgICAgICAgICAgICAgICAgICBEYXRhIGxpc3QuIFtbMSwgMiwgM10sIFsyLCAzLCA0XV1cbiAgICAgKiBAcGFyYW0gIHtBcnJheS48c3RyaW5nPn0gZGVmYXVsdE5hbWVzICAgIERlZmF1bHQgbmFtZXMgdG8gZmlsbCBub3QgbmVjZXNzYXJ5IGRpbWVuc2lvbnMsIGxpa2UgWyd2YWx1ZSddXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBleHRyYVByZWZpeCAgICAgICAgICAgICBQcmVmaXggb2YgbmFtZSB3aGVuIGZpbGxpbmcgdGhlIGxlZnQgZGltZW5zaW9ucy5cbiAgICAgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wbGV0ZURpbWVuc2lvbnMoZGltZW5zaW9ucywgZGF0YSwgZGVmYXVsdE5hbWVzLCBleHRyYVByZWZpeCkge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBkaW1lbnNpb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbHVlMCA9IHJldHJpZXZlVmFsdWUoZGF0YVswXSk7XG4gICAgICAgIHZhciBkaW1TaXplID0genJVdGlsLmlzQXJyYXkodmFsdWUwKSAmJiB2YWx1ZTAubGVuZ3RoIHx8IDE7XG5cbiAgICAgICAgZGVmYXVsdE5hbWVzID0gZGVmYXVsdE5hbWVzIHx8IFtdO1xuICAgICAgICBleHRyYVByZWZpeCA9IGV4dHJhUHJlZml4IHx8ICdleHRyYSc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGltU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWRpbWVuc2lvbnNbaV0pIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGRlZmF1bHROYW1lc1tpXSB8fCAoZXh0cmFQcmVmaXggKyAoaSAtIGRlZmF1bHROYW1lcy5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zW2ldID0gZ3Vlc3NPcmRpbmFsKGRhdGEsIGkpXG4gICAgICAgICAgICAgICAgICAgID8ge3R5cGU6ICdvcmRpbmFsJywgbmFtZTogbmFtZX1cbiAgICAgICAgICAgICAgICAgICAgOiBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRpbWVuc2lvbnM7XG4gICAgfVxuXG4gICAgLy8gVGhlIHJ1bGUgc2hvdWxkIG5vdCBiZSBjb21wbGV4LCBvdGhlcndpc2UgdXNlciBtaWdodCBub3RcbiAgICAvLyBiZSBhYmxlIHRvIGtub3duIHdoZXJlIHRoZSBkYXRhIGlzIHdyb25nLlxuICAgIHZhciBndWVzc09yZGluYWwgPSBjb21wbGV0ZURpbWVuc2lvbnMuZ3Vlc3NPcmRpbmFsID0gZnVuY3Rpb24gKGRhdGEsIGRpbUluZGV4KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSByZXRyaWV2ZVZhbHVlKGRhdGFbaV0pO1xuXG4gICAgICAgICAgICBpZiAoIXpyVXRpbC5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVbZGltSW5kZXhdO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoenJVdGlsLmlzU3RyaW5nKHZhbHVlKSAmJiB2YWx1ZSAhPT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZXRyaWV2ZVZhbHVlKG8pIHtcbiAgICAgICAgcmV0dXJuIHpyVXRpbC5pc0FycmF5KG8pID8gbyA6IHpyVXRpbC5pc09iamVjdChvKSA/IG8udmFsdWU6IG87XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBsZXRlRGltZW5zaW9ucztcblxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC9lY2hhcnRzL2RhdGEvaGVscGVyL2NvbXBsZXRlRGltZW5zaW9ucy5qc1xuICoqIG1vZHVsZSBpZCA9IDEyM1xuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9jb3JlL3V0aWwnKTtcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZ3JhcGhpYycpO1xuXG4gICAgenJVdGlsLmV4dGVuZChyZXF1aXJlKCcuLi8uLi9tb2RlbC9Nb2RlbCcpLnByb3RvdHlwZSwgcmVxdWlyZSgnLi9iYXJJdGVtU3R5bGUnKSk7XG5cbiAgICBmdW5jdGlvbiBmaXhMYXlvdXRXaXRoTGluZVdpZHRoKGxheW91dCwgbGluZVdpZHRoKSB7XG4gICAgICAgIHZhciBzaWduWCA9IGxheW91dC53aWR0aCA+IDAgPyAxIDogLTE7XG4gICAgICAgIHZhciBzaWduWSA9IGxheW91dC5oZWlnaHQgPiAwID8gMSA6IC0xO1xuICAgICAgICAvLyBJbiBjYXNlIHdpZHRoIG9yIGhlaWdodCBhcmUgdG9vIHNtYWxsLlxuICAgICAgICBsaW5lV2lkdGggPSBNYXRoLm1pbihsaW5lV2lkdGgsIE1hdGguYWJzKGxheW91dC53aWR0aCksIE1hdGguYWJzKGxheW91dC5oZWlnaHQpKTtcbiAgICAgICAgbGF5b3V0LnggKz0gc2lnblggKiBsaW5lV2lkdGggLyAyO1xuICAgICAgICBsYXlvdXQueSArPSBzaWduWSAqIGxpbmVXaWR0aCAvIDI7XG4gICAgICAgIGxheW91dC53aWR0aCAtPSBzaWduWCAqIGxpbmVXaWR0aDtcbiAgICAgICAgbGF5b3V0LmhlaWdodCAtPSBzaWduWSAqIGxpbmVXaWR0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVxdWlyZSgnLi4vLi4vZWNoYXJ0cycpLmV4dGVuZENoYXJ0Vmlldyh7XG5cbiAgICAgICAgdHlwZTogJ2JhcicsXG5cbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVTeXN0ZW1UeXBlID0gc2VyaWVzTW9kZWwuZ2V0KCdjb29yZGluYXRlU3lzdGVtJyk7XG5cbiAgICAgICAgICAgIGlmIChjb29yZGluYXRlU3lzdGVtVHlwZSA9PT0gJ2NhcnRlc2lhbjJkJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlck9uQ2FydGVzaWFuKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ncm91cDtcbiAgICAgICAgfSxcblxuICAgICAgICBfcmVuZGVyT25DYXJ0ZXNpYW46IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgICAgICB2YXIgb2xkRGF0YSA9IHRoaXMuX2RhdGE7XG5cbiAgICAgICAgICAgIHZhciBjYXJ0ZXNpYW4gPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICAgICAgdmFyIGJhc2VBeGlzID0gY2FydGVzaWFuLmdldEJhc2VBeGlzKCk7XG4gICAgICAgICAgICB2YXIgaXNIb3Jpem9udGFsID0gYmFzZUF4aXMuaXNIb3Jpem9udGFsKCk7XG5cbiAgICAgICAgICAgIHZhciBlbmFibGVBbmltYXRpb24gPSBzZXJpZXNNb2RlbC5nZXQoJ2FuaW1hdGlvbicpO1xuXG4gICAgICAgICAgICB2YXIgYmFyQm9yZGVyV2lkdGhRdWVyeSA9IFsnaXRlbVN0eWxlJywgJ25vcm1hbCcsICdiYXJCb3JkZXJXaWR0aCddO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVSZWN0KGRhdGFJbmRleCwgaXNVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGF5b3V0ID0gZGF0YS5nZXRJdGVtTGF5b3V0KGRhdGFJbmRleCk7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVXaWR0aCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGRhdGFJbmRleCkuZ2V0KGJhckJvcmRlcldpZHRoUXVlcnkpIHx8IDA7XG4gICAgICAgICAgICAgICAgZml4TGF5b3V0V2l0aExpbmVXaWR0aChsYXlvdXQsIGxpbmVXaWR0aCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IG5ldyBncmFwaGljLlJlY3Qoe1xuICAgICAgICAgICAgICAgICAgICBzaGFwZTogenJVdGlsLmV4dGVuZCh7fSwgbGF5b3V0KVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIEFuaW1hdGlvblxuICAgICAgICAgICAgICAgIGlmIChlbmFibGVBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3RTaGFwZSA9IHJlY3Quc2hhcGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRlUHJvcGVydHkgPSBpc0hvcml6b250YWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRlVGFyZ2V0ID0ge307XG4gICAgICAgICAgICAgICAgICAgIHJlY3RTaGFwZVthbmltYXRlUHJvcGVydHldID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZVRhcmdldFthbmltYXRlUHJvcGVydHldID0gbGF5b3V0W2FuaW1hdGVQcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgICAgIGdyYXBoaWNbaXNVcGRhdGU/ICd1cGRhdGVQcm9wcycgOiAnaW5pdFByb3BzJ10ocmVjdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGU6IGFuaW1hdGVUYXJnZXRcbiAgICAgICAgICAgICAgICAgICAgfSwgc2VyaWVzTW9kZWwsIGRhdGFJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YS5kaWZmKG9sZERhdGEpXG4gICAgICAgICAgICAgICAgLmFkZChmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOepuuaVsOaNrlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEuaGFzVmFsdWUoZGF0YUluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBjcmVhdGVSZWN0KGRhdGFJbmRleCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zZXRJdGVtR3JhcGhpY0VsKGRhdGFJbmRleCwgcmVjdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuYWRkKHJlY3QpO1xuXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudXBkYXRlKGZ1bmN0aW9uIChuZXdJbmRleCwgb2xkSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBvbGREYXRhLmdldEl0ZW1HcmFwaGljRWwob2xkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAvLyDnqbrmlbDmja5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhLmhhc1ZhbHVlKG5ld0luZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXAucmVtb3ZlKHJlY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdCA9IGNyZWF0ZVJlY3QobmV3SW5kZXgsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGxheW91dCA9IGRhdGEuZ2V0SXRlbUxheW91dChuZXdJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lV2lkdGggPSBkYXRhLmdldEl0ZW1Nb2RlbChuZXdJbmRleCkuZ2V0KGJhckJvcmRlcldpZHRoUXVlcnkpIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIGZpeExheW91dFdpdGhMaW5lV2lkdGgobGF5b3V0LCBsaW5lV2lkdGgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMocmVjdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGU6IGxheW91dFxuICAgICAgICAgICAgICAgICAgICB9LCBzZXJpZXNNb2RlbCwgbmV3SW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChuZXdJbmRleCwgcmVjdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGJhY2tcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuYWRkKHJlY3QpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnJlbW92ZShmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWN0ID0gb2xkRGF0YS5nZXRJdGVtR3JhcGhpY0VsKGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3Qgc2hvdyB0ZXh0IHdoZW4gYW5pbWF0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0LnN0eWxlLnRleHQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoaWMudXBkYXRlUHJvcHMocmVjdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgc2VyaWVzTW9kZWwsIGlkeCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwLnJlbW92ZShyZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZXhlY3V0ZSgpO1xuXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVTdHlsZShzZXJpZXNNb2RlbCwgZGF0YSwgaXNIb3Jpem9udGFsKTtcblxuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGRhdGEsIGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gc2V0TGFiZWwoc3R5bGUsIG1vZGVsLCBjb2xvciwgbGFiZWxUZXh0LCBsYWJlbFBvc2l0aW9uT3V0c2lkZSkge1xuICAgICAgICAgICAgICAgIGdyYXBoaWMuc2V0VGV4dChzdHlsZSwgbW9kZWwsIGNvbG9yKTtcbiAgICAgICAgICAgICAgICBzdHlsZS50ZXh0ID0gbGFiZWxUZXh0O1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZS50ZXh0UG9zaXRpb24gPT09ICdvdXRzaWRlJykge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS50ZXh0UG9zaXRpb24gPSBsYWJlbFBvc2l0aW9uT3V0c2lkZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKHJlY3QsIGlkeCkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtTW9kZWwgPSBkYXRhLmdldEl0ZW1Nb2RlbChpZHgpO1xuICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IGRhdGEuZ2V0SXRlbVZpc3VhbChpZHgsICdjb2xvcicpO1xuICAgICAgICAgICAgICAgIHZhciBvcGFjaXR5ID0gZGF0YS5nZXRJdGVtVmlzdWFsKGlkeCwgJ29wYWNpdHknKTtcbiAgICAgICAgICAgICAgICB2YXIgbGF5b3V0ID0gZGF0YS5nZXRJdGVtTGF5b3V0KGlkeCk7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1TdHlsZU1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdpdGVtU3R5bGUubm9ybWFsJyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgaG92ZXJTdHlsZSA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnaXRlbVN0eWxlLmVtcGhhc2lzJykuZ2V0QmFySXRlbVN0eWxlKCk7XG5cbiAgICAgICAgICAgICAgICByZWN0LnNldFNoYXBlKCdyJywgaXRlbVN0eWxlTW9kZWwuZ2V0KCdiYXJCb3JkZXJSYWRpdXMnKSB8fCAwKTtcblxuICAgICAgICAgICAgICAgIHJlY3QudXNlU3R5bGUoenJVdGlsLmRlZmF1bHRzKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IG9wYWNpdHlcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaXRlbVN0eWxlTW9kZWwuZ2V0QmFySXRlbVN0eWxlKClcbiAgICAgICAgICAgICAgICApKTtcblxuICAgICAgICAgICAgICAgIHZhciBsYWJlbFBvc2l0aW9uT3V0c2lkZSA9IGlzSG9yaXpvbnRhbFxuICAgICAgICAgICAgICAgICAgICA/IChsYXlvdXQuaGVpZ2h0ID4gMCA/ICdib3R0b20nIDogJ3RvcCcpXG4gICAgICAgICAgICAgICAgICAgIDogKGxheW91dC53aWR0aCA+IDAgPyAnbGVmdCcgOiAncmlnaHQnKTtcblxuICAgICAgICAgICAgICAgIHZhciBsYWJlbE1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdsYWJlbC5ub3JtYWwnKTtcbiAgICAgICAgICAgICAgICB2YXIgaG92ZXJMYWJlbE1vZGVsID0gaXRlbU1vZGVsLmdldE1vZGVsKCdsYWJlbC5lbXBoYXNpcycpO1xuICAgICAgICAgICAgICAgIHZhciByZWN0U3R5bGUgPSByZWN0LnN0eWxlO1xuICAgICAgICAgICAgICAgIGlmIChsYWJlbE1vZGVsLmdldCgnc2hvdycpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldExhYmVsKFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdFN0eWxlLCBsYWJlbE1vZGVsLCBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHpyVXRpbC5yZXRyaWV2ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXRGb3JtYXR0ZWRMYWJlbChpZHgsICdub3JtYWwnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXRSYXdWYWx1ZShpZHgpXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxQb3NpdGlvbk91dHNpZGVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY3RTdHlsZS50ZXh0ID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChob3ZlckxhYmVsTW9kZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0TGFiZWwoXG4gICAgICAgICAgICAgICAgICAgICAgICBob3ZlclN0eWxlLCBob3ZlckxhYmVsTW9kZWwsIGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgenJVdGlsLnJldHJpZXZlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc01vZGVsLmdldEZvcm1hdHRlZExhYmVsKGlkeCwgJ2VtcGhhc2lzJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0UmF3VmFsdWUoaWR4KVxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsUG9zaXRpb25PdXRzaWRlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBob3ZlclN0eWxlLnRleHQgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ3JhcGhpYy5zZXRIb3ZlclN0eWxlKHJlY3QsIGhvdmVyU3R5bGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgICAgICAgICAgaWYgKGVjTW9kZWwuZ2V0KCdhbmltYXRpb24nKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhdGEuZWFjaEl0ZW1HcmFwaGljRWwoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3Qgc2hvdyB0ZXh0IHdoZW4gYW5pbWF0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5zdHlsZS50ZXh0ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmFwaGljLnVwZGF0ZVByb3BzKGVsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBlY01vZGVsLCBlbC5kYXRhSW5kZXgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cC5yZW1vdmUoZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdyb3VwLnJlbW92ZUFsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL2VjaGFydHMvY2hhcnQvYmFyL0JhclZpZXcuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsImRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG5cbiAgICB2YXIgZ2V0QmFySXRlbVN0eWxlID0gcmVxdWlyZSgnLi4vLi4vbW9kZWwvbWl4aW4vbWFrZVN0eWxlTWFwcGVyJykoXG4gICAgICAgIFtcbiAgICAgICAgICAgIFsnZmlsbCcsICdjb2xvciddLFxuICAgICAgICAgICAgWydzdHJva2UnLCAnYm9yZGVyQ29sb3InXSxcbiAgICAgICAgICAgIFsnbGluZVdpZHRoJywgJ2JvcmRlcldpZHRoJ10sXG4gICAgICAgICAgICAvLyBDb21wYXRpdGFibGUgd2l0aCAyXG4gICAgICAgICAgICBbJ3N0cm9rZScsICdiYXJCb3JkZXJDb2xvciddLFxuICAgICAgICAgICAgWydsaW5lV2lkdGgnLCAnYmFyQm9yZGVyV2lkdGgnXSxcbiAgICAgICAgICAgIFsnb3BhY2l0eSddLFxuICAgICAgICAgICAgWydzaGFkb3dCbHVyJ10sXG4gICAgICAgICAgICBbJ3NoYWRvd09mZnNldFgnXSxcbiAgICAgICAgICAgIFsnc2hhZG93T2Zmc2V0WSddLFxuICAgICAgICAgICAgWydzaGFkb3dDb2xvciddXG4gICAgICAgIF1cbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldEJhckl0ZW1TdHlsZTogZnVuY3Rpb24gKGV4Y2x1ZGVzKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBnZXRCYXJJdGVtU3R5bGUuY2FsbCh0aGlzLCBleGNsdWRlcyk7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRCb3JkZXJMaW5lRGFzaCkge1xuICAgICAgICAgICAgICAgIHZhciBsaW5lRGFzaCA9IHRoaXMuZ2V0Qm9yZGVyTGluZURhc2goKTtcbiAgICAgICAgICAgICAgICBsaW5lRGFzaCAmJiAoc3R5bGUubGluZURhc2ggPSBsaW5lRGFzaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgIH1cbiAgICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC9lY2hhcnRzL2NoYXJ0L2Jhci9iYXJJdGVtU3R5bGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsImRlZmluZShmdW5jdGlvbihyZXF1aXJlKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9jb3JlL3V0aWwnKTtcbiAgICB2YXIgbnVtYmVyVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvbnVtYmVyJyk7XG4gICAgdmFyIHBhcnNlUGVyY2VudCA9IG51bWJlclV0aWwucGFyc2VQZXJjZW50O1xuXG4gICAgZnVuY3Rpb24gZ2V0U2VyaWVzU3RhY2tJZChzZXJpZXNNb2RlbCkge1xuICAgICAgICByZXR1cm4gc2VyaWVzTW9kZWwuZ2V0KCdzdGFjaycpIHx8ICdfX2VjX3N0YWNrXycgKyBzZXJpZXNNb2RlbC5zZXJpZXNJbmRleDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRBeGlzS2V5KGF4aXMpIHtcbiAgICAgICAgcmV0dXJuIGF4aXMuZGltICsgYXhpcy5pbmRleDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxCYXJXaWR0aEFuZE9mZnNldChiYXJTZXJpZXMsIGFwaSkge1xuICAgICAgICAvLyBDb2x1bW5zIGluZm8gb24gZWFjaCBjYXRlZ29yeSBheGlzLiBLZXkgaXMgY2FydGVzaWFuIG5hbWVcbiAgICAgICAgdmFyIGNvbHVtbnNNYXAgPSB7fTtcblxuICAgICAgICB6clV0aWwuZWFjaChiYXJTZXJpZXMsIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgaWR4KSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgIHZhciBjYXJ0ZXNpYW4gPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuXG4gICAgICAgICAgICB2YXIgYmFzZUF4aXMgPSBjYXJ0ZXNpYW4uZ2V0QmFzZUF4aXMoKTtcbiAgICAgICAgICAgIHZhciBheGlzRXh0ZW50ID0gYmFzZUF4aXMuZ2V0RXh0ZW50KCk7XG4gICAgICAgICAgICB2YXIgYmFuZFdpZHRoID0gYmFzZUF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5J1xuICAgICAgICAgICAgICAgID8gYmFzZUF4aXMuZ2V0QmFuZFdpZHRoKClcbiAgICAgICAgICAgICAgICA6IChNYXRoLmFicyhheGlzRXh0ZW50WzFdIC0gYXhpc0V4dGVudFswXSkgLyBkYXRhLmNvdW50KCkpO1xuXG4gICAgICAgICAgICB2YXIgY29sdW1uc09uQXhpcyA9IGNvbHVtbnNNYXBbZ2V0QXhpc0tleShiYXNlQXhpcyldIHx8IHtcbiAgICAgICAgICAgICAgICBiYW5kV2lkdGg6IGJhbmRXaWR0aCxcbiAgICAgICAgICAgICAgICByZW1haW5lZFdpZHRoOiBiYW5kV2lkdGgsXG4gICAgICAgICAgICAgICAgYXV0b1dpZHRoQ291bnQ6IDAsXG4gICAgICAgICAgICAgICAgY2F0ZWdvcnlHYXA6ICcyMCUnLFxuICAgICAgICAgICAgICAgIGdhcDogJzMwJScsXG4gICAgICAgICAgICAgICAgc3RhY2tzOiB7fVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBzdGFja3MgPSBjb2x1bW5zT25BeGlzLnN0YWNrcztcbiAgICAgICAgICAgIGNvbHVtbnNNYXBbZ2V0QXhpc0tleShiYXNlQXhpcyldID0gY29sdW1uc09uQXhpcztcblxuICAgICAgICAgICAgdmFyIHN0YWNrSWQgPSBnZXRTZXJpZXNTdGFja0lkKHNlcmllc01vZGVsKTtcblxuICAgICAgICAgICAgaWYgKCFzdGFja3Nbc3RhY2tJZF0pIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5zT25BeGlzLmF1dG9XaWR0aENvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFja3Nbc3RhY2tJZF0gPSBzdGFja3Nbc3RhY2tJZF0gfHwge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgICAgIG1heFdpZHRoOiAwXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgYmFyV2lkdGggPSBwYXJzZVBlcmNlbnQoXG4gICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0KCdiYXJXaWR0aCcpLCBiYW5kV2lkdGhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB2YXIgYmFyTWF4V2lkdGggPSBwYXJzZVBlcmNlbnQoXG4gICAgICAgICAgICAgICAgc2VyaWVzTW9kZWwuZ2V0KCdiYXJNYXhXaWR0aCcpLCBiYW5kV2lkdGhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB2YXIgYmFyR2FwID0gc2VyaWVzTW9kZWwuZ2V0KCdiYXJHYXAnKTtcbiAgICAgICAgICAgIHZhciBiYXJDYXRlZ29yeUdhcCA9IHNlcmllc01vZGVsLmdldCgnYmFyQ2F0ZWdvcnlHYXAnKTtcbiAgICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgICAgIGlmIChiYXJXaWR0aCAmJiAhc3RhY2tzW3N0YWNrSWRdLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgYmFyV2lkdGggPSBNYXRoLm1pbihjb2x1bW5zT25BeGlzLnJlbWFpbmVkV2lkdGgsIGJhcldpZHRoKTtcbiAgICAgICAgICAgICAgICBzdGFja3Nbc3RhY2tJZF0ud2lkdGggPSBiYXJXaWR0aDtcbiAgICAgICAgICAgICAgICBjb2x1bW5zT25BeGlzLnJlbWFpbmVkV2lkdGggLT0gYmFyV2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJhck1heFdpZHRoICYmIChzdGFja3Nbc3RhY2tJZF0ubWF4V2lkdGggPSBiYXJNYXhXaWR0aCk7XG4gICAgICAgICAgICAoYmFyR2FwICE9IG51bGwpICYmIChjb2x1bW5zT25BeGlzLmdhcCA9IGJhckdhcCk7XG4gICAgICAgICAgICAoYmFyQ2F0ZWdvcnlHYXAgIT0gbnVsbCkgJiYgKGNvbHVtbnNPbkF4aXMuY2F0ZWdvcnlHYXAgPSBiYXJDYXRlZ29yeUdhcCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgICAgICB6clV0aWwuZWFjaChjb2x1bW5zTWFwLCBmdW5jdGlvbiAoY29sdW1uc09uQXhpcywgY29vcmRTeXNOYW1lKSB7XG5cbiAgICAgICAgICAgIHJlc3VsdFtjb29yZFN5c05hbWVdID0ge307XG5cbiAgICAgICAgICAgIHZhciBzdGFja3MgPSBjb2x1bW5zT25BeGlzLnN0YWNrcztcbiAgICAgICAgICAgIHZhciBiYW5kV2lkdGggPSBjb2x1bW5zT25BeGlzLmJhbmRXaWR0aDtcbiAgICAgICAgICAgIHZhciBjYXRlZ29yeUdhcCA9IHBhcnNlUGVyY2VudChjb2x1bW5zT25BeGlzLmNhdGVnb3J5R2FwLCBiYW5kV2lkdGgpO1xuICAgICAgICAgICAgdmFyIGJhckdhcFBlcmNlbnQgPSBwYXJzZVBlcmNlbnQoY29sdW1uc09uQXhpcy5nYXAsIDEpO1xuXG4gICAgICAgICAgICB2YXIgcmVtYWluZWRXaWR0aCA9IGNvbHVtbnNPbkF4aXMucmVtYWluZWRXaWR0aDtcbiAgICAgICAgICAgIHZhciBhdXRvV2lkdGhDb3VudCA9IGNvbHVtbnNPbkF4aXMuYXV0b1dpZHRoQ291bnQ7XG4gICAgICAgICAgICB2YXIgYXV0b1dpZHRoID0gKHJlbWFpbmVkV2lkdGggLSBjYXRlZ29yeUdhcClcbiAgICAgICAgICAgICAgICAvIChhdXRvV2lkdGhDb3VudCArIChhdXRvV2lkdGhDb3VudCAtIDEpICogYmFyR2FwUGVyY2VudCk7XG4gICAgICAgICAgICBhdXRvV2lkdGggPSBNYXRoLm1heChhdXRvV2lkdGgsIDApO1xuXG4gICAgICAgICAgICAvLyBGaW5kIGlmIGFueSBhdXRvIGNhbGN1bGF0ZWQgYmFyIGV4Y2VlZGVkIG1heEJhcldpZHRoXG4gICAgICAgICAgICB6clV0aWwuZWFjaChzdGFja3MsIGZ1bmN0aW9uIChjb2x1bW4sIHN0YWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1heFdpZHRoID0gY29sdW1uLm1heFdpZHRoO1xuICAgICAgICAgICAgICAgIGlmICghY29sdW1uLndpZHRoICYmIG1heFdpZHRoICYmIG1heFdpZHRoIDwgYXV0b1dpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heFdpZHRoID0gTWF0aC5taW4obWF4V2lkdGgsIHJlbWFpbmVkV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICByZW1haW5lZFdpZHRoIC09IG1heFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4ud2lkdGggPSBtYXhXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgYXV0b1dpZHRoQ291bnQtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gUmVjYWxjdWxhdGUgd2lkdGggYWdhaW5cbiAgICAgICAgICAgIGF1dG9XaWR0aCA9IChyZW1haW5lZFdpZHRoIC0gY2F0ZWdvcnlHYXApXG4gICAgICAgICAgICAgICAgLyAoYXV0b1dpZHRoQ291bnQgKyAoYXV0b1dpZHRoQ291bnQgLSAxKSAqIGJhckdhcFBlcmNlbnQpO1xuICAgICAgICAgICAgYXV0b1dpZHRoID0gTWF0aC5tYXgoYXV0b1dpZHRoLCAwKTtcblxuICAgICAgICAgICAgdmFyIHdpZHRoU3VtID0gMDtcbiAgICAgICAgICAgIHZhciBsYXN0Q29sdW1uO1xuICAgICAgICAgICAgenJVdGlsLmVhY2goc3RhY2tzLCBmdW5jdGlvbiAoY29sdW1uLCBpZHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbHVtbi53aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4ud2lkdGggPSBhdXRvV2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RDb2x1bW4gPSBjb2x1bW47XG4gICAgICAgICAgICAgICAgd2lkdGhTdW0gKz0gY29sdW1uLndpZHRoICogKDEgKyBiYXJHYXBQZXJjZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGxhc3RDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICB3aWR0aFN1bSAtPSBsYXN0Q29sdW1uLndpZHRoICogYmFyR2FwUGVyY2VudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IC13aWR0aFN1bSAvIDI7XG4gICAgICAgICAgICB6clV0aWwuZWFjaChzdGFja3MsIGZ1bmN0aW9uIChjb2x1bW4sIHN0YWNrSWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbY29vcmRTeXNOYW1lXVtzdGFja0lkXSA9IHJlc3VsdFtjb29yZFN5c05hbWVdW3N0YWNrSWRdIHx8IHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjb2x1bW4ud2lkdGhcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGNvbHVtbi53aWR0aCAqICgxICsgYmFyR2FwUGVyY2VudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VyaWVzVHlwZVxuICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvR2xvYmFsfSBlY01vZGVsXG4gICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9FeHRlbnNpb25BUEl9IGFwaVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhckxheW91dEdyaWQoc2VyaWVzVHlwZSwgZWNNb2RlbCwgYXBpKSB7XG5cbiAgICAgICAgdmFyIGJhcldpZHRoQW5kT2Zmc2V0ID0gY2FsQmFyV2lkdGhBbmRPZmZzZXQoXG4gICAgICAgICAgICB6clV0aWwuZmlsdGVyKFxuICAgICAgICAgICAgICAgIGVjTW9kZWwuZ2V0U2VyaWVzQnlUeXBlKHNlcmllc1R5cGUpLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWVjTW9kZWwuaXNTZXJpZXNGaWx0ZXJlZChzZXJpZXNNb2RlbClcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW1cbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0udHlwZSA9PT0gJ2NhcnRlc2lhbjJkJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICk7XG5cbiAgICAgICAgdmFyIGxhc3RTdGFja0Nvb3JkcyA9IHt9O1xuXG4gICAgICAgIGVjTW9kZWwuZWFjaFNlcmllc0J5VHlwZShzZXJpZXNUeXBlLCBmdW5jdGlvbiAoc2VyaWVzTW9kZWwpIHtcblxuICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgICAgICAgICB2YXIgY2FydGVzaWFuID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgICAgIHZhciBiYXNlQXhpcyA9IGNhcnRlc2lhbi5nZXRCYXNlQXhpcygpO1xuXG4gICAgICAgICAgICB2YXIgc3RhY2tJZCA9IGdldFNlcmllc1N0YWNrSWQoc2VyaWVzTW9kZWwpO1xuICAgICAgICAgICAgdmFyIGNvbHVtbkxheW91dEluZm8gPSBiYXJXaWR0aEFuZE9mZnNldFtnZXRBeGlzS2V5KGJhc2VBeGlzKV1bc3RhY2tJZF07XG4gICAgICAgICAgICB2YXIgY29sdW1uT2Zmc2V0ID0gY29sdW1uTGF5b3V0SW5mby5vZmZzZXQ7XG4gICAgICAgICAgICB2YXIgY29sdW1uV2lkdGggPSBjb2x1bW5MYXlvdXRJbmZvLndpZHRoO1xuICAgICAgICAgICAgdmFyIHZhbHVlQXhpcyA9IGNhcnRlc2lhbi5nZXRPdGhlckF4aXMoYmFzZUF4aXMpO1xuXG4gICAgICAgICAgICB2YXIgYmFyTWluSGVpZ2h0ID0gc2VyaWVzTW9kZWwuZ2V0KCdiYXJNaW5IZWlnaHQnKSB8fCAwO1xuXG4gICAgICAgICAgICB2YXIgdmFsdWVBeGlzU3RhcnQgPSBiYXNlQXhpcy5vblplcm9cbiAgICAgICAgICAgICAgICA/IHZhbHVlQXhpcy50b0dsb2JhbENvb3JkKHZhbHVlQXhpcy5kYXRhVG9Db29yZCgwKSlcbiAgICAgICAgICAgICAgICA6IHZhbHVlQXhpcy5nZXRHbG9iYWxFeHRlbnQoKVswXTtcblxuICAgICAgICAgICAgdmFyIGNvb3JkcyA9IGNhcnRlc2lhbi5kYXRhVG9Qb2ludHMoZGF0YSwgdHJ1ZSk7XG4gICAgICAgICAgICBsYXN0U3RhY2tDb29yZHNbc3RhY2tJZF0gPSBsYXN0U3RhY2tDb29yZHNbc3RhY2tJZF0gfHwgW107XG5cbiAgICAgICAgICAgIGRhdGEuc2V0TGF5b3V0KHtcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IGNvbHVtbk9mZnNldCxcbiAgICAgICAgICAgICAgICBzaXplOiBjb2x1bW5XaWR0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkYXRhLmVhY2godmFsdWVBeGlzLmRpbSwgZnVuY3Rpb24gKHZhbHVlLCBpZHgpIHtcbiAgICAgICAgICAgICAgICAvLyDnqbrmlbDmja5cbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFsYXN0U3RhY2tDb29yZHNbc3RhY2tJZF1baWR4XSkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0U3RhY2tDb29yZHNbc3RhY2tJZF1baWR4XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvc2l0aXZlIHN0YWNrXG4gICAgICAgICAgICAgICAgICAgICAgICBwOiB2YWx1ZUF4aXNTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5lZ2F0aXZlIHN0YWNrXG4gICAgICAgICAgICAgICAgICAgICAgICBuOiB2YWx1ZUF4aXNTdGFydFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc2lnbiA9IHZhbHVlID49IDAgPyAncCcgOiAnbic7XG4gICAgICAgICAgICAgICAgdmFyIGNvb3JkID0gY29vcmRzW2lkeF07XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RDb29yZCA9IGxhc3RTdGFja0Nvb3Jkc1tzdGFja0lkXVtpZHhdW3NpZ25dO1xuICAgICAgICAgICAgICAgIHZhciB4LCB5LCB3aWR0aCwgaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZUF4aXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IGxhc3RDb29yZDtcbiAgICAgICAgICAgICAgICAgICAgeSA9IGNvb3JkWzFdICsgY29sdW1uT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGNvb3JkWzBdIC0gbGFzdENvb3JkO1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBjb2x1bW5XaWR0aDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMod2lkdGgpIDwgYmFyTWluSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9ICh3aWR0aCA8IDAgPyAtMSA6IDEpICogYmFyTWluSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTdGFja0Nvb3Jkc1tzdGFja0lkXVtpZHhdW3NpZ25dICs9IHdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IGNvb3JkWzBdICsgY29sdW1uT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB5ID0gbGFzdENvb3JkO1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGNvbHVtbldpZHRoO1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBjb29yZFsxXSAtIGxhc3RDb29yZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGhlaWdodCkgPCBiYXJNaW5IZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluY2x1ZGUgemVybyB0byBoYXMgYSBwb3NpdGl2ZSBiYXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IChoZWlnaHQgPD0gMCA/IC0xIDogMSkgKiBiYXJNaW5IZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGFzdFN0YWNrQ29vcmRzW3N0YWNrSWRdW2lkeF1bc2lnbl0gKz0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRhdGEuc2V0SXRlbUxheW91dChpZHgsIHtcbiAgICAgICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhckxheW91dEdyaWQ7XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL2VjaGFydHMvbGF5b3V0L2JhckdyaWQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsImRlZmluZShmdW5jdGlvbihyZXF1aXJlKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKCcuLi91dGlsL2dyYXBoaWMnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9jb3JlL3V0aWwnKTtcbiAgICB2YXIgZWNoYXJ0cyA9IHJlcXVpcmUoJy4uL2VjaGFydHMnKTtcblxuICAgIHJlcXVpcmUoJy4uL2Nvb3JkL2NhcnRlc2lhbi9HcmlkJyk7XG5cbiAgICByZXF1aXJlKCcuL2F4aXMnKTtcblxuICAgIC8vIEdyaWQgdmlld1xuICAgIGVjaGFydHMuZXh0ZW5kQ29tcG9uZW50Vmlldyh7XG5cbiAgICAgICAgdHlwZTogJ2dyaWQnLFxuXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKGdyaWRNb2RlbCwgZWNNb2RlbCkge1xuICAgICAgICAgICAgdGhpcy5ncm91cC5yZW1vdmVBbGwoKTtcbiAgICAgICAgICAgIGlmIChncmlkTW9kZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwLmFkZChuZXcgZ3JhcGhpYy5SZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgc2hhcGU6Z3JpZE1vZGVsLmNvb3JkaW5hdGVTeXN0ZW0uZ2V0UmVjdCgpLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogenJVdGlsLmRlZmF1bHRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IGdyaWRNb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpXG4gICAgICAgICAgICAgICAgICAgIH0sIGdyaWRNb2RlbC5nZXRJdGVtU3R5bGUoKSksXG4gICAgICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZWNoYXJ0cy5yZWdpc3RlclByZXByb2Nlc3NvcihmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgIC8vIE9ubHkgY3JlYXRlIGdyaWQgd2hlbiBuZWVkXG4gICAgICAgIGlmIChvcHRpb24ueEF4aXMgJiYgb3B0aW9uLnlBeGlzICYmICFvcHRpb24uZ3JpZCkge1xuICAgICAgICAgICAgb3B0aW9uLmdyaWQgPSB7fTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC9lY2hhcnRzL2NvbXBvbmVudC9ncmlkLmpzXG4gKiogbW9kdWxlIGlkID0gMTI3XG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCIvLyBUT0RPIGJvdW5kYXJ5R2FwXG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHJlcXVpcmUoJy4uL2Nvb3JkL2NhcnRlc2lhbi9BeGlzTW9kZWwnKTtcblxuICAgIHJlcXVpcmUoJy4vYXhpcy9BeGlzVmlldycpO1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC9lY2hhcnRzL2NvbXBvbmVudC9heGlzLmpzXG4gKiogbW9kdWxlIGlkID0gMTI4XG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCJkZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2NvcmUvdXRpbCcpO1xuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ncmFwaGljJyk7XG4gICAgdmFyIEF4aXNCdWlsZGVyID0gcmVxdWlyZSgnLi9BeGlzQnVpbGRlcicpO1xuICAgIHZhciBpZklnbm9yZU9uVGljayA9IEF4aXNCdWlsZGVyLmlmSWdub3JlT25UaWNrO1xuICAgIHZhciBnZXRJbnRlcnZhbCA9IEF4aXNCdWlsZGVyLmdldEludGVydmFsO1xuXG4gICAgdmFyIGF4aXNCdWlsZGVyQXR0cnMgPSBbXG4gICAgICAgICdheGlzTGluZScsICdheGlzTGFiZWwnLCAnYXhpc1RpY2snLCAnYXhpc05hbWUnXG4gICAgXTtcbiAgICB2YXIgc2VsZkJ1aWxkZXJBdHRycyA9IFtcbiAgICAgICAgJ3NwbGl0QXJlYScsICdzcGxpdExpbmUnXG4gICAgXTtcblxuICAgIC8vIGZ1bmN0aW9uIGdldEFsaWduV2l0aExhYmVsKG1vZGVsLCBheGlzTW9kZWwpIHtcbiAgICAvLyAgICAgdmFyIGFsaWduV2l0aExhYmVsID0gbW9kZWwuZ2V0KCdhbGlnbldpdGhMYWJlbCcpO1xuICAgIC8vICAgICBpZiAoYWxpZ25XaXRoTGFiZWwgPT09ICdhdXRvJykge1xuICAgIC8vICAgICAgICAgYWxpZ25XaXRoTGFiZWwgPSBheGlzTW9kZWwuZ2V0KCdheGlzVGljay5hbGlnbldpdGhMYWJlbCcpO1xuICAgIC8vICAgICB9XG4gICAgLy8gICAgIHJldHVybiBhbGlnbldpdGhMYWJlbDtcbiAgICAvLyB9XG5cbiAgICB2YXIgQXhpc1ZpZXcgPSByZXF1aXJlKCcuLi8uLi9lY2hhcnRzJykuZXh0ZW5kQ29tcG9uZW50Vmlldyh7XG5cbiAgICAgICAgdHlwZTogJ2F4aXMnLFxuXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKGF4aXNNb2RlbCwgZWNNb2RlbCkge1xuXG4gICAgICAgICAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuXG4gICAgICAgICAgICB2YXIgb2xkQXhpc0dyb3VwID0gdGhpcy5fYXhpc0dyb3VwO1xuICAgICAgICAgICAgdGhpcy5fYXhpc0dyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcblxuICAgICAgICAgICAgdGhpcy5ncm91cC5hZGQodGhpcy5fYXhpc0dyb3VwKTtcblxuICAgICAgICAgICAgaWYgKCFheGlzTW9kZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBncmlkTW9kZWwgPSBheGlzTW9kZWwuZmluZEdyaWRNb2RlbCgpO1xuXG4gICAgICAgICAgICB2YXIgbGF5b3V0ID0gbGF5b3V0QXhpcyhncmlkTW9kZWwsIGF4aXNNb2RlbCk7XG5cbiAgICAgICAgICAgIHZhciBheGlzQnVpbGRlciA9IG5ldyBBeGlzQnVpbGRlcihheGlzTW9kZWwsIGxheW91dCk7XG5cbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKGF4aXNCdWlsZGVyQXR0cnMsIGF4aXNCdWlsZGVyLmFkZCwgYXhpc0J1aWxkZXIpO1xuXG4gICAgICAgICAgICB0aGlzLl9heGlzR3JvdXAuYWRkKGF4aXNCdWlsZGVyLmdldEdyb3VwKCkpO1xuXG4gICAgICAgICAgICB6clV0aWwuZWFjaChzZWxmQnVpbGRlckF0dHJzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChheGlzTW9kZWwuZ2V0KG5hbWUgKyAnLnNob3cnKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzWydfJyArIG5hbWVdKGF4aXNNb2RlbCwgZ3JpZE1vZGVsLCBsYXlvdXQubGFiZWxJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIGdyYXBoaWMuZ3JvdXBUcmFuc2l0aW9uKG9sZEF4aXNHcm91cCwgdGhpcy5fYXhpc0dyb3VwLCBheGlzTW9kZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzTW9kZWx9IGF4aXNNb2RlbFxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9HcmlkTW9kZWx9IGdyaWRNb2RlbFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnxGdW5jdGlvbn0gbGFiZWxJbnRlcnZhbFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3NwbGl0TGluZTogZnVuY3Rpb24gKGF4aXNNb2RlbCwgZ3JpZE1vZGVsLCBsYWJlbEludGVydmFsKSB7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IGF4aXNNb2RlbC5heGlzO1xuXG4gICAgICAgICAgICB2YXIgc3BsaXRMaW5lTW9kZWwgPSBheGlzTW9kZWwuZ2V0TW9kZWwoJ3NwbGl0TGluZScpO1xuICAgICAgICAgICAgdmFyIGxpbmVTdHlsZU1vZGVsID0gc3BsaXRMaW5lTW9kZWwuZ2V0TW9kZWwoJ2xpbmVTdHlsZScpO1xuICAgICAgICAgICAgdmFyIGxpbmVDb2xvcnMgPSBsaW5lU3R5bGVNb2RlbC5nZXQoJ2NvbG9yJyk7XG5cbiAgICAgICAgICAgIHZhciBsaW5lSW50ZXJ2YWwgPSBnZXRJbnRlcnZhbChzcGxpdExpbmVNb2RlbCwgbGFiZWxJbnRlcnZhbCk7XG5cbiAgICAgICAgICAgIGxpbmVDb2xvcnMgPSB6clV0aWwuaXNBcnJheShsaW5lQ29sb3JzKSA/IGxpbmVDb2xvcnMgOiBbbGluZUNvbG9yc107XG5cbiAgICAgICAgICAgIHZhciBncmlkUmVjdCA9IGdyaWRNb2RlbC5jb29yZGluYXRlU3lzdGVtLmdldFJlY3QoKTtcbiAgICAgICAgICAgIHZhciBpc0hvcml6b250YWwgPSBheGlzLmlzSG9yaXpvbnRhbCgpO1xuXG4gICAgICAgICAgICB2YXIgbGluZUNvdW50ID0gMDtcblxuICAgICAgICAgICAgdmFyIHRpY2tzQ29vcmRzID0gYXhpcy5nZXRUaWNrc0Nvb3JkcyhcbiAgICAgICAgICAgICAgICAvLyBzcGxpdExpbmVNb2RlbC5nZXQoJ2FsaWduV2l0aExhYmVsJylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB2YXIgdGlja3MgPSBheGlzLnNjYWxlLmdldFRpY2tzKCk7XG5cbiAgICAgICAgICAgIHZhciBwMSA9IFtdO1xuICAgICAgICAgICAgdmFyIHAyID0gW107XG4gICAgICAgICAgICAvLyBTaW1wbGUgb3B0aW1pemF0aW9uXG4gICAgICAgICAgICAvLyBCYXRjaGluZyB0aGUgbGluZXMgaWYgY29sb3IgYXJlIHRoZSBzYW1lXG4gICAgICAgICAgICB2YXIgbGluZVN0eWxlID0gbGluZVN0eWxlTW9kZWwuZ2V0TGluZVN0eWxlKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpY2tzQ29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlmSWdub3JlT25UaWNrKGF4aXMsIGksIGxpbmVJbnRlcnZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHRpY2tDb29yZCA9IGF4aXMudG9HbG9iYWxDb29yZCh0aWNrc0Nvb3Jkc1tpXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHAxWzBdID0gdGlja0Nvb3JkO1xuICAgICAgICAgICAgICAgICAgICBwMVsxXSA9IGdyaWRSZWN0Lnk7XG4gICAgICAgICAgICAgICAgICAgIHAyWzBdID0gdGlja0Nvb3JkO1xuICAgICAgICAgICAgICAgICAgICBwMlsxXSA9IGdyaWRSZWN0LnkgKyBncmlkUmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwMVswXSA9IGdyaWRSZWN0Lng7XG4gICAgICAgICAgICAgICAgICAgIHAxWzFdID0gdGlja0Nvb3JkO1xuICAgICAgICAgICAgICAgICAgICBwMlswXSA9IGdyaWRSZWN0LnggKyBncmlkUmVjdC53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgcDJbMV0gPSB0aWNrQ29vcmQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNvbG9ySW5kZXggPSAobGluZUNvdW50KyspICUgbGluZUNvbG9ycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXhpc0dyb3VwLmFkZChuZXcgZ3JhcGhpYy5MaW5lKGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZUxpbmUoe1xuICAgICAgICAgICAgICAgICAgICBhbmlkOiAnbGluZV8nICsgdGlja3NbaV0sXG5cbiAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxOiBwMVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxOiBwMVsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHgyOiBwMlswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHkyOiBwMlsxXVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogenJVdGlsLmRlZmF1bHRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogbGluZUNvbG9yc1tjb2xvckluZGV4XVxuICAgICAgICAgICAgICAgICAgICB9LCBsaW5lU3R5bGUpLFxuICAgICAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9BeGlzTW9kZWx9IGF4aXNNb2RlbFxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL2Nvb3JkL2NhcnRlc2lhbi9HcmlkTW9kZWx9IGdyaWRNb2RlbFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnxGdW5jdGlvbn0gbGFiZWxJbnRlcnZhbFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3NwbGl0QXJlYTogZnVuY3Rpb24gKGF4aXNNb2RlbCwgZ3JpZE1vZGVsLCBsYWJlbEludGVydmFsKSB7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IGF4aXNNb2RlbC5heGlzO1xuXG4gICAgICAgICAgICB2YXIgc3BsaXRBcmVhTW9kZWwgPSBheGlzTW9kZWwuZ2V0TW9kZWwoJ3NwbGl0QXJlYScpO1xuICAgICAgICAgICAgdmFyIGFyZWFTdHlsZU1vZGVsID0gc3BsaXRBcmVhTW9kZWwuZ2V0TW9kZWwoJ2FyZWFTdHlsZScpO1xuICAgICAgICAgICAgdmFyIGFyZWFDb2xvcnMgPSBhcmVhU3R5bGVNb2RlbC5nZXQoJ2NvbG9yJyk7XG5cbiAgICAgICAgICAgIHZhciBncmlkUmVjdCA9IGdyaWRNb2RlbC5jb29yZGluYXRlU3lzdGVtLmdldFJlY3QoKTtcblxuICAgICAgICAgICAgdmFyIHRpY2tzQ29vcmRzID0gYXhpcy5nZXRUaWNrc0Nvb3JkcyhcbiAgICAgICAgICAgICAgICAvLyBzcGxpdEFyZWFNb2RlbC5nZXQoJ2FsaWduV2l0aExhYmVsJylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB2YXIgdGlja3MgPSBheGlzLnNjYWxlLmdldFRpY2tzKCk7XG5cbiAgICAgICAgICAgIHZhciBwcmV2WCA9IGF4aXMudG9HbG9iYWxDb29yZCh0aWNrc0Nvb3Jkc1swXSk7XG4gICAgICAgICAgICB2YXIgcHJldlkgPSBheGlzLnRvR2xvYmFsQ29vcmQodGlja3NDb29yZHNbMF0pO1xuXG4gICAgICAgICAgICB2YXIgY291bnQgPSAwO1xuXG4gICAgICAgICAgICB2YXIgYXJlYUludGVydmFsID0gZ2V0SW50ZXJ2YWwoc3BsaXRBcmVhTW9kZWwsIGxhYmVsSW50ZXJ2YWwpO1xuXG4gICAgICAgICAgICB2YXIgYXJlYVN0eWxlID0gYXJlYVN0eWxlTW9kZWwuZ2V0QXJlYVN0eWxlKCk7XG4gICAgICAgICAgICBhcmVhQ29sb3JzID0genJVdGlsLmlzQXJyYXkoYXJlYUNvbG9ycykgPyBhcmVhQ29sb3JzIDogW2FyZWFDb2xvcnNdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRpY2tzQ29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlmSWdub3JlT25UaWNrKGF4aXMsIGksIGFyZWFJbnRlcnZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHRpY2tDb29yZCA9IGF4aXMudG9HbG9iYWxDb29yZCh0aWNrc0Nvb3Jkc1tpXSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgeDtcbiAgICAgICAgICAgICAgICB2YXIgeTtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoYXhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgICAgICAgICAgICAgICB4ID0gcHJldlg7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBncmlkUmVjdC55O1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHRpY2tDb29yZCAtIHg7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGdyaWRSZWN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBncmlkUmVjdC54O1xuICAgICAgICAgICAgICAgICAgICB5ID0gcHJldlk7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gZ3JpZFJlY3Qud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IHRpY2tDb29yZCAtIHk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNvbG9ySW5kZXggPSAoY291bnQrKykgJSBhcmVhQ29sb3JzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLl9heGlzR3JvdXAuYWRkKG5ldyBncmFwaGljLlJlY3Qoe1xuICAgICAgICAgICAgICAgICAgICBhbmlkOiAnYXJlYV8nICsgdGlja3NbaV0sXG5cbiAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHpyVXRpbC5kZWZhdWx0cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBhcmVhQ29sb3JzW2NvbG9ySW5kZXhdXG4gICAgICAgICAgICAgICAgICAgIH0sIGFyZWFTdHlsZSksXG4gICAgICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgIHByZXZYID0geCArIHdpZHRoO1xuICAgICAgICAgICAgICAgIHByZXZZID0geSArIGhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgQXhpc1ZpZXcuZXh0ZW5kKHtcbiAgICAgICAgdHlwZTogJ3hBeGlzJ1xuICAgIH0pO1xuICAgIEF4aXNWaWV3LmV4dGVuZCh7XG4gICAgICAgIHR5cGU6ICd5QXhpcydcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxheW91dEF4aXMoZ3JpZE1vZGVsLCBheGlzTW9kZWwpIHtcbiAgICAgICAgdmFyIGdyaWQgPSBncmlkTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcbiAgICAgICAgdmFyIGxheW91dCA9IHt9O1xuXG4gICAgICAgIHZhciByYXdBeGlzUG9zaXRpb24gPSBheGlzLnBvc2l0aW9uO1xuICAgICAgICB2YXIgYXhpc1Bvc2l0aW9uID0gYXhpcy5vblplcm8gPyAnb25aZXJvJyA6IHJhd0F4aXNQb3NpdGlvbjtcbiAgICAgICAgdmFyIGF4aXNEaW0gPSBheGlzLmRpbTtcblxuICAgICAgICAvLyBbbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tXVxuICAgICAgICB2YXIgcmVjdCA9IGdyaWQuZ2V0UmVjdCgpO1xuICAgICAgICB2YXIgcmVjdEJvdW5kID0gW3JlY3QueCwgcmVjdC54ICsgcmVjdC53aWR0aCwgcmVjdC55LCByZWN0LnkgKyByZWN0LmhlaWdodF07XG5cbiAgICAgICAgdmFyIGF4aXNPZmZzZXQgPSBheGlzTW9kZWwuZ2V0KCdvZmZzZXQnKSB8fCAwO1xuXG4gICAgICAgIHZhciBwb3NNYXAgPSB7XG4gICAgICAgICAgICB4OiB7IHRvcDogcmVjdEJvdW5kWzJdIC0gYXhpc09mZnNldCwgYm90dG9tOiByZWN0Qm91bmRbM10gKyBheGlzT2Zmc2V0IH0sXG4gICAgICAgICAgICB5OiB7IGxlZnQ6IHJlY3RCb3VuZFswXSAtIGF4aXNPZmZzZXQsIHJpZ2h0OiByZWN0Qm91bmRbMV0gKyBheGlzT2Zmc2V0IH1cbiAgICAgICAgfTtcblxuICAgICAgICBwb3NNYXAueC5vblplcm8gPSBNYXRoLm1heChNYXRoLm1pbihnZXRaZXJvKCd5JyksIHBvc01hcC54LmJvdHRvbSksIHBvc01hcC54LnRvcCk7XG4gICAgICAgIHBvc01hcC55Lm9uWmVybyA9IE1hdGgubWF4KE1hdGgubWluKGdldFplcm8oJ3gnKSwgcG9zTWFwLnkucmlnaHQpLCBwb3NNYXAueS5sZWZ0KTtcblxuICAgICAgICBmdW5jdGlvbiBnZXRaZXJvKGRpbSwgdmFsKSB7XG4gICAgICAgICAgICB2YXIgdGhlQXhpcyA9IGdyaWQuZ2V0QXhpcyhkaW0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoZUF4aXMudG9HbG9iYWxDb29yZCh0aGVBeGlzLmRhdGFUb0Nvb3JkKDApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEF4aXMgcG9zaXRpb25cbiAgICAgICAgbGF5b3V0LnBvc2l0aW9uID0gW1xuICAgICAgICAgICAgYXhpc0RpbSA9PT0gJ3knID8gcG9zTWFwLnlbYXhpc1Bvc2l0aW9uXSA6IHJlY3RCb3VuZFswXSxcbiAgICAgICAgICAgIGF4aXNEaW0gPT09ICd4JyA/IHBvc01hcC54W2F4aXNQb3NpdGlvbl0gOiByZWN0Qm91bmRbM11cbiAgICAgICAgXTtcblxuICAgICAgICAvLyBBeGlzIHJvdGF0aW9uXG4gICAgICAgIGxheW91dC5yb3RhdGlvbiA9IE1hdGguUEkgLyAyICogKGF4aXNEaW0gPT09ICd4JyA/IDAgOiAxKTtcblxuICAgICAgICAvLyBUaWNrIGFuZCBsYWJlbCBkaXJlY3Rpb24sIHggeSBpcyBheGlzRGltXG4gICAgICAgIHZhciBkaXJNYXAgPSB7dG9wOiAtMSwgYm90dG9tOiAxLCBsZWZ0OiAtMSwgcmlnaHQ6IDF9O1xuXG4gICAgICAgIGxheW91dC5sYWJlbERpcmVjdGlvbiA9IGxheW91dC50aWNrRGlyZWN0aW9uID0gbGF5b3V0Lm5hbWVEaXJlY3Rpb24gPSBkaXJNYXBbcmF3QXhpc1Bvc2l0aW9uXTtcbiAgICAgICAgaWYgKGF4aXMub25aZXJvKSB7XG4gICAgICAgICAgICBsYXlvdXQubGFiZWxPZmZzZXQgPSBwb3NNYXBbYXhpc0RpbV1bcmF3QXhpc1Bvc2l0aW9uXSAtIHBvc01hcFtheGlzRGltXS5vblplcm87XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXhpc01vZGVsLmdldE1vZGVsKCdheGlzVGljaycpLmdldCgnaW5zaWRlJykpIHtcbiAgICAgICAgICAgIGxheW91dC50aWNrRGlyZWN0aW9uID0gLWxheW91dC50aWNrRGlyZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChheGlzTW9kZWwuZ2V0TW9kZWwoJ2F4aXNMYWJlbCcpLmdldCgnaW5zaWRlJykpIHtcbiAgICAgICAgICAgIGxheW91dC5sYWJlbERpcmVjdGlvbiA9IC1sYXlvdXQubGFiZWxEaXJlY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTcGVjaWFsIGxhYmVsIHJvdGF0aW9uXG4gICAgICAgIHZhciBsYWJlbFJvdGF0aW9uID0gYXhpc01vZGVsLmdldE1vZGVsKCdheGlzTGFiZWwnKS5nZXQoJ3JvdGF0ZScpO1xuICAgICAgICBsYXlvdXQubGFiZWxSb3RhdGlvbiA9IGF4aXNQb3NpdGlvbiA9PT0gJ3RvcCcgPyAtbGFiZWxSb3RhdGlvbiA6IGxhYmVsUm90YXRpb247XG5cbiAgICAgICAgLy8gbGFiZWwgaW50ZXJ2YWwgd2hlbiBhdXRvIG1vZGUuXG4gICAgICAgIGxheW91dC5sYWJlbEludGVydmFsID0gYXhpcy5nZXRMYWJlbEludGVydmFsKCk7XG5cbiAgICAgICAgLy8gT3ZlciBzcGxpdExpbmUgYW5kIHNwbGl0QXJlYVxuICAgICAgICBsYXlvdXQuejIgPSAxO1xuXG4gICAgICAgIHJldHVybiBsYXlvdXQ7XG4gICAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC9lY2hhcnRzL2NvbXBvbmVudC9heGlzL0F4aXNWaWV3LmpzXG4gKiogbW9kdWxlIGlkID0gMTI5XG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCJkZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2NvcmUvdXRpbCcpO1xuICAgIHZhciBmb3JtYXRVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9mb3JtYXQnKTtcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZ3JhcGhpYycpO1xuICAgIHZhciBNb2RlbCA9IHJlcXVpcmUoJy4uLy4uL21vZGVsL01vZGVsJyk7XG4gICAgdmFyIG51bWJlclV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL251bWJlcicpO1xuICAgIHZhciByZW1SYWRpYW4gPSBudW1iZXJVdGlsLnJlbVJhZGlhbjtcbiAgICB2YXIgaXNSYWRpYW5Bcm91bmRaZXJvID0gbnVtYmVyVXRpbC5pc1JhZGlhbkFyb3VuZFplcm87XG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCd6cmVuZGVyL2NvcmUvdmVjdG9yJyk7XG4gICAgdmFyIHYyQXBwbHlUcmFuc2Zvcm0gPSB2ZWMyLmFwcGx5VHJhbnNmb3JtO1xuICAgIHZhciByZXRyaWV2ZSA9IHpyVXRpbC5yZXRyaWV2ZTtcblxuICAgIHZhciBQSSA9IE1hdGguUEk7XG5cbiAgICBmdW5jdGlvbiBtYWtlQXhpc0V2ZW50RGF0YUJhc2UoYXhpc01vZGVsKSB7XG4gICAgICAgIHZhciBldmVudERhdGEgPSB7XG4gICAgICAgICAgICBjb21wb25lbnRUeXBlOiBheGlzTW9kZWwubWFpblR5cGVcbiAgICAgICAgfTtcbiAgICAgICAgZXZlbnREYXRhW2F4aXNNb2RlbC5tYWluVHlwZSArICdJbmRleCddID0gYXhpc01vZGVsLmNvbXBvbmVudEluZGV4O1xuICAgICAgICByZXR1cm4gZXZlbnREYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgZmluYWwgYXhpcyBpcyB0cmFuc2xhdGVkIGFuZCByb3RhdGVkIGZyb20gYSBcInN0YW5kYXJkIGF4aXNcIi5cbiAgICAgKiBTbyBvcHQucG9zaXRpb24gYW5kIG9wdC5yb3RhdGlvbiBpcyByZXF1aXJlZC5cbiAgICAgKlxuICAgICAqIEEgc3RhbmRhcmQgYXhpcyBpcyBhbmQgYXhpcyBmcm9tIFswLCAwXSB0byBbMCwgYXhpc0V4dGVudFsxXV0sXG4gICAgICogZm9yIGV4YW1wbGU6ICgwLCAwKSAtLS0tLS0tLS0tLS0+ICgwLCA1MClcbiAgICAgKlxuICAgICAqIG5hbWVEaXJlY3Rpb24gb3IgdGlja0RpcmVjdGlvbiBvciBsYWJlbERpcmVjdGlvbiBpcyAxIG1lYW5zIHRpY2tcbiAgICAgKiBvciBsYWJlbCBpcyBiZWxvdyB0aGUgc3RhbmRhcmQgYXhpcywgd2hlcmVhcyBpcyAtMSBtZWFucyBhYm92ZVxuICAgICAqIHRoZSBzdGFuZGFyZCBheGlzLiBsYWJlbE9mZnNldCBtZWFucyBvZmZzZXQgYmV0d2VlbiBsYWJlbCBhbmQgYXhpcyxcbiAgICAgKiB3aGljaCBpcyB1c2VmdWwgd2hlbiAnb25aZXJvJywgd2hlcmUgYXhpc0xhYmVsIGlzIGluIHRoZSBncmlkIGFuZFxuICAgICAqIGxhYmVsIGluIG91dHNpZGUgZ3JpZC5cbiAgICAgKlxuICAgICAqIFRpcHM6IGxpa2UgYWx3YXlzLFxuICAgICAqIHBvc2l0aXZlIHJvdGF0aW9uIHJlcHJlc2VudHMgYW50aWNsb2Nrd2lzZSwgYW5kIG5lZ2F0aXZlIHJvdGF0aW9uXG4gICAgICogcmVwcmVzZW50cyBjbG9ja3dpc2UuXG4gICAgICogVGhlIGRpcmVjdGlvbiBvZiBwb3NpdGlvbiBjb29yZGluYXRlIGlzIHRoZSBzYW1lIGFzIHRoZSBkaXJlY3Rpb25cbiAgICAgKiBvZiBzY3JlZW4gY29vcmRpbmF0ZS5cbiAgICAgKlxuICAgICAqIERvIG5vdCBuZWVkIHRvIGNvbnNpZGVyIGF4aXMgJ2ludmVyc2UnLCB3aGljaCBpcyBhdXRvIHByb2Nlc3NlZCBieVxuICAgICAqIGF4aXMgZXh0ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9jb250YWluZXIvR3JvdXB9IGdyb3VwXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGF4aXNNb2RlbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHQgU3RhbmRhcmQgYXhpcyBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG9wdC5wb3NpdGlvbiBbeCwgeV1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0LnJvdGF0aW9uIGJ5IHJhZGlhblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0Lm5hbWVEaXJlY3Rpb249MV0gMSBvciAtMSBVc2VkIHdoZW4gbmFtZUxvY2F0aW9uIGlzICdtaWRkbGUnLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LnRpY2tEaXJlY3Rpb249MV0gMSBvciAtMVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LmxhYmVsRGlyZWN0aW9uPTFdIDEgb3IgLTFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5sYWJlbE9mZnNldD0wXSBVc2VmdWxsIHdoZW4gb25aZXJvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0LmF4aXNMYWJlbFNob3ddIGRlZmF1bHQgZ2V0IGZyb20gYXhpc01vZGVsLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0LmF4aXNOYW1lXSBkZWZhdWx0IGdldCBmcm9tIGF4aXNNb2RlbC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5heGlzTmFtZUF2YWlsYWJsZVdpZHRoXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0LmxhYmVsUm90YXRpb25dIGJ5IGRlZ3JlZSwgZGVmYXVsdCBnZXQgZnJvbSBheGlzTW9kZWwuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHQubGFiZWxJbnRlcnZhbF0gRGVmYXVsdCBsYWJlbCBpbnRlcnZhbCB3aGVuIGxhYmVsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwgZnJvbSBtb2RlbCBpcyBudWxsIG9yICdhdXRvJy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdC5zdHJva2VDb250YWluVGhyZXNob2xkXSBEZWZhdWx0IGxhYmVsIGludGVydmFsIHdoZW4gbGFiZWxcbiAgICAgKi9cbiAgICB2YXIgQXhpc0J1aWxkZXIgPSBmdW5jdGlvbiAoYXhpc01vZGVsLCBvcHQpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wdCA9IG9wdDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmF4aXNNb2RlbCA9IGF4aXNNb2RlbDtcblxuICAgICAgICAvLyBEZWZhdWx0IHZhbHVlXG4gICAgICAgIHpyVXRpbC5kZWZhdWx0cyhcbiAgICAgICAgICAgIG9wdCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsYWJlbE9mZnNldDogMCxcbiAgICAgICAgICAgICAgICBuYW1lRGlyZWN0aW9uOiAxLFxuICAgICAgICAgICAgICAgIHRpY2tEaXJlY3Rpb246IDEsXG4gICAgICAgICAgICAgICAgbGFiZWxEaXJlY3Rpb246IDEsXG4gICAgICAgICAgICAgICAgc2lsZW50OiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG5cbiAgICAgICAgLy8gRklYTUUgTm90IHVzZSBhIHNlcGVyYXRlIHRleHQgZ3JvdXA/XG4gICAgICAgIHZhciBkdW1iR3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCh7XG4gICAgICAgICAgICBwb3NpdGlvbjogb3B0LnBvc2l0aW9uLnNsaWNlKCksXG4gICAgICAgICAgICByb3RhdGlvbjogb3B0LnJvdGF0aW9uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHRoaXMuZ3JvdXAuYWRkKGR1bWJHcm91cCk7XG4gICAgICAgIC8vIHRoaXMuX2R1bWJHcm91cCA9IGR1bWJHcm91cDtcblxuICAgICAgICBkdW1iR3JvdXAudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybSA9IGR1bWJHcm91cC50cmFuc2Zvcm07XG5cbiAgICAgICAgdGhpcy5fZHVtYkdyb3VwID0gZHVtYkdyb3VwO1xuICAgIH07XG5cbiAgICBBeGlzQnVpbGRlci5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IEF4aXNCdWlsZGVyLFxuXG4gICAgICAgIGhhc0J1aWxkZXI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gISFidWlsZGVyc1tuYW1lXTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZGQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBidWlsZGVyc1tuYW1lXS5jYWxsKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEdyb3VwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ncm91cDtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHZhciBidWlsZGVycyA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIGF4aXNMaW5lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3B0ID0gdGhpcy5vcHQ7XG4gICAgICAgICAgICB2YXIgYXhpc01vZGVsID0gdGhpcy5heGlzTW9kZWw7XG5cbiAgICAgICAgICAgIGlmICghYXhpc01vZGVsLmdldCgnYXhpc0xpbmUuc2hvdycpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gdGhpcy5heGlzTW9kZWwuYXhpcy5nZXRFeHRlbnQoKTtcblxuICAgICAgICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuX3RyYW5zZm9ybTtcbiAgICAgICAgICAgIHZhciBwdDEgPSBbZXh0ZW50WzBdLCAwXTtcbiAgICAgICAgICAgIHZhciBwdDIgPSBbZXh0ZW50WzFdLCAwXTtcbiAgICAgICAgICAgIGlmIChtYXRyaXgpIHtcbiAgICAgICAgICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKHB0MSwgcHQxLCBtYXRyaXgpO1xuICAgICAgICAgICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocHQyLCBwdDIsIG1hdHJpeCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZ3JvdXAuYWRkKG5ldyBncmFwaGljLkxpbmUoZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplTGluZSh7XG5cbiAgICAgICAgICAgICAgICAvLyBJZCBmb3IgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgYW5pZDogJ2xpbmUnLFxuXG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgeDE6IHB0MVswXSxcbiAgICAgICAgICAgICAgICAgICAgeTE6IHB0MVsxXSxcbiAgICAgICAgICAgICAgICAgICAgeDI6IHB0MlswXSxcbiAgICAgICAgICAgICAgICAgICAgeTI6IHB0MlsxXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3R5bGU6IHpyVXRpbC5leHRlbmQoXG4gICAgICAgICAgICAgICAgICAgIHtsaW5lQ2FwOiAncm91bmQnfSxcbiAgICAgICAgICAgICAgICAgICAgYXhpc01vZGVsLmdldE1vZGVsKCdheGlzTGluZS5saW5lU3R5bGUnKS5nZXRMaW5lU3R5bGUoKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgc3Ryb2tlQ29udGFpblRocmVzaG9sZDogb3B0LnN0cm9rZUNvbnRhaW5UaHJlc2hvbGQgfHwgNSxcbiAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgejI6IDFcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBheGlzVGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGF4aXNNb2RlbCA9IHRoaXMuYXhpc01vZGVsO1xuXG4gICAgICAgICAgICBpZiAoIWF4aXNNb2RlbC5nZXQoJ2F4aXNUaWNrLnNob3cnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGF4aXMgPSBheGlzTW9kZWwuYXhpcztcbiAgICAgICAgICAgIHZhciB0aWNrTW9kZWwgPSBheGlzTW9kZWwuZ2V0TW9kZWwoJ2F4aXNUaWNrJyk7XG4gICAgICAgICAgICB2YXIgb3B0ID0gdGhpcy5vcHQ7XG5cbiAgICAgICAgICAgIHZhciBsaW5lU3R5bGVNb2RlbCA9IHRpY2tNb2RlbC5nZXRNb2RlbCgnbGluZVN0eWxlJyk7XG4gICAgICAgICAgICB2YXIgdGlja0xlbiA9IHRpY2tNb2RlbC5nZXQoJ2xlbmd0aCcpO1xuXG4gICAgICAgICAgICB2YXIgdGlja0ludGVydmFsID0gZ2V0SW50ZXJ2YWwodGlja01vZGVsLCBvcHQubGFiZWxJbnRlcnZhbCk7XG4gICAgICAgICAgICB2YXIgdGlja3NDb29yZHMgPSBheGlzLmdldFRpY2tzQ29vcmRzKHRpY2tNb2RlbC5nZXQoJ2FsaWduV2l0aExhYmVsJykpO1xuICAgICAgICAgICAgdmFyIHRpY2tzID0gYXhpcy5zY2FsZS5nZXRUaWNrcygpO1xuXG4gICAgICAgICAgICB2YXIgcHQxID0gW107XG4gICAgICAgICAgICB2YXIgcHQyID0gW107XG4gICAgICAgICAgICB2YXIgbWF0cml4ID0gdGhpcy5fdHJhbnNmb3JtO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpY2tzQ29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSBvcmRpbmFsIHNjYWxlIHN1cHBvcnQgdGljayBpbnRlcnZhbFxuICAgICAgICAgICAgICAgIGlmIChpZklnbm9yZU9uVGljayhheGlzLCBpLCB0aWNrSW50ZXJ2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdGlja0Nvb3JkID0gdGlja3NDb29yZHNbaV07XG5cbiAgICAgICAgICAgICAgICBwdDFbMF0gPSB0aWNrQ29vcmQ7XG4gICAgICAgICAgICAgICAgcHQxWzFdID0gMDtcbiAgICAgICAgICAgICAgICBwdDJbMF0gPSB0aWNrQ29vcmQ7XG4gICAgICAgICAgICAgICAgcHQyWzFdID0gb3B0LnRpY2tEaXJlY3Rpb24gKiB0aWNrTGVuO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hdHJpeCkge1xuICAgICAgICAgICAgICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKHB0MSwgcHQxLCBtYXRyaXgpO1xuICAgICAgICAgICAgICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKHB0MiwgcHQyLCBtYXRyaXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaWNrIGxpbmUsIE5vdCB1c2UgZ3JvdXAgdHJhbnNmb3JtIHRvIGhhdmUgYmV0dGVyIGxpbmUgZHJhd1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXAuYWRkKG5ldyBncmFwaGljLkxpbmUoZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplTGluZSh7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWQgZm9yIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgICAgICBhbmlkOiAndGlja18nICsgdGlja3NbaV0sXG5cbiAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxOiBwdDFbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB5MTogcHQxWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgeDI6IHB0MlswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHkyOiBwdDJbMV1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHpyVXRpbC5kZWZhdWx0cyhcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVTdHlsZU1vZGVsLmdldExpbmVTdHlsZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogYXhpc01vZGVsLmdldCgnYXhpc0xpbmUubGluZVN0eWxlLmNvbG9yJylcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgejI6IDIsXG4gICAgICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0F4aXNNb2RlbH0gYXhpc01vZGVsXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29vcmQvY2FydGVzaWFuL0dyaWRNb2RlbH0gZ3JpZE1vZGVsXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBheGlzTGFiZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvcHQgPSB0aGlzLm9wdDtcbiAgICAgICAgICAgIHZhciBheGlzTW9kZWwgPSB0aGlzLmF4aXNNb2RlbDtcbiAgICAgICAgICAgIHZhciBzaG93ID0gcmV0cmlldmUob3B0LmF4aXNMYWJlbFNob3csIGF4aXNNb2RlbC5nZXQoJ2F4aXNMYWJlbC5zaG93JykpO1xuXG4gICAgICAgICAgICBpZiAoIXNob3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBheGlzID0gYXhpc01vZGVsLmF4aXM7XG4gICAgICAgICAgICB2YXIgbGFiZWxNb2RlbCA9IGF4aXNNb2RlbC5nZXRNb2RlbCgnYXhpc0xhYmVsJyk7XG4gICAgICAgICAgICB2YXIgdGV4dFN0eWxlTW9kZWwgPSBsYWJlbE1vZGVsLmdldE1vZGVsKCd0ZXh0U3R5bGUnKTtcbiAgICAgICAgICAgIHZhciBsYWJlbE1hcmdpbiA9IGxhYmVsTW9kZWwuZ2V0KCdtYXJnaW4nKTtcbiAgICAgICAgICAgIHZhciB0aWNrcyA9IGF4aXMuc2NhbGUuZ2V0VGlja3MoKTtcbiAgICAgICAgICAgIHZhciBsYWJlbHMgPSBheGlzTW9kZWwuZ2V0Rm9ybWF0dGVkTGFiZWxzKCk7XG5cbiAgICAgICAgICAgIC8vIFNwZWNpYWwgbGFiZWwgcm90YXRlLlxuICAgICAgICAgICAgdmFyIGxhYmVsUm90YXRpb24gPSByZXRyaWV2ZShvcHQubGFiZWxSb3RhdGlvbiwgbGFiZWxNb2RlbC5nZXQoJ3JvdGF0ZScpKSB8fCAwO1xuICAgICAgICAgICAgLy8gVG8gcmFkaWFuLlxuICAgICAgICAgICAgbGFiZWxSb3RhdGlvbiA9IGxhYmVsUm90YXRpb24gKiBQSSAvIDE4MDtcblxuICAgICAgICAgICAgdmFyIGxhYmVsTGF5b3V0ID0gaW5uZXJUZXh0TGF5b3V0KG9wdCwgbGFiZWxSb3RhdGlvbiwgb3B0LmxhYmVsRGlyZWN0aW9uKTtcbiAgICAgICAgICAgIHZhciBjYXRlZ29yeURhdGEgPSBheGlzTW9kZWwuZ2V0KCdkYXRhJyk7XG5cbiAgICAgICAgICAgIHZhciB0ZXh0RWxzID0gW107XG4gICAgICAgICAgICB2YXIgc2lsZW50ID0gaXNTaWxlbnQoYXhpc01vZGVsKTtcbiAgICAgICAgICAgIHZhciB0cmlnZ2VyRXZlbnQgPSBheGlzTW9kZWwuZ2V0KCd0cmlnZ2VyRXZlbnQnKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpZklnbm9yZU9uVGljayhheGlzLCBpLCBvcHQubGFiZWxJbnRlcnZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBpdGVtVGV4dFN0eWxlTW9kZWwgPSB0ZXh0U3R5bGVNb2RlbDtcbiAgICAgICAgICAgICAgICBpZiAoY2F0ZWdvcnlEYXRhICYmIGNhdGVnb3J5RGF0YVtpXSAmJiBjYXRlZ29yeURhdGFbaV0udGV4dFN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1UZXh0U3R5bGVNb2RlbCA9IG5ldyBNb2RlbChcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGVnb3J5RGF0YVtpXS50ZXh0U3R5bGUsIHRleHRTdHlsZU1vZGVsLCBheGlzTW9kZWwuZWNNb2RlbFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdGV4dENvbG9yID0gaXRlbVRleHRTdHlsZU1vZGVsLmdldFRleHRDb2xvcigpXG4gICAgICAgICAgICAgICAgICAgIHx8IGF4aXNNb2RlbC5nZXQoJ2F4aXNMaW5lLmxpbmVTdHlsZS5jb2xvcicpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHRpY2tDb29yZCA9IGF4aXMuZGF0YVRvQ29vcmQodGlja3NbaV0pO1xuICAgICAgICAgICAgICAgIHZhciBwb3MgPSBbXG4gICAgICAgICAgICAgICAgICAgIHRpY2tDb29yZCxcbiAgICAgICAgICAgICAgICAgICAgb3B0LmxhYmVsT2Zmc2V0ICsgb3B0LmxhYmVsRGlyZWN0aW9uICogbGFiZWxNYXJnaW5cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIHZhciBsYWJlbEJlZm9yZUZvcm1hdCA9IGF4aXMuc2NhbGUuZ2V0TGFiZWwodGlja3NbaV0pO1xuXG4gICAgICAgICAgICAgICAgdmFyIHRleHRFbCA9IG5ldyBncmFwaGljLlRleHQoe1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElkIGZvciBhbmltYXRpb25cbiAgICAgICAgICAgICAgICAgICAgYW5pZDogJ2xhYmVsXycgKyB0aWNrc1tpXSxcblxuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogbGFiZWxzW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduOiBpdGVtVGV4dFN0eWxlTW9kZWwuZ2V0KCdhbGlnbicsIHRydWUpIHx8IGxhYmVsTGF5b3V0LnRleHRBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFsaWduOiBpdGVtVGV4dFN0eWxlTW9kZWwuZ2V0KCdiYXNlbGluZScsIHRydWUpIHx8IGxhYmVsTGF5b3V0LnZlcnRpY2FsQWxpZ24sXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Rm9udDogaXRlbVRleHRTdHlsZU1vZGVsLmdldEZvbnQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IHR5cGVvZiB0ZXh0Q29sb3IgPT09ICdmdW5jdGlvbicgPyB0ZXh0Q29sb3IobGFiZWxCZWZvcmVGb3JtYXQpIDogdGV4dENvbG9yXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3MsXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uOiBsYWJlbExheW91dC5yb3RhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgc2lsZW50OiBzaWxlbnQsXG4gICAgICAgICAgICAgICAgICAgIHoyOiAxMFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gUGFjayBkYXRhIGZvciBtb3VzZSBldmVudFxuICAgICAgICAgICAgICAgIGlmICh0cmlnZ2VyRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dEVsLmV2ZW50RGF0YSA9IG1ha2VBeGlzRXZlbnREYXRhQmFzZShheGlzTW9kZWwpO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0RWwuZXZlbnREYXRhLnRhcmdldFR5cGUgPSAnYXhpc0xhYmVsJztcbiAgICAgICAgICAgICAgICAgICAgdGV4dEVsLmV2ZW50RGF0YS52YWx1ZSA9IGxhYmVsQmVmb3JlRm9ybWF0O1xuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgICAgICB0aGlzLl9kdW1iR3JvdXAuYWRkKHRleHRFbCk7XG4gICAgICAgICAgICAgICAgdGV4dEVsLnVwZGF0ZVRyYW5zZm9ybSgpO1xuXG4gICAgICAgICAgICAgICAgdGV4dEVscy5wdXNoKHRleHRFbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cC5hZGQodGV4dEVsKTtcblxuICAgICAgICAgICAgICAgIHRleHRFbC5kZWNvbXBvc2VUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gaXNUd29MYWJlbE92ZXJsYXBwZWQoY3VycmVudCwgbmV4dCkge1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdFJlY3QgPSBjdXJyZW50ICYmIGN1cnJlbnQuZ2V0Qm91bmRpbmdSZWN0KCkuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFJlY3QgPSBuZXh0ICYmIG5leHQuZ2V0Qm91bmRpbmdSZWN0KCkuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RSZWN0ICYmIG5leHRSZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0UmVjdC5hcHBseVRyYW5zZm9ybShjdXJyZW50LmdldExvY2FsVHJhbnNmb3JtKCkpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0UmVjdC5hcHBseVRyYW5zZm9ybShuZXh0LmdldExvY2FsVHJhbnNmb3JtKCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlyc3RSZWN0LmludGVyc2VjdChuZXh0UmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF4aXMudHlwZSAhPT0gJ2NhdGVnb3J5Jykge1xuICAgICAgICAgICAgICAgIC8vIElmIG1pbiBvciBtYXggYXJlIHVzZXIgc2V0LCB3ZSBuZWVkIHRvIGNoZWNrXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHRpY2sgb24gbWluKG1heCkgYXJlIG92ZXJsYXAgb24gdGhlaXIgbmVpZ2hib3VyIHRpY2tcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGV5IGFyZSBvdmVybGFwcGVkLCB3ZSBuZWVkIHRvIGhpZGUgdGhlIG1pbihtYXgpIHRpY2sgbGFiZWxcbiAgICAgICAgICAgICAgICBpZiAoYXhpc01vZGVsLmdldE1pbiA/IGF4aXNNb2RlbC5nZXRNaW4oKSA6IGF4aXNNb2RlbC5nZXQoJ21pbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdExhYmVsID0gdGV4dEVsc1swXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRMYWJlbCA9IHRleHRFbHNbMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1R3b0xhYmVsT3ZlcmxhcHBlZChmaXJzdExhYmVsLCBuZXh0TGFiZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdExhYmVsLmlnbm9yZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGF4aXNNb2RlbC5nZXRNYXggPyBheGlzTW9kZWwuZ2V0TWF4KCkgOiBheGlzTW9kZWwuZ2V0KCdtYXgnKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdExhYmVsID0gdGV4dEVsc1t0ZXh0RWxzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldkxhYmVsID0gdGV4dEVsc1t0ZXh0RWxzLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNUd29MYWJlbE92ZXJsYXBwZWQocHJldkxhYmVsLCBsYXN0TGFiZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0TGFiZWwuaWdub3JlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIGF4aXNOYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3B0ID0gdGhpcy5vcHQ7XG4gICAgICAgICAgICB2YXIgYXhpc01vZGVsID0gdGhpcy5heGlzTW9kZWw7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHJldHJpZXZlKG9wdC5heGlzTmFtZSwgYXhpc01vZGVsLmdldCgnbmFtZScpKTtcblxuICAgICAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbmFtZUxvY2F0aW9uID0gYXhpc01vZGVsLmdldCgnbmFtZUxvY2F0aW9uJyk7XG4gICAgICAgICAgICB2YXIgbmFtZURpcmVjdGlvbiA9IG9wdC5uYW1lRGlyZWN0aW9uO1xuICAgICAgICAgICAgdmFyIHRleHRTdHlsZU1vZGVsID0gYXhpc01vZGVsLmdldE1vZGVsKCduYW1lVGV4dFN0eWxlJyk7XG4gICAgICAgICAgICB2YXIgZ2FwID0gYXhpc01vZGVsLmdldCgnbmFtZUdhcCcpIHx8IDA7XG5cbiAgICAgICAgICAgIHZhciBleHRlbnQgPSB0aGlzLmF4aXNNb2RlbC5heGlzLmdldEV4dGVudCgpO1xuICAgICAgICAgICAgdmFyIGdhcFNpZ25hbCA9IGV4dGVudFswXSA+IGV4dGVudFsxXSA/IC0xIDogMTtcbiAgICAgICAgICAgIHZhciBwb3MgPSBbXG4gICAgICAgICAgICAgICAgbmFtZUxvY2F0aW9uID09PSAnc3RhcnQnXG4gICAgICAgICAgICAgICAgICAgID8gZXh0ZW50WzBdIC0gZ2FwU2lnbmFsICogZ2FwXG4gICAgICAgICAgICAgICAgICAgIDogbmFtZUxvY2F0aW9uID09PSAnZW5kJ1xuICAgICAgICAgICAgICAgICAgICA/IGV4dGVudFsxXSArIGdhcFNpZ25hbCAqIGdhcFxuICAgICAgICAgICAgICAgICAgICA6IChleHRlbnRbMF0gKyBleHRlbnRbMV0pIC8gMiwgLy8gJ21pZGRsZSdcbiAgICAgICAgICAgICAgICAvLyBSZXVzZSBsYWJlbE9mZnNldC5cbiAgICAgICAgICAgICAgICBuYW1lTG9jYXRpb24gPT09ICdtaWRkbGUnID8gb3B0LmxhYmVsT2Zmc2V0ICsgbmFtZURpcmVjdGlvbiAqIGdhcCA6IDBcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIHZhciBsYWJlbExheW91dDtcblxuICAgICAgICAgICAgdmFyIG5hbWVSb3RhdGlvbiA9IGF4aXNNb2RlbC5nZXQoJ25hbWVSb3RhdGUnKTtcbiAgICAgICAgICAgIGlmIChuYW1lUm90YXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5hbWVSb3RhdGlvbiA9IG5hbWVSb3RhdGlvbiAqIFBJIC8gMTgwOyAvLyBUbyByYWRpYW4uXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBheGlzTmFtZUF2YWlsYWJsZVdpZHRoO1xuXG4gICAgICAgICAgICBpZiAobmFtZUxvY2F0aW9uID09PSAnbWlkZGxlJykge1xuICAgICAgICAgICAgICAgIGxhYmVsTGF5b3V0ID0gaW5uZXJUZXh0TGF5b3V0KFxuICAgICAgICAgICAgICAgICAgICBvcHQsXG4gICAgICAgICAgICAgICAgICAgIG5hbWVSb3RhdGlvbiAhPSBudWxsID8gbmFtZVJvdGF0aW9uIDogb3B0LnJvdGF0aW9uLCAvLyBBZGFwdCB0byBheGlzLlxuICAgICAgICAgICAgICAgICAgICBuYW1lRGlyZWN0aW9uXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxhYmVsTGF5b3V0ID0gZW5kVGV4dExheW91dChcbiAgICAgICAgICAgICAgICAgICAgb3B0LCBuYW1lTG9jYXRpb24sIG5hbWVSb3RhdGlvbiB8fCAwLCBleHRlbnRcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgYXhpc05hbWVBdmFpbGFibGVXaWR0aCA9IG9wdC5heGlzTmFtZUF2YWlsYWJsZVdpZHRoO1xuICAgICAgICAgICAgICAgIGlmIChheGlzTmFtZUF2YWlsYWJsZVdpZHRoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYXhpc05hbWVBdmFpbGFibGVXaWR0aCA9IE1hdGguYWJzKFxuICAgICAgICAgICAgICAgICAgICAgICAgYXhpc05hbWVBdmFpbGFibGVXaWR0aCAvIE1hdGguc2luKGxhYmVsTGF5b3V0LnJvdGF0aW9uKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAhaXNGaW5pdGUoYXhpc05hbWVBdmFpbGFibGVXaWR0aCkgJiYgKGF4aXNOYW1lQXZhaWxhYmxlV2lkdGggPSBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0ZXh0Rm9udCA9IHRleHRTdHlsZU1vZGVsLmdldEZvbnQoKTtcblxuICAgICAgICAgICAgdmFyIHRydW5jYXRlT3B0ID0gYXhpc01vZGVsLmdldCgnbmFtZVRydW5jYXRlJywgdHJ1ZSkgfHwge307XG4gICAgICAgICAgICB2YXIgZWxsaXBzaXMgPSB0cnVuY2F0ZU9wdC5lbGxpcHNpcztcbiAgICAgICAgICAgIHZhciBtYXhXaWR0aCA9IHJldHJpZXZlKHRydW5jYXRlT3B0Lm1heFdpZHRoLCBheGlzTmFtZUF2YWlsYWJsZVdpZHRoKTtcbiAgICAgICAgICAgIHZhciB0cnVuY2F0ZWRUZXh0ID0gKGVsbGlwc2lzICE9IG51bGwgJiYgbWF4V2lkdGggIT0gbnVsbClcbiAgICAgICAgICAgICAgICA/IGZvcm1hdFV0aWwudHJ1bmNhdGVUZXh0KFxuICAgICAgICAgICAgICAgICAgICBuYW1lLCBtYXhXaWR0aCwgdGV4dEZvbnQsIGVsbGlwc2lzLFxuICAgICAgICAgICAgICAgICAgICB7bWluQ2hhcjogMiwgcGxhY2Vob2xkZXI6IHRydW5jYXRlT3B0LnBsYWNlaG9sZGVyfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IG5hbWU7XG5cbiAgICAgICAgICAgIHZhciB0b29sdGlwT3B0ID0gYXhpc01vZGVsLmdldCgndG9vbHRpcCcsIHRydWUpO1xuXG4gICAgICAgICAgICB2YXIgbWFpblR5cGUgPSBheGlzTW9kZWwubWFpblR5cGU7XG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVyUGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudFR5cGU6IG1haW5UeXBlLFxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgJHZhcnM6IFsnbmFtZSddXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9ybWF0dGVyUGFyYW1zW21haW5UeXBlICsgJ0luZGV4J10gPSBheGlzTW9kZWwuY29tcG9uZW50SW5kZXg7XG5cbiAgICAgICAgICAgIHZhciB0ZXh0RWwgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcblxuICAgICAgICAgICAgICAgIC8vIElkIGZvciBhbmltYXRpb25cbiAgICAgICAgICAgICAgICBhbmlkOiAnbmFtZScsXG5cbiAgICAgICAgICAgICAgICBfX2Z1bGxUZXh0OiBuYW1lLFxuICAgICAgICAgICAgICAgIF9fdHJ1bmNhdGVkVGV4dDogdHJ1bmNhdGVkVGV4dCxcblxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHRydW5jYXRlZFRleHQsXG4gICAgICAgICAgICAgICAgICAgIHRleHRGb250OiB0ZXh0Rm9udCxcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogdGV4dFN0eWxlTW9kZWwuZ2V0VGV4dENvbG9yKClcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IGF4aXNNb2RlbC5nZXQoJ2F4aXNMaW5lLmxpbmVTdHlsZS5jb2xvcicpLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IGxhYmVsTGF5b3V0LnRleHRBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ246IGxhYmVsTGF5b3V0LnZlcnRpY2FsQWxpZ25cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3MsXG4gICAgICAgICAgICAgICAgcm90YXRpb246IGxhYmVsTGF5b3V0LnJvdGF0aW9uLFxuICAgICAgICAgICAgICAgIHNpbGVudDogaXNTaWxlbnQoYXhpc01vZGVsKSxcbiAgICAgICAgICAgICAgICB6MjogMSxcbiAgICAgICAgICAgICAgICB0b29sdGlwOiAodG9vbHRpcE9wdCAmJiB0b29sdGlwT3B0LnNob3cpXG4gICAgICAgICAgICAgICAgICAgID8genJVdGlsLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyUGFyYW1zOiBmb3JtYXR0ZXJQYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgfSwgdG9vbHRpcE9wdClcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGF4aXNNb2RlbC5nZXQoJ3RyaWdnZXJFdmVudCcpKSB7XG4gICAgICAgICAgICAgICAgdGV4dEVsLmV2ZW50RGF0YSA9IG1ha2VBeGlzRXZlbnREYXRhQmFzZShheGlzTW9kZWwpO1xuICAgICAgICAgICAgICAgIHRleHRFbC5ldmVudERhdGEudGFyZ2V0VHlwZSA9ICdheGlzTmFtZSc7XG4gICAgICAgICAgICAgICAgdGV4dEVsLmV2ZW50RGF0YS5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgIHRoaXMuX2R1bWJHcm91cC5hZGQodGV4dEVsKTtcbiAgICAgICAgICAgIHRleHRFbC51cGRhdGVUcmFuc2Zvcm0oKTtcblxuICAgICAgICAgICAgdGhpcy5ncm91cC5hZGQodGV4dEVsKTtcblxuICAgICAgICAgICAgdGV4dEVsLmRlY29tcG9zZVRyYW5zZm9ybSgpO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5uZXJUZXh0TGF5b3V0KG9wdCwgdGV4dFJvdGF0aW9uLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIHJvdGF0aW9uRGlmZiA9IHJlbVJhZGlhbih0ZXh0Um90YXRpb24gLSBvcHQucm90YXRpb24pO1xuICAgICAgICB2YXIgdGV4dEFsaWduO1xuICAgICAgICB2YXIgdmVydGljYWxBbGlnbjtcblxuICAgICAgICBpZiAoaXNSYWRpYW5Bcm91bmRaZXJvKHJvdGF0aW9uRGlmZikpIHsgLy8gTGFiZWwgaXMgcGFyYWxsZWwgd2l0aCBheGlzIGxpbmUuXG4gICAgICAgICAgICB2ZXJ0aWNhbEFsaWduID0gZGlyZWN0aW9uID4gMCA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gICAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1JhZGlhbkFyb3VuZFplcm8ocm90YXRpb25EaWZmIC0gUEkpKSB7IC8vIExhYmVsIGlzIGludmVyc2UgcGFyYWxsZWwgd2l0aCBheGlzIGxpbmUuXG4gICAgICAgICAgICB2ZXJ0aWNhbEFsaWduID0gZGlyZWN0aW9uID4gMCA/ICdib3R0b20nIDogJ3RvcCc7XG4gICAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcblxuICAgICAgICAgICAgaWYgKHJvdGF0aW9uRGlmZiA+IDAgJiYgcm90YXRpb25EaWZmIDwgUEkpIHtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSBkaXJlY3Rpb24gPiAwID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9IGRpcmVjdGlvbiA+IDAgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJvdGF0aW9uOiByb3RhdGlvbkRpZmYsXG4gICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgICAgIHZlcnRpY2FsQWxpZ246IHZlcnRpY2FsQWxpZ25cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbmRUZXh0TGF5b3V0KG9wdCwgdGV4dFBvc2l0aW9uLCB0ZXh0Um90YXRlLCBleHRlbnQpIHtcbiAgICAgICAgdmFyIHJvdGF0aW9uRGlmZiA9IHJlbVJhZGlhbih0ZXh0Um90YXRlIC0gb3B0LnJvdGF0aW9uKTtcbiAgICAgICAgdmFyIHRleHRBbGlnbjtcbiAgICAgICAgdmFyIHZlcnRpY2FsQWxpZ247XG4gICAgICAgIHZhciBpbnZlcnNlID0gZXh0ZW50WzBdID4gZXh0ZW50WzFdO1xuICAgICAgICB2YXIgb25MZWZ0ID0gKHRleHRQb3NpdGlvbiA9PT0gJ3N0YXJ0JyAmJiAhaW52ZXJzZSlcbiAgICAgICAgICAgIHx8ICh0ZXh0UG9zaXRpb24gIT09ICdzdGFydCcgJiYgaW52ZXJzZSk7XG5cbiAgICAgICAgaWYgKGlzUmFkaWFuQXJvdW5kWmVybyhyb3RhdGlvbkRpZmYgLSBQSSAvIDIpKSB7XG4gICAgICAgICAgICB2ZXJ0aWNhbEFsaWduID0gb25MZWZ0ID8gJ2JvdHRvbScgOiAndG9wJztcbiAgICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUmFkaWFuQXJvdW5kWmVybyhyb3RhdGlvbkRpZmYgLSBQSSAqIDEuNSkpIHtcbiAgICAgICAgICAgIHZlcnRpY2FsQWxpZ24gPSBvbkxlZnQgPyAndG9wJyA6ICdib3R0b20nO1xuICAgICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2ZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG4gICAgICAgICAgICBpZiAocm90YXRpb25EaWZmIDwgUEkgKiAxLjUgJiYgcm90YXRpb25EaWZmID4gUEkgLyAyKSB7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gb25MZWZ0ID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9IG9uTGVmdCA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcm90YXRpb246IHJvdGF0aW9uRGlmZixcbiAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICAgICAgdmVydGljYWxBbGlnbjogdmVydGljYWxBbGlnblxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU2lsZW50KGF4aXNNb2RlbCkge1xuICAgICAgICB2YXIgdG9vbHRpcE9wdCA9IGF4aXNNb2RlbC5nZXQoJ3Rvb2x0aXAnKTtcbiAgICAgICAgcmV0dXJuIGF4aXNNb2RlbC5nZXQoJ3NpbGVudCcpXG4gICAgICAgICAgICAvLyBDb25zaWRlciBtb3VzZSBjdXJzb3IsIGFkZCB0aGVzZSByZXN0cmljdGlvbnMuXG4gICAgICAgICAgICB8fCAhKFxuICAgICAgICAgICAgICAgIGF4aXNNb2RlbC5nZXQoJ3RyaWdnZXJFdmVudCcpIHx8ICh0b29sdGlwT3B0ICYmIHRvb2x0aXBPcHQuc2hvdylcbiAgICAgICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHZhciBpZklnbm9yZU9uVGljayA9IEF4aXNCdWlsZGVyLmlmSWdub3JlT25UaWNrID0gZnVuY3Rpb24gKGF4aXMsIGksIGludGVydmFsKSB7XG4gICAgICAgIHZhciByYXdUaWNrO1xuICAgICAgICB2YXIgc2NhbGUgPSBheGlzLnNjYWxlO1xuICAgICAgICByZXR1cm4gc2NhbGUudHlwZSA9PT0gJ29yZGluYWwnXG4gICAgICAgICAgICAmJiAoXG4gICAgICAgICAgICAgICAgdHlwZW9mIGludGVydmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgID8gKFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3VGljayA9IHNjYWxlLmdldFRpY2tzKClbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAhaW50ZXJ2YWwocmF3VGljaywgc2NhbGUuZ2V0TGFiZWwocmF3VGljaykpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgOiBpICUgKGludGVydmFsICsgMSlcbiAgICAgICAgICAgICk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgICB2YXIgZ2V0SW50ZXJ2YWwgPSBBeGlzQnVpbGRlci5nZXRJbnRlcnZhbCA9IGZ1bmN0aW9uIChtb2RlbCwgbGFiZWxJbnRlcnZhbCkge1xuICAgICAgICB2YXIgaW50ZXJ2YWwgPSBtb2RlbC5nZXQoJ2ludGVydmFsJyk7XG4gICAgICAgIGlmIChpbnRlcnZhbCA9PSBudWxsIHx8IGludGVydmFsID09ICdhdXRvJykge1xuICAgICAgICAgICAgaW50ZXJ2YWwgPSBsYWJlbEludGVydmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnRlcnZhbDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEF4aXNCdWlsZGVyO1xuXG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL2VjaGFydHMvY29tcG9uZW50L2F4aXMvQXhpc0J1aWxkZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxMzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gM1xuICoqLyIsIi8vIEZJWE1FIEJldHRlciB3YXkgdG8gcGFjayBkYXRhIGluIGdyYXBoaWMgZWxlbWVudFxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cbiAgICByZXF1aXJlKCcuL3Rvb2x0aXAvVG9vbHRpcE1vZGVsJyk7XG5cbiAgICByZXF1aXJlKCcuL3Rvb2x0aXAvVG9vbHRpcFZpZXcnKTtcblxuICAgIC8vIFNob3cgdGlwIGFjdGlvblxuICAgIC8qKlxuICAgICAqIEBhY3Rpb25cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZXJpZXNJbmRleFxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhSW5kZXhcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW3hdXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFt5XVxuICAgICAqL1xuICAgIHJlcXVpcmUoJy4uL2VjaGFydHMnKS5yZWdpc3RlckFjdGlvbihcbiAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogJ3Nob3dUaXAnLFxuICAgICAgICAgICAgZXZlbnQ6ICdzaG93VGlwJyxcbiAgICAgICAgICAgIHVwZGF0ZTogJ25vbmUnXG4gICAgICAgIH0sXG4gICAgICAgIC8vIG5vb3BcbiAgICAgICAgZnVuY3Rpb24gKCkge31cbiAgICApO1xuICAgIC8vIEhpZGUgdGlwIGFjdGlvblxuICAgIHJlcXVpcmUoJy4uL2VjaGFydHMnKS5yZWdpc3RlckFjdGlvbihcbiAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogJ2hpZGVUaXAnLFxuICAgICAgICAgICAgZXZlbnQ6ICdoaWRlVGlwJyxcbiAgICAgICAgICAgIHVwZGF0ZTogJ25vbmUnXG4gICAgICAgIH0sXG4gICAgICAgIC8vIG5vb3BcbiAgICAgICAgZnVuY3Rpb24gKCkge31cbiAgICApO1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC9lY2hhcnRzL2NvbXBvbmVudC90b29sdGlwLmpzXG4gKiogbW9kdWxlIGlkID0gMTMxXG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iLCJkZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUpIHtcblxuICAgIHJlcXVpcmUoJy4uLy4uL2VjaGFydHMnKS5leHRlbmRDb21wb25lbnRNb2RlbCh7XG5cbiAgICAgICAgdHlwZTogJ3Rvb2x0aXAnLFxuXG4gICAgICAgIGRlZmF1bHRPcHRpb246IHtcbiAgICAgICAgICAgIHpsZXZlbDogMCxcblxuICAgICAgICAgICAgejogOCxcblxuICAgICAgICAgICAgc2hvdzogdHJ1ZSxcblxuICAgICAgICAgICAgLy8gdG9vbHRpcOS4u+S9k+WGheWuuVxuICAgICAgICAgICAgc2hvd0NvbnRlbnQ6IHRydWUsXG5cbiAgICAgICAgICAgIC8vIOinpuWPkeexu+Wei++8jOm7mOiupOaVsOaNruinpuWPke+8jOingeS4i+Wbvu+8jOWPr+mAieS4uu+8midpdGVtJyDCpiAnYXhpcydcbiAgICAgICAgICAgIHRyaWdnZXI6ICdpdGVtJyxcblxuICAgICAgICAgICAgLy8g6Kem5Y+R5p2h5Lu277yM5pSv5oyBICdjbGljaycgfCAnbW91c2Vtb3ZlJ1xuICAgICAgICAgICAgdHJpZ2dlck9uOiAnbW91c2Vtb3ZlJyxcblxuICAgICAgICAgICAgLy8g5piv5ZCm5rC46L+c5pi+56S6IGNvbnRlbnRcbiAgICAgICAgICAgIGFsd2F5c1Nob3dDb250ZW50OiBmYWxzZSxcblxuICAgICAgICAgICAgLy8g5L2N572uIHtBcnJheX0gfCB7RnVuY3Rpb259XG4gICAgICAgICAgICAvLyBwb3NpdGlvbjogbnVsbFxuXG4gICAgICAgICAgICAvLyDlhoXlrrnmoLzlvI/lmajvvJp7c3RyaW5nfe+8iFRlbXBsYXRl77yJIMKmIHtGdW5jdGlvbn1cbiAgICAgICAgICAgIC8vIGZvcm1hdHRlcjogbnVsbFxuXG4gICAgICAgICAgICBzaG93RGVsYXk6IDAsXG5cbiAgICAgICAgICAgIC8vIOmakOiXj+W7tui/n++8jOWNleS9jW1zXG4gICAgICAgICAgICBoaWRlRGVsYXk6IDEwMCxcblxuICAgICAgICAgICAgLy8g5Yqo55S75Y+Y5o2i5pe26Ze077yM5Y2V5L2Nc1xuICAgICAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiAwLjQsXG5cbiAgICAgICAgICAgIGVudGVyYWJsZTogZmFsc2UsXG5cbiAgICAgICAgICAgIC8vIOaPkOekuuiDjOaZr+minOiJsu+8jOm7mOiupOS4uumAj+aYjuW6puS4ujAuN+eahOm7keiJslxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSg1MCw1MCw1MCwwLjcpJyxcblxuICAgICAgICAgICAgLy8g5o+Q56S66L655qGG6aKc6ImyXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogJyMzMzMnLFxuXG4gICAgICAgICAgICAvLyDmj5DnpLrovrnmoYblnIbop5LvvIzljZXkvY1weO+8jOm7mOiupOS4ujRcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogNCxcblxuICAgICAgICAgICAgLy8g5o+Q56S66L655qGG57q/5a6977yM5Y2V5L2NcHjvvIzpu5jorqTkuLow77yI5peg6L655qGG77yJXG4gICAgICAgICAgICBib3JkZXJXaWR0aDogMCxcblxuICAgICAgICAgICAgLy8g5o+Q56S65YaF6L656Led77yM5Y2V5L2NcHjvvIzpu5jorqTlkITmlrnlkJHlhoXovrnot53kuLo177yMXG4gICAgICAgICAgICAvLyDmjqXlj5fmlbDnu4TliIbliKvorr7lrprkuIrlj7PkuIvlt6bovrnot53vvIzlkIxjc3NcbiAgICAgICAgICAgIHBhZGRpbmc6IDUsXG5cbiAgICAgICAgICAgIC8vIEV4dHJhIGNzcyB0ZXh0XG4gICAgICAgICAgICBleHRyYUNzc1RleHQ6ICcnLFxuXG4gICAgICAgICAgICAvLyDlnZDmoIfovbTmjIfnpLrlmajvvIzlnZDmoIfovbTop6blj5HmnInmlYhcbiAgICAgICAgICAgIGF4aXNQb2ludGVyOiB7XG4gICAgICAgICAgICAgICAgLy8g6buY6K6k5Li655u057q/XG4gICAgICAgICAgICAgICAgLy8g5Y+v6YCJ5Li677yaJ2xpbmUnIHwgJ3NoYWRvdycgfCAnY3Jvc3MnXG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxuXG4gICAgICAgICAgICAgICAgLy8gdHlwZSDkuLogbGluZSDnmoTml7blgJnmnInmlYjvvIzmjIflrpogdG9vbHRpcCBsaW5lIOaJgOWcqOeahOi9tO+8jOWPr+mAiVxuICAgICAgICAgICAgICAgIC8vIOWPr+mAiSAneCcgfCAneScgfCAnYW5nbGUnIHwgJ3JhZGl1cycgfCAnYXV0bydcbiAgICAgICAgICAgICAgICAvLyDpu5jorqQgJ2F1dG8n77yM5Lya6YCJ5oup57G75Z6L5Li6IGNhdGVvZ3J5IOeahOi9tO+8jOWvueS6juWPjOaVsOWAvOi9tO+8jOesm+WNoeWwlOWdkOagh+ezu+S8mum7mOiupOmAieaLqSB4IOi9tFxuICAgICAgICAgICAgICAgIC8vIOaegeWdkOagh+ezu+S8mum7mOiupOmAieaLqSBhbmdsZSDovbRcbiAgICAgICAgICAgICAgICBheGlzOiAnYXV0bycsXG5cbiAgICAgICAgICAgICAgICBhbmltYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uRHVyYXRpb25VcGRhdGU6IDIwMCxcbiAgICAgICAgICAgICAgICBhbmltYXRpb25FYXNpbmdVcGRhdGU6ICdleHBvbmVudGlhbE91dCcsXG5cbiAgICAgICAgICAgICAgICAvLyDnm7Tnur/mjIfnpLrlmajmoLflvI/orr7nva5cbiAgICAgICAgICAgICAgICBsaW5lU3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICcjNTU1JyxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzb2xpZCdcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgY3Jvc3NTdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogJyM1NTUnLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Rhc2hlZCcsXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBmb3JtYXR0ZXJcbiAgICAgICAgICAgICAgICAgICAgdGV4dFN0eWxlOiB7fVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvLyDpmLTlvbHmjIfnpLrlmajmoLflvI/orr7nva5cbiAgICAgICAgICAgICAgICBzaGFkb3dTdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ3JnYmEoMTUwLDE1MCwxNTAsMC4zKSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGV4dFN0eWxlOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICcjZmZmJyxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogMTRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2RlcC9lY2hhcnRzL2NvbXBvbmVudC90b29sdGlwL1Rvb2x0aXBNb2RlbC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzMlxuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cbiAgICB2YXIgVG9vbHRpcENvbnRlbnQgPSByZXF1aXJlKCcuL1Rvb2x0aXBDb250ZW50Jyk7XG4gICAgdmFyIGdyYXBoaWMgPSByZXF1aXJlKCcuLi8uLi91dGlsL2dyYXBoaWMnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9jb3JlL3V0aWwnKTtcbiAgICB2YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZm9ybWF0Jyk7XG4gICAgdmFyIG51bWJlclV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL251bWJlcicpO1xuICAgIHZhciBwYXJzZVBlcmNlbnQgPSBudW1iZXJVdGlsLnBhcnNlUGVyY2VudDtcbiAgICB2YXIgZW52ID0gcmVxdWlyZSgnenJlbmRlci9jb3JlL2VudicpO1xuICAgIHZhciBNb2RlbCA9IHJlcXVpcmUoJy4uLy4uL21vZGVsL01vZGVsJyk7XG5cbiAgICBmdW5jdGlvbiBkYXRhRXF1YWwoYSwgYikge1xuICAgICAgICBpZiAoIWEgfHwgIWIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcm91bmQgPSBudW1iZXJVdGlsLnJvdW5kO1xuICAgICAgICByZXR1cm4gcm91bmQoYVswXSkgPT09IHJvdW5kKGJbMF0pXG4gICAgICAgICAgICAmJiByb3VuZChhWzFdKSA9PT0gcm91bmQoYlsxXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1ha2VMaW5lU2hhcGUoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHgxOiB4MSxcbiAgICAgICAgICAgIHkxOiB5MSxcbiAgICAgICAgICAgIHgyOiB4MixcbiAgICAgICAgICAgIHkyOiB5MlxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1ha2VSZWN0U2hhcGUoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1ha2VTZWN0b3JTaGFwZShjeCwgY3ksIHIwLCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3g6IGN4LFxuICAgICAgICAgICAgY3k6IGN5LFxuICAgICAgICAgICAgcjA6IHIwLFxuICAgICAgICAgICAgcjogcixcbiAgICAgICAgICAgIHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXG4gICAgICAgICAgICBlbmRBbmdsZTogZW5kQW5nbGUsXG4gICAgICAgICAgICBjbG9ja3dpc2U6IHRydWVcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWZpeFRvb2x0aXBQb3NpdGlvbih4LCB5LCBlbCwgdmlld1dpZHRoLCB2aWV3SGVpZ2h0KSB7XG4gICAgICAgIHZhciB3aWR0aCA9IGVsLmNsaWVudFdpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gZWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICB2YXIgZ2FwID0gMjA7XG5cbiAgICAgICAgaWYgKHggKyB3aWR0aCArIGdhcCA+IHZpZXdXaWR0aCkge1xuICAgICAgICAgICAgeCAtPSB3aWR0aCArIGdhcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHggKz0gZ2FwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5ICsgaGVpZ2h0ICsgZ2FwID4gdmlld0hlaWdodCkge1xuICAgICAgICAgICAgeSAtPSBoZWlnaHQgKyBnYXA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB5ICs9IGdhcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGNUb29sdGlwUG9zaXRpb24ocG9zaXRpb24sIHJlY3QsIGRvbSkge1xuICAgICAgICB2YXIgZG9tV2lkdGggPSBkb20uY2xpZW50V2lkdGg7XG4gICAgICAgIHZhciBkb21IZWlnaHQgPSBkb20uY2xpZW50SGVpZ2h0O1xuICAgICAgICB2YXIgZ2FwID0gNTtcbiAgICAgICAgdmFyIHggPSAwO1xuICAgICAgICB2YXIgeSA9IDA7XG4gICAgICAgIHZhciByZWN0V2lkdGggPSByZWN0LndpZHRoO1xuICAgICAgICB2YXIgcmVjdEhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgICAgICBzd2l0Y2ggKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBjYXNlICdpbnNpZGUnOlxuICAgICAgICAgICAgICAgIHggPSByZWN0LnggKyByZWN0V2lkdGggLyAyIC0gZG9tV2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHkgPSByZWN0LnkgKyByZWN0SGVpZ2h0IC8gMiAtIGRvbUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgIHggPSByZWN0LnggKyByZWN0V2lkdGggLyAyIC0gZG9tV2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHkgPSByZWN0LnkgLSBkb21IZWlnaHQgLSBnYXA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgIHggPSByZWN0LnggKyByZWN0V2lkdGggLyAyIC0gZG9tV2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHkgPSByZWN0LnkgKyByZWN0SGVpZ2h0ICsgZ2FwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgeCA9IHJlY3QueCAtIGRvbVdpZHRoIC0gZ2FwO1xuICAgICAgICAgICAgICAgIHkgPSByZWN0LnkgKyByZWN0SGVpZ2h0IC8gMiAtIGRvbUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgeCA9IHJlY3QueCArIHJlY3RXaWR0aCArIGdhcDtcbiAgICAgICAgICAgICAgICB5ID0gcmVjdC55ICsgcmVjdEhlaWdodCAvIDIgLSBkb21IZWlnaHQgLyAyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfEZ1bmN0aW9ufEFycmF5LjxudW1iZXI+fSBwb3NpdGlvbkV4cHJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHggTW91c2UgeFxuICAgICAqIEBwYXJhbSAge251bWJlcn0geSBNb3VzZSB5XG4gICAgICogQHBhcmFtICB7bW9kdWxlOmVjaGFydHMvY29tcG9uZW50L3Rvb2x0aXAvVG9vbHRpcENvbnRlbnR9IGNvbnRlbnRcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R8PEFycmF5LjxPYmplY3Q+fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbCB0YXJnZXQgZWxlbWVudFxuICAgICAqIEBwYXJhbSAge21vZHVsZTplY2hhcnRzL0V4dGVuc2lvbkFQSX0gYXBpXG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlUG9zaXRpb24ocG9zaXRpb25FeHByLCB4LCB5LCBjb250ZW50LCBwYXJhbXMsIGVsLCBhcGkpIHtcbiAgICAgICAgdmFyIHZpZXdXaWR0aCA9IGFwaS5nZXRXaWR0aCgpO1xuICAgICAgICB2YXIgdmlld0hlaWdodCA9IGFwaS5nZXRIZWlnaHQoKTtcblxuICAgICAgICB2YXIgcmVjdCA9IGVsICYmIGVsLmdldEJvdW5kaW5nUmVjdCgpLmNsb25lKCk7XG4gICAgICAgIGVsICYmIHJlY3QuYXBwbHlUcmFuc2Zvcm0oZWwudHJhbnNmb3JtKTtcbiAgICAgICAgaWYgKHR5cGVvZiBwb3NpdGlvbkV4cHIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIENhbGxiYWNrIG9mIHBvc2l0aW9uIGNhbiBiZSBhbiBhcnJheSBvciBhIHN0cmluZyBzcGVjaWZ5IHRoZSBwb3NpdGlvblxuICAgICAgICAgICAgcG9zaXRpb25FeHByID0gcG9zaXRpb25FeHByKFt4LCB5XSwgcGFyYW1zLCBjb250ZW50LmVsLCByZWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh6clV0aWwuaXNBcnJheShwb3NpdGlvbkV4cHIpKSB7XG4gICAgICAgICAgICB4ID0gcGFyc2VQZXJjZW50KHBvc2l0aW9uRXhwclswXSwgdmlld1dpZHRoKTtcbiAgICAgICAgICAgIHkgPSBwYXJzZVBlcmNlbnQocG9zaXRpb25FeHByWzFdLCB2aWV3SGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTcGVjaWZ5IHRvb2x0aXAgcG9zaXRpb24gYnkgc3RyaW5nICd0b3AnICdib3R0b20nICdsZWZ0JyAncmlnaHQnIGFyb3VuZCBncmFwaGljIGVsZW1lbnRcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHBvc2l0aW9uRXhwciA9PT0gJ3N0cmluZycgJiYgZWwpIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSBjYWxjVG9vbHRpcFBvc2l0aW9uKFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uRXhwciwgcmVjdCwgY29udGVudC5lbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHggPSBwb3NbMF07XG4gICAgICAgICAgICB5ID0gcG9zWzFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHBvcyA9IHJlZml4VG9vbHRpcFBvc2l0aW9uKFxuICAgICAgICAgICAgICAgIHgsIHksIGNvbnRlbnQuZWwsIHZpZXdXaWR0aCwgdmlld0hlaWdodFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHggPSBwb3NbMF07XG4gICAgICAgICAgICB5ID0gcG9zWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGVudC5tb3ZlVG8oeCwgeSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaWZTZXJpZXNTdXBwb3J0QXhpc1RyaWdnZXIoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgdmFyIGNvb3JkU3lzID0gc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbTtcbiAgICAgICAgdmFyIHRyaWdnZXIgPSBzZXJpZXNNb2RlbC5nZXQoJ3Rvb2x0aXAudHJpZ2dlcicsIHRydWUpO1xuICAgICAgICAvLyBJZ25vcmUgc2VyaWVzIHVzZSBpdGVtIHRvb2x0aXAgdHJpZ2dlciBhbmQgc2VyaWVzIGNvb3JkaW5hdGUgc3lzdGVtIGlzIG5vdCBjYXJ0ZXNpYW4gb3JcbiAgICAgICAgcmV0dXJuICEoIWNvb3JkU3lzXG4gICAgICAgICAgICB8fCAoY29vcmRTeXMudHlwZSAhPT0gJ2NhcnRlc2lhbjJkJyAmJiBjb29yZFN5cy50eXBlICE9PSAncG9sYXInICYmIGNvb3JkU3lzLnR5cGUgIT09ICdzaW5nbGVBeGlzJylcbiAgICAgICAgICAgIHx8IHRyaWdnZXIgPT09ICdpdGVtJyk7XG4gICAgfVxuXG4gICAgcmVxdWlyZSgnLi4vLi4vZWNoYXJ0cycpLmV4dGVuZENvbXBvbmVudFZpZXcoe1xuXG4gICAgICAgIHR5cGU6ICd0b29sdGlwJyxcblxuICAgICAgICBfYXhpc1BvaW50ZXJzOiB7fSxcblxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgICAgICAgICBpZiAoZW52Lm5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdG9vbHRpcENvbnRlbnQgPSBuZXcgVG9vbHRpcENvbnRlbnQoYXBpLmdldERvbSgpLCBhcGkpO1xuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcENvbnRlbnQgPSB0b29sdGlwQ29udGVudDtcblxuICAgICAgICAgICAgYXBpLm9uKCdzaG93VGlwJywgdGhpcy5fbWFudWFsbHlTaG93VGlwLCB0aGlzKTtcbiAgICAgICAgICAgIGFwaS5vbignaGlkZVRpcCcsIHRoaXMuX21hbnVhbGx5SGlkZVRpcCwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAodG9vbHRpcE1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgICAgIGlmIChlbnYubm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVzZXRcbiAgICAgICAgICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX2F4aXNQb2ludGVycyA9IHt9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvY29tcG9uZW50L3Rvb2x0aXAvVG9vbHRpcE1vZGVsfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl90b29sdGlwTW9kZWwgPSB0b29sdGlwTW9kZWw7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqIEB0eXBlIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX2VjTW9kZWwgPSBlY01vZGVsO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOmVjaGFydHMvRXh0ZW5zaW9uQVBJfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9hcGkgPSBhcGk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX2xhc3RIb3ZlciA9IHtcbiAgICAgICAgICAgICAgICAvLyBkYXRhXG4gICAgICAgICAgICAgICAgLy8gcGF5bG9hZEJhdGNoXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgdG9vbHRpcENvbnRlbnQgPSB0aGlzLl90b29sdGlwQ29udGVudDtcbiAgICAgICAgICAgIHRvb2x0aXBDb250ZW50LnVwZGF0ZSgpO1xuICAgICAgICAgICAgdG9vbHRpcENvbnRlbnQuZW50ZXJhYmxlID0gdG9vbHRpcE1vZGVsLmdldCgnZW50ZXJhYmxlJyk7XG4gICAgICAgICAgICB0aGlzLl9hbHdheXNTaG93Q29udGVudCA9IHRvb2x0aXBNb2RlbC5nZXQoJ2Fsd2F5c1Nob3dDb250ZW50Jyk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBBcnJheT59XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX3Nlcmllc0dyb3VwQnlBeGlzID0gdGhpcy5fcHJlcGFyZUF4aXNUcmlnZ2VyRGF0YShcbiAgICAgICAgICAgICAgICB0b29sdGlwTW9kZWwsIGVjTW9kZWxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHZhciBjcm9zc1RleHQgPSB0aGlzLl9jcm9zc1RleHQ7XG4gICAgICAgICAgICBpZiAoY3Jvc3NUZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cC5hZGQoY3Jvc3NUZXh0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVHJ5IHRvIGtlZXAgdGhlIHRvb2x0aXAgc2hvdyB3aGVuIHJlZnJlc2hpbmdcbiAgICAgICAgICAgIGlmICh0aGlzLl9sYXN0WCAhPSBudWxsICYmIHRoaXMuX2xhc3RZICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3JlZnJlc2hVcGRhdGVUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWZyZXNoVXBkYXRlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTaG93IHRpcCBuZXh0IHRpY2sgYWZ0ZXIgb3RoZXIgY2hhcnRzIGFyZSByZW5kZXJlZFxuICAgICAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIGhpZ2hsaWdodCBhY3Rpb24gaGFzIHdyb25nIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9tYW51YWxseVNob3dUaXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogc2VsZi5fbGFzdFgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBzZWxmLl9sYXN0WVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHpyID0gdGhpcy5fYXBpLmdldFpyKCk7XG4gICAgICAgICAgICB6ci5vZmYoJ2NsaWNrJywgdGhpcy5fdHJ5U2hvdyk7XG4gICAgICAgICAgICB6ci5vZmYoJ21vdXNlbW92ZScsIHRoaXMuX21vdXNlbW92ZSk7XG4gICAgICAgICAgICB6ci5vZmYoJ21vdXNlb3V0JywgdGhpcy5faGlkZSk7XG4gICAgICAgICAgICB6ci5vZmYoJ2dsb2JhbG91dCcsIHRoaXMuX2hpZGUpO1xuICAgICAgICAgICAgaWYgKHRvb2x0aXBNb2RlbC5nZXQoJ3RyaWdnZXJPbicpID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgICAgICAgenIub24oJ2NsaWNrJywgdGhpcy5fdHJ5U2hvdywgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB6ci5vbignbW91c2Vtb3ZlJywgdGhpcy5fbW91c2Vtb3ZlLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB6ci5vbignbW91c2VvdXQnLCB0aGlzLl9oaWRlLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB6ci5vbignZ2xvYmFsb3V0JywgdGhpcy5faGlkZSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX21vdXNlbW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBzaG93RGVsYXkgPSB0aGlzLl90b29sdGlwTW9kZWwuZ2V0KCdzaG93RGVsYXknKTtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9zaG93VGltZW91dCk7XG4gICAgICAgICAgICBpZiAoc2hvd0RlbGF5ID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3dUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3RyeVNob3coZSk7XG4gICAgICAgICAgICAgICAgfSwgc2hvd0RlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyeVNob3coZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3cgdGlwIG1hbnVhbGx5IGJ5XG4gICAgICAgICAqICBkaXNwYXRjaEFjdGlvbih7XG4gICAgICAgICAqICAgICAgdHlwZTogJ3Nob3dUaXAnLFxuICAgICAgICAgKiAgICAgIHg6IDEwLFxuICAgICAgICAgKiAgICAgIHk6IDEwXG4gICAgICAgICAqICB9KTtcbiAgICAgICAgICogT3JcbiAgICAgICAgICogIGRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICogICAgICB0eXBlOiAnc2hvd1RpcCcsXG4gICAgICAgICAqICAgICAgc2VyaWVzSW5kZXg6IDAsXG4gICAgICAgICAqICAgICAgZGF0YUluZGV4OiAxXG4gICAgICAgICAqICB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogIFRPRE8gQmF0Y2hcbiAgICAgICAgICovXG4gICAgICAgIF9tYW51YWxseVNob3dUaXA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgLy8gRnJvbSBzZWxmXG4gICAgICAgICAgICBpZiAoZXZlbnQuZnJvbSA9PT0gdGhpcy51aWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5fZWNNb2RlbDtcbiAgICAgICAgICAgIHZhciBzZXJpZXNJbmRleCA9IGV2ZW50LnNlcmllc0luZGV4O1xuICAgICAgICAgICAgdmFyIGRhdGFJbmRleCA9IGV2ZW50LmRhdGFJbmRleDtcbiAgICAgICAgICAgIHZhciBzZXJpZXNNb2RlbCA9IGVjTW9kZWwuZ2V0U2VyaWVzQnlJbmRleChzZXJpZXNJbmRleCk7XG4gICAgICAgICAgICB2YXIgYXBpID0gdGhpcy5fYXBpO1xuXG4gICAgICAgICAgICBpZiAoZXZlbnQueCA9PSBudWxsIHx8IGV2ZW50LnkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICghc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgZmlyc3Qgc2VyaWVzIGNhbiB1c2UgYXhpcyB0cmlnZ2VyXG4gICAgICAgICAgICAgICAgICAgIGVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoX3Nlcmllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlmU2VyaWVzU3VwcG9ydEF4aXNUcmlnZ2VyKF9zZXJpZXMpICYmICFzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc01vZGVsID0gX3NlcmllcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZXJpZXNNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhSW5kZXggPSBkYXRhLmluZGV4T2ZOYW1lKGV2ZW50Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IGRhdGEuZ2V0SXRlbUdyYXBoaWNFbChkYXRhSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3gsIGN5O1xuICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gZ2V0IHRoZSBwb2ludCBpbiBjb29yZGluYXRlIHN5c3RlbVxuICAgICAgICAgICAgICAgICAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29vcmRTeXMgJiYgY29vcmRTeXMuZGF0YVRvUG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IGNvb3JkU3lzLmRhdGFUb1BvaW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZ2V0VmFsdWVzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6clV0aWwubWFwKGNvb3JkU3lzLmRpbWVuc2lvbnMsIGZ1bmN0aW9uIChkaW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXJpZXNNb2RlbC5jb29yZERpbVRvRGF0YURpbShkaW0pWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgZGF0YUluZGV4LCB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN4ID0gcG9pbnQgJiYgcG9pbnRbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjeSA9IHBvaW50ICYmIHBvaW50WzFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgZ3JhcGhpYyBib3VuZGluZyByZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IGVsLmdldEJvdW5kaW5nUmVjdCgpLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0LmFwcGx5VHJhbnNmb3JtKGVsLnRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjeCA9IHJlY3QueCArIHJlY3Qud2lkdGggLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3kgPSByZWN0LnkgKyByZWN0LmhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN4ICE9IG51bGwgJiYgY3kgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJ5U2hvdyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WDogY3gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WTogY3ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gYXBpLmdldFpyKCkuaGFuZGxlci5maW5kSG92ZXIoZXZlbnQueCwgZXZlbnQueSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJ5U2hvdyh7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFg6IGV2ZW50LngsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFk6IGV2ZW50LnksXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogZWwsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiB7fVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9tYW51YWxseUhpZGVUaXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoZS5mcm9tID09PSB0aGlzLnVpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5faGlkZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9wcmVwYXJlQXhpc1RyaWdnZXJEYXRhOiBmdW5jdGlvbiAodG9vbHRpcE1vZGVsLCBlY01vZGVsKSB7XG4gICAgICAgICAgICAvLyBQcmVwYXJlIGRhdGEgZm9yIGF4aXMgdHJpZ2dlclxuICAgICAgICAgICAgdmFyIHNlcmllc0dyb3VwQnlBeGlzID0ge307XG4gICAgICAgICAgICBlY01vZGVsLmVhY2hTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlmU2VyaWVzU3VwcG9ydEF4aXNUcmlnZ2VyKHNlcmllc01vZGVsKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29vcmRTeXMgPSBzZXJpZXNNb2RlbC5jb29yZGluYXRlU3lzdGVtO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZUF4aXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBjYXJ0ZXNpYW4yZCwgcG9sYXIgYW5kIHNpbmdsZSBzdXBwb3J0IGF4aXMgdHJpZ2dlclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29vcmRTeXMudHlwZSA9PT0gJ2NhcnRlc2lhbjJkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgYGF4aXNQb2ludGVyLmF4aXNgIGlzIG5vdCBiYXNlQXhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZUF4aXMgPSBjb29yZFN5cy5nZXRCYXNlQXhpcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gYmFzZUF4aXMuZGltICsgYmFzZUF4aXMuaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29vcmRTeXMudHlwZSA9PT0gJ3NpbmdsZUF4aXMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlQXhpcyA9IGNvb3JkU3lzLmdldEF4aXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGJhc2VBeGlzLmRpbSArIGJhc2VBeGlzLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlQXhpcyA9IGNvb3JkU3lzLmdldEJhc2VBeGlzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBiYXNlQXhpcy5kaW0gKyBjb29yZFN5cy5uYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzR3JvdXBCeUF4aXNba2V5XSA9IHNlcmllc0dyb3VwQnlBeGlzW2tleV0gfHwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRTeXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBbXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBzZXJpZXNHcm91cEJ5QXhpc1trZXldLmNvb3JkU3lzLnB1c2goY29vcmRTeXMpO1xuICAgICAgICAgICAgICAgICAgICBzZXJpZXNHcm91cEJ5QXhpc1trZXldLnNlcmllcy5wdXNoKHNlcmllc01vZGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgcmV0dXJuIHNlcmllc0dyb3VwQnlBeGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtb3VzZW1vdmUgaGFuZGxlclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RyeVNob3c6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSBlLnRhcmdldDtcbiAgICAgICAgICAgIHZhciB0b29sdGlwTW9kZWwgPSB0aGlzLl90b29sdGlwTW9kZWw7XG4gICAgICAgICAgICB2YXIgZ2xvYmFsVHJpZ2dlciA9IHRvb2x0aXBNb2RlbC5nZXQoJ3RyaWdnZXInKTtcbiAgICAgICAgICAgIHZhciBlY01vZGVsID0gdGhpcy5fZWNNb2RlbDtcbiAgICAgICAgICAgIHZhciBhcGkgPSB0aGlzLl9hcGk7XG5cbiAgICAgICAgICAgIGlmICghdG9vbHRpcE1vZGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTYXZlIG1vdXNlIHgsIG1vdXNlIHkuIFNvIHdlIGNhbiB0cnkgdG8ga2VlcCBzaG93aW5nIHRoZSB0aXAgaWYgY2hhcnQgaXMgcmVmcmVzaGVkXG4gICAgICAgICAgICB0aGlzLl9sYXN0WCA9IGUub2Zmc2V0WDtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RZID0gZS5vZmZzZXRZO1xuXG4gICAgICAgICAgICAvLyBBbHdheXMgc2hvdyBpdGVtIHRvb2x0aXAgaWYgbW91c2UgaXMgb24gdGhlIGVsZW1lbnQgd2l0aCBkYXRhSW5kZXhcbiAgICAgICAgICAgIGlmIChlbCAmJiBlbC5kYXRhSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFVzZSBkYXRhTW9kZWwgaW4gZWxlbWVudCBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgICAgIC8vIFVzZWQgd2hlbiBtb3VzZW92ZXIgb24gYSBlbGVtZW50IGxpa2UgbWFya1BvaW50IG9yIGVkZ2VcbiAgICAgICAgICAgICAgICAvLyBJbiB3aGljaCBjYXNlLCB0aGUgZGF0YSBpcyBub3QgbWFpbiBkYXRhIGluIHNlcmllcy5cbiAgICAgICAgICAgICAgICB2YXIgZGF0YU1vZGVsID0gZWwuZGF0YU1vZGVsIHx8IGVjTW9kZWwuZ2V0U2VyaWVzQnlJbmRleChlbC5zZXJpZXNJbmRleCk7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFJbmRleCA9IGVsLmRhdGFJbmRleDtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbU1vZGVsID0gZGF0YU1vZGVsLmdldERhdGEoKS5nZXRJdGVtTW9kZWwoZGF0YUluZGV4KTtcbiAgICAgICAgICAgICAgICAvLyBTZXJpZXMgb3Igc2luZ2xlIGRhdGEgbWF5IHVzZSBpdGVtIHRyaWdnZXIgd2hlbiBnbG9iYWwgaXMgYXhpcyB0cmlnZ2VyXG4gICAgICAgICAgICAgICAgaWYgKChpdGVtTW9kZWwuZ2V0KCd0b29sdGlwLnRyaWdnZXInKSB8fCBnbG9iYWxUcmlnZ2VyKSA9PT0gJ2F4aXMnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Nob3dBeGlzVG9vbHRpcCh0b29sdGlwTW9kZWwsIGVjTW9kZWwsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGlja2V0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RpY2tldCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBlaXRoZXIgc2luZ2xlIGRhdGEgb3Igc2VyaWVzIHVzZSBpdGVtIHRyaWdnZXJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGlkZUF4aXNQb2ludGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IGxhc3QgaG92ZXIgYW5kIGRpc3BhdGNoIGRvd25wbGF5IGFjdGlvblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNldExhc3RIb3ZlcigpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Nob3dJdGVtVG9vbHRpcENvbnRlbnQoZGF0YU1vZGVsLCBkYXRhSW5kZXgsIGVsLmRhdGFUeXBlLCBlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc2hvd1RpcCcsXG4gICAgICAgICAgICAgICAgICAgIGZyb206IHRoaXMudWlkLFxuICAgICAgICAgICAgICAgICAgICBkYXRhSW5kZXg6IGVsLmRhdGFJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGVsLnNlcmllc0luZGV4XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUb29sdGlwIHByb3ZpZGVkIGRpcmVjdGx5LiBMaWtlIGxlZ2VuZFxuICAgICAgICAgICAgZWxzZSBpZiAoZWwgJiYgZWwudG9vbHRpcCkge1xuICAgICAgICAgICAgICAgIHZhciB0b29sdGlwT3B0ID0gZWwudG9vbHRpcDtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRvb2x0aXBPcHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gdG9vbHRpcE9wdDtcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcE9wdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXhlZCBmb3JtYXR0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogY29udGVudFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc3ViVG9vbHRpcE1vZGVsID0gbmV3IE1vZGVsKHRvb2x0aXBPcHQsIHRvb2x0aXBNb2RlbCk7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRIdG1sID0gc3ViVG9vbHRpcE1vZGVsLmdldCgnY29udGVudCcpO1xuICAgICAgICAgICAgICAgIHZhciBhc3luY1RpY2tldCA9IE1hdGgucmFuZG9tKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvd1Rvb2x0aXBDb250ZW50KFxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHBhcmFtc1xuICAgICAgICAgICAgICAgICAgICBzdWJUb29sdGlwTW9kZWwsIGRlZmF1bHRIdG1sLCBzdWJUb29sdGlwTW9kZWwuZ2V0KCdmb3JtYXR0ZXJQYXJhbXMnKSB8fCB7fSxcbiAgICAgICAgICAgICAgICAgICAgYXN5bmNUaWNrZXQsIGUub2Zmc2V0WCwgZS5vZmZzZXRZLCBlbCwgYXBpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChnbG9iYWxUcmlnZ2VyID09PSAnaXRlbScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGlkZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHNob3cgYXhpcyB0b29sdGlwXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Nob3dBeGlzVG9vbHRpcCh0b29sdGlwTW9kZWwsIGVjTW9kZWwsIGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFjdGlvbiBvZiBjcm9zcyBwb2ludGVyXG4gICAgICAgICAgICAgICAgLy8gb3RoZXIgcG9pbnRlciB0eXBlcyB3aWxsIHRyaWdnZXIgYWN0aW9uIGluIF9kaXNwYXRjaEFuZFNob3dTZXJpZXNUb29sdGlwQ29udGVudCBtZXRob2RcbiAgICAgICAgICAgICAgICBpZiAodG9vbHRpcE1vZGVsLmdldCgnYXhpc1BvaW50ZXIudHlwZScpID09PSAnY3Jvc3MnKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc2hvd1RpcCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiB0aGlzLnVpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IGUub2Zmc2V0WCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IGUub2Zmc2V0WVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3cgdG9vbHRpcCBvbiBheGlzXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29tcG9uZW50L3Rvb2x0aXAvVG9vbHRpcE1vZGVsfSB0b29sdGlwTW9kZWxcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9tb2RlbC9HbG9iYWx9IGVjTW9kZWxcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGVcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9zaG93QXhpc1Rvb2x0aXA6IGZ1bmN0aW9uICh0b29sdGlwTW9kZWwsIGVjTW9kZWwsIGUpIHtcbiAgICAgICAgICAgIHZhciBheGlzUG9pbnRlck1vZGVsID0gdG9vbHRpcE1vZGVsLmdldE1vZGVsKCdheGlzUG9pbnRlcicpO1xuICAgICAgICAgICAgdmFyIGF4aXNQb2ludGVyVHlwZSA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCd0eXBlJyk7XG5cbiAgICAgICAgICAgIGlmIChheGlzUG9pbnRlclR5cGUgPT09ICdjcm9zcycpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBlLnRhcmdldDtcbiAgICAgICAgICAgICAgICBpZiAoZWwgJiYgZWwuZGF0YUluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlcmllc01vZGVsID0gZWNNb2RlbC5nZXRTZXJpZXNCeUluZGV4KGVsLnNlcmllc0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFJbmRleCA9IGVsLmRhdGFJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2hvd0l0ZW1Ub29sdGlwQ29udGVudChzZXJpZXNNb2RlbCwgZGF0YUluZGV4LCBlbC5kYXRhVHlwZSwgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9zaG93QXhpc1BvaW50ZXIoKTtcbiAgICAgICAgICAgIHZhciBhbGxOb3RTaG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIHpyVXRpbC5lYWNoKHRoaXMuX3Nlcmllc0dyb3VwQnlBeGlzLCBmdW5jdGlvbiAoc2VyaWVzQ29vcmRTeXNTYW1lQXhpcykge1xuICAgICAgICAgICAgICAgIC8vIFRyeSBzaG93IHRoZSBheGlzIHBvaW50ZXJcbiAgICAgICAgICAgICAgICB2YXIgYWxsQ29vcmRTeXMgPSBzZXJpZXNDb29yZFN5c1NhbWVBeGlzLmNvb3JkU3lzO1xuICAgICAgICAgICAgICAgIHZhciBjb29yZFN5cyA9IGFsbENvb3JkU3lzWzBdO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgbW91c2UgcG9zaXRpb24gaXMgbm90IGluIHRoZSBncmlkIG9yIHBvbGFyXG4gICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gW2Uub2Zmc2V0WCwgZS5vZmZzZXRZXTtcblxuICAgICAgICAgICAgICAgIGlmICghY29vcmRTeXMuY29udGFpblBvaW50KHBvaW50KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBIaWRlIGF4aXMgcG9pbnRlclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oaWRlQXhpc1BvaW50ZXIoY29vcmRTeXMubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhbGxOb3RTaG93ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHBvaW50IGlzIGRpc2NyZXRlIG9uIGNhdGVvZ3J5IGF4aXNcbiAgICAgICAgICAgICAgICB2YXIgZGltZW5zaW9ucyA9IGNvb3JkU3lzLmRpbWVuc2lvbnM7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gY29vcmRTeXMucG9pbnRUb0RhdGEocG9pbnQsIHRydWUpO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gY29vcmRTeXMuZGF0YVRvUG9pbnQodmFsdWUpO1xuICAgICAgICAgICAgICAgIHZhciBiYXNlQXhpcyA9IGNvb3JkU3lzLmdldEJhc2VBeGlzKCk7XG4gICAgICAgICAgICAgICAgdmFyIGF4aXNUeXBlID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ2F4aXMnKTtcbiAgICAgICAgICAgICAgICBpZiAoYXhpc1R5cGUgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgICAgICAgICBheGlzVHlwZSA9IGJhc2VBeGlzLmRpbTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY29udGVudE5vdENoYW5nZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciBsYXN0SG92ZXIgPSB0aGlzLl9sYXN0SG92ZXI7XG4gICAgICAgICAgICAgICAgaWYgKGF4aXNQb2ludGVyVHlwZSA9PT0gJ2Nyb3NzJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBob3ZlciBkYXRhIG5vdCBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgICAgIC8vIFBvc3NpYmxlIHdoZW4gdHdvIGF4ZXMgYXJlIGFsbCBjYXRlZ29yeVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YUVxdWFsKGxhc3RIb3Zlci5kYXRhLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnROb3RDaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxhc3RIb3Zlci5kYXRhID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsSW5kZXggPSB6clV0aWwuaW5kZXhPZihkaW1lbnNpb25zLCBheGlzVHlwZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgaG92ZXIgZGF0YSBub3QgY2hhbmdlZCBvbiB0aGUgYXhpcyBkaW1lbnNpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RIb3Zlci5kYXRhID09PSB2YWx1ZVt2YWxJbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnROb3RDaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxhc3RIb3Zlci5kYXRhID0gdmFsdWVbdmFsSW5kZXhdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjb29yZFN5cy50eXBlID09PSAnY2FydGVzaWFuMmQnICYmICFjb250ZW50Tm90Q2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Nob3dDYXJ0ZXNpYW5Qb2ludGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgYXhpc1BvaW50ZXJNb2RlbCwgY29vcmRTeXMsIGF4aXNUeXBlLCBwb2ludFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb29yZFN5cy50eXBlID09PSAncG9sYXInICYmICFjb250ZW50Tm90Q2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Nob3dQb2xhclBvaW50ZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzUG9pbnRlck1vZGVsLCBjb29yZFN5cywgYXhpc1R5cGUsIHBvaW50XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvb3JkU3lzLnR5cGUgPT09ICdzaW5nbGVBeGlzJyAmJiAhY29udGVudE5vdENoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaG93U2luZ2xlUG9pbnRlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNQb2ludGVyTW9kZWwsIGNvb3JkU3lzLCBheGlzVHlwZSwgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYXhpc1BvaW50ZXJUeXBlICE9PSAnY3Jvc3MnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoQW5kU2hvd1Nlcmllc1Rvb2x0aXBDb250ZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRTeXMsIHNlcmllc0Nvb3JkU3lzU2FtZUF4aXMuc2VyaWVzLCBwb2ludCwgdmFsdWUsIGNvbnRlbnROb3RDaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLl90b29sdGlwTW9kZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oaWRlQXhpc1BvaW50ZXIoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFsbE5vdFNob3cpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3cgdG9vbHRpcCBvbiBheGlzIG9mIGNhcnRlc2lhbiBjb29yZGluYXRlXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvbW9kZWwvTW9kZWx9IGF4aXNQb2ludGVyTW9kZWxcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb29yZC9jYXJ0ZXNpYW4vQ2FydGVzaWFuMkR9IGNhcnRlc2lhbnNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGF4aXNUeXBlXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHBvaW50XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfc2hvd0NhcnRlc2lhblBvaW50ZXI6IGZ1bmN0aW9uIChheGlzUG9pbnRlck1vZGVsLCBjYXJ0ZXNpYW4sIGF4aXNUeXBlLCBwb2ludCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgYXhpc1BvaW50ZXJUeXBlID0gYXhpc1BvaW50ZXJNb2RlbC5nZXQoJ3R5cGUnKTtcbiAgICAgICAgICAgIHZhciBiYXNlQXhpcyA9IGNhcnRlc2lhbi5nZXRCYXNlQXhpcygpO1xuICAgICAgICAgICAgdmFyIG1vdmVBbmltYXRpb24gPSBheGlzUG9pbnRlclR5cGUgIT09ICdjcm9zcydcbiAgICAgICAgICAgICAgICAmJiBiYXNlQXhpcy50eXBlID09PSAnY2F0ZWdvcnknXG4gICAgICAgICAgICAgICAgJiYgYmFzZUF4aXMuZ2V0QmFuZFdpZHRoKCkgPiAyMDtcblxuICAgICAgICAgICAgaWYgKGF4aXNQb2ludGVyVHlwZSA9PT0gJ2Nyb3NzJykge1xuICAgICAgICAgICAgICAgIG1vdmVHcmlkTGluZSgneCcsIHBvaW50LCBjYXJ0ZXNpYW4uZ2V0QXhpcygneScpLmdldEdsb2JhbEV4dGVudCgpKTtcbiAgICAgICAgICAgICAgICBtb3ZlR3JpZExpbmUoJ3knLCBwb2ludCwgY2FydGVzaWFuLmdldEF4aXMoJ3gnKS5nZXRHbG9iYWxFeHRlbnQoKSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVDcm9zc1RleHQoY2FydGVzaWFuLCBwb2ludCwgYXhpc1BvaW50ZXJNb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXJBeGlzID0gY2FydGVzaWFuLmdldEF4aXMoYXhpc1R5cGUgPT09ICd4JyA/ICd5JyA6ICd4Jyk7XG4gICAgICAgICAgICAgICAgdmFyIG90aGVyRXh0ZW50ID0gb3RoZXJBeGlzLmdldEdsb2JhbEV4dGVudCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNhcnRlc2lhbi50eXBlID09PSAnY2FydGVzaWFuMmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIChheGlzUG9pbnRlclR5cGUgPT09ICdsaW5lJyA/IG1vdmVHcmlkTGluZSA6IG1vdmVHcmlkU2hhZG93KShcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNUeXBlLCBwb2ludCwgb3RoZXJFeHRlbnRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGlubmVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIG1vdmVHcmlkTGluZShheGlzVHlwZSwgcG9pbnQsIG90aGVyRXh0ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldFNoYXBlID0gYXhpc1R5cGUgPT09ICd4J1xuICAgICAgICAgICAgICAgICAgICA/IG1ha2VMaW5lU2hhcGUocG9pbnRbMF0sIG90aGVyRXh0ZW50WzBdLCBwb2ludFswXSwgb3RoZXJFeHRlbnRbMV0pXG4gICAgICAgICAgICAgICAgICAgIDogbWFrZUxpbmVTaGFwZShvdGhlckV4dGVudFswXSwgcG9pbnRbMV0sIG90aGVyRXh0ZW50WzFdLCBwb2ludFsxXSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRlckVsID0gc2VsZi5fZ2V0UG9pbnRlckVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgIGNhcnRlc2lhbiwgYXhpc1BvaW50ZXJNb2RlbCwgYXhpc1R5cGUsIHRhcmdldFNoYXBlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBncmFwaGljLnN1YlBpeGVsT3B0aW1pemVMaW5lKHtcbiAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHRhcmdldFNoYXBlLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogcG9pbnRlckVsLnN0eWxlXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBtb3ZlQW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgICAgID8gZ3JhcGhpYy51cGRhdGVQcm9wcyhwb2ludGVyRWwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlOiB0YXJnZXRTaGFwZVxuICAgICAgICAgICAgICAgICAgICB9LCBheGlzUG9pbnRlck1vZGVsKVxuICAgICAgICAgICAgICAgICAgICA6ICBwb2ludGVyRWwuYXR0cih7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFwZTogdGFyZ2V0U2hhcGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGlubmVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIG1vdmVHcmlkU2hhZG93KGF4aXNUeXBlLCBwb2ludCwgb3RoZXJFeHRlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXhpcyA9IGNhcnRlc2lhbi5nZXRBeGlzKGF4aXNUeXBlKTtcbiAgICAgICAgICAgICAgICB2YXIgYmFuZFdpZHRoID0gYXhpcy5nZXRCYW5kV2lkdGgoKTtcbiAgICAgICAgICAgICAgICB2YXIgc3BhbiA9IG90aGVyRXh0ZW50WzFdIC0gb3RoZXJFeHRlbnRbMF07XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldFNoYXBlID0gYXhpc1R5cGUgPT09ICd4J1xuICAgICAgICAgICAgICAgICAgICA/IG1ha2VSZWN0U2hhcGUocG9pbnRbMF0gLSBiYW5kV2lkdGggLyAyLCBvdGhlckV4dGVudFswXSwgYmFuZFdpZHRoLCBzcGFuKVxuICAgICAgICAgICAgICAgICAgICA6IG1ha2VSZWN0U2hhcGUob3RoZXJFeHRlbnRbMF0sIHBvaW50WzFdIC0gYmFuZFdpZHRoIC8gMiwgc3BhbiwgYmFuZFdpZHRoKTtcblxuICAgICAgICAgICAgICAgIHZhciBwb2ludGVyRWwgPSBzZWxmLl9nZXRQb2ludGVyRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgY2FydGVzaWFuLCBheGlzUG9pbnRlck1vZGVsLCBheGlzVHlwZSwgdGFyZ2V0U2hhcGVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIG1vdmVBbmltYXRpb25cbiAgICAgICAgICAgICAgICAgICAgPyBncmFwaGljLnVwZGF0ZVByb3BzKHBvaW50ZXJFbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHRhcmdldFNoYXBlXG4gICAgICAgICAgICAgICAgICAgIH0sIGF4aXNQb2ludGVyTW9kZWwpXG4gICAgICAgICAgICAgICAgICAgIDogIHBvaW50ZXJFbC5hdHRyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlOiB0YXJnZXRTaGFwZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfc2hvd1NpbmdsZVBvaW50ZXI6IGZ1bmN0aW9uIChheGlzUG9pbnRlck1vZGVsLCBzaW5nbGUsIGF4aXNUeXBlLCBwb2ludCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGF4aXNQb2ludGVyVHlwZSA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCd0eXBlJyk7XG4gICAgICAgICAgICB2YXIgbW92ZUFuaW1hdGlvbiA9IGF4aXNQb2ludGVyVHlwZSAhPT0gJ2Nyb3NzJyAmJiBzaW5nbGUuZ2V0QmFzZUF4aXMoKS50eXBlID09PSAnY2F0ZWdvcnknO1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBzaW5nbGUuZ2V0UmVjdCgpO1xuICAgICAgICAgICAgdmFyIG90aGVyRXh0ZW50ID0gW3JlY3QueSwgcmVjdC55ICsgcmVjdC5oZWlnaHRdO1xuXG4gICAgICAgICAgICBtb3ZlU2luZ2xlTGluZShheGlzVHlwZSwgcG9pbnQsIG90aGVyRXh0ZW50KTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gbW92ZVNpbmdsZUxpbmUoYXhpc1R5cGUsIHBvaW50LCBvdGhlckV4dGVudCkge1xuICAgICAgICAgICAgICAgIHZhciBheGlzID0gc2luZ2xlLmdldEF4aXMoKTtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZW50ID0gYXhpcy5vcmllbnQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0U2hhcGUgPSBvcmllbnQgPT09ICdob3Jpem9udGFsJ1xuICAgICAgICAgICAgICAgICAgICA/IG1ha2VMaW5lU2hhcGUocG9pbnRbMF0sIG90aGVyRXh0ZW50WzBdLCBwb2ludFswXSwgb3RoZXJFeHRlbnRbMV0pXG4gICAgICAgICAgICAgICAgICAgIDogbWFrZUxpbmVTaGFwZShvdGhlckV4dGVudFswXSwgcG9pbnRbMV0sIG90aGVyRXh0ZW50WzFdLCBwb2ludFsxXSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRlckVsID0gc2VsZi5fZ2V0UG9pbnRlckVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZSwgYXhpc1BvaW50ZXJNb2RlbCwgYXhpc1R5cGUsIHRhcmdldFNoYXBlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBtb3ZlQW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgICAgID8gZ3JhcGhpYy51cGRhdGVQcm9wcyhwb2ludGVyRWwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlOiB0YXJnZXRTaGFwZVxuICAgICAgICAgICAgICAgICAgICB9LCBheGlzUG9pbnRlck1vZGVsKVxuICAgICAgICAgICAgICAgICAgICA6ICBwb2ludGVyRWwuYXR0cih7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFwZTogdGFyZ2V0U2hhcGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdyB0b29sdGlwIG9uIGF4aXMgb2YgcG9sYXIgY29vcmRpbmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBheGlzUG9pbnRlck1vZGVsXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL2Nvb3JkL3BvbGFyL1BvbGFyPn0gcG9sYXJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGF4aXNUeXBlXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBfc2hvd1BvbGFyUG9pbnRlcjogZnVuY3Rpb24gKGF4aXNQb2ludGVyTW9kZWwsIHBvbGFyLCBheGlzVHlwZSwgcG9pbnQpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIGF4aXNQb2ludGVyVHlwZSA9IGF4aXNQb2ludGVyTW9kZWwuZ2V0KCd0eXBlJyk7XG5cbiAgICAgICAgICAgIHZhciBhbmdsZUF4aXMgPSBwb2xhci5nZXRBbmdsZUF4aXMoKTtcbiAgICAgICAgICAgIHZhciByYWRpdXNBeGlzID0gcG9sYXIuZ2V0UmFkaXVzQXhpcygpO1xuXG4gICAgICAgICAgICB2YXIgbW92ZUFuaW1hdGlvbiA9IGF4aXNQb2ludGVyVHlwZSAhPT0gJ2Nyb3NzJ1xuICAgICAgICAgICAgICAgICYmIHBvbGFyLmdldEJhc2VBeGlzKCkudHlwZSA9PT0gJ2NhdGVnb3J5JztcblxuICAgICAgICAgICAgaWYgKGF4aXNQb2ludGVyVHlwZSA9PT0gJ2Nyb3NzJykge1xuICAgICAgICAgICAgICAgIG1vdmVQb2xhckxpbmUoJ2FuZ2xlJywgcG9pbnQsIHJhZGl1c0F4aXMuZ2V0RXh0ZW50KCkpO1xuICAgICAgICAgICAgICAgIG1vdmVQb2xhckxpbmUoJ3JhZGl1cycsIHBvaW50LCBhbmdsZUF4aXMuZ2V0RXh0ZW50KCkpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ3Jvc3NUZXh0KHBvbGFyLCBwb2ludCwgYXhpc1BvaW50ZXJNb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXJBeGlzID0gcG9sYXIuZ2V0QXhpcyhheGlzVHlwZSA9PT0gJ3JhZGl1cycgPyAnYW5nbGUnIDogJ3JhZGl1cycpO1xuICAgICAgICAgICAgICAgIHZhciBvdGhlckV4dGVudCA9IG90aGVyQXhpcy5nZXRFeHRlbnQoKTtcblxuICAgICAgICAgICAgICAgIChheGlzUG9pbnRlclR5cGUgPT09ICdsaW5lJyA/IG1vdmVQb2xhckxpbmUgOiBtb3ZlUG9sYXJTaGFkb3cpKFxuICAgICAgICAgICAgICAgICAgICBheGlzVHlwZSwgcG9pbnQsIG90aGVyRXh0ZW50XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGlubmVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIG1vdmVQb2xhckxpbmUoYXhpc1R5cGUsIHBvaW50LCBvdGhlckV4dGVudCkge1xuICAgICAgICAgICAgICAgIHZhciBtb3VzZUNvb3JkID0gcG9sYXIucG9pbnRUb0Nvb3JkKHBvaW50KTtcblxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRTaGFwZTtcblxuICAgICAgICAgICAgICAgIGlmIChheGlzVHlwZSA9PT0gJ2FuZ2xlJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcDEgPSBwb2xhci5jb29yZFRvUG9pbnQoW290aGVyRXh0ZW50WzBdLCBtb3VzZUNvb3JkWzFdXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwMiA9IHBvbGFyLmNvb3JkVG9Qb2ludChbb3RoZXJFeHRlbnRbMV0sIG1vdXNlQ29vcmRbMV1dKTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U2hhcGUgPSBtYWtlTGluZVNoYXBlKHAxWzBdLCBwMVsxXSwgcDJbMF0sIHAyWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFNoYXBlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3g6IHBvbGFyLmN4LFxuICAgICAgICAgICAgICAgICAgICAgICAgY3k6IHBvbGFyLmN5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcjogbW91c2VDb29yZFswXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwb2ludGVyRWwgPSBzZWxmLl9nZXRQb2ludGVyRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgcG9sYXIsIGF4aXNQb2ludGVyTW9kZWwsIGF4aXNUeXBlLCB0YXJnZXRTaGFwZVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBtb3ZlQW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgICAgID8gZ3JhcGhpYy51cGRhdGVQcm9wcyhwb2ludGVyRWwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlOiB0YXJnZXRTaGFwZVxuICAgICAgICAgICAgICAgICAgICB9LCBheGlzUG9pbnRlck1vZGVsKVxuICAgICAgICAgICAgICAgICAgICA6ICBwb2ludGVyRWwuYXR0cih7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFwZTogdGFyZ2V0U2hhcGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGlubmVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIG1vdmVQb2xhclNoYWRvdyhheGlzVHlwZSwgcG9pbnQsIG90aGVyRXh0ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGF4aXMgPSBwb2xhci5nZXRBeGlzKGF4aXNUeXBlKTtcbiAgICAgICAgICAgICAgICB2YXIgYmFuZFdpZHRoID0gYXhpcy5nZXRCYW5kV2lkdGgoKTtcblxuICAgICAgICAgICAgICAgIHZhciBtb3VzZUNvb3JkID0gcG9sYXIucG9pbnRUb0Nvb3JkKHBvaW50KTtcblxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRTaGFwZTtcblxuICAgICAgICAgICAgICAgIHZhciByYWRpYW4gPSBNYXRoLlBJIC8gMTgwO1xuXG4gICAgICAgICAgICAgICAgaWYgKGF4aXNUeXBlID09PSAnYW5nbGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFNoYXBlID0gbWFrZVNlY3RvclNoYXBlKFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9sYXIuY3gsIHBvbGFyLmN5LFxuICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJFeHRlbnRbMF0sIG90aGVyRXh0ZW50WzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gRUNoYXJ0cyB5IGlzIG5lZ2F0aXZlIGlmIGFuZ2xlIGlzIHBvc2l0aXZlXG4gICAgICAgICAgICAgICAgICAgICAgICAoLW1vdXNlQ29vcmRbMV0gLSBiYW5kV2lkdGggLyAyKSAqIHJhZGlhbixcbiAgICAgICAgICAgICAgICAgICAgICAgICgtbW91c2VDb29yZFsxXSArIGJhbmRXaWR0aCAvIDIpICogcmFkaWFuXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRTaGFwZSA9IG1ha2VTZWN0b3JTaGFwZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbGFyLmN4LCBwb2xhci5jeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlQ29vcmRbMF0gLSBiYW5kV2lkdGggLyAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VDb29yZFswXSArIGJhbmRXaWR0aCAvIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLCBNYXRoLlBJICogMlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwb2ludGVyRWwgPSBzZWxmLl9nZXRQb2ludGVyRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgcG9sYXIsIGF4aXNQb2ludGVyTW9kZWwsIGF4aXNUeXBlLCB0YXJnZXRTaGFwZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbW92ZUFuaW1hdGlvblxuICAgICAgICAgICAgICAgICAgICA/IGdyYXBoaWMudXBkYXRlUHJvcHMocG9pbnRlckVsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFwZTogdGFyZ2V0U2hhcGVcbiAgICAgICAgICAgICAgICAgICAgfSwgYXhpc1BvaW50ZXJNb2RlbClcbiAgICAgICAgICAgICAgICAgICAgOiAgcG9pbnRlckVsLmF0dHIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGU6IHRhcmdldFNoYXBlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF91cGRhdGVDcm9zc1RleHQ6IGZ1bmN0aW9uIChjb29yZFN5cywgcG9pbnQsIGF4aXNQb2ludGVyTW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBjcm9zc1N0eWxlTW9kZWwgPSBheGlzUG9pbnRlck1vZGVsLmdldE1vZGVsKCdjcm9zc1N0eWxlJyk7XG4gICAgICAgICAgICB2YXIgdGV4dFN0eWxlTW9kZWwgPSBjcm9zc1N0eWxlTW9kZWwuZ2V0TW9kZWwoJ3RleHRTdHlsZScpO1xuXG4gICAgICAgICAgICB2YXIgdG9vbHRpcE1vZGVsID0gdGhpcy5fdG9vbHRpcE1vZGVsO1xuXG4gICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuX2Nyb3NzVGV4dDtcbiAgICAgICAgICAgIGlmICghdGV4dCkge1xuICAgICAgICAgICAgICAgIHRleHQgPSB0aGlzLl9jcm9zc1RleHQgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogJ2xlZnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ246ICdib3R0b20nXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwLmFkZCh0ZXh0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHZhbHVlID0gY29vcmRTeXMucG9pbnRUb0RhdGEocG9pbnQpO1xuXG4gICAgICAgICAgICB2YXIgZGltcyA9IGNvb3JkU3lzLmRpbWVuc2lvbnM7XG4gICAgICAgICAgICB2YWx1ZSA9IHpyVXRpbC5tYXAodmFsdWUsIGZ1bmN0aW9uICh2YWwsIGlkeCkge1xuICAgICAgICAgICAgICAgIHZhciBheGlzID0gY29vcmRTeXMuZ2V0QXhpcyhkaW1zW2lkeF0pO1xuICAgICAgICAgICAgICAgIGlmIChheGlzLnR5cGUgPT09ICdjYXRlZ29yeScgfHwgYXhpcy50eXBlID09PSAndGltZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gYXhpcy5zY2FsZS5nZXRMYWJlbCh2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gZm9ybWF0VXRpbC5hZGRDb21tYXMoXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwudG9GaXhlZChheGlzLmdldFBpeGVsUHJlY2lzaW9uKCkpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGV4dC5zZXRTdHlsZSh7XG4gICAgICAgICAgICAgICAgZmlsbDogdGV4dFN0eWxlTW9kZWwuZ2V0VGV4dENvbG9yKCkgfHwgY3Jvc3NTdHlsZU1vZGVsLmdldCgnY29sb3InKSxcbiAgICAgICAgICAgICAgICB0ZXh0Rm9udDogdGV4dFN0eWxlTW9kZWwuZ2V0Rm9udCgpLFxuICAgICAgICAgICAgICAgIHRleHQ6IHZhbHVlLmpvaW4oJywgJyksXG4gICAgICAgICAgICAgICAgeDogcG9pbnRbMF0gKyA1LFxuICAgICAgICAgICAgICAgIHk6IHBvaW50WzFdIC0gNVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0ZXh0LnogPSB0b29sdGlwTW9kZWwuZ2V0KCd6Jyk7XG4gICAgICAgICAgICB0ZXh0LnpsZXZlbCA9IHRvb2x0aXBNb2RlbC5nZXQoJ3psZXZlbCcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRQb2ludGVyRWxlbWVudDogZnVuY3Rpb24gKGNvb3JkU3lzLCBwb2ludGVyTW9kZWwsIGF4aXNUeXBlLCBpbml0U2hhcGUpIHtcbiAgICAgICAgICAgIHZhciB0b29sdGlwTW9kZWwgPSB0aGlzLl90b29sdGlwTW9kZWw7XG4gICAgICAgICAgICB2YXIgeiA9IHRvb2x0aXBNb2RlbC5nZXQoJ3onKTtcbiAgICAgICAgICAgIHZhciB6bGV2ZWwgPSB0b29sdGlwTW9kZWwuZ2V0KCd6bGV2ZWwnKTtcbiAgICAgICAgICAgIHZhciBheGlzUG9pbnRlcnMgPSB0aGlzLl9heGlzUG9pbnRlcnM7XG4gICAgICAgICAgICB2YXIgY29vcmRTeXNOYW1lID0gY29vcmRTeXMubmFtZTtcbiAgICAgICAgICAgIGF4aXNQb2ludGVyc1tjb29yZFN5c05hbWVdID0gYXhpc1BvaW50ZXJzW2Nvb3JkU3lzTmFtZV0gfHwge307XG4gICAgICAgICAgICBpZiAoYXhpc1BvaW50ZXJzW2Nvb3JkU3lzTmFtZV1bYXhpc1R5cGVdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF4aXNQb2ludGVyc1tjb29yZFN5c05hbWVdW2F4aXNUeXBlXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGlmIG5vdCBleGlzdHNcbiAgICAgICAgICAgIHZhciBwb2ludGVyVHlwZSA9IHBvaW50ZXJNb2RlbC5nZXQoJ3R5cGUnKTtcbiAgICAgICAgICAgIHZhciBzdHlsZU1vZGVsID0gcG9pbnRlck1vZGVsLmdldE1vZGVsKHBvaW50ZXJUeXBlICsgJ1N0eWxlJyk7XG4gICAgICAgICAgICB2YXIgaXNTaGFkb3cgPSBwb2ludGVyVHlwZSA9PT0gJ3NoYWRvdyc7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBzdHlsZU1vZGVsW2lzU2hhZG93ID8gJ2dldEFyZWFTdHlsZScgOiAnZ2V0TGluZVN0eWxlJ10oKTtcblxuICAgICAgICAgICAgdmFyIGVsZW1lbnRUeXBlID0gY29vcmRTeXMudHlwZSA9PT0gJ3BvbGFyJ1xuICAgICAgICAgICAgICAgID8gKGlzU2hhZG93ID8gJ1NlY3RvcicgOiAoYXhpc1R5cGUgPT09ICdyYWRpdXMnID8gJ0NpcmNsZScgOiAnTGluZScpKVxuICAgICAgICAgICAgICAgIDogKGlzU2hhZG93ID8gJ1JlY3QnIDogJ0xpbmUnKTtcblxuICAgICAgICAgICAgaXNTaGFkb3cgPyAoc3R5bGUuc3Ryb2tlID0gbnVsbCkgOiAoc3R5bGUuZmlsbCA9IG51bGwpO1xuXG4gICAgICAgICAgICB2YXIgZWwgPSBheGlzUG9pbnRlcnNbY29vcmRTeXNOYW1lXVtheGlzVHlwZV0gPSBuZXcgZ3JhcGhpY1tlbGVtZW50VHlwZV0oe1xuICAgICAgICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgICAgICB6OiB6LFxuICAgICAgICAgICAgICAgIHpsZXZlbDogemxldmVsLFxuICAgICAgICAgICAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzaGFwZTogaW5pdFNoYXBlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5ncm91cC5hZGQoZWwpO1xuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwYXRjaCBhY3Rpb25zIGFuZCBzaG93IHRvb2x0aXAgb24gc2VyaWVzXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllcz59IHNlcmllc0xpc3RcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcG9pbnRcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdmFsdWVcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBjb250ZW50Tm90Q2hhbmdlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlXG4gICAgICAgICAqL1xuICAgICAgICBfZGlzcGF0Y2hBbmRTaG93U2VyaWVzVG9vbHRpcENvbnRlbnQ6IGZ1bmN0aW9uIChcbiAgICAgICAgICAgIGNvb3JkU3lzLCBzZXJpZXNMaXN0LCBwb2ludCwgdmFsdWUsIGNvbnRlbnROb3RDaGFuZ2VcbiAgICAgICAgKSB7XG5cbiAgICAgICAgICAgIHZhciByb290VG9vbHRpcE1vZGVsID0gdGhpcy5fdG9vbHRpcE1vZGVsO1xuXG4gICAgICAgICAgICB2YXIgYmFzZUF4aXMgPSBjb29yZFN5cy5nZXRCYXNlQXhpcygpO1xuICAgICAgICAgICAgdmFyIGJhc2VEaW1JbmRleCA9IGJhc2VBeGlzLmRpbSA9PT0gJ3gnIHx8IGJhc2VBeGlzLmRpbSA9PT0gJ3JhZGl1cycgPyAwIDogMTtcblxuICAgICAgICAgICAgdmFyIHBheWxvYWRCYXRjaCA9IHpyVXRpbC5tYXAoc2VyaWVzTGlzdCwgZnVuY3Rpb24gKHNlcmllcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBzZXJpZXMuc2VyaWVzSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFJbmRleDogc2VyaWVzLmdldEF4aXNUb29sdGlwRGF0YUluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNlcmllcy5nZXRBeGlzVG9vbHRpcERhdGFJbmRleChzZXJpZXMuY29vcmREaW1Ub0RhdGFEaW0oYmFzZUF4aXMuZGltKSwgdmFsdWUsIGJhc2VBeGlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBzZXJpZXMuZ2V0RGF0YSgpLmluZGV4T2ZOZWFyZXN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllcy5jb29yZERpbVRvRGF0YURpbShiYXNlQXhpcy5kaW0pWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2Jhc2VEaW1JbmRleF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGEgdGhyZXNob2xkIHRvIGF2b2lkIGZpbmQgdGhlIHdyb25nIGRhdGFJbmRleCB3aGVuIGRhdGEgbGVuZ3RoIGlzIG5vdCBzYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsIGJhc2VBeGlzLnR5cGUgPT09ICdjYXRlZ29yeScgPyAwLjUgOiBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgbGFzdEhvdmVyID0gdGhpcy5fbGFzdEhvdmVyO1xuICAgICAgICAgICAgdmFyIGFwaSA9IHRoaXMuX2FwaTtcbiAgICAgICAgICAgIC8vIERpc3BhdGNoIGRvd25wbGF5IGFjdGlvblxuICAgICAgICAgICAgaWYgKGxhc3RIb3Zlci5wYXlsb2FkQmF0Y2ggJiYgIWNvbnRlbnROb3RDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBhcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZG93bnBsYXknLFxuICAgICAgICAgICAgICAgICAgICBiYXRjaDogbGFzdEhvdmVyLnBheWxvYWRCYXRjaFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGlzcGF0Y2ggaGlnaGxpZ2h0IGFjdGlvblxuICAgICAgICAgICAgaWYgKCFjb250ZW50Tm90Q2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2hpZ2hsaWdodCcsXG4gICAgICAgICAgICAgICAgICAgIGJhdGNoOiBwYXlsb2FkQmF0Y2hcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsYXN0SG92ZXIucGF5bG9hZEJhdGNoID0gcGF5bG9hZEJhdGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGlzcGF0Y2ggc2hvd1RpcCBhY3Rpb25cbiAgICAgICAgICAgIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3Nob3dUaXAnLFxuICAgICAgICAgICAgICAgIGRhdGFJbmRleDogcGF5bG9hZEJhdGNoWzBdLmRhdGFJbmRleCxcbiAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogcGF5bG9hZEJhdGNoWzBdLnNlcmllc0luZGV4LFxuICAgICAgICAgICAgICAgIGZyb206IHRoaXMudWlkXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGJhc2VBeGlzICYmIHJvb3RUb29sdGlwTW9kZWwuZ2V0KCdzaG93Q29udGVudCcpICYmIHJvb3RUb29sdGlwTW9kZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zTGlzdCA9IHpyVXRpbC5tYXAoc2VyaWVzTGlzdCwgZnVuY3Rpb24gKHNlcmllcywgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcmllcy5nZXREYXRhUGFyYW1zKHBheWxvYWRCYXRjaFtpbmRleF0uZGF0YUluZGV4KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmICghY29udGVudE5vdENoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgaHRtbCBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdERhdGFJbmRleCA9IHBheWxvYWRCYXRjaFswXS5kYXRhSW5kZXg7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdCB0b29sdGlwIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgICAgICAgICAgLy8gKDEpIHNob2xkIGJlIHRoZSBmaXJzdCBkYXRhIHdoaWNoIGhhcyBuYW1lP1xuICAgICAgICAgICAgICAgICAgICAvLyAoMikgdGhlbWVSaXZlciwgZmlyc3REYXRhSW5kZXggaXMgYXJyYXksIGFuZCBmaXJzdCBsaW5lIGlzIHVubmVjZXNzYXJ5LlxuICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RMaW5lID0gYmFzZUF4aXMudHlwZSA9PT0gJ3RpbWUnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGJhc2VBeGlzLnNjYWxlLmdldExhYmVsKHZhbHVlW2Jhc2VEaW1JbmRleF0pXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHNlcmllc0xpc3RbMF0uZ2V0RGF0YSgpLmdldE5hbWUoZmlyc3REYXRhSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdEh0bWwgPSAoZmlyc3RMaW5lID8gZmlyc3RMaW5lICsgJzxiciAvPicgOiAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICsgenJVdGlsLm1hcChzZXJpZXNMaXN0LCBmdW5jdGlvbiAoc2VyaWVzLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXJpZXMuZm9ybWF0VG9vbHRpcChwYXlsb2FkQmF0Y2hbaW5kZXhdLmRhdGFJbmRleCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5qb2luKCc8YnIgLz4nKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgYXN5bmNUaWNrZXQgPSAnYXhpc18nICsgY29vcmRTeXMubmFtZSArICdfJyArIGZpcnN0RGF0YUluZGV4O1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Nob3dUb29sdGlwQ29udGVudChcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RUb29sdGlwTW9kZWwsIGRlZmF1bHRIdG1sLCBwYXJhbXNMaXN0LCBhc3luY1RpY2tldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50WzBdLCBwb2ludFsxXSwgbnVsbCwgYXBpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVQb3NpdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RUb29sdGlwTW9kZWwuZ2V0KCdwb3NpdGlvbicpLCBwb2ludFswXSwgcG9pbnRbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwQ29udGVudCwgcGFyYW1zTGlzdCwgbnVsbCwgYXBpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG93IHRvb2x0aXAgb24gaXRlbVxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL1Nlcmllc30gc2VyaWVzTW9kZWxcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGRhdGFJbmRleFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YVR5cGVcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGVcbiAgICAgICAgICovXG4gICAgICAgIF9zaG93SXRlbVRvb2x0aXBDb250ZW50OiBmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGRhdGFJbmRleCwgZGF0YVR5cGUsIGUpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FIEdyYXBoIGRhdGFcbiAgICAgICAgICAgIHZhciBhcGkgPSB0aGlzLl9hcGk7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoZGF0YVR5cGUpO1xuICAgICAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGRhdGFJbmRleCk7XG5cbiAgICAgICAgICAgIHZhciB0b29sdGlwT3B0ID0gaXRlbU1vZGVsLmdldCgndG9vbHRpcCcsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b29sdGlwT3B0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIEluIGVhY2ggZGF0YSBpdGVtIHRvb2x0aXAgY2FuIGJlIHNpbXBseSB3cml0ZTpcbiAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgICAgICAgICAgLy8gIHZhbHVlOiAxMCxcbiAgICAgICAgICAgICAgICAvLyAgdG9vbHRpcDogJ1NvbWV0aGluZyB5b3UgbmVlZCB0byBrbm93J1xuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICB2YXIgdG9vbHRpcENvbnRlbnQgPSB0b29sdGlwT3B0O1xuICAgICAgICAgICAgICAgIHRvb2x0aXBPcHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogdG9vbHRpcENvbnRlbnRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJvb3RUb29sdGlwTW9kZWwgPSB0aGlzLl90b29sdGlwTW9kZWw7XG4gICAgICAgICAgICB2YXIgc2VyaWVzVG9vbHRpcE1vZGVsID0gc2VyaWVzTW9kZWwuZ2V0TW9kZWwoXG4gICAgICAgICAgICAgICAgJ3Rvb2x0aXAnLCByb290VG9vbHRpcE1vZGVsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIHRvb2x0aXBNb2RlbCA9IG5ldyBNb2RlbCh0b29sdGlwT3B0LCBzZXJpZXNUb29sdGlwTW9kZWwsIHNlcmllc1Rvb2x0aXBNb2RlbC5lY01vZGVsKTtcblxuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHNlcmllc01vZGVsLmdldERhdGFQYXJhbXMoZGF0YUluZGV4LCBkYXRhVHlwZSk7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdEh0bWwgPSBzZXJpZXNNb2RlbC5mb3JtYXRUb29sdGlwKGRhdGFJbmRleCwgZmFsc2UsIGRhdGFUeXBlKTtcblxuICAgICAgICAgICAgdmFyIGFzeW5jVGlja2V0ID0gJ2l0ZW1fJyArIHNlcmllc01vZGVsLm5hbWUgKyAnXycgKyBkYXRhSW5kZXg7XG5cbiAgICAgICAgICAgIHRoaXMuX3Nob3dUb29sdGlwQ29udGVudChcbiAgICAgICAgICAgICAgICB0b29sdGlwTW9kZWwsIGRlZmF1bHRIdG1sLCBwYXJhbXMsIGFzeW5jVGlja2V0LFxuICAgICAgICAgICAgICAgIGUub2Zmc2V0WCwgZS5vZmZzZXRZLCBlLnRhcmdldCwgYXBpXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9zaG93VG9vbHRpcENvbnRlbnQ6IGZ1bmN0aW9uIChcbiAgICAgICAgICAgIHRvb2x0aXBNb2RlbCwgZGVmYXVsdEh0bWwsIHBhcmFtcywgYXN5bmNUaWNrZXQsIHgsIHksIHRhcmdldCwgYXBpXG4gICAgICAgICkge1xuICAgICAgICAgICAgLy8gUmVzZXQgdGlja2V0XG4gICAgICAgICAgICB0aGlzLl90aWNrZXQgPSAnJztcblxuICAgICAgICAgICAgaWYgKHRvb2x0aXBNb2RlbC5nZXQoJ3Nob3dDb250ZW50JykgJiYgdG9vbHRpcE1vZGVsLmdldCgnc2hvdycpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvb2x0aXBDb250ZW50ID0gdGhpcy5fdG9vbHRpcENvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgZm9ybWF0dGVyID0gdG9vbHRpcE1vZGVsLmdldCgnZm9ybWF0dGVyJyk7XG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uRXhwciA9IHRvb2x0aXBNb2RlbC5nZXQoJ3Bvc2l0aW9uJyk7XG4gICAgICAgICAgICAgICAgdmFyIGh0bWwgPSBkZWZhdWx0SHRtbDtcblxuICAgICAgICAgICAgICAgIGlmIChmb3JtYXR0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sID0gZm9ybWF0VXRpbC5mb3JtYXRUcGwoZm9ybWF0dGVyLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aWNrZXQgPSBhc3luY1RpY2tldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIChjYlRpY2tldCwgaHRtbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYlRpY2tldCA9PT0gc2VsZi5fdGlja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2x0aXBDb250ZW50LnNldENvbnRlbnQoaHRtbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlUG9zaXRpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkV4cHIsIHgsIHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwQ29udGVudCwgcGFyYW1zLCB0YXJnZXQsIGFwaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl90aWNrZXQgPSB0aWNrZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sID0gZm9ybWF0dGVyKHBhcmFtcywgdGlja2V0LCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0b29sdGlwQ29udGVudC5zaG93KHRvb2x0aXBNb2RlbCk7XG4gICAgICAgICAgICAgICAgdG9vbHRpcENvbnRlbnQuc2V0Q29udGVudChodG1sKTtcblxuICAgICAgICAgICAgICAgIHVwZGF0ZVBvc2l0aW9uKFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkV4cHIsIHgsIHksXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXBDb250ZW50LCBwYXJhbXMsIHRhcmdldCwgYXBpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdyBheGlzIHBvaW50ZXJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjb29yZFN5c05hbWVdXG4gICAgICAgICAqL1xuICAgICAgICBfc2hvd0F4aXNQb2ludGVyOiBmdW5jdGlvbiAoY29vcmRTeXNOYW1lKSB7XG4gICAgICAgICAgICBpZiAoY29vcmRTeXNOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF4aXNQb2ludGVycyA9IHRoaXMuX2F4aXNQb2ludGVyc1tjb29yZFN5c05hbWVdO1xuICAgICAgICAgICAgICAgIGF4aXNQb2ludGVycyAmJiB6clV0aWwuZWFjaChheGlzUG9pbnRlcnMsIGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICBlbC5zaG93KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwLmVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuc2hvdygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXAuc2hvdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9yZXNldExhc3RIb3ZlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxhc3RIb3ZlciA9IHRoaXMuX2xhc3RIb3ZlcjtcbiAgICAgICAgICAgIGlmIChsYXN0SG92ZXIucGF5bG9hZEJhdGNoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Rvd25wbGF5JyxcbiAgICAgICAgICAgICAgICAgICAgYmF0Y2g6IGxhc3RIb3Zlci5wYXlsb2FkQmF0Y2hcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlc2V0IGxhc3RIb3ZlclxuICAgICAgICAgICAgdGhpcy5fbGFzdEhvdmVyID0ge307XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIaWRlIGF4aXMgcG9pbnRlclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2Nvb3JkU3lzTmFtZV1cbiAgICAgICAgICovXG4gICAgICAgIF9oaWRlQXhpc1BvaW50ZXI6IGZ1bmN0aW9uIChjb29yZFN5c05hbWUpIHtcbiAgICAgICAgICAgIGlmIChjb29yZFN5c05hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXhpc1BvaW50ZXJzID0gdGhpcy5fYXhpc1BvaW50ZXJzW2Nvb3JkU3lzTmFtZV07XG4gICAgICAgICAgICAgICAgYXhpc1BvaW50ZXJzICYmIHpyVXRpbC5lYWNoKGF4aXNQb2ludGVycywgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdyb3VwLmNoaWxkcmVuKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXAuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfaGlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3Nob3dUaW1lb3V0KTtcblxuICAgICAgICAgICAgdGhpcy5faGlkZUF4aXNQb2ludGVyKCk7XG4gICAgICAgICAgICB0aGlzLl9yZXNldExhc3RIb3ZlcigpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9hbHdheXNTaG93Q29udGVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBDb250ZW50LmhpZGVMYXRlcih0aGlzLl90b29sdGlwTW9kZWwuZ2V0KCdoaWRlRGVsYXknKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2FwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2hpZGVUaXAnLFxuICAgICAgICAgICAgICAgIGZyb206IHRoaXMudWlkXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5fbGFzdFggPSB0aGlzLl9sYXN0WSA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgICAgICAgICAgaWYgKGVudi5ub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHpyID0gYXBpLmdldFpyKCk7XG4gICAgICAgICAgICB0aGlzLl90b29sdGlwQ29udGVudC5oaWRlKCk7XG5cbiAgICAgICAgICAgIHpyLm9mZignY2xpY2snLCB0aGlzLl90cnlTaG93KTtcbiAgICAgICAgICAgIHpyLm9mZignbW91c2Vtb3ZlJywgdGhpcy5fbW91c2Vtb3ZlKTtcbiAgICAgICAgICAgIHpyLm9mZignbW91c2VvdXQnLCB0aGlzLl9oaWRlKTtcbiAgICAgICAgICAgIHpyLm9mZignZ2xvYmFsb3V0JywgdGhpcy5faGlkZSk7XG5cbiAgICAgICAgICAgIGFwaS5vZmYoJ3Nob3dUaXAnLCB0aGlzLl9tYW51YWxseVNob3dUaXApO1xuICAgICAgICAgICAgYXBpLm9mZignaGlkZVRpcCcsIHRoaXMuX21hbnVhbGx5SGlkZVRpcCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvZWNoYXJ0cy9jb21wb25lbnQvdG9vbHRpcC9Ub29sdGlwVmlldy5qc1xuICoqIG1vZHVsZSBpZCA9IDEzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiLyoqXG4gKiBAbW9kdWxlIGVjaGFydHMvY29tcG9uZW50L3Rvb2x0aXAvVG9vbHRpcENvbnRlbnRcbiAqL1xuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnenJlbmRlci9jb3JlL3V0aWwnKTtcbiAgICB2YXIgenJDb2xvciA9IHJlcXVpcmUoJ3pyZW5kZXIvdG9vbC9jb2xvcicpO1xuICAgIHZhciBldmVudFV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2NvcmUvZXZlbnQnKTtcbiAgICB2YXIgZm9ybWF0VXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZm9ybWF0Jyk7XG4gICAgdmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbiAgICB2YXIgdG9DYW1lbENhc2UgPSBmb3JtYXRVdGlsLnRvQ2FtZWxDYXNlO1xuICAgIHZhciBlbnYgPSByZXF1aXJlKCd6cmVuZGVyL2NvcmUvZW52Jyk7XG5cbiAgICB2YXIgdmVuZG9ycyA9IFsnJywgJy13ZWJraXQtJywgJy1tb3otJywgJy1vLSddO1xuXG4gICAgdmFyIGdDc3NUZXh0ID0gJ3Bvc2l0aW9uOmFic29sdXRlO2Rpc3BsYXk6YmxvY2s7Ym9yZGVyLXN0eWxlOnNvbGlkO3doaXRlLXNwYWNlOm5vd3JhcDt6LWluZGV4Ojk5OTk5OTk7JztcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvblxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NlbWJsZVRyYW5zaXRpb24oZHVyYXRpb24pIHtcbiAgICAgICAgdmFyIHRyYW5zaXRpb25DdXJ2ZSA9ICdjdWJpYy1iZXppZXIoMC4yMywgMSwgMC4zMiwgMSknO1xuICAgICAgICB2YXIgdHJhbnNpdGlvblRleHQgPSAnbGVmdCAnICsgZHVyYXRpb24gKyAncyAnICsgdHJhbnNpdGlvbkN1cnZlICsgJywnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAndG9wICcgKyBkdXJhdGlvbiArICdzICcgKyB0cmFuc2l0aW9uQ3VydmU7XG4gICAgICAgIHJldHVybiB6clV0aWwubWFwKHZlbmRvcnMsIGZ1bmN0aW9uICh2ZW5kb3JQcmVmaXgpIHtcbiAgICAgICAgICAgIHJldHVybiB2ZW5kb3JQcmVmaXggKyAndHJhbnNpdGlvbjonICsgdHJhbnNpdGlvblRleHQ7XG4gICAgICAgIH0pLmpvaW4oJzsnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGV4dFN0eWxlXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2VtYmxlRm9udCh0ZXh0U3R5bGVNb2RlbCkge1xuICAgICAgICB2YXIgY3NzVGV4dCA9IFtdO1xuXG4gICAgICAgIHZhciBmb250U2l6ZSA9IHRleHRTdHlsZU1vZGVsLmdldCgnZm9udFNpemUnKTtcbiAgICAgICAgdmFyIGNvbG9yID0gdGV4dFN0eWxlTW9kZWwuZ2V0VGV4dENvbG9yKCk7XG5cbiAgICAgICAgY29sb3IgJiYgY3NzVGV4dC5wdXNoKCdjb2xvcjonICsgY29sb3IpO1xuXG4gICAgICAgIGNzc1RleHQucHVzaCgnZm9udDonICsgdGV4dFN0eWxlTW9kZWwuZ2V0Rm9udCgpKTtcblxuICAgICAgICBmb250U2l6ZSAmJlxuICAgICAgICAgICAgY3NzVGV4dC5wdXNoKCdsaW5lLWhlaWdodDonICsgTWF0aC5yb3VuZChmb250U2l6ZSAqIDMgLyAyKSArICdweCcpO1xuXG4gICAgICAgIGVhY2goWydkZWNvcmF0aW9uJywgJ2FsaWduJ10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gdGV4dFN0eWxlTW9kZWwuZ2V0KG5hbWUpO1xuICAgICAgICAgICAgdmFsICYmIGNzc1RleHQucHVzaCgndGV4dC0nICsgbmFtZSArICc6JyArIHZhbCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjc3NUZXh0LmpvaW4oJzsnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdG9vbHRpcE1vZGVsXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2VtYmxlQ3NzVGV4dCh0b29sdGlwTW9kZWwpIHtcblxuICAgICAgICB0b29sdGlwTW9kZWwgPSB0b29sdGlwTW9kZWw7XG5cbiAgICAgICAgdmFyIGNzc1RleHQgPSBbXTtcblxuICAgICAgICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9uID0gdG9vbHRpcE1vZGVsLmdldCgndHJhbnNpdGlvbkR1cmF0aW9uJyk7XG4gICAgICAgIHZhciBiYWNrZ3JvdW5kQ29sb3IgPSB0b29sdGlwTW9kZWwuZ2V0KCdiYWNrZ3JvdW5kQ29sb3InKTtcbiAgICAgICAgdmFyIHRleHRTdHlsZU1vZGVsID0gdG9vbHRpcE1vZGVsLmdldE1vZGVsKCd0ZXh0U3R5bGUnKTtcbiAgICAgICAgdmFyIHBhZGRpbmcgPSB0b29sdGlwTW9kZWwuZ2V0KCdwYWRkaW5nJyk7XG5cbiAgICAgICAgLy8gQW5pbWF0aW9uIHRyYW5zaXRpb25cbiAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uICYmXG4gICAgICAgICAgICBjc3NUZXh0LnB1c2goYXNzZW1ibGVUcmFuc2l0aW9uKHRyYW5zaXRpb25EdXJhdGlvbikpO1xuXG4gICAgICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgICAgIGlmIChlbnYuY2FudmFzU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgY3NzVGV4dC5wdXNoKCdiYWNrZ3JvdW5kLUNvbG9yOicgKyBiYWNrZ3JvdW5kQ29sb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIGllXG4gICAgICAgICAgICAgICAgY3NzVGV4dC5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAnYmFja2dyb3VuZC1Db2xvcjojJyArIHpyQ29sb3IudG9IZXgoYmFja2dyb3VuZENvbG9yKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY3NzVGV4dC5wdXNoKCdmaWx0ZXI6YWxwaGEob3BhY2l0eT03MCknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJvcmRlciBzdHlsZVxuICAgICAgICBlYWNoKFsnd2lkdGgnLCAnY29sb3InLCAncmFkaXVzJ10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgYm9yZGVyTmFtZSA9ICdib3JkZXItJyArIG5hbWU7XG4gICAgICAgICAgICB2YXIgY2FtZWxDYXNlID0gdG9DYW1lbENhc2UoYm9yZGVyTmFtZSk7XG4gICAgICAgICAgICB2YXIgdmFsID0gdG9vbHRpcE1vZGVsLmdldChjYW1lbENhc2UpO1xuICAgICAgICAgICAgdmFsICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICBjc3NUZXh0LnB1c2goYm9yZGVyTmFtZSArICc6JyArIHZhbCArIChuYW1lID09PSAnY29sb3InID8gJycgOiAncHgnKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRleHQgc3R5bGVcbiAgICAgICAgY3NzVGV4dC5wdXNoKGFzc2VtYmxlRm9udCh0ZXh0U3R5bGVNb2RlbCkpO1xuXG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgaWYgKHBhZGRpbmcgIT0gbnVsbCkge1xuICAgICAgICAgICAgY3NzVGV4dC5wdXNoKCdwYWRkaW5nOicgKyBmb3JtYXRVdGlsLm5vcm1hbGl6ZUNzc0FycmF5KHBhZGRpbmcpLmpvaW4oJ3B4ICcpICsgJ3B4Jyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3NzVGV4dC5qb2luKCc7JykgKyAnOyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL2NvbXBvbmVudC90b29sdGlwL1Rvb2x0aXBDb250ZW50XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gVG9vbHRpcENvbnRlbnQoY29udGFpbmVyLCBhcGkpIHtcbiAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHZhciB6ciA9IGFwaS5nZXRacigpO1xuXG4gICAgICAgIHRoaXMuZWwgPSBlbDtcblxuICAgICAgICB0aGlzLl94ID0gYXBpLmdldFdpZHRoKCkgLyAyO1xuICAgICAgICB0aGlzLl95ID0gYXBpLmdldEhlaWdodCgpIC8gMjtcblxuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwpO1xuXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcblxuICAgICAgICB0aGlzLl9zaG93ID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9oaWRlVGltZW91dDtcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGVsLm9ubW91c2VlbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGNsZWFyIHRoZSB0aW1lb3V0IGluIGhpZGVMYXRlciBhbmQga2VlcCBzaG93aW5nIHRvb2x0aXBcbiAgICAgICAgICAgIGlmIChzZWxmLmVudGVyYWJsZSkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChzZWxmLl9oaWRlVGltZW91dCk7XG4gICAgICAgICAgICAgICAgc2VsZi5fc2hvdyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLl9pbkNvbnRlbnQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBlbC5vbm1vdXNlbW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoIXNlbGYuZW50ZXJhYmxlKSB7XG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRyaWdnZXIgenJlbmRlciBldmVudCB0byBhdm9pZCBtb3VzZVxuICAgICAgICAgICAgICAgIC8vIGluIGFuZCBvdXQgc2hhcGUgdG9vIGZyZXF1ZW50bHlcbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlciA9IHpyLmhhbmRsZXI7XG4gICAgICAgICAgICAgICAgZXZlbnRVdGlsLm5vcm1hbGl6ZUV2ZW50KGNvbnRhaW5lciwgZSk7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5kaXNwYXRjaCgnbW91c2Vtb3ZlJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGVsLm9ubW91c2VsZWF2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmVudGVyYWJsZSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLl9zaG93KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaGlkZUxhdGVyKHNlbGYuX2hpZGVEZWxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5faW5Db250ZW50ID0gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29tcHJvbWlzZU1vYmlsZShlbCwgY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wcm9taXNlTW9iaWxlKHRvb2x0aXBDb250ZW50RWwsIGNvbnRhaW5lcikge1xuICAgICAgICAvLyBQcmV2ZW50IGRlZmF1bHQgYmVoYXZpb3Igb24gbW9iaWxlLiBGb3IgZXhhbXBsZSxcbiAgICAgICAgLy8gZGVmYXVsdCBwaW5jaCBnZXN0dXJlIHdpbGwgY2F1c2UgYnJvd3NlciB6b29tLlxuICAgICAgICAvLyBXZSBkbyBub3QgcHJldmVudGluZyBldmVudCBvbiB0b29sdGlwIGNvbnRuZXQgZWwsXG4gICAgICAgIC8vIGJlY2F1c2UgdXNlciBtYXkgbmVlZCBjdXN0b21pemF0aW9uIGluIHRvb2x0aXAgZWwuXG4gICAgICAgIGV2ZW50VXRpbC5hZGRFdmVudExpc3RlbmVyKGNvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XG4gICAgICAgIGV2ZW50VXRpbC5hZGRFdmVudExpc3RlbmVyKGNvbnRhaW5lciwgJ3RvdWNobW92ZScsIHByZXZlbnREZWZhdWx0KTtcbiAgICAgICAgZXZlbnRVdGlsLmFkZEV2ZW50TGlzdGVuZXIoY29udGFpbmVyLCAndG91Y2hlbmQnLCBwcmV2ZW50RGVmYXVsdCk7XG5cbiAgICAgICAgZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZSkge1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5zKGUudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNvbnRhaW5zKHRhcmdldEVsKSB7XG4gICAgICAgICAgICB3aGlsZSAodGFyZ2V0RWwgJiYgdGFyZ2V0RWwgIT09IGNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRFbCA9PT0gdG9vbHRpcENvbnRlbnRFbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFyZ2V0RWwgPSB0YXJnZXRFbC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgVG9vbHRpcENvbnRlbnQucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBUb29sdGlwQ29udGVudCxcblxuICAgICAgICBlbnRlcmFibGU6IHRydWUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB3aGVuIHRvb2x0aXAgaXMgcmVuZGVyZWRcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcbiAgICAgICAgICAgIHZhciBzdGwgPSBjb250YWluZXIuY3VycmVudFN0eWxlXG4gICAgICAgICAgICAgICAgfHwgZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpO1xuICAgICAgICAgICAgdmFyIGRvbVN0eWxlID0gY29udGFpbmVyLnN0eWxlO1xuICAgICAgICAgICAgaWYgKGRvbVN0eWxlLnBvc2l0aW9uICE9PSAnYWJzb2x1dGUnICYmIHN0bC5wb3NpdGlvbiAhPT0gJ2Fic29sdXRlJykge1xuICAgICAgICAgICAgICAgIGRvbVN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhpZGUgdGhlIHRvb2x0aXBcbiAgICAgICAgICAgIC8vIFBFTkRJTkdcbiAgICAgICAgICAgIC8vIHRoaXMuaGlkZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNob3c6IGZ1bmN0aW9uICh0b29sdGlwTW9kZWwpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9oaWRlVGltZW91dCk7XG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzLmVsO1xuXG4gICAgICAgICAgICBlbC5zdHlsZS5jc3NUZXh0ID0gZ0Nzc1RleHQgKyBhc3NlbWJsZUNzc1RleHQodG9vbHRpcE1vZGVsKVxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjExMjU1ODcvY3NzMy10cmFuc2l0aW9uLW5vdC13b3JraW5nLWluLWNocm9tZS1hbnltb3JlXG4gICAgICAgICAgICAgICAgKyAnO2xlZnQ6JyArIHRoaXMuX3ggKyAncHg7dG9wOicgKyB0aGlzLl95ICsgJ3B4OydcbiAgICAgICAgICAgICAgICArICh0b29sdGlwTW9kZWwuZ2V0KCdleHRyYUNzc1RleHQnKSB8fCAnJyk7XG5cbiAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5pbm5lckhUTUwgPyAgJ2Jsb2NrJyA6ICdub25lJztcblxuICAgICAgICAgICAgdGhpcy5fc2hvdyA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0Q29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgICAgICAgICBlbC5pbm5lckhUTUwgPSBjb250ZW50O1xuICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGNvbnRlbnQgPyAnYmxvY2snIDogJ25vbmUnO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1vdmVUbzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuZWwuc3R5bGU7XG4gICAgICAgICAgICBzdHlsZS5sZWZ0ID0geCArICdweCc7XG4gICAgICAgICAgICBzdHlsZS50b3AgPSB5ICsgJ3B4JztcblxuICAgICAgICAgICAgdGhpcy5feCA9IHg7XG4gICAgICAgICAgICB0aGlzLl95ID0geTtcbiAgICAgICAgfSxcblxuICAgICAgICBoaWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB0aGlzLl9zaG93ID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gc2hvd0xhdGVyOiBmdW5jdGlvbiAoKVxuXG4gICAgICAgIGhpZGVMYXRlcjogZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zaG93ICYmICEodGhpcy5faW5Db250ZW50ICYmIHRoaXMuZW50ZXJhYmxlKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hpZGVEZWxheSA9IHRpbWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBzaG93IGZhbHNlIHRvIGF2b2lkIGludm9rZSBoaWRlTGF0ZXIgbXV0aXBsZSB0aW1lc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaG93ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hpZGVUaW1lb3V0ID0gc2V0VGltZW91dCh6clV0aWwuYmluZCh0aGlzLmhpZGUsIHRoaXMpLCB0aW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBpc1Nob3c6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaG93O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBUb29sdGlwQ29udGVudDtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9kZXAvZWNoYXJ0cy9jb21wb25lbnQvdG9vbHRpcC9Ub29sdGlwQ29udGVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzNFxuICoqIG1vZHVsZSBjaHVua3MgPSAzXG4gKiovIiwiZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBlY2hhcnRzID0gcmVxdWlyZSgnLi4vZWNoYXJ0cycpO1xuICAgIHZhciBncmFwaGljID0gcmVxdWlyZSgnLi4vdXRpbC9ncmFwaGljJyk7XG4gICAgdmFyIGxheW91dCA9IHJlcXVpcmUoJy4uL3V0aWwvbGF5b3V0Jyk7XG5cbiAgICAvLyBNb2RlbFxuICAgIGVjaGFydHMuZXh0ZW5kQ29tcG9uZW50TW9kZWwoe1xuXG4gICAgICAgIHR5cGU6ICd0aXRsZScsXG5cbiAgICAgICAgbGF5b3V0TW9kZToge3R5cGU6ICdib3gnLCBpZ25vcmVTaXplOiB0cnVlfSxcblxuICAgICAgICBkZWZhdWx0T3B0aW9uOiB7XG4gICAgICAgICAgICAvLyDkuIDnuqflsYLlj6BcbiAgICAgICAgICAgIHpsZXZlbDogMCxcbiAgICAgICAgICAgIC8vIOS6jOe6p+WxguWPoFxuICAgICAgICAgICAgejogNixcbiAgICAgICAgICAgIHNob3c6IHRydWUsXG5cbiAgICAgICAgICAgIHRleHQ6ICcnLFxuICAgICAgICAgICAgLy8g6LaF6ZO+5o6l6Lez6L2sXG4gICAgICAgICAgICAvLyBsaW5rOiBudWxsLFxuICAgICAgICAgICAgLy8g5LuF5pSv5oyBc2VsZiB8IGJsYW5rXG4gICAgICAgICAgICB0YXJnZXQ6ICdibGFuaycsXG4gICAgICAgICAgICBzdWJ0ZXh0OiAnJyxcblxuICAgICAgICAgICAgLy8g6LaF6ZO+5o6l6Lez6L2sXG4gICAgICAgICAgICAvLyBzdWJsaW5rOiBudWxsLFxuICAgICAgICAgICAgLy8g5LuF5pSv5oyBc2VsZiB8IGJsYW5rXG4gICAgICAgICAgICBzdWJ0YXJnZXQ6ICdibGFuaycsXG5cbiAgICAgICAgICAgIC8vICdjZW50ZXInIMKmICdsZWZ0JyDCpiAncmlnaHQnXG4gICAgICAgICAgICAvLyDCpiB7bnVtYmVyfe+8iHjlnZDmoIfvvIzljZXkvY1weO+8iVxuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIC8vICd0b3AnIMKmICdib3R0b20nIMKmICdjZW50ZXInXG4gICAgICAgICAgICAvLyDCpiB7bnVtYmVyfe+8iHnlnZDmoIfvvIzljZXkvY1weO+8iVxuICAgICAgICAgICAgdG9wOiAwLFxuXG4gICAgICAgICAgICAvLyDmsLTlubPlr7npvZBcbiAgICAgICAgICAgIC8vICdhdXRvJyB8ICdsZWZ0JyB8ICdyaWdodCcgfCAnY2VudGVyJ1xuICAgICAgICAgICAgLy8g6buY6K6k5qC55o2uIGxlZnQg55qE5L2N572u5Yik5pat5piv5bem5a+56b2Q6L+Y5piv5Y+z5a+56b2QXG4gICAgICAgICAgICAvLyB0ZXh0QWxpZ246IG51bGxcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyDlnoLnm7Tlr7npvZBcbiAgICAgICAgICAgIC8vICdhdXRvJyB8ICd0b3AnIHwgJ2JvdHRvbScgfCAnbWlkZGxlJ1xuICAgICAgICAgICAgLy8g6buY6K6k5qC55o2uIHRvcCDkvY3nva7liKTmlq3mmK/kuIrlr7npvZDov5jmmK/kuIvlr7npvZBcbiAgICAgICAgICAgIC8vIHRleHRCYXNlbGluZTogbnVsbFxuXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDApJyxcblxuICAgICAgICAgICAgLy8g5qCH6aKY6L655qGG6aKc6ImyXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogJyNjY2MnLFxuXG4gICAgICAgICAgICAvLyDmoIfpopjovrnmoYbnur/lrr3vvIzljZXkvY1weO+8jOm7mOiupOS4ujDvvIjml6DovrnmoYbvvIlcbiAgICAgICAgICAgIGJvcmRlcldpZHRoOiAwLFxuXG4gICAgICAgICAgICAvLyDmoIfpopjlhoXovrnot53vvIzljZXkvY1weO+8jOm7mOiupOWQhOaWueWQkeWGhei+uei3neS4ujXvvIxcbiAgICAgICAgICAgIC8vIOaOpeWPl+aVsOe7hOWIhuWIq+iuvuWumuS4iuWPs+S4i+W3pui+uei3ne+8jOWQjGNzc1xuICAgICAgICAgICAgcGFkZGluZzogNSxcblxuICAgICAgICAgICAgLy8g5Li75Ymv5qCH6aKY57q15ZCR6Ze06ZqU77yM5Y2V5L2NcHjvvIzpu5jorqTkuLoxMO+8jFxuICAgICAgICAgICAgaXRlbUdhcDogMTAsXG4gICAgICAgICAgICB0ZXh0U3R5bGU6IHtcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogMTgsXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogJ2JvbGRlcicsXG4gICAgICAgICAgICAgICAgY29sb3I6ICcjMzMzJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN1YnRleHRTdHlsZToge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAnI2FhYSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gVmlld1xuICAgIGVjaGFydHMuZXh0ZW5kQ29tcG9uZW50Vmlldyh7XG5cbiAgICAgICAgdHlwZTogJ3RpdGxlJyxcblxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uICh0aXRsZU1vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG5cbiAgICAgICAgICAgIGlmICghdGl0bGVNb2RlbC5nZXQoJ3Nob3cnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cDtcblxuICAgICAgICAgICAgdmFyIHRleHRTdHlsZU1vZGVsID0gdGl0bGVNb2RlbC5nZXRNb2RlbCgndGV4dFN0eWxlJyk7XG4gICAgICAgICAgICB2YXIgc3VidGV4dFN0eWxlTW9kZWwgPSB0aXRsZU1vZGVsLmdldE1vZGVsKCdzdWJ0ZXh0U3R5bGUnKTtcblxuICAgICAgICAgICAgdmFyIHRleHRBbGlnbiA9IHRpdGxlTW9kZWwuZ2V0KCd0ZXh0QWxpZ24nKTtcbiAgICAgICAgICAgIHZhciB0ZXh0QmFzZWxpbmUgPSB0aXRsZU1vZGVsLmdldCgndGV4dEJhc2VsaW5lJyk7XG5cbiAgICAgICAgICAgIHZhciB0ZXh0RWwgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0aXRsZU1vZGVsLmdldCgndGV4dCcpLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0Rm9udDogdGV4dFN0eWxlTW9kZWwuZ2V0Rm9udCgpLFxuICAgICAgICAgICAgICAgICAgICBmaWxsOiB0ZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgejI6IDEwXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIHRleHRSZWN0ID0gdGV4dEVsLmdldEJvdW5kaW5nUmVjdCgpO1xuXG4gICAgICAgICAgICB2YXIgc3ViVGV4dCA9IHRpdGxlTW9kZWwuZ2V0KCdzdWJ0ZXh0Jyk7XG4gICAgICAgICAgICB2YXIgc3ViVGV4dEVsID0gbmV3IGdyYXBoaWMuVGV4dCh7XG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogc3ViVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dEZvbnQ6IHN1YnRleHRTdHlsZU1vZGVsLmdldEZvbnQoKSxcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogc3VidGV4dFN0eWxlTW9kZWwuZ2V0VGV4dENvbG9yKCksXG4gICAgICAgICAgICAgICAgICAgIHk6IHRleHRSZWN0LmhlaWdodCArIHRpdGxlTW9kZWwuZ2V0KCdpdGVtR2FwJyksXG4gICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZTogJ3RvcCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHoyOiAxMFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBsaW5rID0gdGl0bGVNb2RlbC5nZXQoJ2xpbmsnKTtcbiAgICAgICAgICAgIHZhciBzdWJsaW5rID0gdGl0bGVNb2RlbC5nZXQoJ3N1YmxpbmsnKTtcblxuICAgICAgICAgICAgdGV4dEVsLnNpbGVudCA9ICFsaW5rO1xuICAgICAgICAgICAgc3ViVGV4dEVsLnNpbGVudCA9ICFzdWJsaW5rO1xuXG4gICAgICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgICAgIHRleHRFbC5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5vcGVuKGxpbmssICdfJyArIHRpdGxlTW9kZWwuZ2V0KCd0YXJnZXQnKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3VibGluaykge1xuICAgICAgICAgICAgICAgIHN1YlRleHRFbC5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5vcGVuKHN1YmxpbmssICdfJyArIHRpdGxlTW9kZWwuZ2V0KCdzdWJ0YXJnZXQnKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdyb3VwLmFkZCh0ZXh0RWwpO1xuICAgICAgICAgICAgc3ViVGV4dCAmJiBncm91cC5hZGQoc3ViVGV4dEVsKTtcbiAgICAgICAgICAgIC8vIElmIG5vIHN1YlRleHQsIGJ1dCBhZGQgc3ViVGV4dEVsLCB0aGVyZSB3aWxsIGJlIGFuIGVtcHR5IGxpbmUuXG5cbiAgICAgICAgICAgIHZhciBncm91cFJlY3QgPSBncm91cC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgIHZhciBsYXlvdXRPcHRpb24gPSB0aXRsZU1vZGVsLmdldEJveExheW91dFBhcmFtcygpO1xuICAgICAgICAgICAgbGF5b3V0T3B0aW9uLndpZHRoID0gZ3JvdXBSZWN0LndpZHRoO1xuICAgICAgICAgICAgbGF5b3V0T3B0aW9uLmhlaWdodCA9IGdyb3VwUmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgbGF5b3V0UmVjdCA9IGxheW91dC5nZXRMYXlvdXRSZWN0KFxuICAgICAgICAgICAgICAgIGxheW91dE9wdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogYXBpLmdldFdpZHRoKCksXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogYXBpLmdldEhlaWdodCgpXG4gICAgICAgICAgICAgICAgfSwgdGl0bGVNb2RlbC5nZXQoJ3BhZGRpbmcnKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIC8vIEFkanVzdCB0ZXh0IGFsaWduIGJhc2VkIG9uIHBvc2l0aW9uXG4gICAgICAgICAgICBpZiAoIXRleHRBbGlnbikge1xuICAgICAgICAgICAgICAgIC8vIEFsaWduIGxlZnQgaWYgdGl0bGUgaXMgb24gdGhlIGxlZnQuIGNlbnRlciBhbmQgcmlnaHQgaXMgc2FtZVxuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9IHRpdGxlTW9kZWwuZ2V0KCdsZWZ0JykgfHwgdGl0bGVNb2RlbC5nZXQoJ3JpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgaWYgKHRleHRBbGlnbiA9PT0gJ21pZGRsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFkanVzdCBsYXlvdXQgYnkgdGV4dCBhbGlnblxuICAgICAgICAgICAgICAgIGlmICh0ZXh0QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0UmVjdC54ICs9IGxheW91dFJlY3Qud2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRleHRBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0UmVjdC54ICs9IGxheW91dFJlY3Qud2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGV4dEJhc2VsaW5lKSB7XG4gICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gdGl0bGVNb2RlbC5nZXQoJ3RvcCcpIHx8IHRpdGxlTW9kZWwuZ2V0KCdib3R0b20nKTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dEJhc2VsaW5lID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRleHRCYXNlbGluZSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0UmVjdC55ICs9IGxheW91dFJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0ZXh0QmFzZWxpbmUgPT09ICdtaWRkbGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheW91dFJlY3QueSArPSBsYXlvdXRSZWN0LmhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gdGV4dEJhc2VsaW5lIHx8ICd0b3AnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBncm91cC5hdHRyKCdwb3NpdGlvbicsIFtsYXlvdXRSZWN0LngsIGxheW91dFJlY3QueV0pO1xuICAgICAgICAgICAgdmFyIGFsaWduU3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ246IHRleHRCYXNlbGluZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRleHRFbC5zZXRTdHlsZShhbGlnblN0eWxlKTtcbiAgICAgICAgICAgIHN1YlRleHRFbC5zZXRTdHlsZShhbGlnblN0eWxlKTtcblxuICAgICAgICAgICAgLy8gUmVuZGVyIGJhY2tncm91bmRcbiAgICAgICAgICAgIC8vIEdldCBncm91cFJlY3QgYWdhaW4gYmVjYXVzZSB0ZXh0QWxpZ24gaGFzIGJlZW4gY2hhbmdlZFxuICAgICAgICAgICAgZ3JvdXBSZWN0ID0gZ3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgICAgICB2YXIgcGFkZGluZyA9IGxheW91dFJlY3QubWFyZ2luO1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGl0bGVNb2RlbC5nZXRJdGVtU3R5bGUoWydjb2xvcicsICdvcGFjaXR5J10pO1xuICAgICAgICAgICAgc3R5bGUuZmlsbCA9IHRpdGxlTW9kZWwuZ2V0KCdiYWNrZ3JvdW5kQ29sb3InKTtcbiAgICAgICAgICAgIHZhciByZWN0ID0gbmV3IGdyYXBoaWMuUmVjdCh7XG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgICAgICAgICAgeDogZ3JvdXBSZWN0LnggLSBwYWRkaW5nWzNdLFxuICAgICAgICAgICAgICAgICAgICB5OiBncm91cFJlY3QueSAtIHBhZGRpbmdbMF0sXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBncm91cFJlY3Qud2lkdGggKyBwYWRkaW5nWzFdICsgcGFkZGluZ1szXSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBncm91cFJlY3QuaGVpZ2h0ICsgcGFkZGluZ1swXSArIHBhZGRpbmdbMl1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplUmVjdChyZWN0KTtcblxuICAgICAgICAgICAgZ3JvdXAuYWRkKHJlY3QpO1xuICAgICAgICB9XG4gICAgfSk7XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vZGVwL2VjaGFydHMvY29tcG9uZW50L3RpdGxlLmpzXG4gKiogbW9kdWxlIGlkID0gMTM1XG4gKiogbW9kdWxlIGNodW5rcyA9IDNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9